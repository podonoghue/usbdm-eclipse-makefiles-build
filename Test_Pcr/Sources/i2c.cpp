/**
 * @file i2c.cpp (180.ARM_Peripherals/Sources/i2c.cpp)
 * @brief I2C Code
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#include "i2c.h"
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
namespace USBDM {

// I2C baud rate divisor table
const uint16_t I2c::I2C_DIVISORS[] = {
      // Divider assuming MULT == 0
      20,   22,  24,   26,   28,   30,   34,   40,   28,   32,   36,   40,   44,   48,   56,   68,
      48,   56,  64,   72,   80,   88,  104,  128,   80,   96,  112,  128,  144,  160,  192,  240,
      160, 192, 224,  256,  288,  320,  384,  480,  320,  384,  448,  512,  576,  640,  768,  960,
      640, 768, 896, 1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048, 2304, 2560, 3072, 3840,
};

/**
 * Calculate value for baud rate register of I2C
 *
 * This is calculated from processor bus frequency and given bps
 *
 * @param[in]  bps            Interface speed in bits-per-second
 * @param[in]  clockFrequency Frequency of I2C input clock
 *
 * @return I2C_F value representing speed
 */
uint8_t I2c::getBPSValue(uint32_t bps, uint32_t clockFrequency) {
   uint8_t  best_mul   = 0;
   uint8_t  best_icr   = (uint8_t)-1u;
   uint16_t best_error = (uint16_t)-1u;

   for (uint8_t mul=0; mul<=2; mul++) {
      uint32_t divisor = (clockFrequency>>mul)/bps;
      for(uint8_t icr=0; icr<(sizeof(I2C_DIVISORS)/sizeof(I2C_DIVISORS[0])); icr++) {
         if (divisor>I2C_DIVISORS[icr]) {
            // Not suitable - try next
            continue;
         }
         uint16_t error=(uint16_t)(I2C_DIVISORS[icr]-divisor);
         if ((error<best_error) || (error==0)) {
            best_error=error;
            best_icr=icr;
            best_mul=mul;
         }
      }
   }
   if (best_icr == (uint8_t)-1u) {
      return I2C_F_MULT(1)|I2C_F_ICR(5);
   }
   else {
      return I2C_F_MULT(best_mul)|I2C_F_ICR(best_icr);
   }
}

/**
 * Start Rx/Tx sequence by sending address byte
 *
 * @param[in]  address - address of slave to access
 */
void I2c::sendAddress(uint8_t address) {

   unsigned timeout = TIMEOUT_LIMIT;

   // Wait for bus idle
   while (((i2c->S & I2C_S_BUSY_MASK) != 0) && (--timeout>0)) {
      __asm("nop");
   }
   if (timeout == 0) {
      errorCode = E_TIMEOUT;
      return;
   }
   addressedDevice = address;

   // Configure for Tx of address
   i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_TX_MASK;

   // Generate START
   i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_TX_MASK|I2C_C1_MST_MASK;

   // Tx address (starts interrupt process)
   i2c->D  = I2C_D_DATA(address);
}

/**
 * I2C state-machine based interrupt handler
 */
void I2c::poll(void) {

   if ((i2c->S & I2C_S_ARBL_MASK) != 0) {
      i2c->S = I2C_S_ARBL_MASK|I2C_S_IICIF_MASK;
      errorCode = E_LOST_ARBITRATION;
      state = i2c_idle;
      // Generate STOP
      i2c->C1 = i2cMode|I2C_C1_IICEN_MASK;
      return;
   }
   if ((i2c->S & I2C_S_IICIF_MASK) == 0) {
      return;
   }
   // Clear interrupt flag
   i2c->S = I2C_S_IICIF_MASK;

   // i2c_txData* +-> i2c_idle
   //             +-> i2c_rxAddress -> i2c_rxData* +-> i2c_idle
   //                                              *-> i2c_txData

   switch (state) {
   case i2c_idle:
   default:
      state = i2c_idle;
      break;

   case i2c_txData:
      // Just send data bytes until none left
      if ((i2c->S & I2C_S_RXAK_MASK) != 0) {
         // No ACK on last Tx data byte
         errorCode = E_NO_ACK;
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK;
         return;
      }
      if (txBytesRemaining-- == 0) {
         if (rxBytesRemaining > 0) {
            // Reception after transmission
            state = i2c_rxAddress;

#if defined(MCU_MKL25Z4)
            {
               // Temporarily clear MULT - see KL25 errata e6070
               uint8_t temp = i2c->F;
               i2c->F&=~I2C_F_MULT(3);
#endif
               // Generate REPEATED-START
               i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TX_MASK|I2C_C1_RSTA_MASK;
#if defined(MCU_MKL25Z4)
               // Restore MULT
               i2c->F = temp;
            }
#endif
#if defined(MCU_MKL27Z4) || defined(MCU_MKL27Z644) || defined(MCU_MKL43Z4)
            // This is a nasty hack
            // It seems these chips need a delay after asserting repeated start
            for (int i=0; i<20; i++) {
               __asm__ volatile("nop");
            }
#endif
            // Send device address again with READ bit set
            i2c->D = addressedDevice|1;
         }
         else {
            // Complete
            state = i2c_idle;
            // Generate stop signal
            i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_TXAK_MASK;
            return;
         }
      }
      else {
         // Transmit next byte
         i2c->D = *txDataPtr++;
      }
      break;

   case i2c_rxAddress:
      // Just sent address for reception phase
      if ((i2c->S & I2C_S_RXAK_MASK) != 0) {
         // No ACK on Tx read address byte
         errorCode = E_NO_ACK;
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK;
         return;
      }
      // Switch to data reception & trigger reception
      state = i2c_rxData;
      // Change to reception
      if (rxBytesRemaining == 1) {
         // Receiving only single byte (don't acknowledge the byte)
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TXAK_MASK;
      }
      else {
         // Switch to Rx mode
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK;
      }
      // Dummy read of data to start Rx of 1st data byte
      (void)i2c->D;
      break;

   case i2c_rxData:
      // Just receive data bytes until complete
      if (--rxBytesRemaining == 0) {
         // Received last byte - complete
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK;
      }
      else if (rxBytesRemaining == 1) {
         // Received 2nd last byte (don't acknowledge the last byte to follow)
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TXAK_MASK;
      }
      else {
         i2c->C1 = i2cMode|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK;
      }
      // Save receive data
      *rxDataPtr++ = i2c->D;
      break;
   }
}

/**
 * Transmit message
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  size     Size of transmission data
 * @param[in]  data     Data to transmit, 0th byte is often register address
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2c::transmit(uint8_t address, uint16_t size, const uint8_t data[]) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif

   errorCode = E_NO_ERROR;

   rxBytesRemaining = 0;

   // Send address byte at start and move to data transmission
   state = i2c_txData;

   // Set up transmit data
   txDataPtr        = data;
   txBytesRemaining = size;

   sendAddress(address);
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Receive message
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  size     Size of reception data
 * @param[out] data     Data buffer for reception
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2c::receive(uint8_t address, uint16_t size,  uint8_t data[]) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif
   errorCode = E_NO_ERROR;

   txBytesRemaining = 0;

   // Send address byte at start and move to data reception
   state = i2c_rxAddress;

   // Set up receive data
   rxDataPtr        = data;
   rxBytesRemaining = size;

   sendAddress(address|1);
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Transmit message followed by receive message.
 * Uses repeated-start.
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  txSize   Size of transmission data
 * @param[in]  txData   Data for transmission
 * @param[in]  rxSize   Size of reception data
 * @param[out] rxData   Date buffer for reception
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2c::txRx(uint8_t address, uint16_t txSize, const uint8_t txData[], uint16_t rxSize, uint8_t rxData[] ) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif
   errorCode = E_NO_ERROR;

   // Send address byte at start and move to data transmission
   state = i2c_txData;

   // Set up transmit and receive data
   rxDataPtr        = rxData;
   rxBytesRemaining = rxSize;
   txDataPtr        = txData;
   txBytesRemaining = txSize;

   sendAddress(address);
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Transmit message followed by receive message.
 * Uses repeated-start.\n
 * Uses shared transmit and receive buffer
 *
 * @param[in]    address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]    txSize   Size of transmission data
 * @param[in]    rxSize   Size of reception data
 * @param[inout] data     Data for transmission and reception
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2c::txRx(uint8_t address, uint16_t txSize, uint16_t rxSize, uint8_t data[] ) {
   return txRx(address, txSize, data, rxSize, data);
}

/*
 * I2C state-machine based interrupt handler
 */
#if defined(MCU_MKM33Z5)
// MCU_MKM33Z5 has a shared handler for I2C0 & I2C1
extern "C"
/*
 * I2C state-machine based interrupt handler
 */
void I2C0_1_IRQHandler() {
   if (I2C0->S&I2C_S_IICIF_MASK) {
      I2c0::thisPtr->poll();
   }
   if (I2C1->S&I2C_S_IICIF_MASK) {
      I2c1::thisPtr->poll();
   }
}
#endif

} // End namespace USBDM

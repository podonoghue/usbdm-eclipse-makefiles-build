/**
 * @file     ewm.h (180.ARM_Peripherals/Project_Headers/ewm.h)
 * @brief    External Watchdog Monitor
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_EWM_H_
#define HEADER_EWM_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */

/**
 *  Enables and selects polarity of EWM hardware input
 */
enum EwmInput {
   EwmInput_Disabled    = EWM_CTRL_INEN(0)|EWM_CTRL_ASSIN(0), //!< EWM_in Pin disabled
   EwmInput_ActiveLow   = EWM_CTRL_INEN(1)|EWM_CTRL_ASSIN(0), //!< EWM_in Pin activeLow
   EwmInput_ActiveHigh  = EWM_CTRL_INEN(1)|EWM_CTRL_ASSIN(1), //!< EWM_in Pin activeHigh
};

/**
 * Controls EWM Interrupts
 */
enum EwmInterrupt {
   EwmInterrupt_Disabled = EWM_CTRL_INTEN(0), //!< Interrupts disabled
   EwmInterrupt_Enabled  = EWM_CTRL_INTEN(1), //!< Interrupts enabled
};

/** Watchdog key value 1 */
static constexpr uint8_t EwmKey1 = 0xB4;

/** Watchdog key value 2 */
static constexpr uint8_t EwmKey2 = 0x2C;

/**
 * Type definition for EWM interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*EwmCallbackFunction)();

/**
 * Template class representing the External Watchdog Monitor
 *
 * External Watchdog Monitor (EWM), is designed to monitor external circuits, as well as the MCU software flow.
 * This provides a back-up mechanism to the internal watchdog that resets the MCU's CPU and peripherals.
 *
 * @tparam info      Information class for EWM
 */
template<class Info>
class EwmBase_T {

protected:
   /** Class to static check output is mapped to a pin - assumes existence */
   template<int ewmOutPin> class CheckOutputPinIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[ewmOutPin].gpioBit >= 0);

      static_assert(Test1, "EWM output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check output is mapped to a pin - assumes existence */
   template<int ewmInPin> class CheckInputPinIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[ewmInPin].gpioBit != UNMAPPED_PCR);

      static_assert(Test1, "EWM input is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static EwmCallbackFunction sCallback;

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to EWM hardware
    */
   static constexpr HardwarePtr<EWM_Type> ewm = Info::baseAddress;

   /** Allow access to PCR of associated pin */
   using InputPin  = PcrTable_T<Info, Info::inputPin>;
   using OutputPin = PcrTable_T<Info, Info::outputPin>;

   /**
    * IRQ handler
    */
   static void irqHandler() {
      // Call handler
      sCallback();
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match EwmCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ewm::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Ewm::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static EwmCallbackFunction wrapCallback() {
      static EwmCallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match EwmCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Ewm::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Ewm::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static EwmCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static EwmCallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set callback function
    *
    * @param[in] callback Callback function to execute on interrupt.\n
    *                     Use nullptr to remove callback.
    */
   static void setCallback(EwmCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "EWM not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Basic enable EWM.
    *
    * Includes enabling clock and configuring all pins of mapPinsOnEnable is selected on configuration
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to CMP interface
      Info::enableClock();
   }

   /**
    * Select watchdog window in LPO cycles.
    *
    * @param minimum The watchdog must be refreshed after this time
    * @param maximum The watchdog must be refreshed before this time
    *
    * @note This is a write-once operation.
    */
   static void setWindow(uint8_t minimum, uint8_t maximum) {
      usbdm_assert(minimum<maximum, "Minimum must be < maximum");

      ewm->CMPL = minimum;
      ewm->CMPH = maximum;
   }

   /**
    * Enable with default settings.
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();
      // Initialise hardware
   }

   /**
    * Write key values to service register.
    * The EWM service mechanism requires the CPU to write two values to the SERV register:
    * - a first data byte of 0xB4 (EwmKey1), followed by
    * - a second data byte of 0x2C (EwmKey2).
    *
    * The EWM service is illegal if either of the following conditions is true.
    * - The first or second data byte is not written correctly.
    * - The second data byte is not written within a fixed number of peripheral bus cycles of the first data byte.
    *   This fixed number of cycles is called EWM_service_time.
    *
    * @param ewmKey1 Key1 value to write (EwmKey1)
    * @param ewmKey2 Key2 value to write (EwmKey2)
    */
   static void writeKeys(uint8_t ewmKey1, uint8_t ewmKey2) {
      ewm->SERV = ewmKey1;
      ewm->SERV = ewmKey2;
   }

   /**
    * Enable EWM_in pin as input and connected to EWM.
    * Configures all Pin Control Register (PCR) values.
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = InputPin::defaultPcrValue,
         PinAction         pinAction         = InputPin::defaultPcrValue,
         PinFilter         pinFilter         = InputPin::defaultPcrValue
         ) {
      CheckInputPinIsMapped<Info::inputPin>::check();

      InputPin::setInput(pinPull, pinAction, pinFilter);
   }

   /**
    * Enable EWM_out pin as output and connected to EWM.
    * Configures all Pin Control Register (PCR) values.
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = OutputPin::defaultPcrValue,
         PinDriveMode      pinDriveMode      = OutputPin::defaultPcrValue,
         PinSlewRate       pinSlewRate       = OutputPin::defaultPcrValue
         ) {
      CheckOutputPinIsMapped<Info::outputPin>::check();

      OutputPin::setOutput(pinDriveStrength, pinDriveMode, pinSlewRate);
   }

   /**
    * Base configuration of EWM.
    *
    * @param ewmInput      Enables and selects polarity of EWM hardware input
    *
    * @note This is a write-once operation
    */
   static void configure(EwmInput  ewmInput) {
      enable();
      ewm->CTRL = EWM_CTRL_EWMEN(1)|ewmInput;
   }

   /**
    * Disable interface to EWM
    */
   static void disable() {
      Info::disableClock();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable/disable interrupts
    *
    * @param[in]  enable        True => enable, False => disable
    */
   static void enableInterrupt(bool enable=true) {
      if (enable) {
         ewm->CTRL |= EWM_CTRL_INTEN_MASK;
      }
      else {
         ewm->CTRL &= ~EWM_CTRL_INTEN_MASK;
      }
   }
};

template<class Info> EwmCallbackFunction EwmBase_T<Info>::sCallback = EwmBase_T<Info>::unhandledCallback;

#if defined(USBDM_EWM_IS_DEFINED)
class Ewm : public EwmBase_T<EwmInfo> {};
#endif

/**
 * End EWM_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_EWM_H_ */

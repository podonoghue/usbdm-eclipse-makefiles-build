<!--
Devices using this peripheral: 
      MKL27Z644
-->
      <peripheral>
         <?sourceFile "USB0_CLKRCV_B" ?>
         <?forcedBlockWidth "32" ?>
         <name>USB0</name>
         <description>USB Controller with clock recovery</description>
         <groupName>USB</groupName>
         <prependToName>USB0</prependToName>
         <headerStructName>USB</headerStructName>
         <baseAddress>0x40072000</baseAddress>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xFFFFFFFF</resetMask>
         <addressBlock>
            <?width "8" ?>
            <offset>0x0</offset>
            <size>0x10</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x1C</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x80</offset>
            <size>0x28</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0xB0</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0xC0</offset>
            <size>0x50</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x114</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x124</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x140</offset>
            <size>0x8</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x154</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <addressBlock>
            <?width "8" ?>
            <offset>0x15C</offset>
            <size>0x4</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>PERID</name>
               <description>Peripheral ID Register</description>
               <addressOffset>0x0</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x4</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>ID</name>
                     <description>Peripheral Identification</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>IDCOMP</name>
               <description>Peripheral ID Complement Register</description>
               <addressOffset>0x4</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0xFB</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>NID</name>
                     <description>Ones complement of peripheral identification bits</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>REV</name>
               <description>Peripheral Revision Register</description>
               <addressOffset>0x8</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x33</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>REV</name>
                     <description>Revision</description>
                     <bitOffset>0</bitOffset>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADDINFO</name>
               <description>Peripheral Additional Info Register</description>
               <addressOffset>0xC</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x1</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>IEHOST</name>
                     <description>USB operating mode</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Device Mode</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Host mode</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>OTGCTL</name>
               <description>OTG Control Register</description>
               <addressOffset>0x1C</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>DPHIGH</name>
                     <description>D+ Data Line pullup resistor enable</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>ISTAT</name>
               <description>Interrupt Status Register\n
The Interrupt Status Register contains bits for each of the interrupt sources within the USB Module.\n
Each of these bits are qualified with their respective interrupt enable bits</description>
               <addressOffset>0x80</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>USBRST</name>
                     <description>USB reset\n
This bit is set when the USB Module has decoded a valid USB reset.\n
USBRST is set after a USB reset has been detected for 2.5 microseconds.\n
It is not asserted again until the USB reset condition has been removed and then reasserted</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Inactive</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Pending</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="USBRST" > <name>ERROR</name> <description>Error Status set\n
This bit is set when any of the error conditions within Error Interrupt Status (ERRSTAT) register occur.\n
The processor must then read the ERRSTAT register to determine the source of the error</description> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="USBRST" > <name>SOFTOK</name> <description>Start Of Frame\n
This bit is set when the USB Module receives a Start Of Frame (SOF) token.\n
In Host mode this field is set when the SOF threshold is reached, so that software can prepare for the next SOF</description> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="USBRST" > <name>TOKDNE</name> <description>Token Done\n
This bit is set when the current token being processed has completed.\n
The processor should immediately read the STAT register to determine the EndPoint and BD used for this token.\n
Clearing this bit (by writing a one) causes the STAT register to be cleared or the STAT holding register to be loaded into the STAT register</description> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="USBRST" > <name>SLEEP</name> <description>Sleep timer\n
This bit is set when the USB Module detects a constant idle on the USB bus for 3 ms.\n
The sleep timer is reset by activity on the USB bus</description> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="USBRST" > <name>RESUME</name> <description>Resume detect\n
This bit is set depending upon the DP/DM signals, and can be used to signal remote wake-up signaling on the USB bus.\n
When not in suspend mode this interrupt must be disabled</description> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="USBRST" > <name>STALL</name> <description>Stall detected\nStall Interrupt</description> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>INTEN</name>
               <description>Interrupt Enable Register\n
The Interrupt Enable Register contains enable bits for each of the interrupt sources within the USB Module.\n
Setting any of these bits enables the respective interrupt source in the INT_STAT register</description>
               <addressOffset>0x84</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>USBRSTEN</name>
                     <description>USBRST Interrupt Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="USBRSTEN" > <name>ERROREN</name> <description>ERROR Interrupt Enable</description> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="USBRSTEN" > <name>SOFTOKEN</name> <description>SOFTOK Interrupt Enable</description> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="USBRSTEN" > <name>TOKDNEEN</name> <description>TOKDNE Interrupt Enable</description> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="USBRSTEN" > <name>SLEEPEN</name> <description>SLEEP Interrupt Enable</description> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="USBRSTEN" > <name>RESUMEEN</name> <description>RESUME Interrupt Enable</description> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="USBRSTEN" > <name>STALLEN</name> <description>STALL Interrupt Enable</description> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ERRSTAT</name>
               <description>Error Interrupt Status Register\n
The Error Interrupt Status Register contains enable bits for each of the error sources within the USB Module.\n
Each of these bits are qualified with their respective error enable bits</description>
               <addressOffset>0x88</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>PIDERR</name>
                     <description>PID Error\nThis bit is set when the PID check field fails</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Not detected</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Detected</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="PIDERR" > <name>CRC5</name> <description>CRC5EOF Error\n
This error interrupt has two functions:
 - When the USB Module is operating in peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token packets generated by the host.
   If set the token packet was rejected due to a CRC5 error</description> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="PIDERR" > <name>CRC16</name> <description>CRC16 Error\n
This bit is set when a data packet is rejected due to a CRC16 error</description> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="PIDERR" > <name>DFN8</name> <description>Data field length invalid\n
This bit is set if the data field received was not 8 bits in length</description> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="PIDERR" > <name>BTOERR</name> <description>Bus Turnaround Error\n
This bit is set when a bus turnaround timeout error occurs.\n
The USB module contains a bus turnaround timer that keeps track of the amount of time elapsed between the token and data phases of a SETUP or OUT TOKEN or the data and handshake phases of a IN TOKEN. If more than 16 bit times are counted from the previous EOP before a transition from IDLE, a bus turnaround timeout error occurs</description> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="PIDERR" > <name>DMAERR</name> <description>DMA Error\n
This bit is set if the USB Module has requested a DMA access to read a new BDT but has not been given the bus before it needs to receive or transmit data. If processing a TX transfer this would cause a transmit data underflow condition. If processing a RX transfer this would cause a receive data overflow condition. This interrupt is useful when developing device arbitration hardware for the microprocessor and the USB Module to minimize bus request and bus grant latency. This bit is also set if a data packet to or from the host is larger than the buffer size allocated in the BDT. In this case the data packet is truncated as it is put into buffer memory</description> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="PIDERR" > <name>BTSERR</name> <description>Bit Stuff Error\n
This bit is set when a bit stuff error is detected. If set, the corresponding packet is rejected due to the error</description> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ERREN</name>
               <description>Error Interrupt Enable Register</description>
               <addressOffset>0x8C</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>PIDERREN</name>
                     <description>PID Error interrupt Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="PIDERREN" > <name>CRC5EN</name> <description>CRC5 Error interrupt Enable</description> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="PIDERREN" > <name>CRC16EN</name> <description>CRC16 Error interrupt Enable</description> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="PIDERREN" > <name>DFN8EN</name> <description>Data format invalid interrupt Enable</description> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="PIDERREN" > <name>BTOERREN</name> <description>Bus turnaround error interrupt Enable</description> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="PIDERREN" > <name>DMAERREN</name> <description>DMA error interrupt Enable</description> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="PIDERREN" > <name>BTSERREN</name> <description>Bit stuff error interrupt Enable</description> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>STAT</name>
               <description>Status Register</description>
               <addressOffset>0x90</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>ODD</name>
                     <description>Buffer ODD/EVEN\n
Indicates if the last buffer descriptor updated was in the odd bank of the BDT</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Even</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Odd</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TX</name>
                     <description>Transmit Indicator\n
Indicates if the most recent transaction was a transmit operation</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Transmit</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Receive</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ENDP</name>
                     <description>Endpoint address\n
This four-bit field encodes the endpoint address that received or transmitted the previous token.\n
This allows the processor core to determine the BDT entry that was updated by the last USB transaction</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTL</name>
               <description>Control Register</description>
               <addressOffset>0x94</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>USBENSOFEN</name>
                     <description>USB Enable</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Module disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Module enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ODDRST</name>
                     <description>Odd Reset\n
Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which then specifies the EVEN BDT bank</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Inactive</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Active</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>TXSUSPENDTOKENBUSY</name>
                     <description>Token Busy\n
In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB token</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Idle</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Busy expecting token</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SE0</name>
                     <description>SE0 indication from bus\n
Live USB Single Ended Zero signal</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>SE0 false</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>SE0 true</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>JSTATE</name>
                     <description>JSTATE indication from bus\n
Live USB differential receiver JSTATE signal</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>KSTATE</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>JSTATE</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADDR</name>
               <description>Address Register</description>
               <addressOffset>0x98</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>ADDR</name>
                     <description>USB Address</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BDTPAGE1</name>
               <description>BDT Page Register 1\n
Address bits 15 through 9 of the BDT base address</description>
               <addressOffset>0x9C</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>BDTBA</name>
                     <description>BDT base address[15:9]</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>7</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>FRMNUML</name>
               <description>Frame Number Register Low</description>
               <addressOffset>0xA0</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>FRM</name>
                     <description>Frame Number[7:0]\n
Bits [7:0] of the current Frame number from SOF token</description>
                     <bitOffset>0</bitOffset>
                  </field>
               </fields>
            </register>
            <register>
               <name>FRMNUMH</name>
               <description>Frame Number Register High</description>
               <addressOffset>0xA4</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>FRM</name>
                     <description>Frame Number[10:9]\n
Bits [10:9] of the current Frame number from SOF token</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>BDTPAGE2</name>
               <description>BDT Page Register 2\n
Address bits 23 through 16 of the BDT base address</description>
               <addressOffset>0xB0</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>BDTBA</name>
                     <description>BDT base address[23:16]</description>
                     <bitOffset>0</bitOffset>
                  </field>
               </fields>
            </register>
            <register>
               <name>BDTPAGE3</name>
               <description>BDT Page Register 3\n
Address bits 15 through 8 of the BDT base address</description>
               <addressOffset>0xB4</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>BDTBA</name>
                     <description>BDT base address[7:0]</description>
                     <bitOffset>0</bitOffset>
                  </field>
               </fields>
            </register>
            <cluster>
               <dim>16</dim>
               <dimIncrement>4</dimIncrement>
               <dimIndex>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</dimIndex>
               <name>ENDPOINT,@p@f@i</name>
               <addressOffset>0xC0</addressOffset>
               <register>
                  <name>ENDPT</name>
                  <description>Endpoint Control Register</description>
                  <addressOffset>0x0</addressOffset>
                  <size>8</size>
                  <resetMask>0xFF</resetMask>
                  <fields>
                     <field>
                        <name>EPHSHK</name>
                        <description>Handshake enable\n
This bit enables an endpoint to perform handshaking during a transaction.\n
This bit is generally 1 unless the endpoint is Isochronous</description>
                        <bitOffset>0</bitOffset>
                        <bitWidth>1</bitWidth>
                        <enumeratedValues>
                           <enumeratedValue>
                              <name>0b0</name>
                              <description>Disabled</description>
                              <value>0b0</value>
                           </enumeratedValue>
                           <enumeratedValue>
                              <name>0b1</name>
                              <description>Enabled</description>
                              <value>0b1</value>
                           </enumeratedValue>
                        </enumeratedValues>
                     </field>
                     <field derivedFrom="EPHSHK" > <name>EPSTALL</name> <description>Endpoint Stall\n
When set this bit indicates that the endpoint is stalled. 
This bit has priority over all other control bits in the EndPoint Enable Register, but it is only valid if EPTXEN=1 or EPRXEN=1.\n
Any access to this endpoint causes the USB Module to return a STALL handshake.\n
After an endpoint is stalled it requires intervention from the Host Controller</description> <bitOffset>1</bitOffset> </field>
                     <field derivedFrom="EPHSHK" > <name>EPTXEN</name> <description>Transmit enable\n
This bit, when set, enables the endpoint for TX transfers</description> <bitOffset>2</bitOffset> </field>
                     <field derivedFrom="EPHSHK" > <name>EPRXEN</name> <description>Receive enable\n
This bit, when set, enables the endpoint for RX transfers</description> <bitOffset>3</bitOffset> </field>
                     <field>
                        <name>EPCTLDIS</name>
                        <description>Disable control transfers\n
This bit, when set, disables control (SETUP) transfers. \n
When cleared, control transfers are enabled.\n
This applies if and only if the EPRXEN and EPTXEN bits are also set</description>
                        <bitOffset>4</bitOffset>
                        <bitWidth>1</bitWidth>
                        <enumeratedValues>
                           <enumeratedValue>
                              <name>0b0</name>
                              <description>Enabled</description>
                              <value>0b0</value>
                           </enumeratedValue>
                           <enumeratedValue>
                              <name>0b1</name>
                              <description>Disabled</description>
                              <value>0b1</value>
                           </enumeratedValue>
                        </enumeratedValues>
                     </field>
                  </fields>
               </register>
            </cluster>
            <register>
               <name>USBCTRL</name>
               <description>USB Control Register</description>
               <addressOffset>0x100</addressOffset>
               <size>8</size>
               <resetValue>0xC0</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>PDE</name>
                     <description>Weak USB pull-down enable\n
Enables the weak pulldowns on the USB transceiver D+ and D-</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Pull-downs disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Pull-downs enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SUSP</name>
                     <description>Suspend Transceiver\n
Places the USB transceiver into the suspend state</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Transceiver active</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Transceiver suspended</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>OBSERVE</name>
               <description>USB OTG Observe Register\n
Provides observablity of USB pull-up/down signals</description>
               <addressOffset>0x104</addressOffset>
               <size>8</size>
               <access>read-only</access>
               <resetValue>0x50</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>DMPD</name>
                     <description>Observe D- \n
Provides observability of the D- Pull Down enable at the USB transceiver</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>D- pull-down disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>D- pull-down enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DPPD</name>
                     <description>Observe D+\n
Provides observability of the D+ Pull Down enable at the USB transceiver</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>D+ pull-down disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>D+ pull-down enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>DPPU</name>
                     <description>Observe D+\n
Provides observability of the D+ Pull Up enable at the USB transceiver</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>D+ pull-up disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>D+ pull-up enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CONTROL</name>
               <description>USB OTG Control Register</description>
               <addressOffset>0x108</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>DPPULLUPNONOTG</name>
                     <description>Non-OTG pull-up control\n
Provides control of the DP Pullup in the USB OTG module, if USB is configured in non-OTG device mode</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>DP Pull-up disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>DP Pull-up enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>USBTRC0</name>
               <description>USB Transceiver Control Register 0</description>
               <addressOffset>0x10C</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>USB_RESUME_INT</name>
                     <description>USB Asynchronous Interrupt Detect</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <access>read-only</access>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Not detected</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Detected</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="USB_RESUME_INT" > <name>SYNC_DET</name> <description>USB Synchronous Interrupt Detect</description> <bitOffset>1</bitOffset> </field>
                  <field>
                     <name>USB_CLK_RECOVERY_INT</name>
                     <description>Combined USB Clock Recovery interrupt status</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <access>read-only</access>
                  </field>
                  <field>
                     <name>USBRESMEN</name>
                     <description>Asynchronous Resume Interrupt Enable\n
This bit, when set, allows the USB module to send an asynchronous wakeup event to the MCU upon detection of resume signaling on the USB bus</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Interrupt disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>USBRESET</name>
                     <description>USB Reset\n
Generates a hard reset to the USB_OTG module. After this bit is set and the reset occurs, this bit is automatically cleared</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <access>write-only</access>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Normal operation</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Reset module</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>USBFRMADJUST</name>
               <description>Frame Adjust Register</description>
               <addressOffset>0x114</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>ADJ</name>
                     <description>Frame Adjustment</description>
                     <bitOffset>0</bitOffset>
                  </field>
               </fields>
            </register>
            <register>
               <name>KEEP_ALIVE_CTRL</name>
               <description>Keep Alive mode control</description>
               <addressOffset>0x124</addressOffset>
               <size>8</size>
               <resetValue>0x8</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>KEEP_ALIVE_EN</name>
                     <description>no description available</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>OWN_OVERRD_EN</name>
                     <description>no description available</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>STOP_ACK_DLY_EN</name>
                     <description>no description available</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Enter KEEP_ALIVE mode until the USB core is idle and there is no USB AHB transfer</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enter KEEP_ALIVE mode immediately when there is no USB AHB transfer</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>AHB_DLY_EN</name>
                     <description>no description available</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Do not delay the USB AHB transfer if the USB AHB transfer occurs while exiting KEEP_ALIVE mode</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Delay the USB AHB transfer until the clock is recovered, if the USB AHB transfer occurs while exiting KEEP_ALIVE mode</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>WAKE_INT_EN</name>
                     <description>Wakeup Interrupt Enable</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                  </field>
                  <field>
                     <name>WAKE_INT_STS</name>
                     <description>Wakeup Interrupt Status</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <access>read-only</access>
                  </field>
               </fields>
            </register>
            <register>
               <name>KEEP_ALIVE_WKCTRL</name>
               <description>Keep Alive mode wakeup control</description>
               <addressOffset>0x128</addressOffset>
               <size>8</size>
               <resetValue>0x1</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>WAKE_ON_THIS</name>
                     <description>no description available</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>4</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0001</name>
                           <description>Wake up on receiving OUT/SETUP token packet</description>
                           <value>0b0001</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1101</name>
                           <description>Wake up on receiving SETUP token packet.All other values are reserved</description>
                           <value>0b1101</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>WAKE_ENDPT</name>
                     <description>no description available</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>4</bitWidth>
                     <access>read-only</access>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_RECOVER_CTRL</name>
               <description>USB Clock recovery control\n
Signals in this register control the crystal-less USB clock mode in which the internal 
IRC48M oscillator is tuned to match the clock extracted from the incoming USB data stream</description>
               <addressOffset>0x140</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>RESTART_IFRTRIM_EN</name>
                     <description>Restart from IFR trim value\n
IRC48 has a default trim fine value whose default value is factory trimmed (the IFR trim value).\n
Clock recover block tracks the accuracy of the clock 48Mhz and keeps updating the trim fine value accordingly</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Trim fine adjustment always works based on the previous updated trim fine value (default)</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Trim fine restarts from the IFR trim value whenever bus_reset/bus_resume is detected or module disabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>RESET_RESUME_ROUGH_EN</name>
                     <description>Reset/resume to rough phase enable\n
The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock. 
It has two phases rough phase and tracking phase.\n
Switch back to rough stage whenever USB bus reset or bus resume occurs</description>
                     <bitOffset>6</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Always works in tracking phase after the 1st time rough to track transition (default)</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Go back to rough stage whenever bus reset or bus resume occurs</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CLOCK_RECOVER_EN</name>
                     <description>Crystal-less USB enable\n
This bit must be enabled if user wants to use the crystal-less USB mode for 
the Full Speed USB controller and transceiver.\n
NOTE: This bit should not be set for USB host mode or OTG</description>
                     <bitOffset>7</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disable clock recovery block (default)</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enable clock recovery block</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_RECOVER_IRC_EN</name>
               <description>IRC48M oscillator enable register\n
Controls basic operation of the on-chip IRC48M module used to produce a nominal 
48MHz clocks for USB crystal-less operation and other functions</description>
               <addressOffset>0x144</addressOffset>
               <size>8</size>
               <resetValue>0x1</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>IRC_EN</name>
                     <description>IRC48M enable\n
This bit is used to enable the on-chip IRC48Mhz module to generate clocks for crystal-less USB. \n
It can only be used for FS USB device mode operation.\n
This bit must be set before using the crystal-less USB clock configuration</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disable the IRC48M module (default)</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enable the IRC48M module</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_RECOVER_INT_EN</name>
               <description>Clock recovery combined interrupt enable</description>
               <addressOffset>0x154</addressOffset>
               <size>8</size>
               <resetValue>0x10</resetValue>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>OVF_ERROR_EN</name>
                     <description>no description available</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>The interrupt will be masked</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>The interrupt will be enabled (default)</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CLK_RECOVER_INT_STATUS</name>
               <description>Clock recovery separated interrupt status\n
A Write operation with value high at 1&apos;b1 on any combination of individual bits 
will clear those bits</description>
               <addressOffset>0x15C</addressOffset>
               <size>8</size>
               <resetMask>0xFF</resetMask>
               <fields>
                  <field>
                     <name>OVF_ERROR</name>
                     <description>Indicates that the USB clock recovery algorithm has detected 
that the frequency trim adjustment needed for the IRC48M output clock is outside the available 
TRIM_FINE adjustment range for the IRC48M module</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No interrupt is reported</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Unmasked interrupt has been generated</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>

<!--
Devices using this peripheral: 
      MCF5223x
      MCF5225x
-->
      <peripheral>
         <?sourceFile "MCF522xx_ADC" ?>
         <?preferredAccessWidth "32" ?>
         <?forcedBlockWidth "32" ?>
         <name>ADC</name>
         <description>Analogue-to-Digital Converter\n
The analog-to-digital converter (ADC) consists of two separate and complete ADCs, each with their own
sample and hold circuits. The converters share a common voltage reference and common digital control
module</description>
         <prependToName>ADC</prependToName>
         <headerStructName>ADC</headerStructName>
         <baseAddress>0x40190000</baseAddress>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xFFFFFFFF</resetMask>
         <addressBlock>
            <offset>0x0</offset>
            <size>0x58</size>
            <usage>registers</usage>
         </addressBlock>
         <registers>
            <register>
               <name>CTRL1</name>
               <description>Control Register 1\n
Used to configure and control the ADC module</description>
               <addressOffset>0x0</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>SMODE</name>
                     <description>Scan Mode Control. \n
This field controls the scan mode of the ADC module</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b000</name>
                           <description>Once sequential</description>
                           <value>0b000</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b001</name>
                           <description>Once parallel</description>
                           <value>0b001</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b010</name>
                           <description>Loop sequential</description>
                           <value>0b010</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b011</name>
                           <description>Loop parallel</description>
                           <value>0b011</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b100</name>
                           <description>Triggered sequential</description>
                           <value>0b100</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b101</name>
                           <description>Triggered parallel</description>
                           <value>0b101</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b110</name>
                           <description>Reserved</description>
                           <value>0b110</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b111</name>
                           <description>Reserved</description>
                           <value>0b111</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CHNCFG0</name>
                     <description>Channel Configure\n
This field configures the inputs for single-ended or differential conversions\n
In differential pair (ANx is + and ANx+1 is -)</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Single ended inputs</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Differential pair</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="CHNCFG0" > <name>CHNCFG1</name> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="CHNCFG0" > <name>CHNCFG2</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="CHNCFG0" > <name>CHNCFG3</name> <bitOffset>7</bitOffset> </field>
                  <field>
                     <name>HLMTIE</name>
                     <description>High Limit Interrupt Enable bit\n
This bit enables the high limit exceeded interrupt if the current result value is
greater than the high limit register value. The raw result value is compared to ADHLMT[HLMT] before the
offset register value is subtracted</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Interrupt disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="HLMTIE" > <name>LLMTIE</name> <description>Low Limit Interrupt Enable bit\n 
This bit enables the low limit exceeded interrupt when the current result value
is less than the low limit register value.\n
The raw result value is compared to ADLLMTn[LLMT] before the offset
register value is subtracted</description> <bitOffset>9</bitOffset> </field>
                  <field derivedFrom="HLMTIE" > <name>ZCIE</name> <description>Zero Crossing Interrupt Enable bit\n 
This bit enables the zero crossing interrupt if the current result value has
a sign change from the previous result as configured by the ADZCC register</description> <bitOffset>10</bitOffset> </field>
                  <field derivedFrom="HLMTIE" > <name>EOSIE0</name> <description>End of Scan Interrupt 0 Enable bit\n 
This bit enables an EOSI0 interrupt to be generated upon completion of the scan.\n
For looping scan modes, the interrupt triggers after the completion of each iteration of the loop</description> <bitOffset>11</bitOffset> </field>
                  <field>
                     <name>SYNC0</name>
                     <description>Synchronisation 0 Enable bit\n
When this bit is set, a conversion may be initiated by asserting a positive edge on the SYNC0 input.\n
Any subsequent SYNC0 input pulses that occur during the scan are ignored.\n
In once sequential and once parallel scan modes, only the first SYNC0 input pulse is honoured.\n
Subsequent SYNC0 input pulses are ignored until SYNC0 input is re-armed by setting SYNC0.\n
This can be done at any time, even during the execution of the scan.\n
The ADC must be in a stable power configuration prior to writing to START0</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>START0\t initiates scan</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>SYNC0 or START0\t initiates scan</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>START0</name>
                     <description>Start Conversion 0 bit\n 
A scan is started by writing a 1 to this bit. START0 is write-only.\n
Writing 1 to the START0 bit again is ignored until the end of the current scan.\n
The ADC must be in a stable power configuration prior to writing to START0</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No action</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Start command is issued</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>STOP0</name>
                     <description>Stop Conversion 0 bit\n 
When STOP0 is set, the current scan is stopped and no further scans can start.\n
Any further SYNC0 input pulses (see the SYNC0 field description) or writes to START0 are ignored until STOP0 is cleared.\n
After the ADC is in stop mode, the result registers can be modified by the processor. \n
Any changes to the result registers in stop mode are treated as if the analogue core supplied the data.\n
Therefore, limit checking, zero crossing, and associated interrupts can occur if enabled</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Normal operation</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Stop mode</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CTRL2</name>
               <description>Control Register 2</description>
               <addressOffset>0x2</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>DIV</name>
                     <description>Clock Divisor Select\n 
This field controls the divider circuit, which generates the ADC clock by dividing the system clock by 2xDIV+1. \n
DIV must be chosen so the ADC clock does not exceed 5.0 MHz</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>5</bitWidth>
                  </field>
                  <field>
                     <name>SIMULT</name>
                     <description>Simultaneous Mode bit\n
This bit only affects parallel scan modes. When SIMULT equals 1, parallel scans operate in simultaneous mode.\n
The scans in the A and B converter operate simultaneously and always result in pairs of simultaneous conversions in the A and B converter.
START0, STOP0, SYNC0, and EOSIE0 control bits and the SYNC0 input are used to start and stop scans in both converters simultaneously</description>
                     <bitOffset>5</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Independent</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Simultaneous</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EOSIE1</name>
                     <description>End of Scan Interrupt 1 Enable bit. \n
In parallel-scan modes when SIMULT equalling 0, this bit enables an EOSI1 interrupt to be generated upon completion of the scan.\n
For looping scan modes, the interrupt triggers after the completion of each iteration of the loop</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Interrupt disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SYNC1</name>
                     <description>Synchronisation 1 Enable bit\n 
In parallel-scan modes when SIMULT equalling 0, setting SYNC1 allows a conversion to be 
initiated by asserting a positive edge on the SYNC1 input. \n
Any subsequent SYNC1 input pulses that occur during the scan are ignored.\n 
In once sequential and once parallel scan modes, only the first SYNC1 input pulse is honoured.\n 
Subsequent SYNC1 input pulses are ignored until SYNC1 input is re-armed by setting SYNC1. \n
This can be done at any time, even during the execution of the scan. \n
The ADC must be in a stable power configuration prior to writing to START0</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>START1 initiates</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>SYNC1 or START1 initiates</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>START1</name>
                     <description>Start Conversion 1 bit\n 
In parallel-scan modes when SIMULT equalling 0, a scan by the B converter is started by writing a 1 to this bit.\n
START1 is write-only. Writing 1 to the START1 bit again is ignored until the end of the current scan.\n
The ADC must be in a stable power configuration prior to writing to START1</description>
                     <bitOffset>13</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No action</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Start command is issued</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>STOP1</name>
                     <description>Stop Conversion 1bit\n
In parallel-scan modes when SIMULT equalling 0, setting STOP1 stops parallel scans
in the B converter and prevents new scans from starting. Any further SYNC1 input pulses or writes to 
START1 are ignored until STOP1 is cleared. After the ADC is in stop mode, the
result registers can be modified by the processor. Any changes to the result registers in stop mode are
treated as if the analogue core supplied the data. Therefore, limit checking, zero crossing, and associated
interrupts can occur if enabled</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Normal operation</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Stop mode</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADZCC</name>
               <description>Zero Crossing Control Register\n 
For each channel n, setting the ZCEn field allows detection of the indicated zero
crossing condition, provided the corresponding offset register (ADOFSn) has a value offset, 
0 &lt; offset &gt; 0x7FF8</description>
               <addressOffset>0x4</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>ZCE0</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>2</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b00</name>
                           <description>Disabled\t- Zero crossing is not detected</description>
                           <value>0b00</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b01</name>
                           <description>Falling\t- Zero crossing enabled for positive to negative</description>
                           <value>0b01</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b10</name>
                           <description>Rising\t- Zero crossing enabled for negative to positive</description>
                           <value>0b10</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b11</name>
                           <description>Either\t- Zero crossing enabled for any sign change</description>
                           <value>0b11</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="ZCE0" > <name>ZCE1</name> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE2</name> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE3</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE4</name> <bitOffset>8</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE5</name> <bitOffset>10</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE6</name> <bitOffset>12</bitOffset> </field>
                  <field derivedFrom="ZCE0" > <name>ZCE7</name> <bitOffset>14</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ADLST1</name>
               <description>Channel List Register 1\n
This register contains a list of channels to be converted when the scan is initiated.\n 
Sequential scan of inputs proceeds in order of SAMPLE0 through SAMPLE7.\n
In parallel sampling modes Converter A samples SAMPLE0-3 &amp; Converter B samples SAMPLE4-7</description>
               <addressOffset>0x6</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>SAMPLE0</name>
                     <description>Sample input channel select 0\n Channel number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE1</name>
                     <description>Sample input channel select 1\n Channel number</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE2</name>
                     <description>Sample input channel select 2\n Channel number</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE3</name>
                     <description>Sample input channel select 3\n Channel number</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADLST2</name>
               <description>Channel List Register 2\n
This register contains a list of channels to be converted when the scan is initiated.\n 
Sequential scan of inputs proceeds in order of SAMPLE0 through SAMPLE7.\n
In parallel sampling modes Converter A samples SAMPLE0-3 &amp; Converter B samples SAMPLE4-7</description>
               <addressOffset>0x8</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>SAMPLE4</name>
                     <description>Sample input channel select 4\n Channel number</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE5</name>
                     <description>Sample input channel select 5\n Channel number</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE6</name>
                     <description>Sample input channel select 6\n Channel number</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
                  <field>
                     <name>SAMPLE7</name>
                     <description>Sample input channel select 7\n Channel number</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>3</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADSDIS</name>
               <description>Sample Disable Register\n
Setting or clearing DSn enables or disables the corresponding SAMPLEn field</description>
               <addressOffset>0xA</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>DS0</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Sample Enabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Sample Disable</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="DS0" > <name>DS1</name> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS2</name> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS3</name> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS4</name> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS5</name> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS6</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="DS0" > <name>DS7</name> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ADSTAT</name>
               <description>Status Register</description>
               <addressOffset>0xC</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>RDY0</name>
                     <description>Channel sample status</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Not ready</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Ready</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="RDY0" > <name>RDY1</name> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY2</name> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY3</name> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY4</name> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY5</name> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY6</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="RDY0" > <name>RDY7</name> <bitOffset>7</bitOffset> </field>
                  <field>
                     <name>HLMTI</name>
                     <description>High Limit Interrupt\n
If any high limit register (ADHLMTn) is enabled by having a value other than 0x7FF8, high limit checking is enabled.\n
This bit is set at the completion of an individual conversion which may or may not be the end of a scan.\n
It is cleared by writing 1 to all active ADLSTAT[HLS] bits</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No Interrupt</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt pending</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>LLMTI</name>
                     <description>Low Limit Interrupt\n
If any low limit register (ADLLMTn) is enabled by having a value other than 0x0, low limit checking is enabled.\n
This bit is set at the completion of an individual conversion which may or may not be the end of a scan.\n
It is cleared by writing 1 to all active ADLSTAT[LLS] bits</description>
                     <bitOffset>9</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No Interrupt</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt pending</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ZCI</name>
                     <description>Zero Crossing Interrupt\n
This bit is asserted at the completion of an individual conversion experiencing a zero 
crossing enabled in the ADC zero crossing control (ADZCC) register.\n
The bit is set as soon as an enabled zero crossing event occurs rather than at the end of the ADC scan.\n
ZCI is cleared by writing 1 to all active ADZCSTAT[ZCS] bits</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No interrupt</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt pending</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>EOSI0</name>
                     <description>End of Scan Interrupt\n
This bit indicates whether a scan of analogue inputs has been completed since the last read of ADSTAT or a reset.\n
The EOSIx bit is cleared by writing a 1 to it. This bit cannot be set by software.\n
EOSIx is the preferred bit to poll for scan completion if interrupts are not enabled.\n
In looping scan modes, this interrupt is triggered at the completion of each iteration of a loop.\n
This interrupt is triggered upon the completion of any sequential scan or parallel scan with SIMULT equalling 1.\n
When executing parallel scans with SIMULT equalling 0, this interrupt is triggered when converter A completes 
its scan while the EOSI1 interrupt services converter B</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No Interrupt\tA scan cycle has not been completed</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Interrupt pending\tA scan cycle has been completed</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="EOSI0" > <name>EOSI1</name> <bitOffset>12</bitOffset> </field>
                  <field>
                     <name>CIP1</name>
                     <description>Conversion in Progress 1 bit\n
This refers only to a B converter scan in non-simultaneous (SIMULT=0) parallel scan modes</description>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Idle state</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>A scan cycle is in progress (the ADC ignores all sync pulses or start commands)</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>CIP0</name>
                     <description>Conversion in Progress 0 bit\n
This bit indicates when a scan is in progress.\n
This bit supports any sequential scan or parallel scan with SIMULT equalling 1.\n
When executing a parallel scan with SIMULT equalling 0, this bit services the scan of 
converter A, and the CIP1 bit services the scan of converter B</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Idle state</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Busy</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>ADLSTAT</name>
               <description>Limit Status Register</description>
               <addressOffset>0xE</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>LLS0</name>
                     <description>Low Limit Status bits\n 
These bits hold the result of a comparison between the sample (stored in ADRSLTn) and the low-limit value (stored in ADLLMTn)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Sample &gt;= low-limit</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Sample &lt; low-limit</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="LLS0" > <name>LLS1</name> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS2</name> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS3</name> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS4</name> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS5</name> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS6</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="LLS0" > <name>LLS7</name> <bitOffset>7</bitOffset> </field>
                  <field>
                     <name>HLS0</name>
                     <description>High Limit Status bits\n
These bits hold the result of a comparison between the sample (stored in ADRSLTn) and the high-limit value (stored in ADHLMTn)</description>
                     <bitOffset>8</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Sample &gt;= high-limit</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Sample &lt; high-limit</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="HLS0" > <name>HLS1</name> <bitOffset>9</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS2</name> <bitOffset>10</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS3</name> <bitOffset>11</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS4</name> <bitOffset>12</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS5</name> <bitOffset>13</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS6</name> <bitOffset>14</bitOffset> </field>
                  <field derivedFrom="HLS0" > <name>HLS7</name> <bitOffset>15</bitOffset> </field>
               </fields>
            </register>
            <register>
               <name>ADZCSTAT</name>
               <description>Zero Crossing Status Register\n
These bits hold the result of a sign comparison between the current and previous sample.
The type of comparison is controlled by the ADZCC register\n
Note: These bits are sticky, and can only be cleared by writing a 1 to them</description>
               <addressOffset>0x10</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>ZCS0</name>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>No sign change</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Sign changed</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field derivedFrom="ZCS0" > <name>ZCS1</name> <bitOffset>1</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS2</name> <bitOffset>2</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS3</name> <bitOffset>3</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS4</name> <bitOffset>4</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS5</name> <bitOffset>5</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS6</name> <bitOffset>6</bitOffset> </field>
                  <field derivedFrom="ZCS0" > <name>ZCS7</name> <bitOffset>7</bitOffset> </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>2</dimIncrement>
               <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
               <name>ADRSLT</name>
               <description>Result Registers\n
The result registers contain the converted results from a scan</description>
               <addressOffset>0x12</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>RSLT</name>
                     <description>Result of the conversion</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
                  <field>
                     <name>SEXT</name>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Result is positive</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Result is negative</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>2</dimIncrement>
               <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
               <name>ADLLMT%s</name>
               <description>Low Limit Register</description>
               <addressOffset>0x22</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>LLMT</name>
                     <description>Low limit\n
Each sample is compared against this value\n
The comparison is based upon the raw conversion value before the offset correction is applied</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>2</dimIncrement>
               <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
               <name>ADHLMT%s</name>
               <description>High Limit Register</description>
               <addressOffset>0x32</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>HLMT</name>
                     <description>High limit\n
Each sample is compared against this value\n
The comparison is based upon the raw conversion value before the offset correction is applied</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <dim>8</dim>
               <dimIncrement>2</dimIncrement>
               <dimIndex>0,1,2,3,4,5,6,7</dimIndex>
               <name>ADOFS%s</name>
               <description>Offset Register</description>
               <addressOffset>0x42</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>OFFSET</name>
                     <description>Offset value\n
This value is subtracted from the raw ADC value, and the result is stored in the respective ADRSLTn register</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>12</bitWidth>
                  </field>
               </fields>
            </register>
            <register>
               <name>POWER</name>
               <description>Power Control Register</description>
               <addressOffset>0x52</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>PD0</name>
                     <description>Manual Power-Down for Converter A\n
This bit forces Converter A to power-down. Setting PD0 powers-down converter A immediately. 
The results of a scan using converter A is invalid when PD0 is set. 
When PD0 is cleared, converter A is continuously powered-up (APD = 0) or automatically powered-up when
needed (APD = 1)</description>
                     <bitOffset>0</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Power-up</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Power-down</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PD1</name>
                     <description>Manual Power-Down for Converter B\n
This bit forces Converter B to power-down. Setting PD1
powers-down converter B immediately. The results of a scan using converter B is invalid when PD1 is set.
When PD1 is cleared, converter B is continuously powered-up (APD = 0) or automatically powered-up when
needed (APD = 1)</description>
                     <bitOffset>1</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Power-up</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Power-down</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PD2</name>
                     <description>Power-Down Control for Voltage Reference\n
This bit controls the power-down of the ADC&apos;s voltage
reference circuit. This circuit is shared by both converters. When PD2 is set, the voltage reference is activated
when PD1 or PD0 are enabled. It is not usually necessary to modify this bit, because disabling
(powering-down) converter A and converter B automatically powers-down the voltage reference</description>
                     <bitOffset>2</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Power-up</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Power-down\tVoltage reference circuit is controlled by PD0 and PD1</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>APD</name>
                     <description>Auto Power-Down Mode bit\n
Auto power-down mode disables converters when they are not in use for a scan.
APD takes precedence over ASB. When a scan is started in APD mode, a delay of PUDELAY ADC clock
cycles is imposed during which the needed converter(s), if idle, are enabled. The ADC then initiates a scan
equivalent to when APD is not active. When the scan is completed, the converter(s) are disabled again</description>
                     <bitOffset>3</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Active</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Inactive</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PUDELAY</name>
                     <description>Power-Up Delay\n
This field determines the number of ADC clock cycles provided to enable an ADC converter
(after clearing PD0 or PD1) before allowing a scan to start. It also determines the number of ADC clock
cycles of delay provided in auto power-down (APD) and auto standby (ASB) modes between when the ADC
goes from the idle to active state and when the scan is allowed to start. The default value is 13 ADC clock
cycles. Accuracy of the initial conversions in a scan is degraded if PUDELAY is too low</description>
                     <bitOffset>4</bitOffset>
                     <bitWidth>6</bitWidth>
                  </field>
                  <field>
                     <name>PSTS0</name>
                     <description>Converter A Power Status bit\n
This bit is asserted immediately after PD0 is set. It is de-asserted PUDELAY
ADC clock cycles after PD0 is cleared if APD is 0. This bit can be read as a status bit to determine when the
ADC is ready for operation. During auto power-down mode, this bit indicates the current powered state of
converter A</description>
                     <bitOffset>10</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Enabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Disabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PSTS1</name>
                     <description>Converter B Power Status bit\n
This bit is asserted immediately after PD1 is set. It is de-asserted PUDELAY
ADC clock cycles after PD1 is cleared if APD is 0. This bit can be read as a status bit to determine when the
ADC is ready for operation. During auto power-down mode, this bit indicates the current powered state of
converter B</description>
                     <bitOffset>11</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Enabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Disabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>PSTS2</name>
                     <description>Voltage Reference Power Status bit</description>
                     <bitOffset>12</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Enabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Disabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>ASB</name>
                     <description>Auto Standby bit\n
This bit selects auto standby mode. ASB is ignored if APD is set. When the ADC is idle,
auto standby mode selects the standby clock as the ADC clock source and puts the converters into standby
current mode. At the start of any scan, the conversion clock is selected as the ADC clock and a delay of
PUDELAY ADC clock cycles is imposed for current levels to stabilize. After this delay, the ADC initiates the
scan. When the ADC returns to the idle state, the standby clock is again selected and the converters revert
to the standby current state</description>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>Disabled</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>Enabled</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
            <register>
               <name>CAL</name>
               <description>Voltage Reference Register</description>
               <addressOffset>0x54</addressOffset>
               <size>16</size>
               <resetMask>0xFFFF</resetMask>
               <fields>
                  <field>
                     <name>SEL_VREFL</name>
                     <bitOffset>14</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>VREFL = VRH</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>VREFL = AN2</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
                  <field>
                     <name>SEL_VREFH</name>
                     <bitOffset>15</bitOffset>
                     <bitWidth>1</bitWidth>
                     <enumeratedValues>
                        <enumeratedValue>
                           <name>0b0</name>
                           <description>VREFH = VRL</description>
                           <value>0b0</value>
                        </enumeratedValue>
                        <enumeratedValue>
                           <name>0b1</name>
                           <description>VREFH = AN6</description>
                           <value>0b1</value>
                        </enumeratedValue>
                     </enumeratedValues>
                  </field>
               </fields>
            </register>
         </registers>
      </peripheral>

/*
 * @file mcg_lite.cpp  (180.ARM_Peripherals/Startup_Code/mcg_lite.cpp)
 *
 * Based on KL03
 *    1 FLL (FRDIV=/1-/128, /32-/1024, /1280, /1536)
 *    1 PLL (VCO PRDIV=/1-/24, VDIV=pll_vdiv_min+x) (pll_vdiv_min=x16,x24)
 *
 *  Created on: 04/03/2012
 *      Author: podonoghue
 */
#include "string.h"
#include "derivative.h"
#include "system.h"
#include "stdbool.h"
#include "pin_mapping.h"
#include "sim.h"
$(/MCG/Includes:// No extra includes found)
#include "mcg.h"
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
extern "C" uint32_t SystemCoreClock;
extern "C" uint32_t SystemBusClock;

namespace USBDM {

#ifndef SIM_CLKDIV1_OUTDIV2
#define SIM_CLKDIV1_OUTDIV2(x) (0)
#endif

#ifndef SIM_CLKDIV1_OUTDIV3
#define SIM_CLKDIV1_OUTDIV3(x) (0)
#endif

ClockChangeCallback *Mcg::clockChangeCallbackQueue = nullptr;

/**
 * Table of clock settings
 */
const ClockInfo Mcg::clockInfo[] = {
$(/MCG/McgClockInfoEntries:!!!!!!!Not found!!!!!!!)
};

/** MCGFFCLK - Fixed frequency clock (input to FLL) */
volatile uint32_t SystemMcgFFClock;

/** MCGOUTCLK - Primary output from MCG, various sources */
volatile uint32_t SystemMcgOutClock;

/** MCGFLLCLK - Output of FLL */
volatile uint32_t SystemMcgFllClock;

/** MCGPLLCLK - Output of PLL */
volatile uint32_t SystemMcgPllClock;

/**
 *  Change SIM->CLKDIV1 value
 *
 * @param simClkDiv1 - Value to write to SIM->CLKDIV1 register
 */
static void setSysDividers(uint32_t simClkDiv1) {
   // Change CLKDIV1
   SIM->CLKDIV1 = simClkDiv1;
}

/** Callback for programmatically set handler */
MCGCallbackFunction Mcg::callback = {unhandledCallback};

/** Current clock mode (FEI out of reset) */
McgClockMode Mcg::currentClockMode = McgClockMode_LIRC_2MHz;

constexpr McgClockMode clockTransitionTable[4][4] = {
         /*  from  to =>   LIRC_2M,                  LIRC_8M,                  HIRC_48M,                  EXT,   */
         /* LIRC_2M,  */ { McgClockMode_LIRC_2MHz,  McgClockMode_HIRC_48MHz, McgClockMode_HIRC_48MHz,  McgClockMode_EXT,   },
         /* LIRC_8M,  */ { McgClockMode_HIRC_48MHz, McgClockMode_LIRC_8MHz,  McgClockMode_HIRC_48MHz,  McgClockMode_EXT,   },
         /* HIRC_48M, */ { McgClockMode_LIRC_2MHz,  McgClockMode_LIRC_8MHz,  McgClockMode_HIRC_48MHz,  McgClockMode_EXT,   },
         /* EXT,      */ { McgClockMode_LIRC_2MHz,  McgClockMode_LIRC_8MHz,  McgClockMode_HIRC_48MHz,  McgClockMode_EXT,   },
};

/**
 * Get name for clock mode
 *
 * @return Pointer to static string
 */
const char *Mcg::getClockModeName(McgClockMode clockMode) {
   static const char *modeNames[] {
         "LIRC_2M",
         "LIRC_8M",
         "HIRC_48M",
         "EXT",
   };

   if ((unsigned)clockMode>=(sizeof(modeNames)/sizeof(modeNames[0]))) {
      return "Illegal";
   }
   return modeNames[clockMode];
}

/**
 * Transition from current clock mode to mode given
 *
 * @param[in]  clockInfo Clock mode to transition to
 *
 * @return E_NO_ERROR on success
 */
ErrorCode Mcg::clockTransition(const ClockInfo &clockInfo) {

   // Notify of clock changes (before)
   notifyBeforeClockChange();

   McgClockMode finalMode = clockInfo.clockMode;


   // Set conservative clock dividers
   setSysDividers(SIM_CLKDIV1_OUTDIV1(0)|SIM_CLKDIV1_OUTDIV2(1)|SIM_CLKDIV1_OUTDIV3(2)|SIM_CLKDIV1_OUTDIV4(3));

   // Set Fast Internal Clock divider (FCRDIV)
   mcg->SC = clockInfo.sc;

   // Set HIRCEN, LIRC_DIV2
   mcg->MC = clockInfo.mc;


   int transitionCount = 0;
   do {
      // Used to indicate that clock stabilization wait is needed
      bool externalClockInUse = false;

      McgClockMode next = clockTransitionTable[currentClockMode][finalMode];

      switch (next) {

      case McgClockMode_LIRC_2MHz: // From HIRC48, EXT or reset(FEI)

         mcg->C2 =
               MCG_C2_IRCS(0)   | // IRCS = 0 -> LIRC is in 2 MHz mode
               clockInfo.c2;      // RANGE0, HGO0, EREFS0

         mcg->C1 =
               MCG_C1_CLKS(1)   | // CLKS     = 1     -> IRC Selected
               clockInfo.c1;      // IREFSTEN, IRCLKEN

         // Wait for S_IREFST to indicate FLL Reference has switched to IRC
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_CLKST_MASK) != (MCG_S_CLKST(1)));
         break;

      case McgClockMode_LIRC_8MHz: // From HIRC48, EXT or reset(FEI)

         mcg->C2 =
               MCG_C2_IRCS(1)   | // IRCS = 1 -> LIRC is in 2 MHz mode
               clockInfo.c2;      // RANGE0, HGO0, EREFS0

         mcg->C1 =
               MCG_C1_CLKS(1)   | // CLKS     = 1     -> IRC Selected
               clockInfo.c1;      // IREFSTEN, IRCLKEN

         // Wait for S_IREFST to indicate FLL Reference has switched to IRC
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_CLKST_MASK) != (MCG_S_CLKST(1)));
         break;

      case McgClockMode_HIRC_48MHz: // from LIRC_2M, LIRC_8M, EXT

         mcg->C2 =
               clockInfo.c2;      // IRCS, RANGE0, HGO0, EREFS0

         mcg->C1 =
               MCG_C1_CLKS(0)   | // CLKS     = 0     -> HIRC selected
               clockInfo.c1;      // IREFSTEN, IRCLKEN

         // Wait for S_CLKST to indicating that OUTCLK has switched to IRC
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_CLKST_MASK) != MCG_S_CLKST(0));
         break;

      case McgClockMode_EXT:  // from LIRC_2M, LIRC_8M, HIRC

         mcg->C2 =
               clockInfo.c2;      // IRCS, RANGE0, HGO0, EREFS0

         mcg->C1 =
               MCG_C1_CLKS(2)   | // CLKS     = 2     -> EXT selected
               clockInfo.c1;      // IREFSTEN, IRCLKEN

         // Wait for S_CLKST to indicating that OUTCLK has switched to IRC
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2));

         externalClockInUse = true;
         break;
      }
      // Wait for oscillator stable (if used)
      if (externalClockInUse && (clockInfo.c2&MCG_C2_EREFS0_MASK)) {
         do {
            __asm__("nop");
         } while ((mcg->S & MCG_S_OSCINIT0_MASK) == 0);
      }
      currentClockMode = next;

      // Maximum number of transitions is 4
      if (transitionCount++>5) {
         return setAndCheckErrorCode(E_CLOCK_INIT_FAILED);
      }
   } while (currentClockMode != finalMode);

   // Main clock dividers
   SIM->CLKDIV1 = clockInfo.clkdiv1;

   // Clock sources
   SIM->SOPT2 = clockInfo.sopt2;

   SystemCoreClockUpdate();

#if defined(SIM_CLKDIV2_USBDIV)
   SimInfo::updateUsbClockDivider();
#endif


   // Notify of clock changes (after)
   notifyAfterClockChange();

   return E_NO_ERROR;
}

/**
 * Update SystemCoreClock variable
 *
 * Updates the SystemCoreClock variable with current core Clock retrieved from CPU registers.
 */
void Mcg::SystemCoreClockUpdate(void) {

   SystemMcgOutClock = McgInfo::getMcgOutClock();

   SystemCoreClock   = SystemMcgOutClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV1_MASK)>>SIM_CLKDIV1_OUTDIV1_SHIFT)+1);
   SystemBusClock    = SystemCoreClock/(((SIM->CLKDIV1&SIM_CLKDIV1_OUTDIV4_MASK)>>SIM_CLKDIV1_OUTDIV4_SHIFT)+1);

//   ::SystemBusClock  = SystemBusClock;
//   ::SystemCoreClock = SystemCoreClock;
}

/**
 * Initialise MCG to default settings.
 */
void Mcg::defaultConfigure() {

#if !defined(INITIAL_CLOCK_STATE)
// Needed for use with a boot-loader that changes the clock
#define INITIAL_CLOCK_STATE McgClockMode_LIRC_2MHz;
#endif

   currentClockMode = INITIAL_CLOCK_STATE;

   // Transition to desired clock mode
   clockTransition(clockInfo[ClockConfig_default]);

   Sim::initRegs();

   SystemCoreClockUpdate();
}

} // end namespace USBDM

/**
 * Sets up the clock out of RESET
 */
extern "C"
void clock_initialise(void) {

$(/MCG/Initialisation:// No Initialisation found)
   USBDM::Mcg::initialise();
}


/*
 * @file ics_no_pll.cpp (180.ARM_Peripherals/Startup_Code/ics_no_pll.cpp)
 *
 * Based on ML02, MKL03, MKW41Z
 *    1 FLL (FRDIV=/1-/128, /32-/1024, /1280, /1536)
 *    0 PLL
 *
 *  Created on: 04/03/2012
 *      Author: podonoghue
 */
#include "string.h"
#include "derivative.h"
#include "system.h"
#include "stdbool.h"
#include "pin_mapping.h"
#include "sim.h"
$(/ICS/Includes:// No extra includes found)
#include "ics.h"
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
extern "C" uint32_t SystemCoreClock;
extern "C" uint32_t SystemBusClock;

namespace USBDM {

#if $(/ICS/enableClockChangeNotifications:false)
ClockChangeCallback *Ics::clockChangeCallbackQueue = nullptr;
#endif

/**
 * Table of clock settings
 */
const ClockInfo Ics::clockInfo[] = {
$(/ICS/IcsClockInfoEntries:!!!!!!!Not found!!!!!!!)
};

/** ICSFFCLK - Fixed frequency clock (input to FLL) */
volatile uint32_t SystemIcsFFClock;

/** ICSOUTCLK - Primary output from ICS, various sources */
volatile uint32_t SystemIcsOutClock;

/** ICSFLLCLK - Output of FLL */
volatile uint32_t SystemIcsFllClock;

/** Callback for programmatically set handler */
ICSCallbackFunction Ics::callback = {0};

/** Current clock mode (FEI out of reset) */
IcsClockMode Ics::currentClockMode = IcsClockMode_FEI;

constexpr IcsClockMode clockTransitionTable[][8] = {
   /* from to =>  FEI,               FEE,               FBI,               BLPI,               FBE,               FBELP, */
   /* FEI,   */ { IcsClockMode_FBI,  IcsClockMode_FBE,  IcsClockMode_FBI,  IcsClockMode_FBI,   IcsClockMode_FBE,  IcsClockMode_FBE,   },
   /* FEE,   */ { IcsClockMode_FBI,  IcsClockMode_FBE,  IcsClockMode_FBI,  IcsClockMode_FBI,   IcsClockMode_FBE,  IcsClockMode_FBE,   },
   /* FBI,   */ { IcsClockMode_FEI,  IcsClockMode_FBE,  IcsClockMode_FBI,  IcsClockMode_FBILP, IcsClockMode_FBE,  IcsClockMode_FBE,   },
   /* BLPI,  */ { IcsClockMode_FBI,  IcsClockMode_FBI,  IcsClockMode_FBI,  IcsClockMode_FBI,   IcsClockMode_FBI,  IcsClockMode_FBI,   },
   /* FBE,   */ { IcsClockMode_FBI,  IcsClockMode_FEE,  IcsClockMode_FBI,  IcsClockMode_FBI,   IcsClockMode_FBI,  IcsClockMode_FBELP,  },
   /* FBELP, */ { IcsClockMode_FBE,  IcsClockMode_FBE,  IcsClockMode_FBE,  IcsClockMode_FBE,   IcsClockMode_FBE,  IcsClockMode_FBE,   },
};

constexpr bool initialwrite[] =
   /* initial => FEI,   FEE,   FBI,   BLPI,  FBE,   FBELP, */
   /* */       { false, false, true,  false, true,  false, };

/**
 * Get name for clock mode
 *
 * @return Pointer to static string
 */
const char *Ics::getClockModeName(IcsClockMode clockMode) {
   static const char *modeNames[] {
         "FEI",
         "FEE",
         "FBI",
         "BLPI",
         "FBE",
         "FBELP",
   };

   if ((unsigned)clockMode>=(sizeof(modeNames)/sizeof(modeNames[0]))) {
      return "Illegal";
   }
   return modeNames[clockMode];
}

/**
 * Transition from current clock mode to mode given
 *
 * @param[in]  clockInfo Clock mode to transition to
 *
 * @return E_NO_ERROR          on success
 * @return E_CLOCK_INIT_FAILED on failure
 */
ErrorCode Ics::clockTransition(const ClockInfo &clockInfo) {

#if $(/ICS/enableClockChangeNotifications:false)
   // Notify of clock changes (before)
   notifyBeforeClockChange();
#endif

   IcsClockMode finalMode = clockInfo.clockMode;

#ifdef USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK
   if (clockInfo.c7&&ICS_C7_OSCSEL_MASK) {
      // Note IRC48M Internal Oscillator automatically enable if ICS_C7_OSCSEL = 2
      SIM->SCGC4 = SIM->SCGC4 | SIM_SCGC4_USBOTG_MASK;
      USB0->CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK|USB_CLK_RECOVER_IRC_EN_REG_EN_MASK;
   }
#endif

   // Set conservative clock dividers
   SIM->CLKDIV = SIM_CLKDIV_OUTDIV1_MASK|SIM_CLKDIV_OUTDIV2_MASK|SIM_CLKDIV_OUTDIV3_MASK;

   // Disable clock monitors while clocks change
   ics->C4 = ics->C4&~ICS_C4_CME_MASK;

   int transitionCount = 0;
   if (initialwrite[currentClockMode]) {
      // Initial update of registers in bypassed modes
      ics->C2 = clockInfo.c2;
   }
   do {
      IcsClockMode next = clockTransitionTable[currentClockMode][finalMode];

      switch (next) {

         case IcsClockMode_FEI: // From FBI or startup

            // Note: C2, C4, C6 and C7 set up in FBI or default from reset

            ics->C1 =
                  ICS_C1_CLKS(0b00)   | // CLKS     = 0     -> ICSOUTCLK = Output of FLL/PLL (depends on ics_c6.PLLS)
                  ICS_C1_IREFS(1)     | // IREFS    = 1     -> FLL source = Slow IRC
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            // Wait for S_IREFST to indicate FLL Reference has switched to IRC
            // Wait for S_CLKST to indicating that OUTCLK has switched to FLL
            do {
               __asm__("nop");
            } while ((ics->S & (ICS_S_CLKST_MASK|ICS_S_IREFST_MASK)) != (ICS_S_CLKST(0)|ICS_S_IREFST(1)));
            break;

         case IcsClockMode_FEE: // from FBE

            // Note: C2, C4, C6 and C7 set up in FBE

            ics->C1 =
                  ICS_C1_CLKS(0b00)   | // CLKS     = 0     -> ICSOUTCLK = Output of FLL/PLL (depends on ics_c6.PLLS)
                  ICS_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            // Wait for S_IREFST to indicate FLL Reference has switched to ERC
            // Wait for S_CLKST to indicating that ICSOUTCLK has switched to FLL
            do {
               __asm__("nop");
            } while ((ics->S & (ICS_S_CLKST_MASK|ICS_S_IREFST_MASK)) != (ICS_S_CLKST(0)|ICS_S_IREFST(0)));
            break;

         case IcsClockMode_FBI: // from BLPI, FEI, FEE, FBE

            ics->C1 =
                  ICS_C1_CLKS(0b01)   | // CLKS     = 1     -> ICSOUTCLK = Internal reference clock is selected
                  ICS_C1_IREFS(1)     | // IREFS    = 1     -> FLL source = IRC
                  clockInfo.c1;         // RDIV, IRCLKEN, IREFSTEN

            ics->C2 = clockInfo.c2;

            // Wait for S_CLKST to indicating that ICSOUTCLK has switched to IRC
            // Wait for S_IREFST to indicate FLL Reference has switched to IRC
            do {
               __asm__("nop");
            } while ((ics->S & (ICS_S_CLKST_MASK|ICS_S_IREFST_MASK)) != (ICS_S_CLKST(1)|ICS_S_IREFST(1)));

            break;

         case IcsClockMode_FBE: // from FEI, FEE, FBI, FBELP

            ics->C1 =
                  ICS_C1_CLKS(0b10)   | // CLKS     = 2     -> ICSOUTCLK = External reference clock
                  ICS_C1_IREFS(0)     | // IREFS    = 0     -> FLL source = External reference clock
                  clockInfo.c1;         // FRDIV, IRCLKEN, IREFSTEN

            ics->C2 = clockInfo.c2;

            // Wait for S_CLKST to indicating that ICSOUTCLK has switched to ERC
            // Wait for S_IREFST to indicate FLL Reference has switched to ERC
            do {
               __asm__("nop");
            } while ((ics->S & (ICS_S_CLKST_MASK|ICS_S_IREFST_MASK)) != (ICS_S_CLKST(2)|ICS_S_IREFST(0)));

            break;

         case IcsClockMode_FBELP: // from FBE, PBE (registers differ depending on transition)
            // Fall through - no break

         case IcsClockMode_FBILP: // from FBI
            // Set LP (low-power)
            ics->C2 = ics->C2|ICS_C2_LP(1);
            break;
      }

#ifdef OSC_CR_OSCEN_MASK
      // Wait for oscillator stable (if active)
      if (USBDM::Osc0Info::osc->CR&OSC_CR_OSCEN_MASK) {
         do {
            __asm__("nop");
         } while ((USBDM::Osc0Info::osc->CR&OSC_CR_OSCINIT_MASK) == 0);
      }
#endif
      currentClockMode = next;

      // Maximum number of transitions is 3
      if (transitionCount++>4) {
         return setErrorCode(E_CLOCK_INIT_FAILED);
      }
   } while (currentClockMode != finalMode);

   // Main clock dividers
   SIM->CLKDIV  = clockInfo.clkdiv1;

   // Clock sources
//   SIM->SOPT2 = clockInfo.sopt2;

   SystemCoreClockUpdate();

   // Enable clock monitors
   ics->C4 = (ics->C4 & (ICS_C4_SCFTRIM_MASK))|clockInfo.c4; // Preserve SCFTRIM

#if $(/ICS/enableClockChangeNotifications:false)
   // Notify of clock changes (after)
   notifyAfterClockChange();
#endif

   return E_NO_ERROR;
}

/**
 * Update SystemCoreClock variable
 *
 * Updates the SystemCoreClock variable with current core Clock retrieved from CPU registers.
 */
void Ics::SystemCoreClockUpdate(void) {
   const bool lowRange = ((USBDM::Osc0Info::osc->CR&OSC_CR_RANGE_MASK) == OSC_CR_RANGE(0));

   // ICS external reference clock
   uint32_t ics_erc_clock = IcsInfo::getExternalReferenceClock();

   // ICS internal reference clock ~37.5 kHz
   uint32_t ics_irc_clock = IcsInfo::getUngatedInternalReferenceClock();

   // Calculate SystemIcsFFClock
   if ((ics->C1&ICS_C1_IREFS_MASK) == 0) {
      // External reference clock/RDIV is selected
      unsigned divisorShift = 0;
      if (!lowRange) {
         divisorShift = 5;
      }
      divisorShift += (ics->C1&ICS_C1_RDIV_MASK)>>ICS_C1_RDIV_SHIFT;
      SystemIcsFFClock = ics_erc_clock >> divisorShift;
   }
   else {
      // Slow internal reference clock is selected
      SystemIcsFFClock = ics_irc_clock;
   }

   uint32_t icsFllClock = 0;

   if ((ics->C2&ICS_C2_LP_MASK) == 0) {
      // Calculate FLL clock if active
      icsFllClock = SystemIcsFFClock * 1280;
   }

   SystemIcsFllClock = 0;

   switch (ics->S&ICS_S_CLKST_MASK) {
      case ICS_S_CLKST(0) : // FLL
         SystemIcsOutClock = icsFllClock;
         SystemIcsFllClock = icsFllClock;
         break;
      case ICS_S_CLKST(1) : // Internal Reference Clock
         SystemIcsOutClock = ics_irc_clock;
         break;
      case ICS_S_CLKST(2) : // External Reference Clock
         SystemIcsOutClock = ics_erc_clock;
         break;
      case ICS_S_CLKST(3) : // PLL - not available
         SystemIcsOutClock = 0;
         break;
   }

   // BDIV ICS clock divider
   SystemIcsOutClock = SystemIcsOutClock>>((ics->C2&ICS_C2_BDIV_MASK)>>ICS_C2_BDIV_SHIFT);

   SimInfo::updateSystemClocks(SystemIcsOutClock);
}

/**
 * Initialise ICS to default settings.
 */
void Ics::defaultConfigure() {

#if !defined(INITIAL_CLOCK_STATE)
// Needed for use with a boot-loader that changes the clock
#define INITIAL_CLOCK_STATE IcsClockMode_FEI;
#endif

static constexpr uint16_t CLOCK_TRIM = $(/ICS/internalClockTrim:0);
static constexpr uint8_t  SCTRIM  = CLOCK_TRIM>>1U;
static constexpr uint8_t  SCFTRIM = CLOCK_TRIM&0b1;

if constexpr (CLOCK_TRIM != 0) {
   ics->C3 = SCTRIM;
   ics->C4 = (ics->C4&ICS_C4_SCFTRIM_MASK)|SCFTRIM;
}

#if $(/ICS/configureClocks:false)
   currentClockMode = INITIAL_CLOCK_STATE;

   // Transition to desired clock mode
   clockTransition(clockInfo[ClockConfig_default]);
#endif

   Sim::initRegs();

   enableNvicInterrupts();

   SystemCoreClockUpdate();
}

} // end namespace USBDM

/**
 * Sets up the clock out of RESET
 */
extern "C"
void clock_initialise(void) {

$(/ICS/Initialisation:// No Initialisation found)
   USBDM::Ics::initialise();
}


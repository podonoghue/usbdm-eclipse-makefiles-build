/**
 * @file i2c.cpp (180.ARM_Peripherals/Sources/i2c.cpp)
 * @brief I2C Code
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#include "i2c.h"
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#if $(/I2C/_BasicInfoGuard) // /I2C/_BasicInfoGuard

namespace USBDM {

/**
 * Start Rx/Tx sequence by sending address byte
 *
 * @param[in]  address - address of slave to access
 *
 * @note Does not wait for transmission to complete
 */
void I2cBasicInfo::sendAddress(uint8_t address) {

   unsigned timeout = TIMEOUT_LIMIT;

   // Wait for bus idle
   while (((i2c->S & I2C_S_BUSY_MASK) != 0) && (--timeout>0)) {
      __asm("nop");
   }
   if (timeout == 0) {
      errorCode = E_TIMEOUT;
      return;
   }
   addressedDevice = address;

   // Configure for Tx of address
   i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_TX_MASK;

   // Generate START
   i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_TX_MASK|I2C_C1_MST_MASK;

   // Tx address (starts interrupt process)
   i2c->D  = I2C_D_DATA(address);
}

/**
 * I2C state-machine based interrupt handler
 */
void I2cBasicInfo::poll(void) {

   if ((i2c->S & I2C_S_ARBL_MASK) != 0) {
      // Lost arbitration

      i2c->S = I2C_S_ARBL_MASK|I2C_S_IICIF_MASK;
      errorCode = E_LOST_ARBITRATION;
      state = i2c_idle;

      // Generate STOP
      i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK;
      return;
   }
   if ((i2c->S & I2C_S_IICIF_MASK) == 0) {
      // Interrupt handler in use - no further processing
      return;
   }

   // Clear interrupt flag
   i2c->S = I2C_S_IICIF_MASK;

   // i2c_txData* +-> i2c_idle
   //             +-> i2c_rxAddress -> i2c_rxData* +-> i2c_idle

   switch (state) {
   case i2c_idle:
   default:
      state = i2c_idle;
      break;

   case i2c_txData:
   case i2c_txDataIncomplete:
      // Just send data bytes until none left
      if ((i2c->S & I2C_S_RXAK_MASK) != 0) {
         // Error - No ACK on last data byte sent
         errorCode = E_NO_ACK;
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK;
         return;
      }
      if (txBytesRemaining-- == 0) {
         // Finished Transmission
         if (state == i2c_txDataIncomplete) {
            // If doing partial transmit - just suspend in incomplete state
            state = i2c_txDataSuspend;
            return;
         }
         if (rxBytesRemaining > 0) {
            // Reception after transmission
            state = i2c_rxAddress;

#if defined(MCU_MKL25Z4)
            {
               // Temporarily clear MULT - see KL25 errata e6070
               uint8_t temp = i2c->F;
               i2c->F&=~I2C_F_MULT(3);
#endif
               // Generate REPEATED-START
               i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TX_MASK|I2C_C1_RSTA_MASK;
#if defined(MCU_MKL25Z4)
               // Restore MULT
               i2c->F = temp;
            }
#endif
#if defined(MCU_MKL27Z4) || defined(MCU_MKL27Z644) || defined(MCU_MKL43Z4)
            // This is a nasty hack
            // It seems these chips need a delay after asserting repeated start
            for (int i=0; i<20; i++) {
               __asm__ volatile("nop");
            }
#endif
            // Send device address again with READ bit set
            i2c->D = addressedDevice|1;
         }
         else {
            // Complete
            state = i2c_idle;
            // Generate stop signal
            i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_TXAK_MASK;
            return;
         }
      }
      else {
         // Transmit next byte
         i2c->D = *txDataPtr++;
      }
      break;

   case i2c_rxAddress:
      // Just sent address for reception phase
      if ((i2c->S & I2C_S_RXAK_MASK) != 0) {
         // No ACK on Tx read address byte
         errorCode = E_NO_ACK;
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK;
         return;
      }
      // Switch to data reception & trigger reception
      state = i2c_rxData;
      // Change to reception
      if (rxBytesRemaining == 1) {
         // Receiving only single byte (don't acknowledge the byte)
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TXAK_MASK;
      }
      else {
         // Switch to Rx mode
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK;
      }
      // Dummy read of data to start Rx of 1st data byte
      (void)i2c->D;
      break;

   case i2c_rxData:
      // Just receive data bytes until complete
      if (--rxBytesRemaining == 0) {
         // Received last byte - complete
         state = i2c_idle;
         // Generate STOP
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK;
      }
      else if (rxBytesRemaining == 1) {
         // Received 2nd last byte (don't acknowledge the last byte to follow)
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK|I2C_C1_TXAK_MASK;
      }
      else {
         i2c->C1 = i2cInterrupt|I2C_C1_IICEN_MASK|I2C_C1_MST_MASK;
      }
      // Save receive data
      *rxDataPtr++ = i2c->D;
      break;
   }
}

/**
 * Transmit message
 * Note: 0th byte of Tx is often register address.
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  size     Size of transmission data
 * @param[in]  data     Data to transmit
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2cBasicInfo::transmit(uint8_t address, uint16_t size, const uint8_t data[]) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif

   errorCode = E_NO_ERROR;

   rxBytesRemaining = 0;

   // Set up transmit data
   txDataPtr        = data;
   txBytesRemaining = size;

   I2C_State lastState = state;
   state = i2c_txData;

   if (lastState != i2c_txDataSuspend) {
      // Send address byte at start and move to data transmission
      sendAddress(address);
   }
   else {
      // Send 1st data byte
      txBytesRemaining--;
      i2c->D = *txDataPtr++;
   }
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Transmit incomplete message.
 * This would be followed by a further transmission.
 * Note: 0th byte of Tx is often register address.
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  size     Size of transmission data
 * @param[in]  data     Data to transmit
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2cBasicInfo::transmitIncomplete(uint8_t address, uint16_t size, const uint8_t data[]) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif

   errorCode = E_NO_ERROR;

   rxBytesRemaining = 0;

   // Send address byte at start and move to data transmission
   state = i2c_txDataIncomplete;

   // Set up transmit data
   txDataPtr        = data;
   txBytesRemaining = size;

   sendAddress(address);
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Receive message
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  size     Size of reception data
 * @param[out] data     Data buffer for reception
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2cBasicInfo::receive(uint8_t address, uint16_t size,  uint8_t data[]) {
#ifdef __CMSIS_RTOS
   startTransaction();
#endif
   errorCode = E_NO_ERROR;

   txBytesRemaining = 0;

   // Send address byte at start and move to data reception
   state = i2c_rxAddress;

   // Set up receive data
   rxDataPtr        = data;
   rxBytesRemaining = size;

   sendAddress(address|1);
   waitWhileBusy();

   ErrorCode tErrorCode = errorCode;

#ifdef __CMSIS_RTOS
   endTransaction();
#endif

   return tErrorCode;
}

/**
 * Transmit message followed by receive message.
 * Note: 0th byte of Tx is often register address.
 *
 * Uses repeated-start.
 *
 * @param[in]  address  Address of slave to communicate with (should include LSB = R/W bit = 0)
 * @param[in]  txSize   Size of transmission data
 * @param[in]  txData   Data for transmission
 * @param[in]  rxSize   Size of reception data
 * @param[out] rxData   Date buffer for reception
 *
 * @return E_NO_ERROR on success
 */
ErrorCode I2cBasicInfo::txRx(uint8_t address, uint16_t txSize, const uint8_t txData[], uint16_t rxSize, uint8_t rxData[] ) {

   if constexpr (!irqHandlerInstalled) {
#if defined __CMSIS_RTOS
      startTransaction();
#endif
   }
   // Clear cumulative error code
   errorCode = E_NO_ERROR;

   // Set up transmit and receive data
   rxDataPtr        = rxData;
   rxBytesRemaining = rxSize;
   txDataPtr        = txData;
   txBytesRemaining = txSize;

   // Send address byte at start and move to data transmission
   state = i2c_txData;

   sendAddress(address);

   if constexpr (!irqHandlerInstalled) {
      // Poll until complete
      waitWhileBusy();
         
#ifdef __CMSIS_RTOS
      endTransaction();
#endif
   }

   return errorCode;
}

/*
 * I2C state-machine based interrupt handler
 */
#if defined(MCU_MKM33Z5)
// MCU_MKM33Z5 has a shared handler for I2C0 & I2C1
extern "C"
/*
 * I2C state-machine based interrupt handler
 */
void I2C0_1_IRQHandler() {
   if (I2C0->S&I2C_S_IICIF_MASK) {
      I2c0::thisPtr->poll();
   }
   if (I2C1->S&I2C_S_IICIF_MASK) {
      I2c1::thisPtr->poll();
   }
}
#endif

} // End namespace USBDM

#endif  // /I2C/enablePeripheralSupport)

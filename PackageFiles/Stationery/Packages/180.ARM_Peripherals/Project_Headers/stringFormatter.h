/**
 * @file    stringFormatter.h  (180.ARM_Peripherals/Project_Headers/stringFormatter.h)
 * @brief   Basic string formatting routines
 * @date    9 June 2018
 */
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */

#ifndef PROJECT_HEADERS_STRINGFORMATTER_H_
#define PROJECT_HEADERS_STRINGFORMATTER_H_

#include <formatted_io.h>

namespace USBDM {

/**
 * @addtogroup FORMATTED_IO_Group Formatted Input/Output
 * @brief C++ Class allowing input and output of basic types as character streams
 * @{
 */

/**
 * Class for writing formatted information into character buffers (C strings)
 *
 * Example:
 * @code
 *    char buff[100];
 *    StringFormatter formatter(buff, sizeof(buff));
 *
 *    for(int count = 0;;count++) {
 *       formatter.clear().write(count).writeln(": Tick...");
 *       console.write(formatter.toString());
 *    }
 * @endcode
 */
class StringFormatter: public FormattedIO {
protected:
   char * const buff;
   char *ptr;
   const size_t  sizeMinusOne;

public:
   /**
    * Create String Formatter using pre-allocated buffer
    *
    * @param[in] buffer      Buffer for characters
    * @param[in] bufferSize  Size of buffer - Note space will be reserved for a terminator
    *
    * Example:
    * @code
    *   char *buff = (char*)malloc(100);
    *   StringFormatter sf(buff, 100);
    *   sf.write("Hello ").writeln("and bye bye");
    *   free(buff);
    * @endcode
    */
   StringFormatter(char buffer[], size_t bufferSize) : buff(buffer), ptr(buffer), sizeMinusOne(bufferSize-1) {
      usbdm_assert(bufferSize>=1, "Buffer size must be >= 1");
      // String is always terminated
      *ptr = '\0';
   }

   /**
    * Create String Formatter using pre-allocated buffer
    *
    * @param[in] buffer      Buffer for characters (Size is inferred from this parameter)
    *
    * Example:
    * @code
    *   char buff[100];
    *   StringFormatter sf(buff);
    *   sf.write("Hello ").writeln("and bye bye");
    * @endcode
    */
   template<size_t N>
   StringFormatter(char (&buffer)[N]) : buff(buffer), ptr(buffer), sizeMinusOne(N-1) {
      static_assert(N>=1, "Buffer size must be >= 1");
      // String is always terminated
      *ptr = '\0';
   }

   /**
    * Destructor
    */
   virtual ~StringFormatter() {
   }

   /**
    *  Flush output data
    *  Resets buffer to empty
    */
   virtual StringFormatter &flushOutput() override {
      ptr = buff;
      return *this;
   };

   /**
    *  Clear buffer
    *  Resets buffer to empty
    */
   StringFormatter &clear() {
      ptr = buff;
      return *this;
   }

   /**
    * Convert buffer to string.
    *
    * @return String ('\0' terminated)
    */
   const char *toString() {
      // Return pointer to internal buffer
      return buff;
   }

   /**
    * Get length of buffer content.
    */
   unsigned length() const {
      return ptr-buff;
   }

protected:

   /**
    * Writes a character.
    * Characters are discarded if buffer is full.
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      *ptr = ch;
      if (ptr < (buff+sizeMinusOne)) {
         ++ptr;
      }
      // Keep string terminated
      *ptr = '\0';
   }

};

/**
 * Class for writing formatted information into character buffers (C strings)
 *
 * Example:
 * @code
 *    StringFormatter_T<100> formatter;
 *
 *    for(int count = 0;;count++) {
 *       formatter.clear().write(count).writeln(": Tick...");
 *       console.write(formatter.toString());
 *    }
 * @endcode
 */
template <int buffSize>
class StringFormatter_T: public StringFormatter {
private:
   char buff[buffSize];

public:
   /**
    * Create String Formatter
    * Example:
    *
    * @code
    *   StringFormatter<100> sf;
    *   sf.write("Hello ").writeln("and bye bye");
    * @endcode
    */
   StringFormatter_T() : StringFormatter(buff, buffSize) {
   }
};

/**
 * End FORMATTED_IO_Group
 * @}
 */

} /* end namespace USBDM */

#endif /* PROJECT_HEADERS_STRINGFORMATTER_H_ */

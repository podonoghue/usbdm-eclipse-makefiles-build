/*
 * @file    tsi.h (180.ARM_Peripherals/Project_Headers/tsi-MKL.h)
 * @brief   Touch Sense Interface
 *
 *  Created on: 25/10/2013
 *      Author: podonoghue
 */

#ifndef TSI_MKL_H_
#define TSI_MKL_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup TSI_Group TSI, Touch Sense Interface
 * @brief C++ Class allowing access to Touch Sense Interface
 * @{
 */

#if 0
/**
 * These 4 bits are used to select the noise threshold.\n
 * These combinations are the maximum possible combinations, not all values are valid.
 */
enum TsiNoiseThreshold {
   TsiNoiseThreshold_0  = TSI_GENCS_NOISE_THRESHOLD(0b0000), //!< DVpm = 0.038 V, Vp = 0.834 V, Vm = 0.796 V
   TsiNoiseThreshold_1  = TSI_GENCS_NOISE_THRESHOLD(0b0001), //!< DVpm = 0.050 V, Vp = 0.830 V, Vm = 0.790 V
   TsiNoiseThreshold_2  = TSI_GENCS_NOISE_THRESHOLD(0b0010), //!< DVpm = 0.066 V, Vp = 0.848 V, Vm = 0.782 V
   TsiNoiseThreshold_3  = TSI_GENCS_NOISE_THRESHOLD(0b0011), //!< DVpm = 0.087 V, Vp = 0.858 V, Vm = 0.772 V
   TsiNoiseThreshold_4  = TSI_GENCS_NOISE_THRESHOLD(0b0100), //!< DVpm = 0.114 V, Vp = 0.872 V, Vm = 0.758 V
   TsiNoiseThreshold_5  = TSI_GENCS_NOISE_THRESHOLD(0b0101), //!< DVpm = 0.150 V, Vp = 0.890 V, Vm = 0.740 V
   TsiNoiseThreshold_6  = TSI_GENCS_NOISE_THRESHOLD(0b0110), //!< DVpm = 0.197 V, Vp = 0.914 V, Vm = 0.716 V
   TsiNoiseThreshold_7  = TSI_GENCS_NOISE_THRESHOLD(0b0111), //!< DVpm = 0.260 V, Vp = 0.945 V, Vm = 0.685 V
   TsiNoiseThreshold_8  = TSI_GENCS_NOISE_THRESHOLD(0b1000), //!< DVpm = 0.342 V, Vp = 0.986 V, Vm = 0.644 V
   TsiNoiseThreshold_9  = TSI_GENCS_NOISE_THRESHOLD(0b1001), //!< DVpm = 0.450 V, Vp = 1.040 V, Vm = 0.590 V
   TsiNoiseThreshold_10 = TSI_GENCS_NOISE_THRESHOLD(0b1010), //!< DVpm = 0.592 V, Vp = 1.111 V, Vm = 0.519 V
   TsiNoiseThreshold_11 = TSI_GENCS_NOISE_THRESHOLD(0b1011), //!< DVpm = 0.780 V, Vp = 1.205 V, Vm = 0.425 V
   TsiNoiseThreshold_12 = TSI_GENCS_NOISE_THRESHOLD(0b1100), //!< DVpm = 1.026 V, Vp = 1.328 V, Vm = 0.302 V
   TsiNoiseThreshold_13 = TSI_GENCS_NOISE_THRESHOLD(0b1101), //!< DVpm = 1.350 V, Vp = 1.490 V, Vm = 0.140 V
   TsiNoiseThreshold_14 = TSI_GENCS_NOISE_THRESHOLD(0b1110), //!< DVpm = 1.630 V, Vp = 1.630 V, Vm = 0 V
   TsiNoiseThreshold_15 = TSI_GENCS_NOISE_THRESHOLD(0b1111), //!< DVpm = 1.630 V, Vp = 1.630 V, Vm = 0 V, Rs = 5k5R
};

/**
 * Series resistor for noise mode (overlaps EXTCHRG[0])
 */
enum TsiSeriesResitor {
   TsiSeriesResitor_32k  = TSI_GENCS_RS(0),  //!< TSI Series resistor 32k
   TsiSeriesResitor_187k = TSI_GENCS_RS(1),  //!< TSI Series resistor 187k
};

/**
 * Noise filter bits (overlaps EXTCHRG[2:1])
 */
enum TsiNoiseFilter {
   TsiNoiseFilter_3Bits    = TSI_GENCS_FILTER(0b00), //!< TSI Noise filter 3 bits
   TsiNoiseFilter_2Bits    = TSI_GENCS_FILTER(0b01), //!< TSI Noise filter 2 bits
   TsiNoiseFilter_1Bits    = TSI_GENCS_FILTER(0b10), //!< TSI Noise filter 1 bits
   TsiNoiseFilter_Disabled = TSI_GENCS_FILTER(0b11), //!< TSI Noise filter disabled
};
#endif

/**
 * Type definition for TSI interrupt call back
 *
 *  @param status - Interrupt flags e.g. TSI_GENCS_EOSF_MASK, TSI_GENCS_OVRF_MASK, TSI_GENCS_EXTERF_MASK
 */
typedef void (*TSICallbackFunction)(uint8_t status);

class TsiBase {
public:
   /** Class to static check channel pin mapping is valid */
   template<class Info, TsiInput channel> class CheckSignal {
      static_assert((channel<Info::numSignals),
            "Non-existent TSI channel - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != PinIndex::UNMAPPED_PCR),
            "TSI channel is not mapped to a pin - Modify Configure.usbdm");
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != PinIndex::INVALID_PCR),
            "TSI channel doesn't exist in this device/package - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||((Info::info[channel].gpioBit == PinIndex::UNMAPPED_PCR)||(Info::info[channel].gpioBit == PinIndex::INVALID_PCR)||(Info::info[channel].gpioBit >= 0)),
            "Illegal TSI Channel - Check Configure.usbdm for available channels");
   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };
};

/**
 * Template class representing a TSI interface
 *
 * @tparam Info      Information class describing the TSI interface
 */
template <class Info>
class Tsi_T : public Info {

public:

   // Make Info::configue methods visible
   using Info::configure;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TSI_Type> tsi = Info::baseAddress;

   /**
    * Enable TSI\n
    * Configures all TSI pins
    */
   static void enable() {
      Info::enableClock();
      __DMB();

      Info::initPCRs();
   }

   /**
    * Enables and configure the TSI for TsiMode_Capacitive
    *
    * @param tsiLowPower            Determines operation in low power modes (STOP, VLPS, LLS and VLLS{3,2,1})
    * @param tsiConsecutiveScan     Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    * @param tsiReferenceCharge     Determines the reference oscillator charge and discharge current value
    * @param tsiExternalCharge      Determines the electrode oscillator charge and discharge current value
    * @param tsiDeltaVoltage        Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configure(
         TsiStopMode             tsiStopMode           = TsiStopMode_Disabled,
         TsiConsecutiveScan      tsiConsecutiveScan    = TsiConsecutiveScan_8Times,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8,
         TsiReferenceCurrent     tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiExternalCharge       tsiExternalCharge     = TsiExternalCharge_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      enable();
      tsi->GENCS =
            TSI_GENCS_TSIEN(1)|TsiMode_Capacitive|
            tsiStopMode|tsiConsecutiveScan|
            tsiReferenceCharge|tsiExternalCharge|
            tsiDeltaVoltage|tsiElectrodePrescaler|TsiCurrentSource_NotSwapped;
   }

#if 0
   /**
    * Enables and configure the TSI for Noise measurement mode
    *
    * @param tsiMode                Determines the TSI analogue mode (must be one of TsiMode_NoiseDetect_...)
    * @param tsiSeriesResitor       Determines the series resistor for noise mode (overlaps EXTCHRG[0])
    * @param tsiNoiseFilter         Determines the noise filter bits (overlaps EXTCHRG[2:1])
    * @param tsiLowPower            Determines operation in low power modes (STOP, VLPS, LLS and VLLS{3,2,1})
    * @param tsiConsecutiveScan     Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    * @param tsiReferenceCharge     Determines the reference oscillator charge and discharge current value
    * @param tsiDeltaVoltage        Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configure(
         TsiMode                 tsiMode,
         TsiSeriesResitor        tsiSeriesResitor      = TsiSeriesResitor_32k,
         TsiNoiseFilter          tsiNoiseFilter        = TsiNoiseFilter_Disabled,
         TsiLowPower             tsiLowPower           = TsiLowPower_Disabled,
         TsiConsecutiveScan      tsiConsecutiveScan    = TsiConsecutiveScan_8Times,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8,
         TsiReferenceCurrent     tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      usbdm_assert(tsiMode != TsiMode_Capacitive, "Wrong mode for this configuration ");
      enable();
      tsi->GENCS =
            TSI_GENCS_TSIEN(1)|
            tsiMode|tsiSeriesResitor|tsiNoiseFilter|
            tsiLowPower|tsiConsecutiveScan|
            tsiReferenceCharge|
            tsiDeltaVoltage|tsiElectrodePrescaler|TsiCurrentSource_NotSwapped;
   }
#endif

   /**
    * Sets the Current Source swap option.\n
    * Assumes the TSI has already been enabled.
    *
    * @param tsiCurrentSource    Determines if sources of electrode and reference oscillators are swapped
    */
   static void setCurentSources(TsiCurrentSource tsiCurrentSource) {
      tsi->GENCS = (tsi->GENCS&~(TSI_GENCS_CURSW_MASK)) | tsiCurrentSource;
   }

   /**
    * Configures the measurement and reference oscillators.\n
    * Assumes the TSI has already been enabled.
    *
    * @param tsiReferenceCharge  Determines the reference oscillator charge and discharge current value
    * @param tsiExternalCharge   Determines the electrode oscillator charge and discharge current value
    * @param tsiDeltaVoltage     Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configureOscillators(
         TsiReferenceCurrent      tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiExternalCharge       tsiExternalCharge     = TsiExternalCharge_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      tsi->GENCS =
            (tsi->GENCS&~(TSI_GENCS_REFCHRG_MASK|TSI_GENCS_EXTCHRG_MASK|TSI_GENCS_DVOLT_MASK|TSI_GENCS_CURSW_MASK)) |
            tsiReferenceCharge|tsiExternalCharge|tsiDeltaVoltage;
   }

   /**
    * Configures TSI counting operation
    *
    * @param tsiConsecutiveScan     Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    */
   static void configureCounting(
         TsiConsecutiveScan      tsiConsecutiveScan    = TsiConsecutiveScan_8Times,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8) {
      enable();
      tsi->GENCS =
            (tsi->GENCS&~(TSI_GENCS_NSCN_MASK|TSI_GENCS_PS_MASK)) |
            tsiConsecutiveScan|tsiElectrodePrescaler;
   }

   /**
    * Get channel count value
    *
    * @return 16-bit count value
    */
   static uint16_t getCount() {
      return Info::tsi->DATA&TSI_DATA_TSICNT_MASK;
   }

   /**
    * Start configured scan on channel
    *
    * @param channel Channel number
    */
   static void startScan(TsiInput tsiInput) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_TSICH(tsiInput);
   }

   /**
    * Start configured scan on channel with DMA request
    *
    * @param channel Channel number
    */
   static void startDmaScan(TsiInput tsiInput) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Select event of end of scan
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_ESOR(1)|TSI_GENCS_TSIIEN(1);
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_DMAEN_MASK|TSI_DATA_TSICH(tsiInput);
   }

   /**
    * Start configured scan and wait for completion
    *
    * @param channel Channel number
    *
    * @return Error code indicating if scan was successful
    */
   static void startScanAndWait(TsiInput tsiInput) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_TSICH(tsiInput);

      // Wait for complete flag or err
      while ((Info::tsi->GENCS&(TSI_GENCS_EOSF_MASK)) == 0) {
      }
   }

   /**
    * Set range thresholds
    *
    * @param high High threshold
    * @param low  Low threshold
    */
   static void setThresholds(uint16_t high, uint16_t low) {
      tsi->TSHD = TSI_TSHD_THRESH(high)|TSI_TSHD_THRESL(low);
   }

   /**
    * Class representing a TSI button
    *
    * @tparam channel   Channel connected to the button
    * @tparam threshold Threshold for the button to be considered pressed
    */
   template<TsiInput channel, int threshold=Info::defaultThreshold>
   class Pin {

      TsiBase::CheckSignal<Info, channel> check;

   public:
      using Pcr = PcrTable_T<Info, channel>;

      /**
       * Configure the pin associated with this TSI channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to TSI
         Pcr::setPCR(Info::info[channel].pcrValue);
      }

      /**
       * Poll button \n
       * This triggers a scan of the button and compares the result to the threshold.
       *
       * @return true => pressed, false => not pressed
       */
      static bool poll() {
         Tsi_T::startScanAndWait(channel);
         return getCount()>threshold;
      }

      /**
       * Start configured scan and wait for completion
       *
       * @return Error code indicating if scan was successful
       */
      static void startScanAndWait() {
         Tsi_T::startScanAndWait(channel);
      }
      /**
       * Get channel count value from last scan
       *
       * @return 16-bit count value
       */
      static uint16_t getCount() {
         return Info::tsi->DATA&TSI_DATA_TSICNT_MASK;
      }
   };

   /**
    * Class representing a TSI slider
    *
    * @tparam channel1  First channel connected to slider
    * @tparam channel2  Second channel connected to slider
    * @tparam threshold Threshold for the contact to be considered
    */
   template<TsiInput channel1, TsiInput channel2, int threshold=Info::defaultThreshold>
   class TsiSlider_T {

   public:
      static int measure() {
         startScanAndWait(channel1);
         int value1 = getCount();
         startScanAndWait(channel2);
         int value2 = getCount();

         return 0; //TODO ???
      }
   };

};

$(/TSI/declarations:  // No declarations found)
/**
 * End TSI_Group
 * @}
 */

} // End namespace USBDM

#endif /* TSI_MKL_H_ */

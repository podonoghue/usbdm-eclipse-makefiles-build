/*
 * @file    tsi.h (180.ARM_Peripherals/Project_Headers/tsi-MKL.h)
 * @brief   Touch Sense Interface
 *
 *  Created on: 25/10/2013
 *      Author: podonoghue
 */

#ifndef TSI_MKL_H_
#define TSI_MKL_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup TSI_Group TSI, Touch Sense Interface
 * @brief C++ Class allowing access to Touch Sense Interface
 * @{
 */

/**
 * Determines if a DMA or Interrupt request is generated on a TSI event
 *
 * @note Requires TsiInterrupt selection
 */
enum TsiDma {
   TsiDma_Disabled = TSI_DATA_DMAEN(0b0), //!< Interrupt is generated on TSI event
   TsiDma_Enabled  = TSI_DATA_DMAEN(0b1), //!< DMA request is generated on TSI event
};

/**
 * These 4 bits are used to select the noise threshold.\n
 * These combinations are the maximum possible combinations, not all values are valid.
 */
enum TsiNoiseThreshold {
   TsiNoiseThreshold_0  = TSI_GENCS_NOISE_THRESHOLD(0b0000), //!< DVpm = 0.038 V, Vp = 0.834 V, Vm = 0.796 V
   TsiNoiseThreshold_1  = TSI_GENCS_NOISE_THRESHOLD(0b0001), //!< DVpm = 0.050 V, Vp = 0.830 V, Vm = 0.790 V
   TsiNoiseThreshold_2  = TSI_GENCS_NOISE_THRESHOLD(0b0010), //!< DVpm = 0.066 V, Vp = 0.848 V, Vm = 0.782 V
   TsiNoiseThreshold_3  = TSI_GENCS_NOISE_THRESHOLD(0b0011), //!< DVpm = 0.087 V, Vp = 0.858 V, Vm = 0.772 V
   TsiNoiseThreshold_4  = TSI_GENCS_NOISE_THRESHOLD(0b0100), //!< DVpm = 0.114 V, Vp = 0.872 V, Vm = 0.758 V
   TsiNoiseThreshold_5  = TSI_GENCS_NOISE_THRESHOLD(0b0101), //!< DVpm = 0.150 V, Vp = 0.890 V, Vm = 0.740 V
   TsiNoiseThreshold_6  = TSI_GENCS_NOISE_THRESHOLD(0b0110), //!< DVpm = 0.197 V, Vp = 0.914 V, Vm = 0.716 V
   TsiNoiseThreshold_7  = TSI_GENCS_NOISE_THRESHOLD(0b0111), //!< DVpm = 0.260 V, Vp = 0.945 V, Vm = 0.685 V
   TsiNoiseThreshold_8  = TSI_GENCS_NOISE_THRESHOLD(0b1000), //!< DVpm = 0.342 V, Vp = 0.986 V, Vm = 0.644 V
   TsiNoiseThreshold_9  = TSI_GENCS_NOISE_THRESHOLD(0b1001), //!< DVpm = 0.450 V, Vp = 1.040 V, Vm = 0.590 V
   TsiNoiseThreshold_10 = TSI_GENCS_NOISE_THRESHOLD(0b1010), //!< DVpm = 0.592 V, Vp = 1.111 V, Vm = 0.519 V
   TsiNoiseThreshold_11 = TSI_GENCS_NOISE_THRESHOLD(0b1011), //!< DVpm = 0.780 V, Vp = 1.205 V, Vm = 0.425 V
   TsiNoiseThreshold_12 = TSI_GENCS_NOISE_THRESHOLD(0b1100), //!< DVpm = 1.026 V, Vp = 1.328 V, Vm = 0.302 V
   TsiNoiseThreshold_13 = TSI_GENCS_NOISE_THRESHOLD(0b1101), //!< DVpm = 1.350 V, Vp = 1.490 V, Vm = 0.140 V
   TsiNoiseThreshold_14 = TSI_GENCS_NOISE_THRESHOLD(0b1110), //!< DVpm = 1.630 V, Vp = 1.630 V, Vm = 0 V
   TsiNoiseThreshold_15 = TSI_GENCS_NOISE_THRESHOLD(0b1111), //!< DVpm = 1.630 V, Vp = 1.630 V, Vm = 0 V, Rs = 5k5R
};

/**
 * Determines the number of scans when measuring an electrode\n
 * This directly affects the TSI counts.
 */
enum TsiScanNumber {
   TsiScanNumber_1  = TSI_GENCS_NSCN(0b00000), //!< 1 times per electrode
   TsiScanNumber_2  = TSI_GENCS_NSCN(0b00001), //!< 2 times per electrode
   TsiScanNumber_3  = TSI_GENCS_NSCN(0b00010), //!< 3 times per electrode
   TsiScanNumber_4  = TSI_GENCS_NSCN(0b00011), //!< 4 times per electrode
   TsiScanNumber_5  = TSI_GENCS_NSCN(0b00100), //!< 5 times per electrode
   TsiScanNumber_6  = TSI_GENCS_NSCN(0b00101), //!< 6 times per electrode
   TsiScanNumber_7  = TSI_GENCS_NSCN(0b00110), //!< 7 times per electrode
   TsiScanNumber_8  = TSI_GENCS_NSCN(0b00111), //!< 8 times per electrode
   TsiScanNumber_9  = TSI_GENCS_NSCN(0b01000), //!< 9 times per electrode
   TsiScanNumber_10 = TSI_GENCS_NSCN(0b01001), //!< 10 times per electrode
   TsiScanNumber_11 = TSI_GENCS_NSCN(0b01010), //!< 11 times per electrode
   TsiScanNumber_12 = TSI_GENCS_NSCN(0b01011), //!< 12 times per electrode
   TsiScanNumber_13 = TSI_GENCS_NSCN(0b01100), //!< 13 times per electrode
   TsiScanNumber_14 = TSI_GENCS_NSCN(0b01101), //!< 14 times per electrode
   TsiScanNumber_15 = TSI_GENCS_NSCN(0b01110), //!< 15 times per electrode
   TsiScanNumber_16 = TSI_GENCS_NSCN(0b01111), //!< 16 times per electrode
   TsiScanNumber_17 = TSI_GENCS_NSCN(0b10000), //!< 17 times per electrode
   TsiScanNumber_18 = TSI_GENCS_NSCN(0b10001), //!< 18 times per electrode
   TsiScanNumber_19 = TSI_GENCS_NSCN(0b10010), //!< 19 times per electrode
   TsiScanNumber_20 = TSI_GENCS_NSCN(0b10011), //!< 20 times per electrode
   TsiScanNumber_21 = TSI_GENCS_NSCN(0b10100), //!< 21 times per electrode
   TsiScanNumber_22 = TSI_GENCS_NSCN(0b10101), //!< 22 times per electrode
   TsiScanNumber_23 = TSI_GENCS_NSCN(0b10110), //!< 23 times per electrode
   TsiScanNumber_24 = TSI_GENCS_NSCN(0b10111), //!< 24 times per electrode
   TsiScanNumber_25 = TSI_GENCS_NSCN(0b11000), //!< 25 times per electrode
   TsiScanNumber_26 = TSI_GENCS_NSCN(0b11001), //!< 26 times per electrode
   TsiScanNumber_27 = TSI_GENCS_NSCN(0b11010), //!< 27 times per electrode
   TsiScanNumber_28 = TSI_GENCS_NSCN(0b11011), //!< 28 times per electrode
   TsiScanNumber_29 = TSI_GENCS_NSCN(0b11100), //!< 29 times per electrode
   TsiScanNumber_30 = TSI_GENCS_NSCN(0b11101), //!< 30 times per electrode
   TsiScanNumber_31 = TSI_GENCS_NSCN(0b11110), //!< 31 times per electrode
   TsiScanNumber_32 = TSI_GENCS_NSCN(0b11111), //!< 32 times per electrode
};

/**
 * Series resistor for noise mode (overlaps EXTCHRG[0])
 */
enum TsiSeriesResitor {
   TsiSeriesResitor_32k  = TSI_GENCS_RS(0),  //!< TSI Series resistor 32k
   TsiSeriesResitor_187k = TSI_GENCS_RS(1),  //!< TSI Series resistor 187k
};

/**
 * Noise filter bits (overlaps EXTCHRG[2:1])
 */
enum TsiNoiseFilter {
   TsiNoiseFilter_3Bits    = TSI_GENCS_FILTER(0b00), //!< TSI Noise filter 3 bits
   TsiNoiseFilter_2Bits    = TSI_GENCS_FILTER(0b01), //!< TSI Noise filter 2 bits
   TsiNoiseFilter_1Bits    = TSI_GENCS_FILTER(0b10), //!< TSI Noise filter 1 bits
   TsiNoiseFilter_Disabled = TSI_GENCS_FILTER(0b11), //!< TSI Noise filter disabled
};

/**
 * Select TSI inputs
 */
enum TsiInput {
   // Mapped inputs
   TsiInput_0          =  0, //!< TSI input 0
   TsiInput_1          =  1, //!< TSI input 1
   TsiInput_2          =  2, //!< TSI input 2
   TsiInput_3          =  3, //!< TSI input 3
   TsiInput_4          =  4, //!< TSI input 4
   TsiInput_5          =  5, //!< TSI input 5
   TsiInput_6          =  6, //!< TSI input 6
   TsiInput_7          =  7, //!< TSI input 7
   TsiInput_8          =  9, //!< TSI input 8
   TsiInput_9          =  8, //!< TSI input 9
   TsiInput_10         = 10, //!< TSI input 10
   TsiInput_11         = 11, //!< TSI input 11
   TsiInput_12         = 12, //!< TSI input 12
   TsiInput_13         = 13, //!< TSI input 13
   TsiInput_14         = 14, //!< TSI input 14
   TsiInput_15         = 15, //!< TSI input 15
$(/TSI/InputMapping:   // No user defined TSI inputs found)
$(/TSI0/InputMapping:   // No user defined TSI0 inputs found)
};

/**
 * Type definition for TSI interrupt call back
 *
 *  @param status - Interrupt flags e.g. TSI_GENCS_EOSF_MASK, TSI_GENCS_OVRF_MASK, TSI_GENCS_EXTERF_MASK
 */
typedef void (*TSICallbackFunction)(uint8_t status);

class TsiBase {
public:
   /** Class to static check channel pin mapping is valid */
   template<class Info, TsiInput channel> class CheckSignal {
      static_assert((channel<Info::numSignals),
            "Non-existent TSI channel - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != PinIndex::UNMAPPED_PCR),
            "TSI channel is not mapped to a pin - Modify Configure.usbdm");
      static_assert((channel>=Info::numSignals)||(Info::info[channel].gpioBit != PinIndex::INVALID_PCR),
            "TSI channel doesn't exist in this device/package - Check Configure.usbdm for available channels");
      static_assert((channel>=Info::numSignals)||((Info::info[channel].gpioBit == PinIndex::UNMAPPED_PCR)||(Info::info[channel].gpioBit == PinIndex::INVALID_PCR)||(Info::info[channel].gpioBit >= 0)),
            "Illegal TSI Channel - Check Configure.usbdm for available channels");
   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };
};

/**
 * Template class representing a TSI interface
 *
 * @tparam Info      Information class describing the TSI interface
 */
template <class Info>
class Tsi_T : public Info {

public:

   // Make Info::configue methods visible
   using Info::configure;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TSI_Type> tsi = Info::baseAddress;

   /**
    * Enable TSI\n
    * Configures all TSI pins
    */
   static void enable() {
      Info::enableClock();
      __DMB();

      Info::initPCRs();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Enables and configure the TSI for TsiMode_Capacitive
    *
    * @param tsiLowPower            Determines operation in low power modes (STOP, VLPS, LLS and VLLS{3,2,1})
    * @param tsiScanNumber          Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    * @param tsiReferenceCharge     Determines the reference oscillator charge and discharge current value
    * @param tsiExternalCharge      Determines the electrode oscillator charge and discharge current value
    * @param tsiDeltaVoltage        Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configure(
         TsiLowPower             tsiLowPower           = TsiLowPower_Disabled,
         TsiScanNumber           tsiScanNumber         = TsiScanNumber_8,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8,
         TsiReferenceCurrent      tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiExternalCharge       tsiExternalCharge     = TsiExternalCharge_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      enable();
      tsi->GENCS =
            TSI_GENCS_TSIEN(1)|TsiMode_Capacitive|
            tsiLowPower|tsiScanNumber|
            tsiReferenceCharge|tsiExternalCharge|
            tsiDeltaVoltage|tsiElectrodePrescaler|TsiCurrentSource_NotSwapped;
   }

   /**
    * Enables and configure the TSI for Noise measurement mode
    *
    * @param tsiMode                Determines the TSI analogue mode (must be one of TsiMode_NoiseDetect_...)
    * @param tsiSeriesResitor       Determines the series resistor for noise mode (overlaps EXTCHRG[0])
    * @param tsiNoiseFilter         Determines the noise filter bits (overlaps EXTCHRG[2:1])
    * @param tsiLowPower            Determines operation in low power modes (STOP, VLPS, LLS and VLLS{3,2,1})
    * @param tsiScanNumber          Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    * @param tsiReferenceCharge     Determines the reference oscillator charge and discharge current value
    * @param tsiDeltaVoltage        Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configure(
         TsiMode                 tsiMode,
         TsiSeriesResitor        tsiSeriesResitor      = TsiSeriesResitor_32k,
         TsiNoiseFilter          tsiNoiseFilter        = TsiNoiseFilter_Disabled,
         TsiLowPower             tsiLowPower           = TsiLowPower_Disabled,
         TsiScanNumber           tsiScanNumber         = TsiScanNumber_8,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8,
         TsiReferenceCurrent      tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      usbdm_assert(tsiMode != TsiMode_Capacitive, "Wrong mode for this configuration ");
      enable();
      tsi->GENCS =
            TSI_GENCS_TSIEN(1)|
            tsiMode|tsiSeriesResitor|tsiNoiseFilter|
            tsiLowPower|tsiScanNumber|
            tsiReferenceCharge|
            tsiDeltaVoltage|tsiElectrodePrescaler|TsiCurrentSource_NotSwapped;
   }

   /**
    * Sets the Current Source swap option.\n
    * Assumes the TSI has already been enabled.
    *
    * @param tsiCurrentSource    Determines if sources of electrode and reference oscillators are swapped
    */
   static void setCurentSources(TsiCurrentSource tsiCurrentSource) {
      tsi->GENCS = (tsi->GENCS&~(TSI_GENCS_CURSW_MASK)) | tsiCurrentSource;
   }

   /**
    * Configures the measurement and reference oscillators.\n
    * Assumes the TSI has already been enabled.
    *
    * @param tsiReferenceCharge  Determines the reference oscillator charge and discharge current value
    * @param tsiExternalCharge   Determines the electrode oscillator charge and discharge current value
    * @param tsiDeltaVoltage     Determine the oscillators' voltage limits (not applicable in noise modes)
    */
   static void configureOscillators(
         TsiReferenceCurrent      tsiReferenceCharge    = TsiReferenceCurrent_8uA,
         TsiExternalCharge       tsiExternalCharge     = TsiExternalCharge_8uA,
         TsiDeltaVoltage         tsiDeltaVoltage       = TsiDeltaVoltage_High) {

      tsi->GENCS =
            (tsi->GENCS&~(TSI_GENCS_REFCHRG_MASK|TSI_GENCS_EXTCHRG_MASK|TSI_GENCS_DVOLT_MASK|TSI_GENCS_CURSW_MASK)) |
            tsiReferenceCharge|tsiExternalCharge|tsiDeltaVoltage;
   }

   /**
    * Configures TSI counting operation
    *
    * @param tsiScanNumber          Determines the number of scans when measuring an electrode
    * @param tsiElectrodePrescaler  Determines the prescaler for the output of the electrode oscillator
    */
   static void configureCounting(
         TsiScanNumber           tsiScanNumber         = TsiScanNumber_8,
         TsiElectrodePrescaler   tsiElectrodePrescaler = TsiElectrodePrescaler_DivBy8) {
      enable();
      tsi->GENCS =
            (tsi->GENCS&~(TSI_GENCS_NSCN_MASK|TSI_GENCS_PS_MASK)) |
            tsiScanNumber|tsiElectrodePrescaler;
   }

   /**
    * Disables or selects touch sensing Interrupt/DMA source
    *
    * @param tsiInterrupt Interrupt source
    */
   static void selectTsiInterrupt(TsiInterrupt tsiInterrupt) {
      tsi->GENCS = (tsi->GENCS&~TSI_GENCS_TSIIEN_MASK)|tsiInterrupt;
   }

   /**
    * Get channel count value
    *
    * @return 16-bit count value
    */
   static uint16_t getCount() {
      return Info::tsi->DATA&TSI_DATA_TSICNT_MASK;
   }

   /**
    * Start configured scan on channel
    *
    * @param channel Channel number
    */
   static void startScan(TsiInput channel) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_TSICH(channel);
   }

   /**
    * Start configured scan on channel with DMA request
    *
    * @param channel Channel number
    */
   static void startDmaScan(TsiInput channel) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Select event of end of scan
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_ESOR(1)|TSI_GENCS_TSIIEN(1);
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_DMAEN_MASK|TSI_DATA_TSICH(channel);
   }

   /**
    * Start configured scan and wait for completion
    *
    * @param channel Channel number
    *
    * @return Error code indicating if scan was successful
    */
   static void startScanAndWait(TsiInput channel) {
      // Clear flags
      Info::tsi->GENCS = Info::tsi->GENCS | TSI_GENCS_OUTRGF_MASK|TSI_GENCS_EOSF_MASK;
      // Start scan
      Info::tsi->DATA = TSI_DATA_SWTS_MASK|TSI_DATA_TSICH(channel);

      // Wait for complete flag or err
      while ((Info::tsi->GENCS&(TSI_GENCS_EOSF_MASK)) == 0) {
      }
   }

   /**
    * Set range thresholds
    *
    * @param high High threshold
    * @param low  Low threshold
    */
   static void setThresholds(uint16_t high, uint16_t low) {
      tsi->TSHD = TSI_TSHD_THRESH(high)|TSI_TSHD_THRESL(low);
   }

   /**
    * Class representing a TSI button
    *
    * @tparam channel   Channel connected to the button
    * @tparam threshold Threshold for the button to be considered pressed
    */
   template<TsiInput channel, int threshold=Info::defaultThreshold>
   class Pin {

      TsiBase::CheckSignal<Info, channel> check;

   public:
      using Pcr = PcrTable_T<Info, channel>;

      /**
       * Configure the pin associated with this TSI channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to TSI
         Pcr::setPCR(Info::info[channel].pcrValue);
      }

      /**
       * Poll button \n
       * This triggers a scan of the button and compares the result to the threshold.
       *
       * @return true => pressed, false => not pressed
       */
      static bool poll() {
         Tsi_T::startScanAndWait(channel);
         return getCount()>threshold;
      }

      /**
       * Start configured scan and wait for completion
       *
       * @return Error code indicating if scan was successful
       */
      static void startScanAndWait() {
         Tsi_T::startScanAndWait(channel);
      }
      /**
       * Get channel count value from last scan
       *
       * @return 16-bit count value
       */
      static uint16_t getCount() {
         return Info::tsi->DATA&TSI_DATA_TSICNT_MASK;
      }
   };

   /**
    * Class representing a TSI slider
    *
    * @tparam channel1  First channel connected to slider
    * @tparam channel2  Second channel connected to slider
    * @tparam threshold Threshold for the contact to be considered
    */
   template<TsiInput channel1, TsiInput channel2, int threshold=Info::defaultThreshold>
   class TsiSlider_T {

   public:
      static int measure() {
         startScanAndWait(channel1);
         int value1 = getCount();
         startScanAndWait(channel2);
         int value2 = getCount();

         return 0; //TODO ???
      }
   };

};

$(/TSI/declarations:  // No declarations found)
/**
 * End TSI_Group
 * @}
 */

} // End namespace USBDM

#endif /* TSI_MKL_H_ */

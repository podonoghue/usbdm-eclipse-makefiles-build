/**
 * @file     fmc.h (180.ARM_Peripherals/Project_Headers/fmc.h)
 * @brief    Miscellaneous Control Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_FMC_H
#define HEADER_FMC_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup FMC_Group FMC, Flash Memory Controller
 * @brief Abstraction for Miscellaneous Control Module
 * @{
 */

/**
 * Template class providing a base for Miscellaneous Control Module
 */
class FmcBase : public FmcInfo {

public:
$(/FMC/DefaultFlashInitValue: // /FMC/DefaultFlashInitValue Value not found)
};

#if $(/FMC/irqOption_present:false)
/**
 * Type definition for FMC interrupt call back
 */
typedef void (*FmcCallbackFunction)();

/**
 * Template class providing interface to Miscellaneous Control Module
 *
 * @tparam info      Information class for FMC
 *
 * @code
 * using fmc = FmcInterrupt_T<FmcInfo>;
 *
 *  fmc::configure();
 *
 * @endcode
 */
template <class Info>
class FmcInterrupt_T {

protected:
   /** Callback function for ISR */
   static FmcCallbackFunction sCallback;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {
      sCallback();
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match FmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Fmc::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Fmc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static FmcCallbackFunction wrapCallback() {
      static FmcCallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match FmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Fmc::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Fmc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static FmcCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static FmcCallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set Callback function
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(FmcCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "FMC not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

public:

   /**
    * Basic enable of FMC\n
    * Includes configuring all pins
    */
   static void enable() {
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }
   
};

template<class Info> FmcCallbackFunction FmcInterrupt_T<Info>::sCallback = FmcInterrupt_T<Info>::unhandledCallback;
#endif

$(/FMC/declarations: // No declarations found)
/**
 * End FMC_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_FMC_H */

/**
 * @file     cmt.h (180.ARM_Peripherals/Project_Headers/cmt.h)
 * @brief    Carrier Modulator Transmitter
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_CMT_H_
#define HEADER_CMT_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief  Abstraction for Carrier Modulator Transmitter
 * @{
 */

/**
 * Template class representing a Carrier Modulator Transmitter.
 *
 * Typical modes of operation:
 * Time mode
 *    Waveform alternates between modulation frequency (mark) and idle (space).
 *    Modulation waveform is controlled by setPrimaryTiming().
 *    Mark/Space time is controlled by setMarkSpaceTiming().
 * Baseband mode
 *    Waveform alternates between high (mark) and idle (space) without use of modulation.
 *    Mark/Space time is controlled by setMarkSpaceTiming().
 * FSK mode
 *    Waveform changes between two modulation frequencies(mark) separated by idle time (space) i.e.
 *    (Primary modulation - idle - Secondary modulation - idle) repeated.
 *    Modulation waveforms are controlled by setPrimaryTiming() and setSecondaryTiming().
 *    Mark/Space time is controlled by setMarkSpaceTiming().
 *    Space time may be set to zero to obtain simple FSK with no idle time.
 *
 * @tparam info      Information class for CMT
 */
template<class Info>
class Cmt_T : public Info, public PcrTable_T<Info, 0> {

protected:
   /** Class to static check output is mapped to a pin - Assumes existence */
   template<unsigned index> class CheckOutputIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[index].pinIndex != PinIndex::UNMAPPED_PCR);

      static_assert(Test1, "CMT output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   // Output pin
   using OutputPin = PcrTable_T<Info, 0>;

public:
   // Make these visible and remove ambiguity
   using Info::configure;
   using Info::irqHandler;

   /**
    * Hardware instance pointer.
    *
    * @return Reference to CMT hardware
    */
   static constexpr HardwarePtr<CMT_Type> cmt = Info::baseAddress;

   /**
    * Get CMT status.
    * The status is set:\n
    * - When the modulator is not currently active and CMT is enabled to begin the initial CMT transmission.
    * - At the end of each modulation cycle while CMT is enabled.
    *
    * @return Status value
    *
    * @note The status is cleared by either:\n
    * - Calling getStatus() followed by calling getMarkTime(), getSpaceTime() or setMarkSpaceTiming().
    * - A DMA cycle.
    */
   static uint32_t getStatus() {
      return cmt->MSC & CMT_MSC_EOCF_MASK;
   }

public:
$(/CMT/classInfo: // No class Info found)
   /**
    * Base configuration of CMT.
    * The CMT clock is configured for a nominal 8MHz frequency
    *
    * @param[in] cmtMode             Basic mode
    * @param[in] cmtClockDivideBy    Divider for carrier (from nominal 8MHz)
    */
   static void configure(CmtMode cmtMode, CmtIntermediatePrescaler cmtClockDivideBy=CmtIntermediatePrescaler_DivBy1) {
      Info::enable();
      CmtInfo::setClockDivider(CmtClockPrescaler_Auto);
      cmt->MSC = cmtMode|cmtClockDivideBy;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

};

$(/CMT/declarations: // No declaration found)
/**
 * End CMT_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMT_H_ */

/**
 * @file     cmp.h (180.ARM_Peripherals/Project_Headers/cmp.h)
 * @brief    Analogue Comparator
 */

#ifndef HEADER_CMP_H_
#define HEADER_CMP_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

$(/CMP/peripheral_h_definition:// $/CMP/peripheral_h_definition not found)
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

/**
 * Template class representing a Analogue Comparator
 *
 * @tparam info      Information class for CMP
 *
 * @code
 * // Example using an interrupt handler on both rising and falling edges of comparator output
 *
 * // Comparator to use
 * using Cmp = Cmp0;
 *
 * // Comparator pin
 * using CmpPositiveInput = Cmp::Pin<4>;
 *
 * // Callback to handle comparator
 * void cmpCallback(const CmpStatus &status) {
 *    switch (status.event) {
 *       case CmpEvent_Rising  : console.write("Cmp rising, state = ",  status.state); break;
 *       case CmpEvent_Falling : console.write("Cmp falling, state = ", status.state); break;
 *       case CmpEvent_Both    : console.write("Cmp both, state = ",    status.state); break;
 *       case CmpEvent_None    : console.write("Cmp none, state = ",    status.state); break;
 *    }
 * }
 *
 * // Test comparator
 * void testComparator() {
 *    CmpPositiveInput::setInput();
 *
 *    Cmp::configure(CmpPower_HighSpeed, CmpHysteresis_2, CmpPolarity_Noninverted);
 *    Cmp::selectInputs(CmpPositiveInput::pinNum, CmpInput_DacRef);
 *    Cmp::setCallback(cmpCallback);
 *    Cmp::enableNvicInterrupts(NvicPriority_Normal);
 *    Cmp::enableInterrupts(CmpInterrupt_Both);
 *
 *    Cmp::configureDac(Cmp::MAXIMUM_DAC_VALUE/2, CmpDacrefSel_Vdda);
 *    for(;;) {
 *       // Sleep between interrupts
 *       Smc::enterWaitMode();
 *    }
 * }
 * @endcode
 */
template<class Info>
class CmpBase_T : public Info {

protected:
   /**
    * Limit index to permitted pin index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param index   Index to limit
    *
    * @return Index limited to permitted range
    */
   static inline constexpr int limitIndex(int index) {
      if (index<0) {
         return 0;
      }
      if (index>(Info::numSignals-1)) {
         return Info::numSignals-1;
      }
      return index;
   }

   /** Class to static check output is mapped to a pin - Assumes existence */
   template<int cmpOutput> class CheckOutputIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[cmpOutput].pinIndex != PinIndex::UNMAPPED_PCR);

      static_assert(Test1, "CMP output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check cmpInput exists and is mapped to a pin */
   template<int cmpInput> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (cmpInput>=0) && (cmpInput<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[cmpInput].gpioBit != PinIndex::UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[cmpInput].gpioBit >= PinIndex::MIN_PIN_INDEX);

      static_assert(Test1, "Illegal CMP Input - Check Configure.usbdm for available inputs");
      static_assert(Test2, "CMP input is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "CMP input doesn't exist in this device/package - Check Configure.usbdm for available input pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    *
    * @param[in] status Struct indicating interrupt source and state
    */
   static void unhandledCallback(const CmpStatus &status) {
      (void)status;
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /// Pin mapped to CMP output
   using OutputPin = PcrTable_T<Info, Info::outputPin>;

   using Info::configure;

   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static constexpr HardwarePtr<CMP_Type> cmp = Info::baseAddress;

#if $(/CMP/irqHandlingMethod:false) // /CMP/irqHandlingMethod
   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CmpCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(CmpStatus status), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = [](CmpStatus status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CmpCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(CmpStatus status)>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = [](CmpStatus status) {
         (obj.*callback)(status);
      };
      return fn;
   }
#endif

public:
$(/CMP/classInfo: // /CMP/classInfo not found)
$(/CMP/InitMethod: // /CMP/InitMethod not found)
   /**
    * Configure all input pins associated with this CMP
    * The pins are set to analogue mode so no PCR settings are active.
    * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
    */
   static void setInputs() {
      Info::configureAllPins();
   }

$(/CMP/set_output: // /CMP/set_output not found)

   /*                                                             CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT   FPR.FILT_PER
    * 1  Disabled                              0      X      X      X                X
    * 2a/b Continuous                          1      0      0     (0     or         0)    COUT == COUTA
    * 3a   Sampled, Non-Filtered, external     1      0      1      1                X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1               >=1    COUTA combinational, COUT sampled by busclk/PFR
    * 4a   Sampled, Filtered, external         1      0      1     >=2               X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >=2              >=1    COUTA combinational, COUT filtered by busclk/PFR
    * 5a/b Windowed                            1      1      0      0                0     COUT == COUTA clocked by bus clock when Window=1
    * 6    Windowed, Re-sampled                1      1      0      1               >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
    * 7    Windowed, Filtered                  1      1      0     >=2              >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    */

   /**
    * Base configuration - Continuous sampling: Modes 2a/2b.
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
    * DAC is initially disabled.
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    *
    * @param cmpPower        Power level. Tradeoff between speed and power consumption
    * @param cmpHysteresis   Hysteresis level for analogue comparator
    * @param cmpPolarity     Allows inversion of the comparator output
    */
   static void configure(
         CmpPower       cmpPower       = CmpPower_HighSpeed,
         CmpHysteresis  cmpHysteresis  = CmpHysteresis_Level_2,
         CmpPolarity    cmpPolarity    = CmpPolarity_Normal
         ) {
      Info::enable();

      // Initialise hardware
      cmp->CR1   = CmpEnable_Enabled|cmpPower|cmpPolarity;
      cmp->CR0   = CMP_CR0_FILTER_CNT(0)|cmpHysteresis;
      cmp->FPR   = 0;
      cmp->SCR   = CMP_SCR_IER(0)|CMP_SCR_IEF(0);
      cmp->DACCR = (CMP_DACCR_VOSEL_MASK>>1)&CMP_DACCR_VOSEL_MASK;
      cmp->MUXCR = Info::DefaultInitValue.muxcr;
   }

   /**
    * Set Continuous input - Mode 2a/b.
    * Assumes basic configuration done
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    */
   static void setInputContinous() {
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(0);
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpMode_Direct;
      cmp->FPR = 0;
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time in ticks
    */
   static Seconds convertTicksToSeconds(const Ticks &ticks) {

      return (float)ticks/Info::getClockFrequency();
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    */
   static Ticks convertSecondsToTicks(const Seconds &seconds) {

      uint32_t res = roundf((float)seconds*Info::getClockFrequency());
      if (res >= 256) {
         setErrorCode(E_TOO_LARGE);
      }
      return Ticks(res);
   }

   /**
    * Set Sampled, Non-Filtered input - Modes 3a/3b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the CmpSampleEnable_External source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 3a   Sampled, Non-Filtered, external     1      0      1      1              X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1             >=1    COUTA combinational, COUT sampled by busclk/PFR
    *
    * @param[in] CmpSampleEnable          Filter clock source
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
    *                                     Only applicable if CmpSampleEnable=CmpSampleEnable_Internal
    */
   static void setInputSampled(
         CmpSampleEnable  CmpSampleEnable,
         int              cmpFilterSamplePeriod=1
         ) {
      usbdm_assert((CmpSampleEnable == CmpSampleEnable_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(1);
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable|CmpWindowEnable_Disabled;
      cmp->FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Sampled, Filtered input - Modes 4a/4b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the CmpSampleEnable_External source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 4a   Sampled, Filtered, external         1      0      1     >=2             X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >=2            >=1    COUTA combinational, COUT filtered by busclk/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2)
    * @param[in] cmpSampleEnable          Filter clock source
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
    *                                     Only applicable if CmpSampleEnable_Internal
    */
   static void setInputFiltered(
         CmpFilterSamples      cmpFilterSamples,
         CmpSampleEnable       cmpSampleEnable=CmpSampleEnable_Internal,
         uint8_t               cmpFilterSamplePeriod=1
         ) {
      usbdm_assert((cmpSampleEnable == CmpSampleEnable_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      usbdm_assert((cmpFilterSamples>1) , "Illegal parameter combination");
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|cmpSampleEnable|CmpWindowEnable_Disabled;
      cmp->FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Windowed input - Modes 5a/5b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the Window source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 5a/b Windowed                            1      1      0      0              0     COUT == COUTA clocked by bus clock when Window=1
    */
   static void setInputWindowed() {
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|0;
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      cmp->FPR = 0;
   }

   /**
    * Set Windowed, Re-sampled input - mode 6.
    * Assumes basic configuration done.
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 6    Windowed, Re-sampled                1      1      0      1             >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
    *
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
    */
   static void setInputWindowedResampled(
         int  cmpFilterSamplePeriod=1
         ) {
      usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(1);
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      cmp->FPR = cmpFilterSamplePeriod;
   }

   /**
    * Set Windowed, Filtered input - mode 7.
    * Assumes basic configuration done.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
    * 7    Windowed, Filtered                  1      1      0     >=2            >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2).
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
    */
   static void setInputWindowedFiltered(
         CmpFilterSamples     cmpFilterSamples,
         int                  cmpFilterSamplePeriod=1
         ) {
      usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      cmp->FPR = cmpFilterSamplePeriod;
   }

   /**
    * Enables Window mode
    * The TRGMUX is used as the Window source.
    *
    * @note Window mode may not be selected with external filter.
    */
   static void enableWindowMode() {
      cmp->CR1 = cmp->CR1 | CMP_CR1_WE_MASK;
   }

   /**
    * Disables Window mode
    */
   static void disableWindowMode() {
      cmp->CR1 = cmp->CR1 & ~CMP_CR1_WE_MASK;
   }

   /**
    * Enables Filter mode
    *
    * @note Window mode may not be selected with external filter.
    */
   static void enableFilterMode() {
      cmp->CR1 = cmp->CR1 | CMP_CR1_WE_MASK;
   }

   /**
    * Disables Filter mode
    */
   static void disableFilterMode() {
      cmp->CR1 = cmp->CR1 & ~CMP_CR1_WE_MASK;
   }

   /**
    * Get current output value of comparator
    *
    * @return true  => Cmp+ > Cmp- (unless inverted)
    * @return false => Cmp+ < Cmp- (unless inverted)
    */
   static bool getCmpOutput() {
      return cmp->SCR & CMP_SCR_COUT_MASK;
   }

   /**
    * Set input filtering and hysteresis
    *
    * @param[in] cmpFilterSamples Filtering clock pulses
    * @param[in] cmpHysteresis    Hysteresis level
    *
    * @note Window mode may not be selected with external filter.
    */
   static void setInputConditioning(CmpFilterSamples cmpFilterSamples, CmpHysteresis cmpHysteresis) {
      cmp->CR0 = cmpFilterSamples|cmpHysteresis;
   }

   /**
    * Enable/disable edge interrupts
    *
    * @param[in]  cmpEvent Controls edge selection
    */
   static void enableInterrupts(CmpEvent cmpEvent) {
      cmp->SCR = (cmp->SCR&~(CMP_SCR_IER_MASK|CMP_SCR_IEF_MASK))|cmpEvent;
   }

   /**
    * Enable rising edge interrupts
    */
   static void enableRisingEdgeInterrupts() {
      cmp->SCR = cmp->SCR | CMP_SCR_IER_MASK;
   }

   /**
    * Disable rising edge interrupts
    */
   static void disableRisingEdgeInterrupts() {
      cmp->SCR = cmp->SCR & ~CMP_SCR_IER_MASK;
   }

   /**
    * Enable falling edge interrupts
    */
   static void enableFallingEdgeInterrupts() {
      cmp->SCR = cmp->SCR | CMP_SCR_IEF_MASK;
   }

   /**
    * Disable falling edge interrupts
    */
   static void disableFallingEdgeInterrupts() {
      cmp->SCR = cmp->SCR & ~CMP_SCR_IEF_MASK;
   }

#ifdef CMP_SCR_DMAEN_MASK
   /**
    * Enable DMA requests
    */
   static void enableDmaRequests() {
      cmp->SCR = cmp->SCR | CMP_SCR_DMAEN_MASK;
   }

   /**
    * Disable DMA requests
    */
   static void disableDmaRequests() {
      cmp->SCR = cmp->SCR & ~CMP_SCR_DMAEN_MASK;
   }
#endif

   /**
    * Clear edge interrupt flags
    */
   static void clearInterruptFlags() {
   cmp->SCR = cmp->SCR | CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK;
   }

   /**
    * Enable and configure DAC
    *
    * @param[in]  level        DAC level to select (0...MAXIMUM_DAC_VALUE) => (Vref/MAXIMUM_DAC_VALUE...Vref)
    * @param[in]  cmpDacSource Reference source select
    */
   static void configureDac(
         uint8_t       level,
         CmpDacrefSel  cmpDacSource) {
      cmp->DACCR = CMP_DACCR_DACEN_MASK|cmpDacSource|CMP_DACCR_VOSEL(level);
   }

   /**
    * Enable DAC
    */
   static void enableDAC() {
      cmp->DACCR = cmp->DACCR | CMP_DACCR_DACEN_MASK;
   }

   /**
    * Disable DAC
    */
   static void disableDAC() {
      cmp->DACCR = cmp->DACCR & ~CMP_DACCR_DACEN_MASK;
   }

   /** Maximum DAC value corresponding to Vref) */
   static constexpr CmpDacLevel MAXIMUM_DAC_VALUE = CmpDacLevel(CMP_DACCR_VOSEL_MASK);

   /**
    * Set DAC level\n
    * Assumes the DAC has already been configured by configureDac()
    *
    * @param[in]  level  DAC level to select (0...MAXIMUM_DAC_VALUE) => (Vref/MAXIMUM_DAC_VALUE...Vref)
    */
   static void setDacLevel(uint8_t level) {
      cmp->DACCR = (cmp->DACCR&~CMP_DACCR_VOSEL_MASK) | CMP_DACCR_VOSEL(level);
   }

protected:
   /**
    * Class representing a Comparator 0 pin
    *
    * @tparam cmpInput Number of comparator input (0-7) for associated pin.
    */
   template<typename T, T cmpInput>
   class PinBase_T : public PcrTable_T<Info, (unsigned)cmpInput> {

   public:
      // CmpInput number for use with selectInputs()
      static constexpr T pinNum = cmpInput;

      // Pin mask for use with Round Robin mode
      static constexpr uint8_t  pinMask = (1<<(unsigned)cmpInput);

      using Pcr = PcrTable_T<Info, (unsigned)cmpInput>;

      /**
       * Configure pin associated with CMP input.\n
       * This will map the pin to the CMP function. \n
       * The pins are set to analogue mode so no PCR settings are used.\n
       * The clock to the port will be enabled before changing the PCR.\n
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       *
       * @note Resets the entire Pin Control Register value (PCR value).
       */
      static void setInput() {

         CmpBase_T::CheckPinExistsAndIsMapped<(unsigned)cmpInput>::check();

         // Map pin
         Pcr::setPCR();
      }
   };
};

$(/CMP/InputMapping:   // /CMP/InputMapping None Found)
$(/CMP/declarations:   // /CMP/declarations None Found)


/**
 * End CMP_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMP_H_ */

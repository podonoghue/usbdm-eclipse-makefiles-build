/**
 * @file     cmp.h (180.ARM_Peripherals/Project_Headers/cmp32.h)
 * @brief    Analogue Comparator
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_CMP_H_
#define HEADER_CMP_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */

/**
 * Filter Sample Count
 *
 * Represents the number of consecutive samples that must agree
 * prior to the comparator output filter accepting a new output state
 */
enum CmpFilterSamples {
   CmpFilterSamples_2    = CMP_C0_FILTER_CNT(2), //!< 2 samples must agree
   CmpFilterSamples_3    = CMP_C0_FILTER_CNT(3), //!< 3 samples must agree
   CmpFilterSamples_4    = CMP_C0_FILTER_CNT(4), //!< 4 samples must agree
   CmpFilterSamples_5    = CMP_C0_FILTER_CNT(5), //!< 5 samples must agree
   CmpFilterSamples_6    = CMP_C0_FILTER_CNT(6), //!< 6 samples must agree
   CmpFilterSamples_7    = CMP_C0_FILTER_CNT(7), //!< 7 samples must agree
};

/**
 * Determines hysteresis of comparator
 */
enum CmpHysteresis {
   CmpHysteresis_0 = CMP_C0_HYSTCTR(0), //!< Minimum.
   CmpHysteresis_1 = CMP_C0_HYSTCTR(1), //!< Middle-low
   CmpHysteresis_2 = CMP_C0_HYSTCTR(2), //!< Middle-high
   CmpHysteresis_3 = CMP_C0_HYSTCTR(3), //!< Maximum.
};

/**
 * Comparator interrupt selection
 */
enum CmpInterrupt {
   CmpInterrupt_None    = CMP_C0_IER(0)|CMP_C0_IEF(0),  //!< Neither edge
   CmpInterrupt_Rising  = CMP_C0_IER(1)|CMP_C0_IEF(0),  //!< Rising edge
   CmpInterrupt_Falling = CMP_C0_IER(0)|CMP_C0_IEF(1),  //!< Falling edge
   CmpInterrupt_Both    = CMP_C0_IER(1)|CMP_C0_IEF(1),  //!< Rising or falling edge
};

/**
 * Comparator event identification
 */
enum CmpEvent {
   CmpEvent_None    = CMP_C0_CFR(0)|CMP_C0_CFF(0),  //!< Neither edge
   CmpEvent_Rising  = CMP_C0_CFR(1)|CMP_C0_CFF(0),  //!< Rising edge
   CmpEvent_Falling = CMP_C0_CFR(0)|CMP_C0_CFF(1),  //!< Falling edge
   CmpEvent_Both    = CMP_C0_CFR(1)|CMP_C0_CFF(1),  //!< Rising or falling edge
};

/**
 * Used to represent the comparator status for interrupt handler
 */
struct CmpStatus {
   CmpEvent event;                //!< Event triggering handler
   uint8_t  roundRobinEventMask;  //!< Round-robin interrupt flags
   uint8_t  roundRobinStatusMask; //!< Round-robin interrupt flags
   bool     state;                //!< State of CMPO at event
};

/**
 * Comparator mode
 */
enum CmpFilterClockSource {
   CmpFilterClockSource_Internal = CMP_C0_SE(0),                  //!< Internal filter clock
   CmpFilterClockSource_BusClock = CmpFilterClockSource_Internal, //!< Internal filter clock = Bus clock
   CmpFilterClockSource_External = CMP_C0_SE(1),                  //!< External filter clock
   CmpFilterClockSource_TrgMux   = CmpFilterClockSource_External, //!< External filter clock = Trigger Multiplexor
};

/**
 * Comparator mode
 */
enum CmpWindow {
   CmpWindow_Disabled = CMP_C0_WE(0),  //!< Windowing disabled
   CmpWindow_Enabled  = CMP_C0_WE(1),  //!< Windowing enabled
};

/**
 * Comparator power select
 */
enum CmpPower {
   CmpPower_LowPower    = CMP_C0_PMODE(0), //!< Low power
   CmpPower_HighSpeed   = CMP_C0_PMODE(1), //!< High speed
};

/**
 * Comparator invert
 */
enum CmpPolarity {
   CmpPolarity_Noninverted  = CMP_C0_INVT(0), //!< Not inverted
   CmpPolarity_Inverted     = CMP_C0_INVT(1), //!< Inverted
};

/**
 * Comparator output select
 */
enum CmpOutput {
   CmpOutput_Disabled  = CMP_C0_OPE(0)|CMP_C0_COS(0), //!< Disabled
   CmpOutput_Direct    = CMP_C0_OPE(1)|CMP_C0_COS(1), //!< Direct (unfiltered) output
   CmpOutput_Filtered  = CMP_C0_OPE(1)|CMP_C0_COS(0), //!< Filtered output
};

/**
 * Comparator mode
 */
enum CmpMode {
   CmpMode_Disabled    = CMP_C0_EN(0),  //!< Disabled
   CmpMode_Enabled     = CMP_C0_EN(1),  //!< Continuous
};

/**
 * DAC reference source
 */
enum CmpDacSource {
   CmpDacSource_Vin1 = CMP_C1_VRSEL(0),    //!< Select Vrin1
   CmpDacSource_Vin2 = CMP_C1_VRSEL(1),    //!< Select Vrin2
   CmpDacSource_Vdda = CmpDacSource_Vin1,  //!< Select Vrin2 = VddA
   CmpDacSource_Vref = CmpDacSource_Vin2,  //!< Select Vrin1 = Vref_out
};

/**
 * Identifies CMP inputs
 */
enum CmpInput {
   CmpInput_CmpIn0  = 0, //!< External pin 0
   CmpInput_CmpIn1  = 1, //!< External pin 1
   CmpInput_CmpIn2  = 2, //!< External pin 2
   CmpInput_CmpIn3  = 3, //!< External pin 3
   CmpInput_CmpIn4  = 4, //!< External pin 4
   CmpInput_CmpIn5  = 4, //!< External pin 5
   CmpInput_CmpIn6  = 6, //!< External pin 6
   CmpInput_CmpIn7  = 7, //!< External pin 7
   CmpInput_DacRef  = 8, //!< 6-bit Dac0 reference
};

/**
 * Controls which comparator input is fixed and whether it is connected to +ve or -ve input in Round-Robin mode.
 * Conversely the other input is scanned.
 */
enum CmpFixedChannel {
   CmpFixedChannel_PositiveInput0 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(0),//!< Channel 0 is the fixed positive input
   CmpFixedChannel_PositiveInput1 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(1),//!< Channel 1 is the fixed positive input
   CmpFixedChannel_PositiveInput2 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(2),//!< Channel 2 is the fixed positive input
   CmpFixedChannel_PositiveInput3 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(3),//!< Channel 3 is the fixed positive input
   CmpFixedChannel_PositiveInput4 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(4),//!< Channel 4 is the fixed positive input
   CmpFixedChannel_PositiveInput5 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(5),//!< Channel 5 is the fixed positive input
   CmpFixedChannel_PositiveInput6 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(6),//!< Channel 6 is the fixed positive input
   CmpFixedChannel_PositiveInput7 = CMP_C2_FXMP(0)|CMP_C2_FXMXCH(7),//!< Channel 7 is the fixed positive input
   CmpFixedChannel_NegativeInput0 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(0),//!< Channel 0 is the fixed negative input
   CmpFixedChannel_NegativeInput1 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(1),//!< Channel 1 is the fixed negative input
   CmpFixedChannel_NegativeInput2 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(2),//!< Channel 2 is the fixed negative input
   CmpFixedChannel_NegativeInput3 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(3),//!< Channel 3 is the fixed negative input
   CmpFixedChannel_NegativeInput4 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(4),//!< Channel 4 is the fixed negative input
   CmpFixedChannel_NegativeInput5 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(5),//!< Channel 5 is the fixed negative input
   CmpFixedChannel_NegativeInput6 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(6),//!< Channel 6 is the fixed negative input
   CmpFixedChannel_NegativeInput7 = CMP_C2_FXMP(1)|CMP_C2_FXMXCH(7),//!< Channel 7 is the fixed negative input
};

/**
 * Number of sample clocks.
 * For a given channel, this field specifies how many round-robin clock cycles later the sample takes place.
 */
enum CmpSampleClocks {
   CmpSampleClocks_Immediate = CMP_C2_NSAM(0),  //!< Sampled as soon as the channel is scanned
   CmpSampleClocks_Delayed1  = CMP_C2_NSAM(1),  //!< Sampled 1 round-robin clock after round-robin cycle
   CmpSampleClocks_Delayed2  = CMP_C2_NSAM(2),  //!< Sampled 2 round-robin clock after round-robin cycle
   CmpSampleClocks_Delayed3  = CMP_C2_NSAM(3),  //!< Sampled 3 round-robin clock after round-robin cycle
};

/**
 * Type definition for CMP interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*CmpCallbackFunction)(CmpStatus status);

/**
 * Template class representing a Analogue Comparator
 *
 * @tparam info      Information class for CMP
 *
 * @code
 * // Example using an interrupt handler on both rising and falling edges of comparator output
 *
 * // Comparator to use
 * using Cmp = Cmp0;
 *
 * // Comparator pin
 * using CmpPositiveInput = Cmp::Pin<4>;
 *
 * // Callback to handle comparator
 * void cmpCallback(CmpStatus status) {
 *    switch (status.event) {
 *       case CmpEvent_Rising  : console.write("Cmp rising  = ").writeln(Cmp::getCmpOutput()); break;
 *       case CmpEvent_Falling : console.write("Cmp falling = ").writeln(Cmp::getCmpOutput()); break;
 *       case CmpEvent_Both    : console.write("Cmp both    = ").writeln(Cmp::getCmpOutput()); break;
 *       case CmpEvent_None    : console.write("Cmp none    = ").writeln(Cmp::getCmpOutput()); break;
 *    }
 * }
 *
 * // Test comparator
 * void testComparator() {
 *    CmpPositiveInput::setInput();
 *
 *    Cmp::configure(CmpPower_HighSpeed, CmpHysteresis_2, CmpPolarity_Noninverted);
 *    Cmp::selectInputs(CmpPositiveInput::pinNum, CmpInput_DacRef);
 *    Cmp::setCallback(cmpCallback);
 *    Cmp::enableNvicInterrupts(NvicPriority_Normal);
 *    Cmp::enableInterrupts(CmpInterrupt_Both);
 *
 *    Cmp::configureDac(Cmp::MAXIMUM_DAC_VALUE/2, CmpDacSource_Vdda);
 *    for(;;) {
 *       // Sleep between interrupts
 *       Smc::enterWaitMode();
 *    }
 * }
 * @endcode
 */
template<class Info>
class CmpBase_T {

protected:
   /**
    * Limit index to permitted pin index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param index   Index to limit
    *
    * @return Index limited to permitted range
    */
   static inline constexpr int limitIndex(int index) {
      if (index<0) {
         return 0;
      }
      if (index>(Info::numSignals-1)) {
         return Info::numSignals-1;
      }
      return index;
   }

   /** Class to static check output is mapped to a pin - Assumes existence */
   template<int cmpOutput> class CheckOutputIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[cmpOutput].gpioBit != UNMAPPED_PCR);

      static_assert(Test1, "CMP output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check cmpInput exists and is mapped to a pin */
   template<int cmpInput> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (cmpInput>=0) && (cmpInput<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[cmpInput].gpioBit != UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[cmpInput].gpioBit >= 0);

      static_assert(Test1, "Illegal CMP Input - Check Configure.usbdm for available inputs");
      static_assert(Test2, "CMP input is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "CMP input doesn't exist in this device/package - Check Configure.usbdm for available input pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    *
    * @param[in] status Struct indicating interrupt source and state
    */
   static void unhandledCallback(CmpStatus status) {
      (void)status;
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static CmpCallbackFunction sCallback;

public:
   /// Pin mapped to CMP output
   using OutputPin = PcrTable_T<Info, Info::outputPin>;

   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static constexpr HardwarePtr<CMP_Type> cmp = Info::baseAddress;

   /**
    * IRQ handler
    */
   static void irqHandler() {
      unsigned status = cmp->C0&(CMP_C0_CFR_MASK|CMP_C0_CFF_MASK|CMP_C0_COUT_MASK);

      // Clear interrupt flags
      cmp->C0 |= status;

      unsigned rrEvents = (cmp->C2 & CMP_C2_CHF_MASK);
      if (rrEvents != 0) {
         // Clear RR interrupt flags
         cmp->C2 |= rrEvents;
      }
      rrEvents = rrEvents>>CMP_C2_CHF_SHIFT;
      uint8_t rrStatus = (uint8_t)((cmp->C2 & CMP_C2_ACOn_MASK)>>CMP_C2_ACOn_SHIFT);

      // Create status from snapshot
      CmpStatus cmpStatus{
         (CmpEvent)(status&(CMP_C0_CFR_MASK|CMP_C0_CFF_MASK)),
         (uint8_t)rrEvents,
         rrStatus,
         (bool)(status&CMP_C0_COUT_MASK)};

      // Call handler
      sCallback(cmpStatus);
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CmpCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(CmpStatus status), T &object>
   static CmpCallbackFunction wrapCallback() {
      static CmpCallbackFunction fn = [](CmpStatus status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CmpCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(CmpStatus status)>
   static CmpCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static CmpCallbackFunction fn = [](CmpStatus status) {
         (obj.*callback)(status);
      };
      return fn;
   }

   /**
    * Set callback function
    *
    * @param[in] callback Callback function to execute on interrupt.\n
    *                     Use nullptr to remove callback.
    */
   static void setCallback(CmpCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "CMP not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Basic enable CMP.
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }
      // Enable clock to CMP interface
      Info::enableClock();
   }

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Initialise hardware
      cmp->C0 = Info::cr0 | CMP_C0_EN_MASK;
      cmp->C1 = Info::daccr;

      enableNvicInterrupts(Info::irqLevel);
   }

   /**
    * Configure all input pins associated with this CMP
    * The pins are set to analogue mode so no PCR settings are active.
    * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
    */
   static void setInputs() {
      configureAllPins();
   }

   /**
    * Enable comparator output pin as output.\n
    * Pin control parameters default to values usually appropriate for the function being used.\n
    * The clock to the port will be enabled before changing the PCR.
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = OutputPin::defaultPcrValue,
         PinDriveMode      pinDriveMode      = OutputPin::defaultPcrValue,
         PinSlewRate       pinSlewRate       = OutputPin::defaultPcrValue
         ) {

      CheckOutputIsMapped<Info::outputPin>::check();

      // Enable CMP_OUT
      cmp->C0 |= CMP_C0_OPE_MASK;

      // Map CMP_OUT to pin
      OutputPin::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /**
    * Enable round robin output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding MUX value). See pcrValue()
    */
   static void setRoundRobinOutput(PcrValue pcrValue=GPIO_DEFAULT_PCR) {
      using Pcr = PcrTable_T<Info, Info::roundRobinPin>;

      // Map pin to CMP_OUT
      Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[Info::roundRobinPin].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Enable round robin output pin as output.
    * Configures all Pin Control Register (PCR) values
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setRoundRobinOutput(
         PinDriveStrength  pinDriveStrength,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
         ) {
      setOutput(pinDriveStrength|pinDriveMode|pinSlewRate);
   }

   /*                                                          CmpFilterSamples    cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT       C0.FPR
    * 1  Disabled                              0      X      X      X                X
    * 2a/b Continuous                          1      0      0     (0     or         0)    COUT == COUTA
    * 3a   Sampled, Non-Filtered, external     1      0      1      1                X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1               >=1    COUTA combinational, COUT sampled by busclk/PFR
    * 4a   Sampled, Filtered, external         1      0      1     >=2               X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >=2              >=1    COUTA combinational, COUT filtered by busclk/PFR
    * 5a/b Windowed                            1      1      0      0                0     COUT == COUTA clocked by bus clock when Window=1
    * 6    Windowed, Re-sampled                1      1      0      1               >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
    * 7    Windowed, Filtered                  1      1      0     >=2              >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    */

   /**
    * Base configuration - Continuous sampling: Modes 2a/2b.
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
    * DAC is initially disabled.
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
    *
    * @param cmpPower        Power level. Tradeoff between speed and power consumption
    * @param cmpHysteresis   Hysteresis level for analogue comparator
    * @param cmpPolarity     Allows inversion of the comparator output
    */
   static void configure(
         CmpPower       cmpPower       = CmpPower_HighSpeed,
         CmpHysteresis  cmpHysteresis  = CmpHysteresis_2,
         CmpPolarity    cmpPolarity    = CmpPolarity_Noninverted
         ) {
      enable();

      // Initialise hardware
      cmp->C0 = 0;
      cmp->C1 = 0;
      cmp->C2 = 0;
      cmp->C0 = cmpPower|cmpHysteresis|cmpPolarity|CmpMode_Enabled;
   }

   /**
    * Configure Comparator input sources.
    *
    * @param[in]  cmpInputP Positive comparator input
    * @param[in]  cmpInputN Negative comparator input
    *
    * @note In Round-robin Trigger mode the inputs MUST be set to different values even though they are
    *       not used!
    * @note In Round-robin Trigger mode the input chosen here does affect the INxSEL control so must be
    *       set correctly to choose between analogue inputs and the DAC output.  The Analogue input chosen
    *       is unused!
    */
   static void selectInputs(CmpInput cmpInputP, CmpInput cmpInputN) {

      cmp->C1 = (cmp->C1&~(CMP_C1_PSEL_MASK|CMP_C1_MSEL_MASK|CMP_C1_INPSEL_MASK|CMP_C1_INNSEL_MASK))|
         ((cmpInputP==CmpInput_DacRef)?CMP_C1_INPSEL(0):CMP_C1_INPSEL(1))|CMP_C1_PSEL(cmpInputP)| // Plus Input Control
         ((cmpInputN==CmpInput_DacRef)?CMP_C1_INNSEL(0):CMP_C1_INNSEL(1))|CMP_C1_MSEL(cmpInputN); // Minus Input Control
   }

   /**
    * Set Continuous input - Mode 2a/b.
    * Assumes basic configuration done
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT C0.FPR
    * 2a/b Continuous                          1      0      0      0          0     COUT == COUTA
    */
   static void setInputContinous() {
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CMP_C0_FILTER_CNT(0)|CmpFilterClockSource_Internal|CmpWindow_Disabled;
   }

   /**
    * Set Sampled, Non-Filtered input - Modes 3a/3b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the CmpFilterClockSource_External source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 3a   Sampled, Non-Filtered, external     1      0      1      1              X     COUTA combinational, COUT sampled by external clk pin
    * 3b   Sampled, Non-Filtered, internal     1      0      0      1             >=1    COUTA combinational, COUT sampled by busclk/PFR
    *
    * @param[in] cmpFilterClockSource     Filter clock source
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
    *                                     Only applicable if CmpFilterClockSource=CmpFilterClockSource_Internal
    */
   static void setInputSampled(
         CmpFilterClockSource  cmpFilterClockSource,
         int                   cmpFilterSamplePeriod=1
         ) {
      usbdm_assert((cmpFilterClockSource == CmpFilterClockSource_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CmpWindow_Disabled|cmpFilterClockSource|CMP_C0_FILTER_CNT(1)|CMP_C0_FPR(cmpFilterSamplePeriod);
   }

   /**
    * Set Sampled, Filtered input - Modes 4a/4b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the CmpFilterClockSource_External source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 4a   Sampled, Filtered, external         1      0      1     >=2             X     COUTA combinational, COUT filtered by external clk pin
    * 4b   Sampled, Filtered, internal         1      0      0     >=2            >=1    COUTA combinational, COUT filtered by busclk/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2)
    * @param[in] cmpFilterClockSource     Filter clock source
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
    *                                     Only applicable if CmpFilterClockSource_Internal
    */
   static void setInputFiltered(
         CmpFilterSamples      cmpFilterSamples,
         CmpFilterClockSource  cmpFilterClockSource=CmpFilterClockSource_Internal,
         int                   cmpFilterSamplePeriod=1
         ) {
      usbdm_assert((cmpFilterClockSource == CmpFilterClockSource_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      usbdm_assert((cmpFilterSamples>1) , "Illegal parameter combination");
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CmpWindow_Disabled|cmpFilterClockSource|cmpFilterSamples|CMP_C0_FPR(cmpFilterSamplePeriod);
   }

   /**
    * Set Windowed input - Modes 5a/5b.
    *
    * Assumes basic configuration done
    * The TRGMUX is used as the Window source.
    *
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 5a/b Windowed                            1      1      0      0              0     COUT == COUTA clocked by bus clock when Window=1
    */
   static void setInputWindowed() {
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CmpWindow_Enabled|CmpFilterClockSource_Internal|CMP_C0_FILTER_CNT(0)|CMP_C0_FPR(0);
   }

   /**
    * Set Windowed, Re-sampled input - mode 6.
    * Assumes basic configuration done.
    * The TRGMUX is used as the Window source.
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 6    Windowed, Re-sampled                1      1      0      1             >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
    *
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
    */
   static void setInputWindowedResampled(
         int  cmpFilterSamplePeriod=1
         ) {
      usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CmpWindow_Enabled|CmpFilterClockSource_Internal|CMP_C0_FILTER_CNT(1)|CMP_C0_FPR(cmpFilterSamplePeriod);
   }

   /**
    * Set Windowed, Filtered input - mode 7.
    * Assumes basic configuration done.
    * The TRGMUX is used as the Window source.
    *                                                          CmpFilterSamples cmpFilterSamplePeriod
    *                                        C0.EN C0.WE C0.SE C0.FILTER_CNT    C0.FPR
    * 7    Windowed, Filtered                  1      1      0     >=2            >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
    *
    * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2).
    * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
    */
   static void setInputWindowedFiltered(
         CmpFilterSamples     cmpFilterSamples,
         int                  cmpFilterSamplePeriod=1
         ) {
      usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      cmp->C0 = (cmp->C0&~(CMP_C0_WE_MASK|CMP_C0_SE_MASK|CMP_C0_FILTER_CNT_MASK|CMP_C0_FPR_MASK))|
            CmpWindow_Enabled|CmpFilterClockSource_Internal|cmpFilterSamples|CMP_C0_FPR(cmpFilterSamplePeriod);
   }

   /**
    * Enables Window mode
    * The TRGMUX is used as the Window source.
    *
    * @note Window mode may not be selected with external filter.
    */
   static void enableWindowMode() {
      cmp->C0 |= CMP_C0_WE_MASK;
   }

   /**
    * Disables Window mode
    */
   static void disableWindowMode() {
      cmp->C0 &= ~CMP_C0_WE_MASK;
   }

   /**
    * Enables Filter mode
    *
    * @note Window mode may not be selected with external filter.
    */
   static void enableFilterMode() {
      cmp->C0 |= CMP_C0_WE_MASK;
   }

   /**
    * Disables Filter mode
    */
   static void disableFilterMode() {
      cmp->C0 &= ~CMP_C0_WE_MASK;
   }

   /**
    * Get current output value of comparator
    *
    * @return true  => Cmp+ > Cmp- (unless inverted)
    * @return false => Cmp+ < Cmp- (unless inverted)
    */
   static bool getCmpOutput() {
      return cmp->C0 & CMP_C0_COUT_MASK;
   }

   /**
    * Set input filtering and hysteresis
    *
    * @param[in] cmpFilterSamples Filtering clock pulses
    * @param[in] cmpHysteresis    Hysteresis level
    *
    * @note Window mode may not be selected with external filter.
    */
   static void setInputConditioning(CmpFilterSamples cmpFilterSamples, CmpHysteresis cmpHysteresis) {
      cmp->C0 = cmpFilterSamples|cmpHysteresis;
   }

   /**
    * Disable Comparator
    */
   static void disable() {
      cmp->C0 = 0;
      Info::disableClock();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable/disable edge interrupts
    *
    * @param[in]  cmpInterrupt Controls edge selection
    */
   static void enableInterrupts(CmpInterrupt cmpInterrupt) {
      cmp->C0 = (cmp->C0&~(CMP_C0_IER_MASK|CMP_C0_IEF_MASK))|cmpInterrupt;
   }

   /**
    * Enable rising edge interrupts
    */
   static void enableRisingEdgeInterrupts() {
      cmp->C0 |= CMP_C0_IER_MASK;
   }

   /**
    * Disable rising edge interrupts
    */
   static void disableRisingEdgeInterrupts() {
      cmp->C0 &= ~CMP_C0_IER_MASK;
   }

   /**
    * Enable falling edge interrupts
    */
   static void enableFallingEdgeInterrupts() {
      cmp->C0 |= CMP_C0_IEF_MASK;
   }

   /**
    * Disable falling edge interrupts
    */
   static void disableFallingEdgeInterrupts() {
      cmp->C0 &= ~CMP_C0_IEF_MASK;
   }

   /**
    * Enable DMA requests
    */
   static void enableDmaRequests() {
      cmp->C0 |= CMP_C0_DMAEN_MASK;
   }

   /**
    * Disable DMA requests
    */
   static void disableDmaRequests() {
      cmp->C0 &= ~CMP_C0_DMAEN_MASK;
   }

   /**
    * Clear edge interrupt flags
    */
   static void clearInterruptFlags() {
      cmp->C0 |= CMP_C0_CFR_MASK|CMP_C0_CFF_MASK;
   }

   /**
    * Configures the comparator to operate in scanned round-robin mode when the system is in STOP1 mode.
    *
    * In this mode one input pin is used as a fixed input to either the positive or negative input of the comparator.
    * A range of other input pins are scanned in a round-robin fashion when triggered from the TRGMUX source.
    * The comparison results are compared against a pre-set state written to ACOn and may be used to optionally
    * generate an interrupt. The result of each comparison is available by reading ACOn.
    *
    * The LPTMR is used as the round-robin clock.
    * The TRGMUX is used as the trigger source.
    *
    * An initialisation delay must be configured to allow the CMP and DAC to go from standby to active mode.  This
    * depends on process but typically:
    *   CMP - <30 us in low-power mode, and <3 us in High-speed mode.
    *   DAC - <30 us.
    *
    * @param cmpFixedChannel     Select which pin is the fixed input and to which comparator input it is connected
    * @param inputEnableMask     Selects which inputs are scanned.  This is a bit mask so may select multiple channels.
    * @param cmpSampleClocks     Selects sample delay
    * @param initialisationCycle Initialisation delay in round-robin clock cycles
    */
   static void configureRoundRobin(
         CmpFixedChannel   cmpFixedChannel,
         uint8_t           inputEnableMask,
         CmpSampleClocks   cmpSampleClocks,
         uint8_t           initialisationCycle) {
      cmp->C1 = (cmp->C1 & ~(CMP_C1_CHN_MASK)) | CMP_C1_CHN(inputEnableMask);
      cmp->C2 =
            (cmp->C2 & ~(CMP_C2_FXMP_MASK|CMP_C2_FXMXCH_MASK|CMP_C2_NSAM_MASK|CMP_C2_INITMOD_MASK))|
            cmpFixedChannel|                     // Fixed channel and +ve/-ve input select
            cmpSampleClocks|                     // Sample delay
            CMP_C2_INITMOD(initialisationCycle)| // Initialisation delay
            CMP_C2_RRE_MASK;                     // Enable round-robin mode
   }

   /**
    * This function allows the reference value for the comparison results to be set.
    * Only inputs that have been enabled will be checked.
    *
    * @param referenceResults    Reference comparison results for the up to 8 inputs.
    */
   static void setRoundRobinComparisonState(uint8_t referenceResults) {
      cmp->C2 = (cmp->C2 & ~CMP_C2_ACOn_MASK)|referenceResults;
   }

   /**
    * This function allows the reference value for the comparison results to be set.
    * Only inputs that have been enabled will be checked.
    */
   static uint8_t getRoundRobinComparisonState() {
      return (cmp->C2 & CMP_C2_ACOn_MASK);
   }

   /**
    * Enable interrupts for comparison changes in Round Robin mode.
    *
    * @note Rising and Falling edge interrupts should not be enabled with this.
    */
   static void enableRoundRobinInterrupts() {
      cmp->C2 |= CMP_C2_RRIE_MASK;
   }

   /**
    * Disable interrupts for comparison changes in Round Robin mode.
    */
   static void disableRoundRobinInterrupts() {
      cmp->C2 &= ~CMP_C2_RRIE_MASK;
   }

   /**
    * Enable and configure DAC
    *
    * @param[in]  level        DAC level to select (0...MAXIMUM_DAC_VALUE) => (Vref/MAXIMUM_DAC_VALUE...Vref)
    * @param[in]  cmpDacSource Reference source select
    */
   static void configureDac(
         uint8_t       level,
         CmpDacSource  cmpDacSource) {
      cmp->C1 = (cmp->C1&~(CMP_C1_VRSEL_MASK|CMP_C1_VOSEL_MASK))|CMP_C1_DACEN_MASK|cmpDacSource|CMP_C1_VOSEL(level);
   }

   /**
    * Enable DAC
    */
   static void enableDAC() {
      cmp->C1 |= CMP_C1_DACEN_MASK;
   }

   /**
    * Disable DAC
    */
   static void disableDAC() {
      cmp->C1 &= ~CMP_C1_DACEN_MASK;
   }

   /** Maximum DAC value corresponding to Vref) */
   static constexpr int MAXIMUM_DAC_VALUE = CMP_C1_VOSEL_MASK;

   /**
    * Set DAC level\n
    * Assumes the DAC has already been configured by configureDac()
    *
    * @param[in]  level  DAC level to select (0...MAXIMUM_DAC_VALUE) => (Vref/MAXIMUM_DAC_VALUE...Vref)
    */
   static void setDacLevel(uint8_t level) {
      cmp->C1 = (cmp->C1&~CMP_C1_VOSEL_MASK) | CMP_C1_VOSEL(level);
   }

   /**
    * Class representing a Comparator 0 pin
    *
    * @tparam cmpInput Number of comparator input (0-7) for associated pin.
    */
   template<int cmpInput>
   class Pin {
   public:
      // CmpInput number for use with selectInputs()
      static constexpr CmpInput pinNum  = (CmpInput)cmpInput;

      // Pin mask for use with Round Robin mode
      static constexpr uint8_t  pinMask = (1<<cmpInput);

      /**
       * Configure pin associated with CMP input.
       * This will map the pin to the CMP function (analogue MUX value) \n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @note Resets the entire Pin Control Register value (PCR value).
       */
      static void setInput() {
         using Pcr = PcrTable_T<Info, cmpInput>;
         CmpBase_T::CheckPinExistsAndIsMapped<cmpInput>::check();

         // Map pin
         Pcr::setPCR(Info::info[cmpInput].pcrValue);
      }
   };
};

template<class Info> CmpCallbackFunction CmpBase_T<Info>::sCallback = CmpBase_T<Info>::unhandledCallback;

#if defined(USBDM_CMP_IS_DEFINED)
using Cmp = CmpBase_T<CmpInfo>;
#endif

#if defined(USBDM_CMP0_IS_DEFINED)
class Cmp0 : public CmpBase_T<Cmp0Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  cmpInputP (0..7) (7 => DAC)
    * @param[in]  cmpInputN (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(CmpInput cmpInputP, CmpInput cmpInputN) {
      CmpBase_T::selectInputs(cmpInputP, cmpInputN);
   }
};
#endif

#if defined(USBDM_CMP1_IS_DEFINED)
class Cmp1 : public CmpBase_T<Cmp1Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp1Input positiveInput, Cmp1Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif

#if defined(USBDM_CMP2_IS_DEFINED)
class Cmp2 : public CmpBase_T<Cmp2Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp2Input positiveInput, Cmp2Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif

#if defined(USBDM_CMP3_IS_DEFINED)
class Cmp2 : public CmpBase_T<Cmp3Info> {
public:
   /**
    * Configure Comparator input sources
    *
    * @param[in]  positiveInput (0..7) (7 => DAC)
    * @param[in]  negativeInput (0..7) (7 => DAC)
    */
   static __attribute__((always_inline)) void selectInputs(Cmp3Input positiveInput, Cmp3Input negativeInput) {
      CmpBase_T::selectInputs((unsigned)positiveInput, (unsigned)negativeInput);
   }
};
#endif
/**
 * End CMP_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_CMP_H_ */

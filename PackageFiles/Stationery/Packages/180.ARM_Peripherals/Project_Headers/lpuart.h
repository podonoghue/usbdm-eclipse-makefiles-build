/**
 * @file     lpuart.h (180.ARM_Peripherals/Project_Headers/lpuart.h)
 * @brief    Analogue Comparator
 */

#ifndef HEADER_LPUART_H_
#define HEADER_LPUART_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"
#include "formatted_io.h"
#include "uart_queue.h"

namespace USBDM {

/**
 * @addtogroup LPUART_Group LPUART, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
$(/LPUART/peripheral_h_definition:// $/LPUART/peripheral_h_definition not found)



/**
 * @brief Template class representing an LPUART interface with buffered reception
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  LpuartBuffered_T<100, 100> bufferedUart{console};
 *
 *  for(int i=0; i++;) {
 *     bufferedUart.writeln("Tick... ", i);
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing LPUART hardware
 */
template<int rxSize=100, int txSize=100>
class LpuartBuffered_T : public LpuartBasicInfo {

private:
   LpuartBuffered_T(const LpuartBuffered_T&) = delete;
   LpuartBuffered_T(LpuartBuffered_T&&) = delete;

   static constexpr Init initValue = {
      (LpuartEvent::ReceiveDataAction|
       LpuartEvent::TransmitEmptyAction) , // (lpuart_ctrl_interrupt) Event enables
#ifdef LPUART_FIFO_TXFE      
      LpuartIdleEmptyEnable_WhenIdleFor_3_Char , // (lpuart_fifo_rxiden) Receiver Idle Empty Enable - Data available and idle for 4 chars
      LpuartTxFifoEnable_Enabled , // (lpuart_fifo_txfe) Transmit FIFO Enable - Transmit FIFO enabled
      LpuartRxFifoEnable_Enabled , // (lpuart_fifo_rxfe) Receive FIFO Enable - Receive FIFO enabled
      LpuartReceiveWatermark(7) , // (lpuart_water_rxwater) Receive Watermark
      LpuartTransmitWatermark(7) , // (lpuart_water_txwater) Transmit Watermark
#endif
   };

public:

   template<typename T>
   LpuartBuffered_T(const T &uart) : LpuartBasicInfo(uart) {
      T::setCallback(T::wrapCallback(this, &USBDM::LpuartBuffered_T<rxSize, txSize>::callback));
      T::configure(initValue);
      enableEvents(LpuartEvent::TransmitEmptyAction|LpuartEvent::ReceiveDataAction);
   }

   virtual ~LpuartBuffered_T() {
      disableEvents(LpuartEvent::TransmitEmptyAction|LpuartEvent::ReceiveDataAction);
   }

protected:
   /**
    * Queue for Buffered reception (if used)
    */
   static inline UartQueue<char, rxSize> rxQueue;
   /**
    * Queue for Buffered transmission (if used)
    */
   static inline UartQueue<char, txSize> txQueue;

   /**
    * Writes a character (blocking on transmit queue full)
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      lock();
      // Add character to buffer
      while (!txQueue.enQueueDiscardOnFull(ch)) {
         __asm__("nop");
      }
      lpuart->CTRL = lpuart->CTRL | LPUART_CTRL_TIE_MASK;
      unlock();
      if (ch=='\n') {
        _writeChar('\r');
      }
   }

   /**
    * Receives a single character (blocking on receive queue empty)
    *
    * @return Character received
    */
   virtual int _readChar() override {
      lock();
      while (rxQueue.isEmpty()) {
         __asm__("nop");
      }
      char t = rxQueue.deQueue();
      unlock();
      return t;
   }

   /**
    * Check if character is available
    *
    * @return true  Character available i.e. _readChar() will not block
    * @return false No character available
    */
   virtual bool _isCharAvailable() override {
      return (!rxQueue.isEmpty());
   }

public:
   /**
    * Receive/Transmit/Error IRQ handler call-back
    */
   void callback()  {
      LpuartStatusFlag status = getStatusFlags();

      // Empty UART Rx FIFO
      while(status&LpuartStatusFlag::ReceiveDataRegisterFullFlag) {
         // Receive data register full - save data
         rxQueue.enQueueDiscardOnFull(lpuart->DATA);
         status = getStatusFlags();
      }
      // Fill UART Tx FIFO
      while(status&LpuartStatusFlag::TransmitDataRegisterEmptyFlag) {
         // Transmitter ready
         if (txQueue.isEmpty()) {
            // No data available - disable further transmit interrupts
            lpuart->CTRL = lpuart->CTRL & ~LPUART_CTRL_TIE_MASK;
            break;
         }
         else {
            // Transmit next byte
            lpuart->DATA = txQueue.deQueue();
         }
         status = getStatusFlags();
      }
   }

   /**
    *  Flush output data.
    *  This blocks until all pending data has been sent
    */
   virtual LpuartBuffered_T &flushOutput() override {
      while (!txQueue.isEmpty()) {
         // Wait until queue empty
      }
      while ((lpuart->STAT & LPUART_STAT_TC_MASK) == 0) {
         // Wait until transmission of last character is complete
      }
      return *this;
   }

   /**
    *  Flush input data
    */
   virtual LpuartBuffered_T &flushInput() override {
      rxQueue.clear();
      LpuartBasicInfo::flushInput();
      return *this;
   }

};
$(/LPUART/declarations: // No declarations found)
/**
 * End LPUART_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_LPUART_H_ */

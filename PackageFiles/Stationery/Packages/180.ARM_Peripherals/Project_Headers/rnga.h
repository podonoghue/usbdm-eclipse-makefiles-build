/**
 * @file     rnga.h (180.ARM_Peripherals/Project_Headers/rnga.h)
 * @brief    External Watchdog Monitor
 *
 * @version  V4.12.1.230
 * @date     13 April 2016
 */

#ifndef HEADER_RNGA_H_
#define HEADER_RNGA_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup RNGA_Group RNGA, Random Number Generator Accelerator
 * @brief Abstraction for Random Number Generator Accelerator
 * @{
 */

/**
 * Type definition for RNGA interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*RNGACallbackFunction)();

/**
 * Template class representing the Random Number Generator Accelerator.
 *
 * RNGA is a digital integrated circuit capable of generating 32-bit random numbers.
 * The random bits are generated using shift registers with clocks derived from two free-running,
 * independent ring oscillators. The configuration of the shift registers ensures statistically
 * good data, that is, data that looks random. The oscillators, with their unknown
 * frequencies and independent phases, provide the means of generating the required
 * entropy needed to create random data.
 *
 * @tparam info      Information class for RNGA
 */
template<class Info>
class RngaBase_T : public Info {

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to RNGA hardware
    */
   static constexpr HardwarePtr<RNGA_Type> rnga = Info::baseAddress;

public:

   /**
    * Basic enable RNGA.
    *
    * Includes enabling clock
    */
   static void enable() {

      // Enable clock to RNGA interface
      Info::enableClock();
   }

   /**
    * Get random number.
    *
    * @return 0    => Error - No random number available.  This may trigger an error interrupt if enabled.
    * @return != 0 => Random value
    *
    * @note This function may fail!
    */
   static uint32_t getRandomValue() {
      return rnga->OR;
   }

   /**
    * Get random number.
    * This routine will wait until a new number is available.
    *
    * @return Random value
    *
    * @note This function may hang is RNGA is incorrectly configured!
    */
   static uint32_t waitForRandomValue() {
      for(;;) {
         if ((rnga->SR&RNGA_SR_OREG_LVL_MASK) != 0) {
            break;
         }
      }
      return rnga->OR;
   }

   /**
    * Checks if a new random value is available.
    *
    * @return false Calling getRandomValue() may generate an exception.
    * @return true  Calling getRandomValue() will return a valid number.
    */
   static bool isValueAvailable() {
      return (rnga->SR & RNGA_SR_OREG_LVL_MASK) != 0;
   }

   /**
    * Disable interface to RNGA.
    */
   static void disable() {
      Info::disableClock();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }
   /**
    * Enable/disable interrupts.
    *
    * @param[in]  enable True => enable, False => disable
    */
   static void enableInterrupt(bool enable=true) {
      if (enable) {
         // Unmask
         rnga->CR = rnga->CR & ~RNGA_CR_INTM_MASK;
      }
      else {
         // Mask
         rnga->CR = rnga->CR | RNGA_CR_INTM_MASK;
      }
   }
   
$(/RNGA/InitMethod: // /RNGA/InitMethod not found)
};

$(/RNGA/declarations: // No declarations found)
/**
 * End RNGA_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_RNGA_H_ */

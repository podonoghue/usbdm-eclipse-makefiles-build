/**
 * @file     usbphy.h (180.ARM_Peripherals/Project_Headers/USBPHY.h)
 * @brief    USB High Speed PHY
 *
 * @version  V4.12.1.80
 * @date     13 April 2019
 */
#ifndef HEADER_USBPHY_H
#define HEADER_USBPHY_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "pin_mapping.h"
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

namespace USBDM {

/**
 * @addtogroup USBPHY_Group USBPHY, USB High Speed OTG Controller
 * @brief C++ Class allowing access to USBPHY interface
 * @{
 */

/**
 * Type definition for interrupt call back
 */
typedef void (*UsbphyCallbackFunction)();

/**
 * Virtual Base class for USBPHY interface
 */
class Usbphy {

protected:
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      // Not considered an error as may be using polling
   }

   volatile USBPHY_Type  *usbphy;                 //!< USBPHY hardware instance

   /**
    * Construct USBPHY interface
    *
    * @param[in]  usbphy     Base address of USBPHY hardware
    */
   Usbphy(volatile USBPHY_Type *usbphy) : usbphy(usbphy) {
   }

   /**
    * Destructor
    */
   ~Usbphy() {}

public:
};

/**
 * @brief Template class representing an USBPHY interface
 *
 * <b>Example</b>
 *
 * @code
 *  @endcode
 *
 * @tparam Info            Class describing USBPHY hardware
 */
template<class Info> class UsbphyBase_T : public Usbphy {

public:
   // Handle on USBPHY hardware
   static constexpr HardwarePtr<USBPHY_Type> usbphy = Info::baseAddress;

   /** Used by ISR to obtain handle of object */
   static USBPHY_Type *thisPtr;

   /** Callback function for ISR */
   static UsbphyCallbackFunction sCallback;

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

public:
   $(/USBPHY/classInfo: // No class Info found)

   /**
    * Construct USBPHY interface
    */
   UsbphyBase_T() : Usbphy(&Info::usbphy()) {

   }

   /**
    * Destructor
    */
   virtual ~UsbphyBase_T() {}

   /**
    * Set channel Callback function\n
    * This callback is executed when the USBPHY state machine returns to the IDLE state
    * at the end of a transaction.
    *
    * @param[in] callback Callback function to execute on interrupt.\n
    *                     Use nullptr to remove callback.
    */
   static __attribute__((always_inline)) void setCallback(UsbphyCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "USBPHY not configured for interrupts");
      if (callback == nullptr) {
         callback = Usbphy::unhandledCallback;
      }
      sCallback = callback;
   }

   static void irqHandler() {
   }


   static void initialise() {

      // External reference clock enable
      Osc0Info::enableExternalReference(OscErClkEn_Enabled);

      // IRC enable
      McgInfo::enableMcgIrClk(McgIrClkEn_Enabled);

      // Power PHY
      SimInfo::enableUsbPhyRegulator(SimUsbPhyRegEn_Enabled);

      // Enable PHY clock
      Info::enableClock();

      // Release PHY from reset
      Info::assertPhyReset();
      Info::releasePhyReset();

      // Enable UTMI Clocks
      Info::enableUtmiClocks();

      // Power USB PLL
      Info::enablePllPower();

      // Set reference frequency provided to PLL
      Info::setPllInputFrequency(Usbphy1Info::usbPllInputClkFrq_default);

      // Set the output clock
      Info::setPfdClk(Usbphy1Info::usbPfdClkFreq_default, Usbphy1Info::usbPfdClkSrc_default);
   }
};

template<class Info> UsbphyCallbackFunction UsbphyBase_T<Info>::sCallback = Usbphy::unhandledCallback;

/** Used by ISR to obtain handle of object */
template<class Info> USBPHY_Type *UsbphyBase_T<Info>::thisPtr = 0;

$(/USBPHY/declarations: // No declarations found)
/**
 * End USBPHY_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_USBPHY_H */

/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */

/**
 * Type definition for LPTMR interrupt call back
 */
typedef void (*LptmrCallbackFunction)(void);

#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), //!< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), //!< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), //!< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), //!< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif

/**
 * @brief Template class representing a Low Power Timer
 */
template<class Info>
class LptmrBase_T : public Info {

protected:
   /** Minimum resolution required when setting interval */
   static constexpr int MINIMUM_RESOLUTION = 100;

   /** Callback function for ISR */
   static LptmrCallbackFunction sCallback;

   /** Hardware instance */
   static constexpr HardwarePtr<LPTMR_Type> lptmr = Info::baseAddress;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   $(/LPTMR/classInfo: // No class Info found)

   /**
    * Set LPTMR to pulse counting mode.
    * Provides selection of input pin, edge selection and reset mode.\n
    * The timer is enabled and pins configured.
    *
    * @param[in] lptmrPinSel        Input pin for Pulse Counting mode
    * @param[in] lptmrPulseEdge     Edge for pulse counting (default = rising-edge)
    * @param[in] lptmrClockSel      Clock source selection
    * @param[in] lptmrGlitchFilter  Input glitch filter
    * @param[in] lptmrResetOn       Selects when the LPTMR counter resets to zero (default = on overflow)
    * @param[in] lptmrInterrupt     Enable/disable interrupts
    */
   static void configurePulseCountingMode(
         LptmrPinSel       lptmrPinSel,
         LptmrPulseEdge    lptmrPulseEdge    = LptmrPulseEdge_Rising,
         LptmrClockSel     lptmrClockSel     = LptmrClockSel_Lpoclk,
         LptmrGlitchFilter lptmrGlitchFilter = LptmrGlitchFilter_Direct,
         LptmrResetOn      lptmrResetOn      = LptmrResetOn_Overflow,
         LptmrInterrupt    lptmrInterrupt    = LptmrInterrupt_Disabled) {

      enable();
      // Change settings with timer disabled
      lptmr->CSR = LptmrMode_PulseCounting|lptmrPinSel|lptmrPulseEdge|lptmrResetOn|lptmrInterrupt;
      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrGlitchFilter;
      // Enable timer
      lptmr->CSR = LptmrMode_PulseCounting|lptmrPinSel|lptmrPulseEdge|lptmrResetOn|lptmrInterrupt|LPTMR_CSR_TEN_MASK;
   }

   /**
    * Set LPTMR to time counting mode.
    * The timer is enabled and pins configured.
    *
    * @param[in] lptmrResetOn    Selects when the LPTMR counter resets to zero
    * @param[in] lptmrInterrupt  Enable/disable interrupts
    * @param[in] lptmrClockSel   Clock source selection
    * @param[in] lptmrPrescale   Clock divider
    */
   static void configureTimeIntervalMode(

         LptmrResetOn      lptmrResetOn   = LptmrResetOn_Compare,
         LptmrInterrupt    lptmrInterrupt = LptmrInterrupt_Disabled,
         LptmrClockSel     lptmrClockSel  = LptmrClockSel_Lpoclk,
         LptmrPrescale     lptmrPrescale  = LptmrPrescale_Direct) {
      enable();
      // Change settings with timer disabled
      lptmr->CSR = LptmrMode_TimeInterval|lptmrResetOn|lptmrInterrupt;
      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrPrescale;
      // Set dummy timer value to avoid immediate interrupts
      lptmr->CMR = (uint32_t)-1;
      // Enable timer and clear interrupt flag
      lptmr->CSR = LptmrMode_TimeInterval|lptmrResetOn|lptmrInterrupt|LPTMR_CSR_TEN_MASK|LPTMR_CSR_TCF_MASK;
   }

   /**
    * Restarts the counter\n
    * Mostly for debug.
    *
    */
   static void restart() {
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      lptmr->CSR   = csr|LPTMR_CSR_TCF_MASK;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match LptmrCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static LptmrCallbackFunction wrapCallback() {
      static LptmrCallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match LptmrCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static LptmrCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static LptmrCallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set callback for ISR and enable NVIC interrupts.
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(LptmrCallbackFunction callback) {
      static_assert(Info::irqLevel>=0, "LPTMR not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * PIT interrupt handler. \n
    * Calls PIT0 callback
    */
   static void irqHandler() {
      // Clear interrupt flag
      lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;

      sCallback();
   }

   /**
    * Converts a number in ticks to time in microseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static uint32_t convertTicksToMicroseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in milliseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in seconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in seconds (as float)
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static Seconds convertTicksToSeconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      return ((float)ticks)/(unsigned)tickRate;
   }

   /**
    * Converts a time in microseconds to number of ticks.
    *
    * @param[in]  time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;

#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   /**
    * Converts a time in milliseconds to number of ticks.
    *
    * @param[in]  time Time in milliseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertMillisecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;

#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in seconds to number of ticks
    *
    * @param[in]  time Time in seconds (float!)
    *
    * @return Time in ticks
    *
    * @note Uses floating point
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertSecondsToTicks(Seconds time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = (unsigned)((float)time*tickRate);

#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Set period of timer.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setPeriod(Seconds period) {
   
      float    inputClock = Info::getInputClockFrequency();
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         float    clockFrequency = inputClock/prescaleFactor;
         uint32_t mod   = rintf(period*clockFrequency);
         if (mod < MINIMUM_RESOLUTION) {
            // Too short a period for reasonable resolution
            return setAndCheckErrorCode(E_TOO_SMALL);
         }
         if (mod <= 65535) {
            // Disable LPTMR before prescale change
            uint32_t csr = lptmr->CSR;
            lptmr->CSR = 0;
            (void)(lptmr->CSR);
            lptmr->CMR  = mod;
            lptmr->PSR  = (lptmr->PSR & ~(LPTMR_PSR_PRESCALE_MASK|LPTMR_PSR_PBYP_MASK))|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            lptmr->CSR  = csr;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Set glitch filter interval.
    * This adjusts the clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]  interval Interval in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setFilterInterval(Seconds interval) {
   
      long     inputClock = Info::getInputClockFrequency();
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         if ((float)(interval*prescaleFactor) < inputClock) {
            // Disable LPTMR before prescale change
            uint32_t csr = lptmr->CSR;
            lptmr->CSR = 0;
            __DSB();
            lptmr->PSR  = (lptmr->PSR & ~(LPTMR_PSR_PRESCALE_MASK|LPTMR_PSR_PBYP_MASK))|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            lptmr->CSR  = csr;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Get timer counter value
    *
    * @return Timer value in ticks.
    */
   static Ticks getCounterValue() {
      // It is necessary to write to the CNR to capture current value
      lptmr->CNR = 0;
      return (Ticks)(lptmr->CNR);
   }

};

template<class Info> LptmrCallbackFunction LptmrBase_T<Info>::sCallback = LptmrBase_T<Info>::unhandledCallback;

$(/LPTMR/declarations: // No declarations found)
/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */

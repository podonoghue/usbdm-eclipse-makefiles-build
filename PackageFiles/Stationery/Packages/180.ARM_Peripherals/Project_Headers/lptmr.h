/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */

#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), ///< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), ///< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), ///< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif

/**
 * @brief Template class representing a Low Power Timer
 */
template<class Info>
class LptmrBase_T : public Info {

protected:
   /** Minimum resolution required when setting interval */
   static constexpr int MINIMUM_RESOLUTION = 100;

   /** Callback function for ISR */
   static typename Info::CallbackFunction sCallback;

   /** Hardware instance */
   static constexpr HardwarePtr<LPTMR_Type> lptmr = Info::baseAddress;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:

$(/LPTMR/classInfo: // No class Info found)
$(/LPTMR/StaticMethods: // /LPTMR/StaticMethods not found)
$(/LPTMR/InitMethod: // /LPTMR/InitMethod not found)
   /**
    * Restarts the counter\n
    * Mostly for debug.
    */
   static void restart() {
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      lptmr->CSR   = csr|LPTMR_CSR_TCF_MASK;
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(), T &object>
   static typename Info::CallbackFunction wrapCallback() {
      static typename Info::CallbackFunction fn = []() {
         (object.*callback)();
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Lptmr0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Lptmr0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)()>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static typename Info::CallbackFunction fn = []() {
         (obj.*callback)();
      };
      return fn;
   }

   /**
    * Set callback for ISR and enable NVIC interrupts.
    *
    *   @param[in]  callback Callback function to be executed on interrupt\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(typename Info::CallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "LPTMR not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * PIT interrupt handler. \n
    * Calls PIT0 callback
    */
   static void irqHandler() {
      // Clear interrupt flag
      lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;

      sCallback();
   }

   /**
    * Converts a number in ticks to time in microseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static uint32_t convertTicksToMicroseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in milliseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in seconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in seconds (as float)
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Seconds convertTicksToSeconds(Ticks ticks) {
      float tickRate = Info::getClockFrequencyF();
      return ((float)ticks)/tickRate;
   }

   /**
    * Converts a time in microseconds to number of ticks.
    *
    * @param[in]  time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   /**
    * Converts a time in milliseconds to number of ticks.
    *
    * @param[in]  time Time in milliseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMillisecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in seconds to number of ticks
    *
    * @param[in]  time Time in seconds (float!)
    *
    * @return Time in ticks
    *
    * @note Uses floating point
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertSecondsToTicks(Seconds time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = (unsigned)((float)time*tickRate);

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Calculate timing information based on desired duration
    *
    * @param[in]     duration  Desired period or event duration
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    * @param[out]    cmr        Compare register value
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint32_t &cmr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         float    clockFrequency = inputClock/prescaleFactor;
         uint32_t mod   = rintf(duration*clockFrequency)-1;
         if (mod < Info::minimumResolution) {
            // Too short a period for reasonable resolution
            return setAndCheckErrorCode(E_TOO_SMALL);
         }
         if (mod <= LPTMR_CMR_COMPARE_MASK) {
            cmr  = mod;
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Calculate filter information based on desired interval
    * This calculates a clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]     interval   Desired filter interval
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateFilterValues(Seconds interval, uint8_t &psr) {

      float    inputClock = Info::getInputClockFrequency((LptmrClockSel)(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         if ((float)(interval*prescaleFactor) < inputClock) {
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a duration
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period of timer.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode setPeriod(Seconds period) {

      uint8_t  psr = lptmr->PSR;
      uint32_t cmr;
      ErrorCode rc = calculateDurationValues(period, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable before changing clock
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->CMR  = cmr;
      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Set glitch filter interval.
    * This adjusts the clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]  interval Interval in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setFilterInterval(Seconds interval) {

      uint8_t  psr = lptmr->PSR;

      ErrorCode rc = calculateFilterValues(interval, psr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Get timer counter value
    *
    * @return Timer value in ticks.
    */
   static Ticks getCounterValue() {
      // It is necessary to write to the CNR to capture current value
      lptmr->CNR = 0;
      return (Ticks)(lptmr->CNR);
   }

};

template<class Info> typename Info::CallbackFunction LptmrBase_T<Info>::sCallback = LptmrBase_T<Info>::unhandledCallback;

$(/LPTMR/declarations: // No declarations found)
/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */

/**
 * @file     lptmr.h (180.ARM_Peripherals/Project_Headers/lptmr.h)
 * @brief    Low power timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_LPTMR_H
#define HEADER_LPTMR_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cmath>
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#if $(/LPTMR/enablePeripheralSupport:false) // /LPTMR/enablePeripheralSupport

#ifdef PCC_PCC_LPTMR0_CGC_MASK
/**
 * Select the LPTMR clock source which determines count speed or glitch filtering
 */
enum LptmrClockSel {
   LptmrClockSel_SircDiv2Clk  = LPTMR_PSR_PCS(0), ///< Slow Internal Reference Div 2 Clock (SIRCDIV2_CLK)
   LptmrClockSel_Lpo1Kclk     = LPTMR_PSR_PCS(1), ///< Low power oscillator 1kHz (LPO1K_CLK)
   LptmrClockSel_Rtcclk       = LPTMR_PSR_PCS(2), ///< 32kHz Clock Source (RTC_CLK)
   LptmrClockSel_PccLptmrClk  = LPTMR_PSR_PCS(3), ///< Clock from PCC_LPTMRx multiplexor (PCC)
   LptmrClockSel_Default      = LptmrClockSel_Lpo1Kclk,
};
#endif

/**
 * @brief Template class representing a Low Power Timer
 */
template<class Info>
class LptmrBase_T : public Info {

protected:
   /** Minimum resolution required when setting interval */
   static constexpr int MINIMUM_RESOLUTION = 100;

   /** Hardware instance */
   static constexpr HardwarePtr<LPTMR_Type> lptmr = Info::baseAddress;

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /**
    * Configure LPTMR in time counting mode.
    * The timer is enabled
    *
    * @param lptmrCounterActionOnEvent Counter action when compare event occurs
    *             The counter can continue counting or be reset to zero.
    * @param lptmrEventAction          Enables LPTMR interrupts
    * @param lptmrClockSel             Selects the clock source for LPTMR
    * @param ticks                     Comparison value
    *             The timer comparison flag is set when the counter reaches this value and increments.
    *             The hardware trigger will assert until the next time the counter increments.
    *             This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    * @param lptmrPrescale             Configures the size of the Prescaler in Time Interval mode
    */
   static void configureTimeIntervalMode(
         LptmrCounterActionOnEvent  lptmrCounterActionOnEvent,
         LptmrEventAction           lptmrEventAction,
         LptmrClockSel              lptmrClockSel,
         const Ticks&               ticks              = 65535_ticks,
         LptmrPrescale              lptmrPrescale      = LptmrPrescale_Direct) {

      Info::enable();

      // Change settings with timer disabled 1
      lptmr->CSR = lptmrCounterActionOnEvent|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;

      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrPrescale;

      // Set event time
      lptmr->CMR = ticks;

      // Enable timer
      lptmr->CSR = lptmrCounterActionOnEvent|lptmrEventAction|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   }

   /**
    * Configure LPTMR in time counting mode.
    * The timer is enabled
    *
    * @param lptmrCounterActionOnEvent Counter action when compare event occurs
    *             The counter can continue counting or be reset to zero.
    * @param lptmrEventAction          Enables LPTMR interrupts
    * @param seconds                   Comparison value
    *             The timer comparison flag is set when the counter reaches this value and increments.
    *             The hardware trigger will assert until the next time the counter increments.
    *             This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    * @param lptmrClockSel             Selects the clock source for LPTMR
    */
   static ErrorCode configureTimeIntervalMode(
         LptmrCounterActionOnEvent  lptmrCounterActionOnEvent,
         LptmrEventAction           lptmrEventAction,
         const Seconds&             seconds,
         LptmrClockSel              lptmrClockSel      = LptmrClockSel_Lpoclk) {

      Info::enable();

      uint8_t  psr = lptmrClockSel;
      uint32_t cmr;

      ErrorCode rc = calculateDurationValues(seconds, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }

      // Change settings with timer disabled 2
      lptmr->CSR = lptmrCounterActionOnEvent|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;

      // Set clock source and prescaler
      lptmr->PSR = psr;

      // Set event time
      lptmr->CMR = cmr;

      // Enable timer
      lptmr->CSR = lptmrCounterActionOnEvent|lptmrEventAction|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;

      return E_NO_ERROR;
   }

   /**
    * Configure LPTMR in pulse counting mode.
    * Provides selection of input pin, edge selection and reset mode.
    * The timer is enabled and pins configured.
    *
    * @param lptmrInput                   Input source to be used in Pulse Counter mode
    * @param lptmrInputEdge               Polarity of the input source in Pulse Counter mode
    * @param lptmrClockSel                Selects the clock source for LPTMR
    * @param lptmrGlitchFilter            Configures the size of the glitch filter in Pulse Counting mode
    * @param lptmrCounterActionOnEvent    Counter action when compare event occurs
    *        The counter can continue counting or be reset to zero.
    * @param lptmrEventAction             Enables LPTMR interrupts
    * @param ticks                        Comparison value
    *        The timer comparison flag is set when the counter reaches this value and increments.
    *        The hardware trigger will assert until the next time the counter increments.
    *        This value determines the period in TimeInterval mode or the event time in Pulse Counting mode
    */
   static void configurePulseCountingMode(
         LptmrInput                 lptmrInput,
         LptmrInputEdge             lptmrInputEdge,
         LptmrClockSel              lptmrClockSel              = LptmrClockSel_Lpoclk,
         LptmrGlitchFilter          lptmrGlitchFilter          = LptmrGlitchFilter_Direct,
         LptmrCounterActionOnEvent  lptmrCounterActionOnEvent  = LptmrCounterActionOnEvent_Reset,
         LptmrEventAction           lptmrEventAction           = LptmrEventAction_None,
         const Ticks&               ticks                      = 65535_ticks) {

      Info::enable();

      // Change settings with timer disabled 3
      lptmr->CSR = lptmrInput|lptmrInputEdge|lptmrCounterActionOnEvent|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK;

      // Set clock source and prescaler
      lptmr->PSR = lptmrClockSel|lptmrGlitchFilter;

      // Set Event time
      lptmr->CMR = ticks;

      // Enable timer
      lptmr->CSR = lptmrInput|lptmrInputEdge|lptmrCounterActionOnEvent|lptmrEventAction|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
   }

   /**
    * Restarts the counter\n
    * Mostly for debug.
    */
   static void restart() {
      uint32_t csr = lptmr->CSR;
      lptmr->CSR   = 0;
      lptmr->CSR   = csr|LPTMR_CSR_TCF_MASK;
   }


   /**
    * Converts a number in ticks to time in microseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static uint32_t convertTicksToMicroseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in milliseconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen appropriately.
    * @note Rudimentary range checking only. Sets error code.
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a number in ticks to time in seconds.
    *
    * @param[in]  ticks Time in ticks
    *
    * @return Time in seconds (as float)
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Seconds convertTicksToSeconds(Ticks ticks) {
      float tickRate = Info::getClockFrequencyF();
      return ((float)ticks)/tickRate;
   }

   /**
    * Converts a time in microseconds to number of ticks.
    *
    * @param[in]  time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }
   /**
    * Converts a time in milliseconds to number of ticks.
    *
    * @param[in]  time Time in milliseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen appropriately.
    */
   static Ticks convertMillisecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in seconds to number of ticks
    *
    * @param[in]  time Time in seconds (float!)
    *
    * @return Time in ticks
    *
    * @note Uses floating point
    * @note Rudimentary range checking only. Sets error code.
    */
   static Ticks convertSecondsToTicks(Seconds time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = (unsigned)((float)time*tickRate);

#ifdef DEBUG_BUILD
      if (rv > UINT_MAX) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Calculate timing information based on desired duration
    *
    * @param[in]     duration  Desired period or event duration
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    * @param[out]    cmr        Compare register value
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint32_t &cmr) {

      float    inputClock = Info::getInputClockFrequency(LptmrClockSel(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         float    clockFrequency = inputClock/prescaleFactor;
         uint32_t mod   = rintf(float(duration*clockFrequency))-1;
         if (mod <= LPTMR_CMR_COMPARE_MASK) {
            cmr  = mod;
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Calculate filter information based on desired interval
    * This calculates a clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]     interval   Desired filter interval
    * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode calculateFilterValues(Seconds interval, uint8_t &psr) {

      float    inputClock = Info::getInputClockFrequency(LptmrClockSel(psr&LPTMR_PSR_PCS_MASK));
      int      prescaleFactor=1;
      uint32_t prescalerValue=0;
      while (prescalerValue<=16) {
         if ((float)(interval*prescaleFactor) < inputClock) {
            psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a duration
      return setAndCheckErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period of timer.
    *
    * @param[in]  period Period in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
    */
   static ErrorCode setPeriod(Seconds period) {

      uint8_t  psr = lptmr->PSR;
      uint32_t cmr;
      ErrorCode rc = Info::calculateDurationValues(period, psr, cmr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable before changing clock
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->CMR  = cmr;
      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Set glitch filter interval.
    * This adjusts the clock prescaler so that the filter interval is at least the given value.
    *
    * @param[in]  interval Interval in seconds as a float
    *
    * @note Will enable and adjust the pre-scaler to appropriate value.\n
    *       The clock source should be selected by setClock() before using this function.
    *
    * @return E_NO_ERROR      => Success
    * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
    */
   static ErrorCode setFilterInterval(Seconds interval) {

      uint8_t  psr = lptmr->PSR;

      ErrorCode rc = calculateFilterValues(interval, psr);
      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable LPTMR before prescale change
      uint32_t csr = lptmr->CSR;
      lptmr->CSR = 0;
      (void)(lptmr->CSR);

      lptmr->PSR  = psr;

      lptmr->CSR  = csr;

      return E_NO_ERROR;
   }

   /**
    * Get timer counter value
    *
    * @return Timer value in ticks.
    */
   static Ticks getCounterValue() {
      // It is necessary to write to the CNR to capture current value
      lptmr->CNR = 0;
      return (Ticks)(lptmr->CNR);
   }

};

$(/LPTMR/declarations: // No declarations found)
#endif // /LPTMR/enablePeripheralSupport
/**
 * End LPTMR_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_LPTMR_H */

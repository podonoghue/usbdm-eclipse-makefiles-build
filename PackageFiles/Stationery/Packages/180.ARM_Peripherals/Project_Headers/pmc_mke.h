/**
 * @file     pmc.h (180.ARM_Peripherals/Project_Headers/pmc.h)
 * @brief    Power Management Controller
 *
 * @version  V4.12.1.210
 * @date     30 September 2017
 */

#ifndef HEADER_PMC_H
#define HEADER_PMC_H
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Peripheral information for Power Management Controller
 * @{
 */

/**
 * Indicates reason for execution of call-back
 */
enum PmcInterruptReason {
   PmcInterruptReason_LowVoltageDetect,//!< Low Voltage Detect
   PmcInterruptReason_LowVoltageWarning//!< Low Voltage Warning
};

/**
 * Type definition for PDB interrupt call back
 *
 * @param pmcInterruptReason Reason for interrupt leading to call-back
 */
typedef void (*PmcCallbackFunction)(PmcInterruptReason pmcInterruptReason);

/**
 * Template class providing interface to Power Management Controller
 *
 * @tparam info      Information class for PMC
 *
 * @code
 * using pmc = PmcBase_T<PmcInfo>;
 *
 *  pmc::defaultConfigure();
 *
 * @endcode
 */
template <class Info>
class PmcBase_T {

protected:
   /** Callback function for ISR */
   static PmcCallbackFunction sCallback;

   /** Handler for unexpected interrupts */
   static void unhandledCallback(PmcInterruptReason) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {

      pmc->SPMSC1 = pmc->SPMSC1 | PMC_SPMSC1_LVWACK_MASK;

      sCallback(PmcInterruptReason_LowVoltageWarning);
      return;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(PmcInterruptReason reason), T &object>
   static PmcCallbackFunction wrapCallback() {
      static PmcCallbackFunction fn = [](PmcInterruptReason reason) {
         (object.*callback)(reason);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PmcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Cmp0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Cmp0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(PmcInterruptReason reason)>
   static PmcCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static PmcCallbackFunction fn = [](PmcInterruptReason reason) {
         (obj.*callback)(reason);
      };
      return fn;
   }

   /**
    * Set Callback function
    *
    *  @param[in]  callback  Callback function to be executed on interrupt.\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(PmcCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "PMC not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }


protected:
   /** Hardware instance */
   static constexpr HardwarePtr<PMC_Type> pmc = Info::baseAddress;

public:
   /**
    * Enable clock to the PMC
    */
   static void  __attribute__((always_inline)) enable() {
   }

   /**
    * Configure PMC from configuration provided
    *
    * @param config Configuration to use
    */
   static void configure(const PmcInfo::Init &config) {
      // ToDo add IRQ
      pmc->SPMSC1 = config.spmsc1;
      pmc->SPMSC2 = config.spmsc2;
   }

   /**
    * Enables PMC and sets to default configuration.
    *
    * Includes enabling clock and any pins used.\n
    * Sets PMC to default configuration.
    */
   static void defaultConfigure() {
      enable();
      configure(PmcInfo::DefaultInitValue);
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

#ifdef PMC_SRAMCTL_VLLS2PD_MASK
   /**
    * Sets which SRAM blocks are powered during LLS2 mode and VLLS2 modes.
    *
    * @param blocks Bit mask for the 8 SRAM blocks, 1=> retain, 0=> not powered during LLS2 mode and VLLS2 modes.
    */
   static void setVlpRamRetention(uint8_t blocks) {
      pmc->SRAMCTL = (uint8_t)~blocks;
   }
#endif
};

template<class Info> PmcCallbackFunction PmcBase_T<Info>::sCallback = PmcBase_T<Info>::unhandledCallback;

$(/PMC/declarations: // No declarations found)
/**
 * End PMC_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_PMC_H */

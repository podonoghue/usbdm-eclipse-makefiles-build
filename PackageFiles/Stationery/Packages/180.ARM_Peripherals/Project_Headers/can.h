/**
 * @file     can.h (180.ARM_Peripherals/Project_Headers/can.h)
 *
 * @brief    Abstraction layer for CAN interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef PROJECT_HEADERS_CAN_H_
#define PROJECT_HEADERS_CAN_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"
#include "string.h"
#include <limits.h>

namespace USBDM {

/**
 * Select Standard or Extended CAN mode
 * Standard - 11-bit ID field
 * Extended - 29-bit ID field
 */
enum CanMode {
   CanMode_Standard = false,  //!< CanMode_Standard
   CanMode_Extended = true,   //!< CanMode_Extended
};

/**
 * Selects Remote or Data frame
 */
enum CanFrameType {
   CanFrameType_Data   = false, //!< Data Frame
   CanFrameType_Remote = true,  //!< Remote Frame
};

/**
 * Class holding CAN communication parameters
 */
union CanParameters {
public:
   struct {
      uint32_t    ctrl1;      //!< Control register 1
      uint32_t    ctrl2;      //!< Control register 2
      uint32_t    mcr;        //!< Mode control register
   };
   struct {
      //--- CTRL1 --------------------------
      unsigned propSeg:3;    //!< Propagation Segment
      bool     lom:1;        //!< Listen-Only Mode
      bool     lbuf:1;       //!< Lowest Buffer Transmitted First
      bool     tsyn:1;       //!< Timer Sync
      bool     boffrec:1;    //!< Bus Off Recovery
      bool     smp:1;        //!< CAN Bit Sampling
      unsigned :2;
      bool     rwrnmsk:1;    //!< Receive Warning Interrupt Mask for ESR1.RWRNINT
      bool     twrnmsk:1;    //!< Transmit Warning Interrupt Mask for ESR1.TWRNINT
      bool     lpb:1;        //!< Loop Back Mode
      bool     clksrc:1;     //!< CAN Engine Clock Source
      bool     errmsk:1;     //!< Error Mask for ESR1.ERRINT (BIT1ERR, BIT0ERR, ACKERR, CRCERR, FRMERR or STFERR)
      bool     boffmsk:1;    //!< Bus Off Mask
      unsigned pSeg2:3;      //!< Phase Segment 2
      unsigned pSeg1:3;      //!< Phase Segment 1
      unsigned rjw:2;        //!< Resynchronisation Jump Width
      unsigned presdiv:8;    //!< Prescaler Division Factor
      //--- CTRL2 --------------------------
      unsigned :16;
      bool     eacen:1;      //!< Entire Frame Arbitration Field Comparison Enable For Receive Mailboxes
      bool     rrs:1;        //!< Remote Request Stored (Automatic Remote Response Frame is not generated)
      bool     mrp:1;        //!< Mailboxes Reception Priority
      unsigned tasd:5;       //!< Transmit Arbitration Start Delay
      unsigned rffn:4;       //!< Number Of Receive FIFO Filters
#ifdef CAN_CTRL2_WRMFRZ
      bool     wrmfrz:1;     //!< Write-Access To Memory In Freeze Mode
#else
      unsigned :1;     //!< WRMFRZ not available
#endif
#ifdef CAN_CTRL2_BOFFDONEMSK_MASK
      bool     boffdonemsk:1;     //!< Mask for the Bus Off Done Interrupt in CAN_ESR1 register.
#else
      unsigned :1;     //!< BOFFDONEMSK not available
#endif
#ifdef CAN_CTRL2_ERRMSK_FAST_MASK
      bool     errmsk_fast:1;     //!< Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
#else
      unsigned :1;     //!< ERRMSK_FAST not available
#endif
      unsigned :1;
      //--- MCR --------------------------
      unsigned maxmb:7;     //!< Number of the last message buffer
      unsigned :1;
      unsigned idam:2;      //!< ID Acceptance Mode
      unsigned :1;
#ifdef CAN_MCR_FDEN_MASK
      bool     fden:1;      //!< Flexible Data rate enable
#else
      unsigned :1;          //!< FDEN not available
#endif
      bool     aen:1;       //!< Abort Enable
      bool     lprioen:1;   //!< Local Priority Enable
#ifdef CAN_MCR_PNET_EN_MASK
      unsigned :1;          //!< Pretended Networking Enable
#else
      unsigned :1;          //!< PNET_EN not available
#endif
#ifdef CAN_MCR_DMA_MASK
      unsigned :1;          //!< DMA Enable
#else
      unsigned :1;          //!< DMA not available
#endif
      bool     irmq:1;      //!< Individual mailbox and FIFO masking, or use of RXMGMASK, RX14MASK, RX15MASK and RXFGMASK
      bool     srxdis:1;    //!< Self Reception Disable
      unsigned :1;
#ifdef CAN_MCR_WAKSRC_MASK
      bool     waksrc:1;    //!< Wake Up Source
#else
      unsigned :1;          //!< WAKSRC not available
#endif
      unsigned :1;          //!< LPMACK - Low-Power Mode Acknowledge
      bool     wrnen:1;     //!< Warning Interrupt Enable
#ifdef CAN_MCR_SLFWAK_MASK
      bool     slfwak:1;    //!< Self Wake Up
#else
      unsigned :1;          //!< SLFWAK not available
#endif
      bool     supv:1;      //!< Supervisor Mode
      unsigned :1;          //!< FRZACK - Freeze Mode Acknowledge
      unsigned :1;          //!< SOFTRST - Soft Reset
#ifdef CAN_MCR_WAKMSK_MASK
      bool     wakmsk:1;    //!< Wake Up Interrupt Mask
#else
      unsigned :1;          //!< WAKMSK not available
#endif
      unsigned :1;          //!< NOTRDY - FlexCAN Not Ready
      bool     :1;          //!< HALT - Halt FlexCAN
      bool     rfen:1;      //!< Receive FIFO Enable
      bool     :1;          //!< FRZ - Freeze Enable
      bool     :1;          //!< MDIS - Module Disable
   };

private:
   /**
    * Utility function to select the smaller of two unsigned values
    *
    * @param a
    * @param b
    *
    * @return smaller of a and b
    */
   static constexpr unsigned min(unsigned a, unsigned b) {
      return (a<b)?a:b;
   }

   /**
    * Constructor
    * Most parameters will be set to a default disabled value apart from:\n
    * Communication parameters calculated from bitRate and clockFreq:\n
    *   - presdiv Prescaler Division Factor
    *   - propSeg Propagation Segment
    *   - pSeg1   Phase Segment 1
    *   - pSeg2   Phase Segment 2
    *   - rjw     Resynchronisation Jump Width
    *   - tasd    Transmit Arbitration Start Delay (=22, reset default)
    *   - maxmb   Number Of The Last Message Buffer (=15, reset default)
    *
    * @param bitRate    Desired bit rate
    * @param clockFreq  Protocol Engine input clock frequency
    *
    * @note Use isValid to check for success or check USBDM error code
    */
   CanParameters(unsigned bitRate, unsigned clockFreq) {

      unsigned bestError        = INT_MAX;
      unsigned bestPrescaler    = 1;  // 1..256
      unsigned bestTq           = 0;  // 8..25 = 1 + timeSegment1 + timeSegment2

      // Try each tq value checking for the best outcome
      // Prefer higher tq if multiple equal best
      for (uint8_t tq = 25; tq>=8; tq--) {
         unsigned prescaler = clockFreq/tq/bitRate;  // 1..256

         auto checkParams = [&] {
            // Check settings
            int error = clockFreq/tq/prescaler - bitRate;
            if (error<0) {
               error = -error;
            }
//            console.
//               write("TQ =").write(tq).
//               write(", PS = ").write(prescaler).
//               write(", F =").write(clockFreq/tq/prescaler/1000.0).write(" kHz").
//               write(", E =").write(error).write(" Hz");
            if ((unsigned)error < bestError) {
//               console.write(" *");
               bestError     = (unsigned)error;
               bestTq        = tq;
               bestPrescaler = prescaler;
            }
//            console.writeln();
         };
         if (prescaler>=1) {
            checkParams();
         }
         prescaler++;
         if (prescaler<=256) {
            checkParams();
         }
      }
      if (bestTq == 0) {
         // Indicates failure
         propSeg = 0;
         setErrorCode(E_ILLEGAL_PARAM);
         return;
      }
      /*
       * tq has to be allocated between
       *   Sync segment   = fixed @ 1
       *   Time segment 1 = 4..16
       *   Time segment 2 = 2..8
       * Time segment 1 gets subdivided into propSegment and pseg1
       * Time segment 2 become pseg2
       *
       * Resync is equal to Time segment 2 up to a maximum of 4
       */
      unsigned timeSegment2 = (bestTq-1)/3;
      unsigned timeSegment1 = (bestTq-1) - timeSegment2;
      unsigned resyncJumpWidth = timeSegment2;
      if (resyncJumpWidth>4) {
         resyncJumpWidth = 4;
      }
      ctrl1   = 0; // Reset value
      presdiv = bestPrescaler - 1;
      propSeg = ((timeSegment1+1)/2) - 1;
      pSeg1   = (timeSegment1 - propSeg) - 2;
      pSeg2   = timeSegment2 - 1;
      rjw     = resyncJumpWidth - 1;

      ctrl2   = 0;
      tasd    = 22; // Reset value

      mcr     = 0;
      maxmb   = 16-1;
      aen     = true;
      irmq    = true;
   }

public:
   /**
    * Constructor
    * Most parameters will be set to a default disabled value apart from:\n
    * Communication parameters calculated from bitRate and SystemCoreClock:\n
    *   - presdiv Prescaler Division Factor
    *   - propSeg Propagation Segment
    *   - pSeg1   Phase Segment 1
    *   - pSeg2   Phase Segment 2
    *   - rjw     Resynchronisation Jump Width
    *   - tasd    Transmit Arbitration Start Delay (=22, reset default)
    *   - maxmb   Number Of The Last Message Buffer (=15, reset default)
    *
    *   - clksrc = 1 : System clock source
    *
    * @param bitRate    Desired bit rate
    *
    * @note Use isValid to check for success or check USBDM error code
    */
   CanParameters(unsigned bitRate) : CanParameters(bitRate, SystemCoreClock) {
      clksrc  = true;  // SYS_CLK
   }

   /**
    * Check if value was constructed correctly
    *
    * @return true  Values appear valid
    * @return false Values appear invalid
    */
   bool isValid() const {
      //TODO - Check values properly
      return (propSeg != 0);
   }

   /**
    * Calculates number of FIFO filters available based on number of Mailboxes available.
    *
    * @param availableMailBoxes Number of Mailboxes available
    *
    * @return Number of individual FIFO filter masks
    */
   static constexpr unsigned calculateMaximumFifoFilters(unsigned availableMailBoxes) {
      return min((availableMailBoxes-6)*4, 128);
   }

   /**
    * Calculates the number of message buffers required to accommodate FIFO, FIFO filters and mailboxes.
    * Some of the message buffers can be used as a receive FIFO with
    * the remainder available as transmit or receive mailboxes.
    * The total number of message buffers is limited by the hardware
    * There are also timing constraints as the CAN hardware must scan
    * the FIFO filters and mailboxes.
    *
    * @param fifoIdFilters   Number of FIFO filter entries (Format_A=x1, Format_B=x2, Format_C=x4)
    * @param mailboxes       Number of mailboxes
    *
    * @return The number of message buffers required.
    */
   static constexpr unsigned calulateRequiredMessageBuffers(unsigned fifoIdFilters, unsigned mailboxes) {
      return (fifoIdFilters==0?0:6)+(fifoIdFilters/4) + mailboxes;
   }

   /**
    * Calculates number of FIFO filter masks available based on number of FIFO filters.
    * Each FIFO filter is masked by either an individual mask or a shared mask.
    * This calculates the number of individual masks available to be applied to the FIFO filters.
    * The remaining FIFO filters are masked by the shared mask.
    *
    * @param fifoIdFilterCount   Number of FIFO filters implemented
    *
    * @return Number of individual FIFO filter masks
    */
   static constexpr unsigned calculateFifoIndividualMaskCount(unsigned fifoIdFilterCount) {
      return (fifoIdFilterCount<8)?0:(8 + 2*((fifoIdFilterCount/8)-1));
   }

};

/**
 * @addtogroup CAN_Group CAN, Controller Area Network
 * @brief Abstraction for Controller Area Network
 * @{
 */
/**
 * Type definition for CAN interrupt call back
 */
typedef void (*CanCallbackFunction)(void);

enum CanMessageCode {
   CanMessageCode_RxInactive = 0b0000, //!< MB does not participate
   CanMessageCode_RxEmpty    = 0b0100, //!< May be filled on reception
   CanMessageCode_RxFull     = 0b0010, //!< Buffer holds received data
   CanMessageCode_RxOverrun  = 0b0110, //!< Reception Overrun, Buffer holds received data
   CanMessageCode_RxAnswer   = 0b1010, //!< Buffer used for remote answer reception

   CanMessageCode_RxBusy     = 0b0001, //!< This bit indicate the buffer is busy (changing)

   CanMessageCode_TxInactive = 0b1000, //!< MB does not participate
   CanMessageCode_TxAbort    = 0b1001, //!< Aborted, MB does not participate
   CanMessageCode_TxData     = 0b1100, //!< (RTR=0) Transmit Data
   CanMessageCode_TxRemote   = 0b1100, //!< (RTR=1) Transmit Remote request
   CanMessageCode_TxAnswer   = 0b1110, //!< Buffer automatically used for remote answer response
};

/**
 * Size of data in message
 */
enum CanDataSize {
   CanDataSize_0  = 0,   // No Data bytes in message
   CanDataSize_1  = 1,   // 1 bytes in message
   CanDataSize_2  = 2,   // 2 bytes in message
   CanDataSize_3  = 3,   // 3 bytes in message
   CanDataSize_4  = 4,   // 4 bytes in message
   CanDataSize_5  = 5,   // 5 bytes in message
   CanDataSize_6  = 6,   // 6 bytes in message
   CanDataSize_7  = 7,   // 7 bytes in message
   CanDataSize_8  = 8,   // 8 bytes in message
   CanDataSize_12 = 9,   // 12 bytes in message
   CanDataSize_16 = 10,  // 16 bytes in message
   CanDataSize_20 = 11,  // 20 bytes in message
   CanDataSize_24 = 12,  // 24 bytes in message
   CanDataSize_32 = 13,  // 32 bytes in message
   CanDataSize_48 = 14,  // 48 bytes in message
   CanDataSize_64 = 15,  // 64 bytes in message
};

/**
 * Can CS value in message
 */
union CanControlStatus {
   uint32_t  raw;
   struct {
      unsigned       timeStamp : 16;    //!< Time stamp
      CanDataSize    dlc       :  4;    //!< Length of Data
      CanFrameType   rtr       :  1;    //!< Remote Transmission Request
      unsigned       ide       :  1;    //!< ID Extended Bit
      unsigned       srr       :  1;    //!< Substitute Remote Request
      unsigned                 :  1;
      CanMessageCode code      :  4;    //!< Message Buffer Code
      unsigned                 :  1;
      unsigned       esi       :  1;    //!< Error State Indicator
      unsigned       brs       :  1;    //!< Bit Rate Switch
      unsigned       edl       :  1;    //!< Extended Data Length
   };
   struct {
      unsigned       : 23;
      unsigned idhit :  9; //!< Identifier Acceptance Filter Hit Indicator
   };
   void operator=(uint32_t value) volatile { raw = value; }
   void operator=(uint32_t value) { raw = value; }
   void operator=(volatile CanControlStatus &other) volatile { raw = other.raw; }
   void operator=(const CanControlStatus &other) volatile { raw = other.raw; }
   void operator=(CanControlStatus &other) volatile { raw = other.raw; }
   constexpr CanControlStatus(uint32_t value) : raw(value) {}
   constexpr CanControlStatus(CanControlStatus &other) : raw(other.raw) {}
   constexpr CanControlStatus(const CanControlStatus &other) : raw(other.raw) {}
   constexpr CanControlStatus(volatile CanControlStatus &other) : raw(((CanControlStatus &)other).raw) {}
   constexpr CanControlStatus() : raw(0) {}
   /**
    * Constructor for CanControlStatus for use in Receive message buffers
    *
    * @param canMessageCode   Message type, usually CanMessageCode_RxEmpty, CanMessageCode_RxAnswer
    * @param canFrameType     Accept remote requests, false => may be used as part of matching
    */
   constexpr CanControlStatus(
         const CanMessageCode canMessageCode,
         const CanFrameType   canFrameType=CanFrameType_Data ) :
         raw(CAN_CS_CODE(canMessageCode)|CAN_CS_RTR(canFrameType)) {}
   /**
    * Constructor for CanControlStatus for use in Transmit message buffers
    *
    * @param canMessageCode   Message type, usually CanMessageCode_TxData, CanMessageCode_TxRemote
    * @param canMode          CAN Mode (affects ID size etc)
    * @param canDataSize      Size of data to transmit
    * @param canFrameType     DATA or REMOTE frames Tx REMOTE(MB switches to Rx EMPTY on success)
    */
   constexpr CanControlStatus(
         const CanMessageCode canMessageCode,
         const CanMode        canMode,
         const CanDataSize    canDataSize,
         const CanFrameType   canFrameType=CanFrameType_Data) :
         raw(CAN_CS_CODE(canMessageCode)|CAN_CS_IDE(canMode)|CAN_CS_DLC(canDataSize)|CAN_CS_RTR(canFrameType)|CAN_CS_SRR(1)) {}
} __attribute__((__packed__)) ;

/**
 * Can CS value in message
 */
union CanId {
   uint32_t  raw;
   struct {
      unsigned idExt : 29;  //!< Extended Frame Identifier
      unsigned prio  :  3;  //!< Local priority
   };
   struct {
      unsigned       : 18;
      unsigned idStd : 11;  //!< Standard Frame Identifier
      unsigned       :  3;
   };
   void operator=(uint32_t value) volatile { raw = value; }

   void operator=(volatile CanId &other)       { raw = other.raw; }
   void operator=(const CanId &other) volatile { raw = other.raw; }

   constexpr CanId(uint32_t value) : raw(value) {}
   constexpr CanId(const CanId &other) : raw(other.raw) {}
   constexpr CanId() : raw(0) {}

   /**
    * Constructor for CanId for use in Transmit or Receive message buffers
    *
    * @param canMode          CAN Mode (affects ID size etc)
    * @param id               ID (standard or extended)
    * @param priority         Priority - only for transmission if MCR.LPRIO_EN=true
    */
   constexpr CanId(
         const CanMode  canMode,
         const unsigned id,
         const unsigned priority=0) :
         raw((canMode?CAN_ID_EXT(id):CAN_ID_STD(id))|CAN_ID_PRIO(priority)) {}

}  __attribute__((__packed__));

/**
 * Represents a CAN Message in CAN RAM area.
 * This is never constructed.
 */
struct CanMessageBuffer {
   CanControlStatus CS;        //!< CS Register
   CanId            ID;        //!< ID Register
   uint32_t         DATA32[];  //!< DATA portion of buffer - variable size

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex8(const unsigned index) {
      return (index^0x3U);
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint8_t &data8(const unsigned index) volatile {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint8_t &data8(const int index) const {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint8_t &data8(const int index) {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
    }

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex16(const unsigned index) {
      return (index&~0x1U) + (1-(index&0x1U));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint16_t &data16(const unsigned index) volatile {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint16_t &data16(const int index) const {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint16_t &data16(const int index) {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
    }
} __attribute__((__packed__));

/**
 * Represents a standard 8-byte CAN Message in RAM
 */
struct CanMessageBuffer8 {
   CanControlStatus CS;         //!< CS Register
   CanId            ID;         //!< ID Register
   uint32_t         DATA32[2];  //!< DATA portion of buffer - standard size

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex8(const unsigned index) {
      return (index^0x3U);
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint8_t &data8(const unsigned index) volatile {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint8_t &data8(const int index) const {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint8_t &data8(const int index) {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
    }

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex16(const unsigned index) {
      return (index&~0x1U) + (1-(index&0x1U));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint16_t &data16(const unsigned index) volatile {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint16_t &data16(const int index) const {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint16_t &data16(const int index) {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
    }
} __attribute__((__packed__));

/**
 * Filter mask for CAN Mailboxes
 * The mask is applied to the comparison to the MB[ID], MB[RTR] and MB[ID]
 */
union CanMailboxFilterMask {
   uint32_t     raw;             //!< RAW 32-bit value
   struct {
      unsigned  idMask     : 29; //!< Mask for MB[ID] field
      unsigned  fill       :  1;
      unsigned  ideMask    :  1; //!< Mask for MB[IDE] field
      unsigned  rtrMask    :  1; //!< Mask for MB[RTR] field
   };

   /**
    * Constructor for Mail box filter
    *
    * @param canMode          Select Standard or Extended mode
    * @param idMask           Mask for MB[ID] (standard 11-bit, or extended 29-bit)
    * @param ideMask          Enables filtering on MB[IDE] field
    * @param frameTypeMask    Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanMailboxFilterMask(
         CanMode  canMode,
         unsigned idMask,
         bool     ideMask=true,
         bool     frameTypeMask=true) :
         idMask(canMode?idMask:(idMask<<18)), fill(0), ideMask(ideMask), rtrMask(frameTypeMask) {}

   constexpr CanMailboxFilterMask(uint32_t value) : raw(value) {}
   constexpr CanMailboxFilterMask(const CanId &other) : raw(other.raw) {}
   constexpr CanMailboxFilterMask() : raw(~0U) {}

   void operator=(uint32_t value) volatile { raw = value; }
   };


/**
 * Filter mask for CAN receive FIFO filters - Formats A, B and C
 * These masks are applied to Frame matching comparisons using the FIFO Filter table.
 */
union CanFifoIdFilterMask {
   uint32_t     raw;             //!< RAW 32-bit value
   struct {
      unsigned  filla      :  1;
      unsigned  rxidaMask  : 29; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit)
      unsigned  ideaMask   :  1; //!< Mask for Extended Frame
      unsigned  rtraMask   :  1; //!< Mask for Remote Frame
   };
   struct {
      unsigned  rxidb1Mask : 14; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb1Mask  :  1; //!< Mask for Extended Frame
      unsigned  rtrb1Mask  :  1; //!< Mask for Remote Frame

      unsigned  rxidb0Mask : 14; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb0Mask  :  1; //!< Mask for Extended Frame
      unsigned  rtrb0Mask  :  1; //!< Mask for Remote Frame
   };
   struct {
      unsigned  rxidc3Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc2Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc1Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc0Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
   };

   /**
    * Constructor for filter table entry mask - Format A
    * Used when each entry in the FIFO filter table represents 1 frame filter.
    * This is the most general format (can filter on IDE, RTR, and the full extended ID, )
    *
    * @param canMode          Select Standard or Extended mode
    * @param rxidMask         Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit)
    * @param ideMask          Mask for Extended Frame
    * @param frameTypeMask    Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanFifoIdFilterMask(
         CanMode   canMode,
         unsigned  rxidMask,
         bool      ideMask,
         bool      frameTypeMask) :
            filla(1),
            rxidaMask(canMode?rxidMask:(rxidMask<<18)),
            ideaMask(ideMask),
            rtraMask(frameTypeMask) {}

   /**
    * Constructor for filter table entry mask - Format B
    * Used when each entry in the FIFO filter table represents 2 frame filters
    * This is a more restricted format (can filter on IDE, RTR, and 14 bits of the extended ID)
    *
    * @param canMode          Mask for Select Standard or Extended mode
    * @param rxid0Mask        Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 14 MSBs retained)
    * @param ide0Mask         Mask for Extended Frame
    * @param frameType0Mask   Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    * @param rxid1Mask        Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 14 MSBs retained)
    * @param ide1Mask         Mask for Extended Frame
    * @param frameType0Mask   Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanFifoIdFilterMask(
         CanMode   canMode,
         unsigned  rxid0Mask,
         unsigned  ide0Mask,
         unsigned  frameType0Mask,
         unsigned  rxid1Mask,
         unsigned  ide1Mask,
         unsigned  frameType1Mask
         ) :
         rxidb1Mask(canMode?rxid1Mask:(rxid1Mask<<3)), ideb1Mask(ide1Mask), rtrb1Mask(frameType1Mask),
         rxidb0Mask(canMode?rxid0Mask:(rxid0Mask<<3)), ideb0Mask(ide0Mask), rtrb0Mask(frameType0Mask) {}

   /**
    * Constructor for filter table entry mask - Format C
    * Used when each entry in the FIFO filter table represents 4 frame filters
    * This is the most restricted format (can filter 8 bits of the ID only)
    *
    * @param rxid0Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid1Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid2Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid3Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    */
   constexpr CanFifoIdFilterMask(unsigned  rxid0Mask, unsigned  rxid1Mask, unsigned  rxid2Mask, unsigned  rxid3Mask) :
      rxidc3Mask(rxid3Mask), rxidc2Mask(rxid2Mask), rxidc1Mask(rxid1Mask), rxidc0Mask(rxid0Mask) {}

   constexpr CanFifoIdFilterMask(uint32_t value)     : raw(value) {}
   constexpr CanFifoIdFilterMask(const CanId &other) : raw(other.raw) {}
   constexpr CanFifoIdFilterMask() : raw(~0UL) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }
   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanFifoIdFilterMask other) volatile { raw = other.raw; }
   };

/**
 * FIFO ID Filter table entry - Formats A, B and C
 * These entries are used to filter received messages for acceptance into the Receive FIFO.
 * These entries contain the data to match against incoming frames. The CanFifoIdFilterMask
 * controls which bits are significant in the matching process.
 */
union CanFifoIdFilter {
   uint32_t raw;             //!< RAW 32-bit value
   struct {
      unsigned  filla  :  1;
      unsigned  rxida  : 29; //!< Receive Frame Identifier (standard 11-bit, or extended 29-bit)
      unsigned  idea   :  1; //!< Extended Frame
      unsigned  rtra   :  1; //!< Remote Frame
   };
   struct {
      unsigned  rxidb1 : 14; //!< Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb1  :  1; //!< Extended Frame
      unsigned  rtrb1  :  1; //!< Remote Frame

      unsigned  rxidb0 : 14; //!< Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb0  :  1; //!< Extended Frame
      unsigned  rtrb0  :  1; //!< Remote Frame
   };
   struct {
      unsigned  rxidc3 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc2 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc1 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc0 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
   };

   /**
    * Constructor for filter table entry - Format A
    * Used when each entry in the FIFO filter table represents 1 frame filter.
    * This is the most general format (can filter on IDE, RTR, and the full extended ID, )
    *
    * @param canMode    Select Standard or Extended mode
    * @param rxid       Receive Frame Identifier (standard 11-bit, or extended 29-bit)
    * @param frameType  Accepted frame type (Remote or Data frames)
    */
   constexpr CanFifoIdFilter(
         CanMode        canMode,
         unsigned       rxid,
         CanFrameType   frameType) :
      filla(0), rxida(canMode?rxid:(rxid<<18)), idea(canMode), rtra(frameType) {}

   /**
    * Constructor for filter table entry - Format B
    * Assumes both filters will accept the same mode of frame (standard or extended).
    * Used when each entry in the FIFO filter table represents 2 frame filters
    * This is a more restricted format (can filter on IDE, RTR, and 14 bits of the extended ID)
    *
    * @param canMode       Select Standard or Extended mode
    * @param rxid0         Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs retained)
    * @param frameType0    Accepted frame type (Remote or data frames)
    * @param rxid1         Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs retained)
    * @param frameType1    Accepted frame type (Remote or data frames)
    */
   constexpr CanFifoIdFilter(
         CanMode        canMode,
         unsigned       rxid0,
         CanFrameType   frameType0,
         unsigned       rxid1,
         CanFrameType   frameType1
         ) :
         rxidb1(canMode?(rxid1>>15):(rxid1<<3)), ideb1(canMode), rtrb1(frameType1),
         rxidb0(canMode?(rxid0>>15):(rxid0<<3)), ideb0(canMode), rtrb0(frameType0) {}

   /**
    * Constructor for filter table entry - Format C
    * Used when each entry in the FIFO filter table represents 4 frame filters
    * This is the most restricted format.
    * Frame type is ignored in filtering and only the top 8-bits of ID are checked.
    *
    * @param canMode  Select Standard or Extended mode
    * @param rxid0    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid1    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid2    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid3    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    */
   constexpr CanFifoIdFilter(
         CanMode   canMode,
         unsigned  rxid0, unsigned  rxid1, unsigned  rxid2, unsigned  rxid3) :
      rxidc3(canMode?(rxid3>>21):(rxid3>>3)),
      rxidc2(canMode?(rxid2>>21):(rxid2>>3)),
      rxidc1(canMode?(rxid1>>21):(rxid1>>3)),
      rxidc0(canMode?(rxid0>>21):(rxid0>>3))
   {}

   // Don't allow implicit declaration
   constexpr CanFifoIdFilter() = delete;

   /**
    * Constructor filter table entry - Format A
    *
    * @param raw
    */
   constexpr CanFifoIdFilter(uint32_t  raw) : raw(raw) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanFifoIdFilter(const CanFifoIdFilter &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(const CanFifoIdFilter &other) volatile { raw = other.raw; }
};

/**
 * Represents the error counts
 */
union CanErrorCounts {
   uint32_t raw;  //!< Raw value as 32-bit integer
   struct {
      uint8_t transmitErrorCount;      //!< Transmit Error Counter
      uint8_t receiveErrorCount;       //!< Receive Error Counter
      uint8_t transmitFastErrorCount;  //!< Transmit Error Counter for fast bits
      uint8_t receiveFastErrorCount;   //!< Receive Error Counter for fast bits
   };

   /**
    * Constructor from uint32_t
    *
    * @param value
    */
   constexpr CanErrorCounts(uint32_t value) : raw(value) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanErrorCounts(const CanErrorCounts &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanErrorCounts &other) volatile { raw = other.raw; }
};

/**
 * Represents CRC value for last transmitted buffer
 */
union CanCrc15 {
   uint32_t raw;  //!< Raw value as 32-bit integer
   struct {
      unsigned txcrc : 15; //!< 15-bit CRC value
      unsigned pad1  : 1;
      unsigned mbcrc : 7;  //!< Number of message buffer
   };

   /**
    * Constructor from uint32_t
    *
    * @param value
    */
   constexpr CanCrc15(uint32_t value) : raw(value) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanCrc15(const CanCrc15 &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { this->raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanCrc15 &other) volatile { this->raw = other.raw; }
};

/**
 * Indicates size of message buffer in terms of data size.
 * A single buffer size is used for a range of data sizes.
 */
enum CanMessageSize {
   CanMessageSize_8  = 8,   // <= 8  data bytes in message, buffer is 16 bytes
   CanMessageSize_16 = 16,  // <= 16 data bytes in message, buffer is 24 bytes
   CanMessageSize_32 = 32,  // <= 32 data bytes in message, buffer is 40 bytes
   CanMessageSize_64 = 64,  // <= 64 data bytes in message, buffer is 72 bytes
};

/**
 * CAN Acceptance mode (CAN_MCR_IDAM)
 */
enum CanAcceptanceMode {
   CanAcceptanceMode_FormatA   = 0,//!< CanAcceptanceMode_FormatA
   CanAcceptanceMode_FormatB   = 1,//!< CanAcceptanceMode_FormatB
   CanAcceptanceMode_FormatC   = 2,//!< CanAcceptanceMode_FormatC
   CanAcceptanceMode_RejectAll = 3,//!< CanAcceptanceMode_RejectAll
};

/**
 * CAN FIFO filter table size (CAN_CTRL2_RFFN)
 * The remaining MBs are available for non-FIFO use.
 */
enum CanFifoFilterSize {
   CanFifoFilterSize_8   = 0x0, // 8   entry Filter table
   CanFifoFilterSize_16  = 0x1, // 16  entry Filter table
   CanFifoFilterSize_24  = 0x2, // 24  entry Filter table
   CanFifoFilterSize_32  = 0x3, // 32  entry Filter table
   CanFifoFilterSize_40  = 0x4, // 40  entry Filter table
   CanFifoFilterSize_48  = 0x5, // 48  entry Filter table
   CanFifoFilterSize_56  = 0x6, // 56  entry Filter table
   CanFifoFilterSize_64  = 0x7, // 64  entry Filter table
   CanFifoFilterSize_72  = 0x8, // 72  entry Filter table
   CanFifoFilterSize_80  = 0x9, // 80  entry Filter table
   CanFifoFilterSize_88  = 0xA, // 88  entry Filter table
   CanFifoFilterSize_96  = 0xB, // 96  entry Filter table
   CanFifoFilterSize_104 = 0xC, // 104 entry Filter table
   CanFifoFilterSize_112 = 0xD, // 112 entry Filter table
   CanFifoFilterSize_120 = 0xE, // 120 entry Filter table
   CanFifoFilterSize_128 = 0xF, // 128 entry Filter table
};

/**
 * Receive FIFO flags
 *
 * for use with clearFifoFlags(), getFifoFlags(), enableFifoInterrupts(), disableFifoInterrupts()
 */
enum {
   CAN_FIFO_OVERFLOW_FLAG  = 1<<7,     //!< Overflow   - A message was lost
   CAN_FIFO_WARNING_FLAG   = 1<<6,     //!< Warning    - The FIFO is nearly full (set 4->5 messages)
   CAN_FIFO_DATA_FLAG      = 1<<5,     //!< Frame available - At least 1 frame available in FIFO
};

/**
 * @brief Class representing a Controller Area Network (CAN() interface.
 *
 * <b>Example</b>
 * @code
 * using can = Can_T<Can0Info>;
 *
 *  can::configure(12500);
 *
 * @endcode
 */
template<class Info>
class Can_T {
protected:

   /** Hardware instance pointer */
   static __attribute__((always_inline)) volatile CAN_Type &can() { return Info::can(); }

   static constexpr unsigned MAILBOX_HANDLER_INDEX = 0;
   static constexpr unsigned ERROR_HANDLER_INDEX   = 1;
   static constexpr unsigned ORED_HANDLER_INDEX    = 2;
   static constexpr unsigned WAKEUP_HANDLER_INDEX  = 3;
   static constexpr unsigned NUM_HANDLERS          = 4;

   /** sCallbacks functions for ISRs */
   static CanCallbackFunction sCallbacks[NUM_HANDLERS];

   /** sCallbacks to catch unhandled interrupt */
   static void noHandlerCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Number of Message Buffers used by FIFO (including filters) */
   static unsigned messageBuffersAllocatedToFifo;

   /** The number of mailboxes available (after allocation to FIFO) */
   static unsigned availableMailboxes;

public:
   /** CAN interrupt handler */
   static void irqHandler() {
      Can_T::sCallbacks[ORED_HANDLER_INDEX]();
   }

   /** CAN interrupt handler */
   static void errorIrqHandler() {
      Can_T::sCallbacks[ERROR_HANDLER_INDEX]();
   }

   /** CAN interrupt handler */
   static void wakeupIrqHandler() {
      Can_T::sCallbacks[WAKEUP_HANDLER_INDEX]();
   }

   /** CAN message buffer interrupt handler */
   static void messageBufferIrqHandler() {
      Can_T::sCallbacks[MAILBOX_HANDLER_INDEX]();
   }

protected:
   /**
    * Set callbacks for ISR
    *
    * @param callback The function to call from stub ISR
    * @param index    Index of callback to install
    */
   static void setCallback(CanCallbackFunction callback, int index) {
      usbdm_assert(Info::irqHandlerInstalled, "DMA not configured for interrupts");

      if (sCallbacks == nullptr) {
         sCallbacks[index] = noHandlerCallback;
      }
      sCallbacks[index] = callback;
   }

public:
   /**
    * Set Ored callback for ISR
    *
    *  Bus Off OR Bus Off Done OR Transmit Warning OR Receive Warning
    *  (ESR1.BOFFINT, CTRL1.BOFFMSK, ESR1.BOFFDONEINT, CTRL1.BOFFDONEMSK)
    *  Interrupt indicating Transmit Error Counter transition from < 96 to >= 96.
    *  (ESR1.TWRNINT, CTRL1.TWRNMSK)
    *  Interrupt indicating Receive Error Counter transition from < 96 to >= 96.
    *  (ESR1.RWRNINT, CTRL1.RWRNMSK)
    *
    * @param callback The function to call from stub ISR
    */
   static void setOredCallback(CanCallbackFunction callback) {
      setCallback(callback, ORED_HANDLER_INDEX);
   }

   /**
    * Set Error callback for ISR.
    *
    * Interrupt indicating that errors were detected on the CAN bus
    * (ESR1.ERRINT, CTRL1.ERRMSK = BIT1ERR, BIT0ERR, ACKERR, CRCERR, FRMERR or STFERR)
    * Interrupt indicating that errors were detected on the CAN bus for FD messages in the Fast
    * Bit Rate region. (S32K)
    * (ESR1.ERRINT_FAST, CTRL2.ERRMSK_FAST = BIT1ERR_FAST, BIT0ERR_FAST, CRCERR_FAST, FRMERR_FAST or STFERR_FAST)
    *
    * @param callback The function to call from stub ISR
    */
   static void setErrorCallback(CanCallbackFunction callback) {
      setCallback(callback, ERROR_HANDLER_INDEX);
   }

   /**
    * Set Wake-up callback for ISR
    *
    * S32K (pretend networking)
    * Interrupt asserted when Pretended Networking operation is enabled, and
    * a valid message matches the selected filter criteria during Low Power mode
    * (WU_MTC.WUMF, CTRL1_PN.WUMF_MSK)
    * Interrupt asserted when Pretended Networking operation is enabled, and
    * no-reception of a matching message for a defined quantity of time during low power mode
    * (WU.WTOF, CTRL1_PN.WTOF_MSK)
    *
    * Other devices
    * Interrupt asserted for Self Wake Up mechanism.
    * (ESR1.WAKINT, MCR.WAKMSK, MCR.SLFWAK enables)
    *
    * @param callback The function to call from stub ISR
    */
   static void setWakeupCallback(CanCallbackFunction callback) {
      setCallback(callback, WAKEUP_HANDLER_INDEX);
   }

   /**
    * Set Message buffer callback for ISR
    *
    * OR'ed Message buffer (Mailbox + FIFO) interrupts (IFLAG1, IMASK1)
    *
    * @param callback The function to call from stub ISR
    */
   static void setMessageBufferCallback(CanCallbackFunction callback) {
      setCallback(callback, MAILBOX_HANDLER_INDEX);
   }

   /**
    * Get pointer to CAN mailbox
    * Allowances are made for mailboxes lost to the Receive FIFO so the
    * index is relative to the first usable mailbox
    *
    * @param canMessageSize    Size of message buffers being used.
    * @param index             Index of message buffer
    *
    * @return Pointer to message buffer.
    */
   static volatile CanMessageBuffer *getMailbox(CanMessageSize canMessageSize, unsigned index) {
      usbdm_assert(index<availableMailboxes, "Invalid mailbox index");
      return (CanMessageBuffer *) (Info::baseAddress + offsetof(struct CAN_Type, MB) + messageBuffersAllocatedToFifo*sizeof(CanMessageBuffer8) + index*(canMessageSize+8));
   };

   /**
    * Get pointer to CAN mailbox assuming default size (8 data bytes)
    * Allowances are made for mailboxes lost to the Receive FIFO so the
    * index is relative to the first usable mailbox
    *
    * @param index   Index of message buffer
    *
    * @return Pointer to mailbox
    */
   static inline volatile CanMessageBuffer8 *getMailbox(unsigned index) {
      return (CanMessageBuffer8 *) getMailbox(CanMessageSize_8, index);
   };

   /**
    * Get pointer to CAN mailboxes assuming default size (8 data bytes)
    * Allowances are made for mailboxes lost to the Receive FIFO so array
    * starts at first available mailbox
    *
    * @return Pointer to mailbox
    */
   static inline volatile CanMessageBuffer8 *getMailboxArray() {
      return (CanMessageBuffer8 *) getMailbox(CanMessageSize_8, 0);
   };

   /**
    * Get pointer to CAN Top of FIFO Message Buffer.
    *
    * @return Pointer to message buffer.
    *
    * @note This is only applicable when FIFO is enabled.
    */
   static CanMessageBuffer8 *getFifoMessageBuffer() {
      return (CanMessageBuffer8 *) (can().MB);
   };

   /**
    * Get Filter Table array.
    * The result is formatted as an array of CanFifoFilters.
    * These filters are applied to the entry of Received messages into the FIFO.
    * The filter is modified by the FIFO filter masks see getFifoFilterMaskTable()
    *
    * @return Pointer to start of filter table array
    *
    * @note This is only applicable when FIFO is enabled.
    */
   static CanFifoIdFilter *getFifoFilterTable() {
      return (CanFifoIdFilter *) (can().FIFO.FILTER_ID_A);
   }

   /**
    * Get FIFO Mask Table array.
    * The result is formatted as an array of CanFilterMasks.
    * These masks are applied to filtering of Received messages into the FIFO.
    *
    * @return Pointer to start of filter mask table array
    */
   static CanFifoIdFilterMask *getFifoFilterMaskTable() {
      return (CanFifoIdFilterMask *) (can().RXIMR);
   }

   /**
    * Get Mailbox Mask Table array.
    * The result is formatted as an array of CanMailboxFilterMask.
    * These masks are applied to filtering of Received messages into the mailboxes.
    *
    * @return Pointer to start of filter mask table array
    */
   static CanMailboxFilterMask *getMailboxFilterMaskTable() {
      return (CanMailboxFilterMask *) (can().RXIMR + messageBuffersAllocatedToFifo);
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    *  Configure the CAN with default settings
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to peripheral
      Info::enableClock();
      __DMB();
   }

   /*
    * FIFO is 6 entries deep (re-uses MBs[0..5])
    * TOP is MB[0]
    * FIFO ID Filter table (re-uses MBs[6..])
    * RFFN determines size of Filter table
    *
    * FIFO mode options
    * MCR.RFEN    Enable FIFO
    * MCR.IDAM    ID Acceptance mode Format of Receive FIFO ID Filter Table elements
    * CTRL2.RFFN  Number Of Receive FIFO Filters
    * MCR.DMA     Enable DMA
    *
    * MCR.FDN  Flexible Data rate - excluded
    */
   /**
    * Configure for Receive FIFO use (with mailboxes)
    *
    * In this mode received packets can be stored in a receive FIFO.
    * The received messages are accepted/rejected for entry to the FIFO using an acceptance filter table (fifoIdFilters).
    * The filter table (fifoIdFilters) is of size fifoIdFilterCount.
    * The entries in the table may have one of 3 formats (canAcceptanceMode).  These formats are a trade-off between
    * the number of filters and their filtering capability - mainly the number of ID bits included in the filter matching.
    * The acceptance filters are masked by a FIFO filter mask table (fifoIdFilterMasks) and/or a default mask (fifoDefaultFilterMask).
    * Note that, due to memory arrangements, not all FIFO filters will have their own mask (fifoIdFilterMasks).
    * The remaining entries use a shared mask (fifoDefaultFilterMask).
    * AND
    * A series of mailboxes are also available for transmit or receive messages.
    * These have their own mailbox acceptance filter (mailboxFilterMasks).
    * The number of mailboxes is reduced as the number of the FIFO filters increases.
    *
    * @param[in] canParameters         CAN communication parameters
    * @param[in] canAcceptanceMode     Format for FIFO acceptance filters
    * @param[in] fifoIdFilterCount     Number of FIFO acceptance filters
    * @param[in] fifoIdFilters         FIFO Acceptance filters [fifoIdFilterCount]
    * @param[in] fifoIdFilterMasks     Masks applied to FIFO acceptance filters [calculateFifoIndividualMaskCount(fifoIdFilterCount)]
    * @param[in] fifoDefaultFilterMask Mask applied to FIFO acceptance filters not covered by fifoIdFilterMasks
    * @param[in] mailboxCount          Number of mailboxes
    * @param[in] mailboxFilterMasks    Individual acceptance filters applied to received messages for mailboxes [mailboxCount] OR
    * @param[in] mailboxFilterMasks    Shared acceptance filters applied to received messages for mailboxes [3] RXMGMASK, RX14MASK and RX15MASK
    */
   static void configure(
         const CanParameters           &canParameters,
         const CanAcceptanceMode       canAcceptanceMode,
         const unsigned                fifoIdFilterCount,
         const CanFifoIdFilter         fifoIdFilters[/* fifoIdFilterCount */],
         const CanFifoIdFilterMask     fifoIdFilterMasks[/* calculateFifoIndividualMaskCount(fifoIdFilterCount)*/],
         const CanFifoIdFilterMask     fifoDefaultFilterMask,
         const unsigned                mailboxCount,
         const CanMailboxFilterMask    mailboxFilterMasks[/* 3 or mailboxCount */]
         ) {
#ifdef CAN_MCR_FDEN_MASK
      usbdm_assert(!canParameters.fden,"FIFO cannot be used with Flexible Data Rate");
#endif

      configure(canParameters, canAcceptanceMode, fifoIdFilterCount, mailboxCount);

      // Set up individual FIFO ID filters
      auto filters = Can_T::getFifoFilterTable();
      for (unsigned index=0; index<fifoIdFilterCount; index++) {
         filters[index] = fifoIdFilters[index];
      }

      /*
       * Mask for Receive FIFO ID Filter Table elements not covered by an
       * individual masks or if individual masks are disabled (IRQM=0)
       */
      can().RXFGMASK = fifoDefaultFilterMask.raw;

      if (canParameters.irmq) {
         // Individual FIFO ID filter masks
         auto fifoMasks = Can_T::getFifoFilterMaskTable();
         unsigned fifoMaskCount = calculateFifoIndividualMaskCount(fifoIdFilterCount);
         for (unsigned index=0; index<fifoMaskCount; index++) {
            fifoMasks[index] = fifoIdFilterMasks[index];
         }
         // Individual Mailbox filter masks
         auto mbMasks = Can_T::getMailboxFilterMaskTable();
         for (unsigned index=0; index<mailboxCount; index++) {
            mbMasks[index] = mailboxFilterMasks[index];
         }
      }
      else {
         // Shared Mailbox filter masks
         can().RXMGMASK = mailboxFilterMasks[0].raw;
         can().RX14MASK = mailboxFilterMasks[1].raw;
         can().RX15MASK = mailboxFilterMasks[2].raw;
      }

      // Negate Freeze mode
      can().MCR &= ~CAN_MCR_HALT_MASK;
   }

   /**
    * Configure CAN with given settings
    *
    * @param[in] canParameters
    * @param[in] canAcceptanceMode     Format for FIFO acceptance filters
    * @param[in] fifoIdFilterCount     Number of FIFO acceptance filters
    * @param[in] mailboxCount          Number of mailboxes
    */
   static void configure(
         const CanParameters      &canParameters,
         const CanAcceptanceMode   canAcceptanceMode,
         const unsigned            fifoIdFilterCount,
         const unsigned            mailboxCount
         ) {
      enable();

      usbdm_assert(
            CanParameters::calulateRequiredMessageBuffers(fifoIdFilterCount, mailboxCount)<=Info::NumberOfMessageBuffers,
            "Too many FIFO filters and Mailboxes");

      for(unsigned index=0; index<(sizeof(sCallbacks)/sizeof(sCallbacks[0])); index++) {
         if (sCallbacks[index] == nullptr) {
            sCallbacks[index] = Can_T<Info>::noHandlerCallback;
         }
      }
      CanParameters modifiedCanParameters(canParameters);

      unsigned rffn = (fifoIdFilterCount/8) - 1;
      modifiedCanParameters.rfen  = true;
      modifiedCanParameters.idam  = canAcceptanceMode;
      modifiedCanParameters.rffn  = rffn;
      modifiedCanParameters.maxmb = CanParameters::calulateRequiredMessageBuffers(fifoIdFilterCount, mailboxCount)-1;

      // Lost to FIFO + Filters
      messageBuffersAllocatedToFifo = 2*rffn + 8;

      // Available mailboxes
      availableMailboxes = mailboxCount;

      // Make sure disabled so CLKSRC can be set
      can().MCR = CAN_MCR_MDIS(1);

      // Wait until in LP mode
      while (!(can().MCR & CAN_MCR_LPMACK_MASK)) {
         __asm__("nop");
      }

      can().CTRL1 = modifiedCanParameters.ctrl1 & CAN_CTRL1_CLKSRC_MASK;

      // Enable
      can().MCR = CAN_MCR_MDIS(0)|CAN_MCR_FRZ(1);

      // Wait until not in LP mode
      while (can().MCR & CAN_MCR_LPMACK_MASK) {
         __asm__("nop");
      }

      // Apply software reset and wait until complete
      can().MCR |= CAN_MCR_SOFTRST(1);
      while (can().MCR & CAN_MCR_SOFTRST_MASK) {
         __asm__("nop");
      }
      // Wait until in Freeze mode
      while ((can().MCR & CAN_MCR_FRZACK_MASK)==0) {
         __asm__("nop");
      }

      // Clear message buffers and disable message buffer masks
      // This will also clear the FIFO as it overlaps
      memset((void*)(can().MB),     0, Info::NumberOfMessageBuffers*sizeof(can().MB[0]));
      memset((void*)(can().RXIMR), -1, Info::NumberOfMessageBuffers*sizeof(can().RXIMR[0]));

      // Clear any pending flags
      can().IFLAG1 = ~0;

      can().CTRL1 = modifiedCanParameters.ctrl1;

      can().CTRL2 = modifiedCanParameters.ctrl2;

      // Configure CAN
      can().MCR = modifiedCanParameters.mcr|
            CAN_MCR_HALT(1) |            // Stay in Freeze
            CAN_MCR_FRZ(1);
   }
   
   /**
    *   Disable the CAN
    */
   static void finalise(uint8_t channel) {
      // Halt CAN
      can().MCR |= CAN_MCR_HALT_MASK;

      // Wait until ack'ed
      while (can().MCR & CAN_MCR_FRZACK_MASK) {
         __asm__("nop");
      }
      Info::disableClock();
   }
   
   /**
    * Calculates number of FIFO filter masks available based on number of FIFO filters.
    * Each FIFO filter is masked by either an individual mask or a shared mask.
    * This calculates the number of individual masks available to be applied to the FIFO filters.
    * The remaining FIFO filters are masked by the shared mask.
    *
    * @param fifoIdFilterCount Number of FIFO filters implemented
    *
    * @return Number of individual FIFO filter masks
    */
   static constexpr unsigned calculateFifoIndividualMaskCount(unsigned fifoIdFilterCount) {
      return CanParameters::calculateFifoIndividualMaskCount(fifoIdFilterCount);
   }

   /**
    * Calculates the number of mailboxes and mailbox filters available based on number
    * of FIFO filters and maximum mailboxes available.
    * The mailboxes share storage with the FIFO and FIFO filters.
    * The number of mailboxes decreases as the number of FIFO filters increases.
    *
    * @param fifoIdFilterCount     Number of FIFO filters implemented
    * @param maximumMailboxCount   Maximum number of mailboxes
    *
    * @return Number of CAN mailboxes available
    *
    * @note maximumMailboxCount is limited by the hardware and may be reduced by setting MCR.MAXMB.
    */
   static constexpr unsigned calculateMailboxCount(unsigned fifoIdFilterCount, unsigned maximumMailboxCount) {
      return maximumMailboxCount - calculateFifoIndividualMaskCount(fifoIdFilterCount);
   }

   /**
    * Calculates the maximum number of mailboxes and mailbox filters based on number of FIFO filters.
    * The CAN mailboxes share storage with the FIFO and FIFO filters.
    * The number of CAN mailboxes decreases as the number of FIFO filters increases.
    *
    * @param fifoIdFilterCount   Number of FIFO filters implemented
    *
    * @return Maximum number of CAN mailboxes available
    *
    * @note This is a maximum determined by the hardware.
    *       The actual number of mailboxes available may be reduced by setting MCR.MAXMB.
    */
   static constexpr unsigned calculateMaximumMailboxCount(unsigned fifoIdFilterCount) {
      return calculateMailboxCount(fifoIdFilterCount, Info::NumberOfMessageBuffers);
   }

   /**
    * Write value to 16-bit free running counter
    * The timer is clocked by CAN bit clock or an external clock and does not count
    * in Disable, Stop, Pretended Networking and Freeze modes.
    *
    * The timer starts from 0x0 after Reset, counts linearly to 0xFFFF, and wraps around.
    * The timer value is captured when the second bit of the identifier field of any frame is on
    * the CAN bus. This captured value is written into the Time Stamp entry in a message
    * buffer after a successful reception or transmission of a message.
    * If CTRL1[TSYN] is asserted, the Timer is reset whenever a message is received in the
    * first available Mailbox, according to CAN_CTRL2[RFFN] setting.
    * The CPU can write to this register any time. However, if the write occurs at the same time
    * that the Timer is being reset by a reception in the first Mailbox, then the write value is
    * discarded.
    *
    * @param value
    */
   static void writeTimer(uint16_t value) {
      can().TIMER = value;
   }

   /**
    * Read value from 16-bit free running counter
    *
    * @return Timer value
    */
   static uint16_t readTimer() {
      return can().TIMER;
   }

   /**
    * Set FIFO Message Buffer Mask\n
    * Used to mask the Receive FIFO ID Filter Table elements that do
    * not have a corresponding RXIMR according to CAN_CTRL2[RFFN]
    * field setting.
    *
    * @param mask
    */
   static void setFifoMessageBufferMask(uint16_t mask) {
      can().RXFGMASK = mask;
   }

   /**
    * Set Global Message Buffer Mask\n
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields of all Receive MBs, excluding MBs 14-15, which
    * have individual mask registers
    *
    * @param mask
    */
   static void setMailboxGlobalMask(uint16_t mask) {
      can().RXMGMASK = mask;
   }

   /**
    * Set Message Buffer 14 Message Buffer Mask
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields in Mailbox 14.
    *
    * @param mask
    */
   static void setMailbox14Mask(uint16_t mask) {
      can().RX14MASK = mask;
   }

   /**
    * Set Message Buffer 15 Message Buffer Mask
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields in Mailbox 15.
    *
    * @param mask
    */
   static void setMailbox15Mask(uint16_t mask) {
      can().RX15MASK = mask;
   }

   /**
    * Get error counts
    *
    * @return Error counts
    */
   static CanErrorCounts getErrorCounters() {
      return (CanErrorCounts)can().ECR;
   }

   /**
    * Get Error Status
    *
    * @return Mask representing various errors.
    */
   static uint32_t getErrorStatus() {
      return can().ESR1;
   }

   /**
    * Clear Error Status
    *
    * @param flags Mask representing various errors to clear
    */
   static uint32_t clearErrorStatus(uint32_t flags) {
      return can().ESR1 = flags;
   }

   /**
    * Enable interrupts from selected mail boxes
    *
    * @param[in] mask 1's in the mask enable interrupts from the corresponding message buffer.
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void enableMailboxInterrupts(uint32_t mask) {
      can().IMASK1 |= (mask<<messageBuffersAllocatedToFifo);
   }

   /**
    * Disable interrupts from selected mail boxes
    *
    * @param[in] mask 1's in the mask disable interrupts from the corresponding message buffer.
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void disableMailboxInterrupts(uint32_t mask) {
      can().IMASK1 &= ~(mask<<messageBuffersAllocatedToFifo);
   }

   /**
    * Get message buffer flags.
    * Each bit represents the flags from a mail boxes
    *
    * @return Bitmask representing the flags from mail boxes
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static uint32_t getMailboxFlags() {
      return (can().IFLAG1>>messageBuffersAllocatedToFifo);
   }

   /**
    * Clear mail box flags.
    * Each bit represents a mail boxes flag to clear
    *
    * @param[in] mask 1's in the mask clear the flag from the corresponding message buffer.
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void clearMailboxFlags(uint32_t mask) {
      can().IFLAG1 = mask<<messageBuffersAllocatedToFifo;
   }

   /**
    * Enable interrupts from FIFO
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask clear the flag from the corresponding message buffer.
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void enableFifoInterrupts(uint32_t mask) {
      can().IMASK1 |= mask & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Disable interrupts from FIFO
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask clear the flag from the corresponding message buffer.
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void disableFifoBufferInterrupts(uint32_t mask) {
      can().IMASK1 &= ~(mask & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK));
   }

   /**
    * Get FIFO flags.
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @return bit mask\n
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static uint32_t getFifoFlags() {
      return can().IFLAG1 & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Clear FIFO flags.
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask clear the flag from the corresponding message buffer.
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void clearFifoFlags(uint32_t mask) {
      can().IFLAG1 = mask&(CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Get FIFO information.\n
    *
    * This indicates which Identifier Acceptance Filter was hit by the received message that is in the output
    * of the Receive FIFO. If multiple filters match the incoming message ID then the first matching IDAF found
    * (lowest number) by the matching process is indicated. This field is valid only while the CAN_IFLAG1[BUF5I]
    * is asserted.
    *
    * @return The index of the matching acceptance filter
    */
   static uint32_t getFifoAcceptanceFilterHit() {
      return can().RXFIR & CAN_RXFIR_IDHIT_MASK;
   }

#ifdef CAN_CBT_EPSEG1
   /**
    * Set extended timing
    *
    * @param phaseSegment1           Phase Buffer Segment 1 = phaseSegment1 x S-clock.
    * @param phaseSegment2           Phase Buffer Segment 2 = phaseSegment2 x S-clock.
    * @param propagationSegment      Propagation Segment Time = propagationSegment x S-clock.
    * @param resyncJumpWidth         Resynchronisation Jump Width = resyncJumpWidth x S-clock.
    * @param prescalerDivisionFactor S-clock frequency = PE clock frequency / prescalerDivisionFactor
    */
   static void setExtendedTiming(
      unsigned phaseSegment1,
      unsigned phaseSegment2,
      unsigned propagationSegment,
      unsigned resyncJumpWidth,
      unsigned prescalerDivisionFactor
   ) {
      can().CBT =
            CAN_CBT_EPSEG1(phaseSegment1-1) |
            CAN_CBT_EPSEG2(phaseSegment2-1) |
            CAN_CBT_EPROPSEG(propagationSegment-1) |
            CAN_CBT_ERJW(resyncJumpWidth-1) |
            CAN_CBT_EPRESDIV(prescalerDivisionFactor-1);
   }
#endif

   /**
    * Get CRC value for last transmitted buffer
    *
    * @return CRC value and buffer number
    */
   static CanCrc15 getTransmittedCrc() {
      return (CanCrc15)(can().CRCR);
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableWakeupNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[Info::WakeupIrqNumIndex]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableWakeupNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[Info::WakeupIrqNumIndex], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableWakeupNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[Info::WakeupIrqNumIndex]);
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableErrorNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[Info::ErrorIrqNumIndex]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableErrorNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[Info::ErrorIrqNumIndex], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableErrorNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[Info::ErrorIrqNumIndex]);
   }

$(/CAN/NvicControl)
};

/**
 * Callback table for programmatically set handlers
 */
template<class Info> CanCallbackFunction Can_T<Info>::sCallbacks[]      = {0};
/**
 * Number of Message Buffers used by FIFO (including filters)
 */
template<class Info> unsigned Can_T<Info>::messageBuffersAllocatedToFifo = 0;
/**
 * The number of mailboxes available (after allocation to FIFO)
 */
template<class Info> unsigned Can_T<Info>::availableMailboxes        = 0;

typedef void (*CanMailboxCallbackFunction)(unsigned);

template<class Info, int mailboxCount>
class CanHandler_T : public Can_T<Info> {

   static CanMailboxCallbackFunction mailboxCallBacks[mailboxCount];
   static uint32_t allocatedMailboxes;

public:

   class CanMailBox {
      unsigned mailboxNumber;

   public:
      /**
       * Constructor
       *
       * @param number
       */
      constexpr CanMailBox(unsigned number) : mailboxNumber(number) {
         usbdm_assert(number<mailboxCount,"");
      }

      /**
       * Constructor
       *
       * @param number
       */
      constexpr CanMailBox(unsigned number, bool) : mailboxNumber(number) {
      }

      /**
       * Destructor
       */
      ~CanMailBox() {
         dispose();
      }

      /**
       * Set callbacks for ISR
       *
       * @param callback The function to call from stub ISR
       * @param index    Index of callback to install
       */
      void setCallback(CanMailboxCallbackFunction callback) {
         usbdm_assert(Info::irqHandlerInstalled, "DMA not configured for interrupts");
         if (mailboxCallBacks == nullptr) {
            mailboxCallBacks[mailboxNumber] = (CanMailboxCallbackFunction)Can_T<Info>::noHandlerCallback;
         }
         mailboxCallBacks[mailboxNumber] = callback;
      }

      /**
       * Get pointer to CAN mailbox assuming default size (8 data bytes)
       * Allowances are made for mailboxes lost to the Receive FIFO so the
       * index is relative to the first usable mailbox
       *
       * @return Pointer to mailbox
       */
      volatile CanMessageBuffer8 *getMailbox() {
         return (CanMessageBuffer8 *) Can_T<Info>::getMailbox(mailboxNumber);
      };

      /**
       * Check if mailbox is valid (allocated successfully)
       *
       * @return
       */
      bool isValid() {
         return mailboxNumber < mailboxCount;
      }

      /**
       * Obtain mailbox number
       *
       * @return Mailbox Number
       */
      unsigned getMailboxNumber() {
         return mailboxNumber;
      }

      void dispose() {
         freeMailbox(*this);
         setCallback(nullptr);
         mailboxNumber = mailboxCount;
      }
   };

   static CanMailBox MailboxNone;

   static void configure(
         const CanParameters           &canParameters,
         const CanAcceptanceMode       canAcceptanceMode,
         const unsigned                fifoIdFilterCount,
         const CanFifoIdFilter         fifoIdFilters[/* fifoIdFilterCount */],
         const CanFifoIdFilterMask     fifoIdFilterMasks[/* calculateFifoIndividualMaskCount(fifoIdFilterCount)*/],
         const CanFifoIdFilterMask     fifoDefaultFilterMask,
         const CanMailboxFilterMask    mailboxFilterMasks[/* 3 or mailboxCount */]
         ) {
      Can_T<Info>::configure(
            canParameters,
            canAcceptanceMode,
            fifoIdFilterCount,
            fifoIdFilters,
            fifoIdFilterMasks,
            fifoDefaultFilterMask,
            mailboxCount,
            mailboxFilterMasks);
      for(unsigned index=0; index<mailboxCount; index++) {
         if (mailboxCallBacks[index] == nullptr) {
            mailboxCallBacks[index] = (CanMailboxCallbackFunction)Can_T<Info>::noHandlerCallback;
         }
      }
   }

   /**
    * Allocate DMA channel.
    *
    * @return DmaChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static CanMailBox allocateMailbox() {
      unsigned mailboxNum = __builtin_ffs(allocatedMailboxes);
      if ((mailboxNum == 0)||(--mailboxNum>=mailboxCount)) {
         setErrorCode(E_NO_RESOURCE);
         return MailboxNone;
      }
      allocatedMailboxes &= ~(1<<mailboxNum);
      return CanMailBox(mailboxNum);
   }

   /**
    * Free DMA channel.
    *
    * @param dmaChannelNum Channel to release
    */
   static void freeMailbox(CanMailBox mailbox) {
      const uint32_t mailboxMask = (1<<mailbox.getMailboxNumber());
      usbdm_assert(mailbox.getMailboxNumber()<mailboxCount,        "Illegal mailbox number");
      usbdm_assert((allocatedMailboxes & mailboxMask) == 0, "Freeing unallocated mailbox");
      volatile CanMessageBuffer8 *mb = mailbox.getMailbox();
      mb->CS = CanControlStatus(CanMessageCode_RxInactive);
      allocatedMailboxes |= mailboxMask;
   }

   /** CAN message buffer interrupt handler */
   static void messageBufferIrqHandler() {
      uint32_t flags = Can_T<Info>::getMailboxFlags();
      int channelNum = __builtin_ffs(flags);

      if (channelNum==0) {
         Can_T<Info>::sCallbacks[Can_T<Info>::MAILBOX_HANDLER_INDEX]();
      }
      else {
         channelNum--;
         mailboxCallBacks[channelNum](channelNum);
      }
   }
};

template<class Info, int numMailboxes>
CanMailboxCallbackFunction CanHandler_T<Info, numMailboxes>::mailboxCallBacks[numMailboxes] = {0};
template<class Info, int numMailboxes>
uint32_t CanHandler_T<Info, numMailboxes>::allocatedMailboxes = ~0;
template<class Info, int numMailboxes>
typename CanHandler_T<Info, numMailboxes>::CanMailBox CanHandler_T<Info, numMailboxes>::MailboxNone{numMailboxes, false};

#if defined(USBDM_CAN0_IS_DEFINED)
using Can0 = CanHandler_T<Can0Info, 12>;
#endif

#if defined(USBDM_CAN1_IS_DEFINED)
using Can1 = CanHandler_T<Can1Info, 12>;
#endif

#if defined(USBDM_CAN2_IS_DEFINED)
using Can2 = CanHandler_T<Can2Info, 12>;
#endif
/**
 * @}
 */
} // End namespace USBDM

#endif /* PROJECT_HEADERS_CAN_H_ */

/**
 * @file     can.h (180.ARM_Peripherals/Project_Headers/can.h)
 *
 * @brief    Abstraction layer for CAN interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef PROJECT_HEADERS_CAN_H_
#define PROJECT_HEADERS_CAN_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "hardware.h"
#include "string.h"
#include <limits.h>

namespace USBDM {

/**
 * Select Standard or Extended CAN mode
 * Standard - 11-bit ID field
 * Extended - 29-bit ID field
 */
enum CanMode {
   CanMode_Standard = false,  //!< CanMode_Standard
   CanMode_Extended = true,   //!< CanMode_Extended
};

/**
 * Selects Remote or Data frame
 */
enum CanFrameType {
   CanFrameType_Data   = false, //!< Data Frame
   CanFrameType_Remote = true,  //!< Remote Frame
};

/**
 * @addtogroup CAN_Group CAN, Controller Area Network
 * @brief Abstraction for Controller Area Network
 * @{
 */
/**
 * Type definition for CAN interrupt call back
 */
typedef void (*CanCallbackFunction)(void);

enum CanMessageCode {
   CanMessageCode_RxInactive = 0b0000U, //!< MB does not participate
   CanMessageCode_RxEmpty    = 0b0100U, //!< May be filled on reception
   CanMessageCode_RxFull     = 0b0010U, //!< Buffer holds received data
   CanMessageCode_RxOverrun  = 0b0110U, //!< Reception Overrun, Buffer holds received data
   CanMessageCode_RxAnswer   = 0b1010U, //!< Buffer used for remote answer reception

   CanMessageCode_RxBusy     = 0b0001U, //!< This bit indicate the buffer is busy (changing)

   CanMessageCode_TxInactive = 0b1000U, //!< MB does not participate
   CanMessageCode_TxAbort    = 0b1001U, //!< Aborted, MB does not participate
   CanMessageCode_TxData     = 0b1100U, //!< (RTR=0) Transmit Data
   CanMessageCode_TxRemote   = 0b1100U, //!< (RTR=1) Transmit Remote request
   CanMessageCode_TxAnswer   = 0b1110U, //!< Buffer automatically used for remote answer response
};

/**
 * Size of data in message
 */
enum CanDataSize {
   CanDataSize_0  =  0U,  // No Data bytes in message
   CanDataSize_1  =  1U,  // 1 bytes in message
   CanDataSize_2  =  2U,  // 2 bytes in message
   CanDataSize_3  =  3U,  // 3 bytes in message
   CanDataSize_4  =  4U,  // 4 bytes in message
   CanDataSize_5  =  5U,  // 5 bytes in message
   CanDataSize_6  =  6U,  // 6 bytes in message
   CanDataSize_7  =  7U,  // 7 bytes in message
   CanDataSize_8  =  8U,  // 8 bytes in message
   CanDataSize_12 =  9U,  // 12 bytes in message
   CanDataSize_16 = 10U,  // 16 bytes in message
   CanDataSize_20 = 11U,  // 20 bytes in message
   CanDataSize_24 = 12U,  // 24 bytes in message
   CanDataSize_32 = 13U,  // 32 bytes in message
   CanDataSize_48 = 14U,  // 48 bytes in message
   CanDataSize_64 = 15U,  // 64 bytes in message
};

static constexpr unsigned CanDataSizeToUnsigned(CanDataSize canDataSize) {
   constexpr unsigned sizes[] = {0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64};
   return sizes[canDataSize];
}

/**
 * Can CS value in message
 */
union CanControlStatus {
   uint32_t  raw;
   struct {
      unsigned       timeStamp : 16;    //!< Time stamp
      CanDataSize    dlc       :  4;    //!< Length of Data
      CanFrameType   rtr       :  1;    //!< Remote Transmission Request
      unsigned       ide       :  1;    //!< ID Extended Bit
      unsigned       srr       :  1;    //!< Substitute Remote Request
      unsigned                 :  1;
      CanMessageCode code      :  4;    //!< Message Buffer Code
      unsigned                 :  1;
      unsigned       esi       :  1;    //!< Error State Indicator
      unsigned       brs       :  1;    //!< Bit Rate Switch
      unsigned       edl       :  1;    //!< Extended Data Length
   };
   struct {
      unsigned       : 23;
      unsigned idhit :  9; //!< Identifier Acceptance Filter Hit Indicator
   };
   void operator=(uint32_t value) volatile { raw = value; }
   void operator=(uint32_t value) { raw = value; }
   void operator=(volatile CanControlStatus &other) volatile { raw = other.raw; }
   void operator=(const CanControlStatus &other) volatile { raw = other.raw; }
   void operator=(CanControlStatus &other) volatile { raw = other.raw; }
   constexpr CanControlStatus(uint32_t value) : raw(value) {}
   constexpr CanControlStatus(CanControlStatus &other) : raw(other.raw) {}
   constexpr CanControlStatus(const CanControlStatus &other) : raw(other.raw) {}
   constexpr CanControlStatus(volatile CanControlStatus &other) : raw(((CanControlStatus &)other).raw) {}
   constexpr CanControlStatus() : raw(0) {}
   /**
    * Constructor for CanControlStatus for use in Receive message buffers
    *
    * @param canMessageCode   Message type, usually CanMessageCode_RxEmpty, CanMessageCode_RxAnswer
    * @param canFrameType     Accept remote requests, false => may be used as part of matching
    */
   constexpr CanControlStatus(
         const CanMessageCode canMessageCode,
         const CanFrameType   canFrameType=CanFrameType_Data ) :
               raw(CAN_CS_CODE(canMessageCode)|CAN_CS_RTR(canFrameType)) {}
   /**
    * Constructor for CanControlStatus for use in Transmit message buffers
    *
    * @param canMessageCode   Message type, usually CanMessageCode_TxData, CanMessageCode_TxRemote
    * @param canMode          CAN Mode (affects ID size etc)
    * @param canDataSize      Size of data to transmit
    * @param canFrameType     DATA or REMOTE frames Tx REMOTE(MB switches to Rx EMPTY on success)
    */
   constexpr CanControlStatus(
         const CanMessageCode canMessageCode,
         const CanMode        canMode,
         const CanDataSize    canDataSize,
         const CanFrameType   canFrameType=CanFrameType_Data) :
               raw(CAN_CS_CODE(canMessageCode)|CAN_CS_IDE(canMode)|CAN_CS_DLC(canDataSize)|CAN_CS_RTR(canFrameType)|CAN_CS_SRR(1)) {}
} __attribute__((__packed__)) ;

/**
 * Can CS value in message
 */
union CanId {
   uint32_t  raw;
   struct {
      unsigned idExt : 29;  //!< Extended Frame Identifier
      unsigned prio  :  3;  //!< Local priority
   };
   struct {
      unsigned       : 18;
      unsigned idStd : 11;  //!< Standard Frame Identifier
      unsigned       :  3;
   };
   void operator=(uint32_t value) volatile { raw = value; }

   void operator=(volatile CanId &other)       { raw = other.raw; }
   void operator=(const CanId &other) volatile { raw = other.raw; }

   constexpr CanId(uint32_t value) : raw(value) {}
   constexpr CanId(const CanId &other) : raw(other.raw) {}
   constexpr CanId() : raw(0) {}

   /**
    * Constructor for CanId for use in Transmit or Receive message buffers
    *
    * @param canMode          CAN Mode (affects ID size etc)
    * @param id               ID (standard or extended)
    * @param priority         Priority - only for transmission if MCR.LPRIO_EN=true
    */
   constexpr CanId(
         const CanMode  canMode,
         const unsigned id,
         const unsigned priority=0) :
               raw((canMode?CAN_ID_EXT(id):CAN_ID_STD(id))|CAN_ID_PRIO(priority)) {}

}  __attribute__((__packed__));

/**
 * Represents a CAN Message in CAN RAM area.
 * This is never constructed.
 */
struct CanMessageBuffer {
   CanControlStatus CS;        //!< CS Register
   CanId            ID;        //!< ID Register
   uint32_t         DATA32[];  //!< DATA portion of buffer - variable size

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex8(const unsigned index) {
      return (index^0x3U);
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint8_t &data8(const unsigned index) volatile {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint8_t &data8(const int index) const {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint8_t &data8(const unsigned index) {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex16(const unsigned index) {
      return (index&~0x1U) + (1-(index&0x1U));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint16_t &data16(const unsigned index) volatile {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint16_t &data16(const unsigned index) const {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint16_t &data16(const unsigned index) {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }
} __attribute__((__packed__));

/**
 * Represents a standard 8-byte CAN Message in RAM
 */
struct CanMessageBuffer8 {
   CanControlStatus CS;         //!< CS Register
   CanId            ID;         //!< ID Register
   uint32_t         DATA32[2];  //!< DATA portion of buffer - standard size

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex8(const unsigned index) {
      return (index^0x3U);
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint8_t &data8(const unsigned index) volatile {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint8_t &data8(const unsigned index) const {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Index data array as uint8_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint8_t &data8(const unsigned index) {
      return *(((uint8_t *)DATA32) + mapIndex8(index));
   }

   /**
    * Map index from uint8_t to little-endian uint_32_t
    *
    * @param index Index to map
    *
    * @return Mapped index
    */
   static constexpr unsigned mapIndex16(const unsigned index) {
      return (index&~0x1U) + (1-(index&0x1U));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   volatile uint16_t &data16(const unsigned index) volatile {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   const uint16_t &data16(const unsigned index) const {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }

   /**
    * Index data array as uint16_t
    *
    * @param index
    *
    * @return Reference to indexed byte
    */
   uint16_t &data16(const unsigned index) {
      return *(((uint16_t *)DATA32) + mapIndex16(index));
   }
} __attribute__((__packed__));

/**
 * Filter mask for CAN Mailboxes
 * The mask is applied to the comparison to the MB[ID], MB[RTR] and MB[ID]
 */
union CanMailboxFilterMask {
   uint32_t     raw;             //!< RAW 32-bit value
   struct {
      unsigned  idMask     : 29; //!< Mask for MB[ID] field
      unsigned  fill       :  1;
      unsigned  ideMask    :  1; //!< Mask for MB[IDE] field
      unsigned  rtrMask    :  1; //!< Mask for MB[RTR] field
   };

   /**
    * Constructor for Mail box filter
    *
    * @param canMode          Select Standard or Extended mode
    * @param idMask           Mask for MB[ID] (standard 11-bit, or extended 29-bit)
    * @param ideMask          Enables filtering on MB[IDE] field
    * @param frameTypeMask    Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanMailboxFilterMask(
         CanMode  canMode,
         unsigned idMask,
         bool     ideMask=true,
         bool     frameTypeMask=true) :
               idMask(canMode?idMask:(idMask<<18)), fill(1), ideMask(ideMask), rtrMask(frameTypeMask) {}

   constexpr CanMailboxFilterMask(uint32_t value) : raw(value) {}
   constexpr CanMailboxFilterMask(const CanId &other) : raw(other.raw) {}
   constexpr CanMailboxFilterMask() : raw(~0U) {}

   void operator=(uint32_t value) volatile { raw = value; }
};


/**
 * Filter mask for CAN receive FIFO filters - Formats A, B and C
 * These masks are applied to Frame matching comparisons using the FIFO Filter table.
 */
union CanFifoIdFilterMask {
   uint32_t     raw;             //!< RAW 32-bit value
   struct {
      unsigned  filla      :  1;
      unsigned  rxidaMask  : 29; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit)
      unsigned  ideaMask   :  1; //!< Mask for Extended Frame
      unsigned  rtraMask   :  1; //!< Mask for Remote Frame
   };
   struct {
      unsigned  rxidb1Mask : 14; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb1Mask  :  1; //!< Mask for Extended Frame
      unsigned  rtrb1Mask  :  1; //!< Mask for Remote Frame

      unsigned  rxidb0Mask : 14; //!< Mask for Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb0Mask  :  1; //!< Mask for Extended Frame
      unsigned  rtrb0Mask  :  1; //!< Mask for Remote Frame
   };
   struct {
      unsigned  rxidc3Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc2Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc1Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc0Mask :  8; //!< Mask for Receive Frame Identifier (standard or extended only 8 MSBs)
   };

   /**
    * Constructor for filter table entry mask - Format A
    * Used when each entry in the FIFO filter table represents 1 frame filter.
    * This is the most general format (can filter on IDE, RTR, and the full extended ID, )
    *
    * @param canMode          Select Standard or Extended mode
    * @param rxidMask         Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit)
    * @param ideMask          Mask for Extended Frame
    * @param frameTypeMask    Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanFifoIdFilterMask(
         CanMode   canMode,
         unsigned  rxidMask,
         bool      ideMask,
         bool      frameTypeMask) :
                  filla(1),
                  rxidaMask(canMode?rxidMask:(rxidMask<<18)),
                  ideaMask(ideMask),
                  rtraMask(frameTypeMask) {}

   /**
    * Constructor for filter table entry mask - Format B
    * Used when each entry in the FIFO filter table represents 2 frame filters
    * This is a more restricted format (can filter on IDE, RTR, and 14 bits of the extended ID)
    *
    * @param canMode          Mask for Select Standard or Extended mode
    * @param rxid0Mask        Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 14 MSBs retained)
    * @param ide0Mask         Mask for Extended Frame
    * @param frameType0Mask   Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    * @param rxid1Mask        Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 14 MSBs retained)
    * @param ide1Mask         Mask for Extended Frame
    * @param frameType1Mask   Enables filtering on Frame Type (Data or Remote) (MB[RTR] field)
    */
   constexpr CanFifoIdFilterMask(
         CanMode   canMode,
         unsigned  rxid0Mask,
         unsigned  ide0Mask,
         unsigned  frameType0Mask,
         unsigned  rxid1Mask,
         unsigned  ide1Mask,
         unsigned  frameType1Mask
   ) :
               rxidb1Mask(canMode?rxid1Mask:(rxid1Mask<<3)), ideb1Mask(ide1Mask), rtrb1Mask(frameType1Mask),
               rxidb0Mask(canMode?rxid0Mask:(rxid0Mask<<3)), ideb0Mask(ide0Mask), rtrb0Mask(frameType0Mask) {}

   /**
    * Constructor for filter table entry mask - Format C
    * Used when each entry in the FIFO filter table represents 4 frame filters
    * This is the most restricted format (can filter 8 bits of the ID only)
    *
    * @param rxid0Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid1Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid2Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    * @param rxid3Mask    Mask for Receive Frame Identifier (standard 11-bit, or extended 29-bit - only 8 MSBs retained)
    */
   constexpr CanFifoIdFilterMask(unsigned  rxid0Mask, unsigned  rxid1Mask, unsigned  rxid2Mask, unsigned  rxid3Mask) :
            rxidc3Mask(rxid3Mask), rxidc2Mask(rxid2Mask), rxidc1Mask(rxid1Mask), rxidc0Mask(rxid0Mask) {}

   constexpr CanFifoIdFilterMask(uint32_t value)     : raw(value) {}
   constexpr CanFifoIdFilterMask(const CanId &other) : raw(other.raw) {}
   constexpr CanFifoIdFilterMask() : raw(~0UL) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }
   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanFifoIdFilterMask other) volatile { raw = other.raw; }
};

/**
 * FIFO ID Filter table entry - Formats A, B and C
 * These entries are used to filter received messages for acceptance into the Receive FIFO.
 * These entries contain the data to match against incoming frames. The CanFifoIdFilterMask
 * controls which bits are significant in the matching process.
 */
union CanFifoIdFilter {
   uint32_t raw;             //!< RAW 32-bit value
   struct {
      unsigned  filla  :  1;
      unsigned  rxida  : 29; //!< Receive Frame Identifier (standard 11-bit, or extended 29-bit)
      unsigned  idea   :  1; //!< Extended Frame
      unsigned  rtra   :  1; //!< Remote Frame
   };
   struct {
      unsigned  rxidb1 : 14; //!< Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb1  :  1; //!< Extended Frame
      unsigned  rtrb1  :  1; //!< Remote Frame

      unsigned  rxidb0 : 14; //!< Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs)
      unsigned  ideb0  :  1; //!< Extended Frame
      unsigned  rtrb0  :  1; //!< Remote Frame
   };
   struct {
      unsigned  rxidc3 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc2 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc1 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
      unsigned  rxidc0 :  8; //!< Receive Frame Identifier (standard or extended only 8 MSBs)
   };

   /**
    * Constructor for filter table entry - Format A
    * Used when each entry in the FIFO filter table represents 1 frame filter.
    * This is the most general format (can filter on IDE, RTR, and the full extended ID, )
    *
    * @param canMode    Select Standard or Extended mode
    * @param rxid       Receive Frame Identifier (standard 11-bit, or extended 29-bit)
    * @param frameType  Accepted frame type (Remote or Data frames)
    */
   constexpr CanFifoIdFilter(
         CanMode        canMode,
         unsigned       rxid,
         CanFrameType   frameType) :
            filla(0), rxida(canMode?rxid:(rxid<<18)), idea(canMode), rtra(frameType) {}

   /**
    * Constructor for filter table entry - Format B
    * Assumes both filters will accept the same mode of frame (standard or extended).
    * Used when each entry in the FIFO filter table represents 2 frame filters
    * This is a more restricted format (can filter on IDE, RTR, and 14 bits of the extended ID)
    *
    * @param canMode       Select Standard or Extended mode
    * @param rxid0         Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs retained)
    * @param frameType0    Accepted frame type (Remote or data frames)
    * @param rxid1         Receive Frame Identifier (standard 11-bit, or extended only 14 MSBs retained)
    * @param frameType1    Accepted frame type (Remote or data frames)
    */
   constexpr CanFifoIdFilter(
         CanMode        canMode,
         unsigned       rxid0,
         CanFrameType   frameType0,
         unsigned       rxid1,
         CanFrameType   frameType1
   ) :
               rxidb1(canMode?(rxid1>>15):(rxid1<<3)), ideb1(canMode), rtrb1(frameType1),
               rxidb0(canMode?(rxid0>>15):(rxid0<<3)), ideb0(canMode), rtrb0(frameType0) {}

   /**
    * Constructor for filter table entry - Format C
    * Used when each entry in the FIFO filter table represents 4 frame filters
    * This is the most restricted format.
    * Frame type is ignored in filtering and only the top 8-bits of ID are checked.
    *
    * @param canMode  Select Standard or Extended mode
    * @param rxid0    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid1    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid2    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    * @param rxid3    Receive Frame Identifier (standard or extended, only 8 MSBs retained)
    */
   constexpr CanFifoIdFilter(
         CanMode   canMode,
         unsigned  rxid0, unsigned  rxid1, unsigned  rxid2, unsigned  rxid3) :
            rxidc3(canMode?(rxid3>>21):(rxid3>>3)),
            rxidc2(canMode?(rxid2>>21):(rxid2>>3)),
            rxidc1(canMode?(rxid1>>21):(rxid1>>3)),
            rxidc0(canMode?(rxid0>>21):(rxid0>>3))
   {}

   // Don't allow implicit declaration
   constexpr CanFifoIdFilter() = delete;

   /**
    * Constructor filter table entry - Format A
    *
    * @param raw
    */
   constexpr CanFifoIdFilter(uint32_t  raw) : raw(raw) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanFifoIdFilter(const CanFifoIdFilter &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(const CanFifoIdFilter &other) volatile { raw = other.raw; }
};

/**
 * Represents the error counts
 */
union CanErrorCounts {
   uint32_t raw;  //!< Raw value as 32-bit integer
   struct {
      uint8_t transmitErrorCount;      //!< Transmit Error Counter
      uint8_t receiveErrorCount;       //!< Receive Error Counter
      uint8_t transmitFastErrorCount;  //!< Transmit Error Counter for fast bits
      uint8_t receiveFastErrorCount;   //!< Receive Error Counter for fast bits
   };

   /**
    * Constructor from uint32_t
    *
    * @param value
    */
   constexpr CanErrorCounts(uint32_t value) : raw(value) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanErrorCounts(const CanErrorCounts &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanErrorCounts &other) volatile { raw = other.raw; }
};

/**
 * Represents CRC value for last transmitted buffer
 */
union CanCrc15 {
   uint32_t raw;  //!< Raw value as 32-bit integer
   struct {
      unsigned txcrc : 15; //!< 15-bit CRC value
      unsigned pad1  : 1;
      unsigned mbcrc : 7;  //!< Number of message buffer
   };

   /**
    * Constructor from uint32_t
    *
    * @param value
    */
   constexpr CanCrc15(uint32_t value) : raw(value) {}

   /**
    * Copy constructor
    *
    * @param other
    */
   constexpr CanCrc15(const CanCrc15 &other) : raw(other.raw) {}

   /**
    * Assignment operator from uint32_t
    *
    * @param value 32-bit value to assign
    */
   void operator=(uint32_t value) volatile { this->raw = value; }

   /**
    * Assignment operator
    *
    * @param other
    */
   void operator=(CanCrc15 &other) volatile { this->raw = other.raw; }
};

/**
 * Indicates size of message buffer in terms of data size.
 * A single buffer size is used for a range of data sizes.
 */
enum CanMessageSize {
   CanMessageSize_8  = 8,   // <= 8  data bytes in message, buffer is 16 bytes
   CanMessageSize_16 = 16,  // <= 16 data bytes in message, buffer is 24 bytes
   CanMessageSize_32 = 32,  // <= 32 data bytes in message, buffer is 40 bytes
   CanMessageSize_64 = 64,  // <= 64 data bytes in message, buffer is 72 bytes
};

/**
 * CAN Acceptance mode (CAN_MCR_IDAM)
 */
enum CanAcceptanceMode {
   CanAcceptanceMode_FormatA   = 0,//!< CanAcceptanceMode_FormatA
   CanAcceptanceMode_FormatB   = 1,//!< CanAcceptanceMode_FormatB
   CanAcceptanceMode_FormatC   = 2,//!< CanAcceptanceMode_FormatC
   CanAcceptanceMode_RejectAll = 3,//!< CanAcceptanceMode_RejectAll
};

/**
 * CAN FIFO filter table size (CAN_CTRL2_RFFN)
 * The remaining MBs are available for non-FIFO use.
 */
enum CanFifoFilterSize {
   CanFifoFilterSize_8   = 0x0, // 8   entry Filter table
   CanFifoFilterSize_16  = 0x1, // 16  entry Filter table
   CanFifoFilterSize_24  = 0x2, // 24  entry Filter table
   CanFifoFilterSize_32  = 0x3, // 32  entry Filter table
   CanFifoFilterSize_40  = 0x4, // 40  entry Filter table
   CanFifoFilterSize_48  = 0x5, // 48  entry Filter table
   CanFifoFilterSize_56  = 0x6, // 56  entry Filter table
   CanFifoFilterSize_64  = 0x7, // 64  entry Filter table
   CanFifoFilterSize_72  = 0x8, // 72  entry Filter table
   CanFifoFilterSize_80  = 0x9, // 80  entry Filter table
   CanFifoFilterSize_88  = 0xA, // 88  entry Filter table
   CanFifoFilterSize_96  = 0xB, // 96  entry Filter table
   CanFifoFilterSize_104 = 0xC, // 104 entry Filter table
   CanFifoFilterSize_112 = 0xD, // 112 entry Filter table
   CanFifoFilterSize_120 = 0xE, // 120 entry Filter table
   CanFifoFilterSize_128 = 0xF, // 128 entry Filter table
};

/**
 * Receive FIFO flags
 *
 * for use with clearFifoFlags(), getFifoFlags(), enableFifoInterrupts(), disableFifoInterrupts()
 */
enum {
   CAN_FIFO_OVERFLOW_FLAG  = 1<<7,     //!< Overflow   - A message was lost
   CAN_FIFO_WARNING_FLAG   = 1<<6,     //!< Warning    - The FIFO is nearly full (set 4->5 messages)
   CAN_FIFO_DATA_FLAG      = 1<<5,     //!< Frame available - At least 1 frame available in FIFO
};

/* NOTES:
 *
 * FIFO is 6 entries deep (re-uses MBs[0..5])
 * TOP is MB[0]
 * FIFO ID Filter table (re-uses MBs[6..])
 * RFFN determines size of FIFO Filter table
 *
 * FIFO mode options
 * MCR.RFEN    Enable FIFO
 * MCR.IDAM    ID Acceptance mode Format of Receive FIFO ID Filter Table elements
 * CTRL2.RFFN  Number Of Receive FIFO Filters
 * MCR.DMA     Enable DMA
 * MCR.IRMQ    Enable Individual MB masking (if disabled: FIFO uses RXFGMASK, Mailboxes use RXMGMASK, RX14MASK and RX15MASK)
 *
 * MCR.FDN  Flexible Data rate - excluded
 */

/**
 * @brief Class representing a Controller Area Network (CAN) interface.
 *
 * @tparam Info Can information structure
 *
 * <b>Example</b>
 * @code
 * using can = Can_T<Can0Info>;
 *
 *  can::configure(12500);
 *
 * @endcode
 */
template<class Info>
class Can_T {

public:

   /**
    * Class holding CAN communication parameters
    */
   union CanParameters {
   public:
      struct {
         uint32_t    ctrl1;      //!< Control register 1
         uint32_t    ctrl2;      //!< Control register 2
         uint32_t    mcr;        //!< Mode control register
      };
      struct {
         //--- CTRL1 --------------------------
         unsigned propSeg:3;    //!< Propagation Segment
         bool     lom:1;        //!< Listen-Only Mode
         bool     lbuf:1;       //!< Lowest Buffer Transmitted First
         bool     tsyn:1;       //!< Timer Sync
         bool     boffrec:1;    //!< Bus Off Recovery
         bool     smp:1;        //!< CAN Bit Sampling
         unsigned :2;
         bool     rwrnmsk:1;    //!< Receive Warning Interrupt Mask for ESR1.RWRNINT
         bool     twrnmsk:1;    //!< Transmit Warning Interrupt Mask for ESR1.TWRNINT
         bool     lpb:1;        //!< Loop Back Mode
         bool     clksrc:1;     //!< CAN Engine Clock Source
         bool     errmsk:1;     //!< Error Mask for ESR1.ERRINT (BIT1ERR, BIT0ERR, ACKERR, CRCERR, FRMERR or STFERR)
         bool     boffmsk:1;    //!< Bus Off Mask
         unsigned pSeg2:3;      //!< Phase Segment 2
         unsigned pSeg1:3;      //!< Phase Segment 1
         unsigned rjw:2;        //!< Resynchronisation Jump Width
         unsigned presdiv:8;    //!< Prescaler Division Factor
         //--- CTRL2 --------------------------
         unsigned :16;
         bool     eacen:1;      //!< Entire Frame Arbitration Field Comparison Enable For Receive Mailboxes
         bool     rrs:1;        //!< Remote Request Stored (Automatic Remote Response Frame is not generated)
         bool     mrp:1;        //!< Mailboxes Reception Priority
         unsigned tasd:5;       //!< Transmit Arbitration Start Delay
         unsigned rffn:4;       //!< Number Of Receive FIFO Filters
   #ifdef CAN_CTRL2_WRMFRZ
         bool     wrmfrz:1;     //!< Write-Access To Memory In Freeze Mode
   #else
         unsigned :1;     //!< WRMFRZ not available
   #endif
   #ifdef CAN_CTRL2_BOFFDONEMSK_MASK
         bool     boffdonemsk:1;     //!< Mask for the Bus Off Done Interrupt in CAN_ESR1 register.
   #else
         unsigned :1;     //!< BOFFDONEMSK not available
   #endif
   #ifdef CAN_CTRL2_ERRMSK_FAST_MASK
         bool     errmsk_fast:1;     //!< Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
   #else
         unsigned :1;     //!< ERRMSK_FAST not available
   #endif
         unsigned :1;
         //--- MCR --------------------------
         unsigned maxmb:7;     //!< Number of the last message buffer
         unsigned :1;
         unsigned idam:2;      //!< ID Acceptance Mode
         unsigned :1;
   #ifdef CAN_MCR_FDEN_MASK
         bool     fden:1;      //!< Flexible Data rate enable
   #else
         unsigned :1;          //!< FDEN not available
   #endif
         bool     aen:1;       //!< Abort Enable
         bool     lprioen:1;   //!< Local Priority Enable
   #ifdef CAN_MCR_PNET_EN_MASK
         unsigned :1;          //!< Pretended Networking Enable
   #else
         unsigned :1;          //!< PNET_EN not available
   #endif
   #ifdef CAN_MCR_DMA_MASK
         unsigned :1;          //!< DMA Enable
   #else
         unsigned :1;          //!< DMA not available
   #endif
         bool     irmq:1;      //!< Individual mailbox and FIFO masking, or use of RXMGMASK, RX14MASK, RX15MASK and RXFGMASK
         bool     srxdis:1;    //!< Self Reception Disable
         unsigned :1;
   #ifdef CAN_MCR_WAKSRC_MASK
         bool     waksrc:1;    //!< Wake Up Source
   #else
         unsigned :1;          //!< WAKSRC not available
   #endif
         unsigned :1;          //!< LPMACK - Low-Power Mode Acknowledge
         bool     wrnen:1;     //!< Warning Interrupt Enable
   #ifdef CAN_MCR_SLFWAK_MASK
         bool     slfwak:1;    //!< Self Wake Up
   #else
         unsigned :1;          //!< SLFWAK not available
   #endif
         bool     supv:1;      //!< Supervisor Mode
         unsigned :1;          //!< FRZACK - Freeze Mode Acknowledge
         unsigned :1;          //!< SOFTRST - Soft Reset
   #ifdef CAN_MCR_WAKMSK_MASK
         bool     wakmsk:1;    //!< Wake Up Interrupt Mask
   #else
         unsigned :1;          //!< WAKMSK not available
   #endif
         unsigned :1;          //!< NOTRDY - FlexCAN Not Ready
         bool     :1;          //!< HALT - Halt FlexCAN
         bool     rfen:1;      //!< Receive FIFO Enable
         bool     :1;          //!< FRZ - Freeze Enable
         bool     :1;          //!< MDIS - Module Disable
      };

   public:
      /**
       * Constructor
       *
       * Most parameters will be set to a default disabled value apart from:\n
       * Communication parameters calculated from bitRate and SystemCoreClock:\n
       *   - ctrl1.clksrc  = clockSource
       *   - ctrl1.presdiv Prescaler Division Factor
       *   - ctrl1.propSeg Propagation Segment
       *   - ctrl1.pSeg1   Phase Segment 1
       *   - ctrl1.pSeg2   Phase Segment 2
       *   - ctrl1.rjw     Resynchronisation Jump Width
       *
       *   - ctrl2.tasd    Transmit Arbitration Start Delay (=22, reset default)
       *
       *   - mcr.maxmb   = Number Of The Last Message Buffer (MaxNumberOfFifoMessageFilters - 1)
       *   - mcr.aen     = true
       *   - mcr.irmq    = true
       *
       * @param bitRate      Desired bit rate
       * @param clockSource  Clock source used by CAN interface engine
       *
       * @note Use isValid to check for success or check USBDM error code
       */
      CanParameters(unsigned bitRate, CanClockSource clockSource = CanClockSource_Default) : ctrl1(0), ctrl2(0), mcr(0) {

         clksrc = clockSource;
         calculateParameters(bitRate, Info::getPeClockFrequency(clockSource));

         maxmb   = Info::MaxNumberOfMessageBuffers-1;
         aen     = true;
         irmq    = true;
      }

      /**
       * Communication parameters calculated from bitRate and SystemCoreClock:\n
       *
       *   - ctrl1.presdiv Prescaler Division Factor
       *   - ctrl1.propSeg Propagation Segment
       *   - ctrl1.pSeg1   Phase Segment 1
       *   - ctrl1.pSeg2   Phase Segment 2
       *   - ctrl1.rjw     Resynchronisation Jump Width
       *
       *   - ctrl2.tasd    Transmit Arbitration Start Delay (=22, reset default)
       *
       * @param bitRate      Desired bit rate
       * @param clockFreq    CAN input clock frequency
       *
       * @return E_NO_ERROR      Success
       * @return E_ILLEGAL_PARAM Failed to find suitable parameters for clocking
       */
      ErrorCode calculateParameters(unsigned bitRate, unsigned clockFreq) {

         unsigned bestError        = INT_MAX;
         unsigned bestPrescaler    = 1;  // 1..256
         unsigned bestTq           = 0;  // 8..25 = 1 + timeSegment1 + timeSegment2

         // Try each tq value checking for the best outcome
         // Prefer higher tq if multiple equal best
         for (uint8_t tq = 25; tq>=8; tq--) {
            unsigned prescaler = clockFreq/tq/bitRate;  // 1..256

            auto checkParams = [&] {
               // Check settings
               int error = clockFreq/tq/prescaler - bitRate;
               if (error<0) {
                  error = -error;
               }
   //            console.
   //               write("TQ =").write(tq).
   //               write(", PS = ").write(prescaler).
   //               write(", F =").write(clockFreq/tq/prescaler/1000.0).write(" kHz").
   //               write(", E =").write(error).write(" Hz");
               if ((unsigned)error < bestError) {
   //               console.write(" *");
                  bestError     = (unsigned)error;
                  bestTq        = tq;
                  bestPrescaler = prescaler;
               }
   //            console.writeln();
            };
            if (prescaler>=1) {
               checkParams();
            }
            prescaler++;
            if (prescaler<=256) {
               checkParams();
            }
         }
         if (bestTq == 0) {
            // Indicates failure
            propSeg = 0;
            return setErrorCode(E_ILLEGAL_PARAM);
         }
         /*
          * tq has to be allocated between
          *   Sync segment   = fixed @ 1
          *   Time segment 1 = 4..16
          *   Time segment 2 = 2..8
          * Time segment 1 gets subdivided into propSegment and pseg1
          * Time segment 2 become pseg2
          *
          * Resync is equal to Time segment 2 up to a maximum of 4
          */
         unsigned timeSegment2 = (bestTq-1)/3;
         unsigned timeSegment1 = (bestTq-1) - timeSegment2;
         unsigned resyncJumpWidth = timeSegment2;
         if (resyncJumpWidth>4) {
            resyncJumpWidth = 4;
         }
         presdiv = bestPrescaler - 1;
         propSeg = ((timeSegment1+1)/2) - 1;
         pSeg1   = (timeSegment1 - propSeg) - 2;
         pSeg2   = timeSegment2 - 1;
         rjw     = resyncJumpWidth - 1;

         tasd    = 22; // Reset value

         return E_NO_ERROR;
      }

      /**
       * Check if value was constructed correctly
       *
       * @return true  Values appear valid
       * @return false Values appear invalid
       */
      bool isValid() const {
         //TODO - Check values properly
         return (propSeg != 0);
      }

   };
protected:
   /**
    * Calculates number of Message buffers required for the FIFO and FIFO filters.
    * The remaining Message Buffers are available for individual mailboxes.
    *
    * @param fifoIdFilterCount   Number of FIFO filters implemented
    *
    * @return Number of Message Buffers occupied by the FIFO and FIFO filters.
    */
   static constexpr unsigned calculateMessageBuffersRequiredForFIFO(unsigned fifoIdFilterCount) {
      return (fifoIdFilterCount==0?0:6)+(fifoIdFilterCount/4);
   }

   /**
    * Calculates the number of message buffers required to accommodate FIFO, FIFO filters and mailboxes.
    * The buffers are used for:
    * - Receive FIFO (optional) (6 message buffers)
    * - Receive FIFO filters (optional and number is software configurable) (8 filters = 1 message buffer)
    * - Mailboxes (number is software configurable) (1 mailbox = 1 message buffer)
    * The available Message Buffers is determined by the hardware maximum and the CAN_MCR.MAXMB value.
    *
    * @param fifoIdFilterCount   Number of FIFO filter entries (Format_A=x1, Format_B=x2, Format_C=x4)
    * @param mailboxes           Number of mailboxes
    *
    * @return The number of message buffers required.
    */
   static constexpr unsigned calculateMessageBuffersRequired(unsigned fifoIdFilterCount, unsigned mailboxes) {
      return calculateMessageBuffersRequiredForFIFO(fifoIdFilterCount) + mailboxes;
   }

   /**
    * Calculates maximum number of FIFO filters entries available based on number of Message buffers available.
    * This assumes no Message buffers are used for individual mailboxes i.e. only the Rx FIFO is used.
    * The available Message Buffers is determined by the hardware maximum and the CAN_MCR.MAXMB value.
    * There are also timing constraints as the CAN hardware must scan the FIFO filters and mailboxes.
    * This is not considered here.
    *
    * @param availableMessageBuffers Number of Message buffers available
    *
    * @return Number of FIFO filter entries. Each entry may be x1, x2 or x4 filters
    */
   static constexpr unsigned calculateMaximumFifoFilterEntries(unsigned availableMessageBuffers) {
      return min((availableMessageBuffers-6)*4, 128U);
   }

   /**
    * Calculates number of FIFO individual filter masks available based on number of FIFO filters.
    * Each FIFO filter is masked by either an individual mask (RXIMR[]) or a shared mask (RXFGMASK).
    * This calculates the number of individual masks available (RXIMR[]).
    * The remaining FIFO filters are masked by the shared mask (RXFGMASK).
    * (The remaining RXIMR[] entries are used for individual mailbox filter masking.)
    *
    * @param fifoIdFilterCount   Number of FIFO filters implemented.
    *
    * @return Number of individual FIFO filter masks
    */
   static constexpr unsigned calculateAvailableFifoIdFilterMasks(unsigned fifoIdFilterCount) {
      return (fifoIdFilterCount<8)?0:(8 + 2*((fifoIdFilterCount/8)-1));
   }

   /**
    * Calculates the maximum number of mailboxes and mailbox filters based on number of FIFO filters.
    * The CAN mailboxes share storage with the FIFO and FIFO filters.
    * The number of CAN mailboxes decreases as the number of FIFO filters increases.
    *
    * @param fifoIdFilterCount   Number of FIFO filters implemented
    *
    * @return Maximum number of CAN mailboxes available
    *
    * @note This is a maximum determined by the hardware.
    *       The actual number of mailboxes available may be reduced by setting MCR.MAXMB.
    */
   static constexpr unsigned calculateMaximumMailboxCount(unsigned fifoIdFilterCount) {
      return calculateMailboxCount(fifoIdFilterCount, Info::NumberOfMessageBuffers);
   }

public:
   //! Whether FIFO is configured
   static constexpr unsigned FIFO_AVAILABLE                 = Info::EnableFifo;
   //! Maximum number of Message buffers (determined by hardware, shared b/w FIFO use and mailboxes)
   static constexpr unsigned MAX_NUM_MESSAGE_BUFFERS        = Info::MaxNumberOfMessageBuffers;
   //! Maximum number of Message Buffer filters (determined by hardware, shared b/w FIFO use and mailboxes)
   static constexpr unsigned MAX_NUM_FIFO_MESSAGE_FILTERS   = Info::MaxNumberOfFifoMessageFilters;
   //! Number of Mailbox buffers allocated
   static constexpr unsigned NUM_MAILBOXES                  = Info::NumberOfIndividualMailboxes;
   //! Number of FIFO Message filters
   static constexpr unsigned NUM_FIFO_MESSAGE_FILTERS       = Info::NumberOfFifoMessageFilters;
   //! Number of FIFO Message filter masks (remaining filters use a shared mask)
   static constexpr unsigned NUM_FIFO_MESSAGE_FILTER_MASKS  = calculateAvailableFifoIdFilterMasks(Info::NumberOfFifoMessageFilters);
   //! Number of Mailbox filter masks (remaining filters use a shared mask)
   static constexpr unsigned NUM_MAILBOX_FILTER_MASKS       = min(Info::NumberOfIndividualMailboxes, 32U-NUM_FIFO_MESSAGE_FILTER_MASKS);
   //! Number of Message Buffers used by FIFO (including filters)
   static constexpr unsigned MESSAGE_BUFFERS_ALLOCATED_TO_FIFO = calculateMessageBuffersRequiredForFIFO(Info::NumberOfFifoMessageFilters);

protected:

   //! Hardware instance pointer
   static constexpr HardwarePtr<CAN_Type> can = Info::baseAddress;

   static constexpr unsigned MAILBOX_HANDLER_INDEX       = 0;
   static constexpr unsigned ERROR_HANDLER_INDEX         = 1;
   static constexpr unsigned MISCELLANEOUS_HANDLER_INDEX = 2;
   static constexpr unsigned WAKEUP_HANDLER_INDEX        = 3;
   static constexpr unsigned NUM_HANDLERS                = 4;

   /** Callbacks functions for ISRs */
   static CanCallbackFunction sCallbacks[NUM_HANDLERS];

   /** Callback to catch unhandled interrupt */
   static void noHandlerCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Bit-mask used to allocate mailbox slots */
   static uint32_t       allocatedMailboxes;

public:
   /** CAN interrupt handler */
   static void irqHandler() {
      Can_T::sCallbacks[MISCELLANEOUS_HANDLER_INDEX]();
   }

   /** CAN interrupt handler */
   static void errorIrqHandler() {
      Can_T::sCallbacks[ERROR_HANDLER_INDEX]();
   }

   /** CAN interrupt handler */
   static void wakeupIrqHandler() {
      Can_T::sCallbacks[WAKEUP_HANDLER_INDEX]();
   }

   /** CAN message buffer interrupt handler */
   static void messageBufferIrqHandler() {
      Can_T::sCallbacks[MAILBOX_HANDLER_INDEX]();
   }

protected:
   /**
    * Set callbacks for ISR
    *
    * @param callback The function to call from stub ISR
    * @param index    Index of callback to install
    */
   static void setCallback(CanCallbackFunction callback, int index) {
      static_assert(Info::irqHandlerInstalled, "CAN not configured for interrupts");

      if (callback == nullptr) {
         callback = noHandlerCallback;
      }
      sCallbacks[index] = callback;
   }

public:
   /**
    * Set Miscellaneous callback for ISR
    *
    *  Meaning depends on MCU
    *  For S32K:
    *    * Bus Off OR Bus Off Done OR Transmit Warning OR Receive Warning
    *      (ESR1.BOFFINT, CTRL1.BOFFMSK, ESR1.BOFFDONEINT, CTRL1.BOFFDONEMSK)
    *    * Interrupt indicating Transmit Error Counter transition from < 96 to >= 96.
    *      (ESR1.TWRNINT, CTRL1.TWRNMSK)
    *    * Interrupt indicating Receive Error Counter transition from < 96 to >= 96.
    *      (ESR1.RWRNINT, CTRL1.RWRNMSK)
    *
    * @param callback The function to call from stub ISR
    */
   static void setMiscellaneousCallback(CanCallbackFunction callback) {
      setCallback(callback, MISCELLANEOUS_HANDLER_INDEX);
   }

   /**
    * Set Error callback for ISR.
    *
    *  Meaning depends on MCU
    *  For S32K:
    *  * Interrupt indicating that errors were detected on the CAN bus
    *    (ESR1.ERRINT, CTRL1.ERRMSK = BIT1ERR, BIT0ERR, ACKERR, CRCERR, FRMERR or STFERR)
    *  * Interrupt indicating that errors were detected on the CAN bus for FD messages in the Fast
    *    Bit Rate region. (S32K)
    *    (ESR1.ERRINT_FAST, CTRL2.ERRMSK_FAST = BIT1ERR_FAST, BIT0ERR_FAST, CRCERR_FAST, FRMERR_FAST or STFERR_FAST)
    *
    * @param callback The function to call from stub ISR
    */
   static void setErrorCallback(CanCallbackFunction callback) {
      setCallback(callback, ERROR_HANDLER_INDEX);
   }

   /**
    * Set Wake-up callback for ISR
    *
    *  Meaning depends on MCU
    *  For S32K (pretend networking)
    *    * Interrupt asserted when Pretended Networking operation is enabled, and
    *      a valid message matches the selected filter criteria during Low Power mode
    *      (WU_MTC.WUMF, CTRL1_PN.WUMF_MSK)
    *    * Interrupt asserted when Pretended Networking operation is enabled, and
    *      no-reception of a matching message for a defined quantity of time during low power mode
    *      (WU.WTOF, CTRL1_PN.WTOF_MSK)
    *
    *  Other devices
    *    * Interrupt asserted for Self Wake Up mechanism.
    *      (ESR1.WAKINT, MCR.WAKMSK, MCR.SLFWAK enables)
    *
    * @param callback The function to call from stub ISR
    */
   static void setWakeupCallback(CanCallbackFunction callback) {
      setCallback(callback, WAKEUP_HANDLER_INDEX);
   }

   /**
    * Set Message buffer callback for ISR
    *
    * Message buffer (Mailbox + FIFO) interrupts (IFLAG1, IMASK1)
    *
    * @param callback The function to call from stub ISR
    */
   static void setMessageBufferCallback(CanCallbackFunction callback) {
      setCallback(callback, MAILBOX_HANDLER_INDEX);
   }

   /**
    * Get pointer to message buffer for the mailbox
    * Allowances are made for mailboxes lost to the Receive FIFO so the
    * index is relative to the first usable mailbox
    *
    * @param canMessageSize    Size of message buffers being used.
    * @param index             Index of message buffer
    *
    * @return Pointer to message buffer.
    */
   static volatile CanMessageBuffer *getMailbox(CanMessageSize canMessageSize, unsigned index) {
      usbdm_assert(index<NUM_MAILBOXES, "Invalid mailbox index");
      return (CanMessageBuffer *) (Info::baseAddress + offsetof(struct CAN_Type, MB) + MESSAGE_BUFFERS_ALLOCATED_TO_FIFO*sizeof(CanMessageBuffer8) + index*(canMessageSize+8));
   };

   /**
    * Get pointer to message buffer for the mailbox assuming default size (8 data bytes)
    * Allowances are made for mailboxes lost to the Receive FIFO so the
    * index is relative to the first usable mailbox
    *
    * @param index   Index of message buffer
    *
    * @return Pointer to mailbox
    */
   static inline volatile CanMessageBuffer8 *getMailbox(unsigned index) {
      return (CanMessageBuffer8 *) getMailbox(CanMessageSize_8, index);
   };

   /**
    * Get pointer to message buffers for the mailboxes assuming default size (8 data bytes)
    * Allowances are made for mailboxes lost to the Receive FIFO so array
    * starts at first available mailbox
    *
    * @return Pointer to mailbox
    */
   static inline volatile CanMessageBuffer8 *getMailboxArray() {
      return (CanMessageBuffer8 *) getMailbox(CanMessageSize_8, 0);
   };

   /**
    * Get pointer to Top of FIFO Message Buffer.
    *
    * @return Pointer to message buffer.
    *
    * @note This is only applicable when FIFO is enabled.
    */
   static CanMessageBuffer8 *getFifoMessageBuffer() {
      return (CanMessageBuffer8 *) (can->MB);
   };

   /**
    * Get FIFO Filter Table array.
    * The result is formatted as an array of CanFifoFilters.
    * These filters are applied to the entry of Received messages into the FIFO.
    * The filter is modified by the FIFO filter masks see getFifoFilterMaskTable()
    *
    * @return Pointer to start of filter table array
    *
    * @note This is only applicable when FIFO is enabled.
    */
   static CanFifoIdFilter *getFifoFilterTable() {
      return (CanFifoIdFilter *) (can->FIFO.FILTER_ID_A);
   }

   /**
    * Get FIFO Mask array.
    * The result is formatted as an array of CanFilterMasks.
    * These masks are applied to filtering of Received messages into the FIFO.
    *
    * @return Pointer to start of filter mask table array
    */
   static CanFifoIdFilterMask *getFifoFilterMaskTable() {
      return (CanFifoIdFilterMask *) (can->RXIMR);
   }

   /**
    * Get Mailbox Mask array.
    * The result is formatted as an array of CanMailboxFilterMask.
    * These masks are applied to filtering of Received messages into the mailboxes.
    *
    * @return Pointer to start of filter mask table array
    */
   static CanMailboxFilterMask *getMailboxFilterMaskTable() {
      return (CanMailboxFilterMask *) (can->RXIMR + MESSAGE_BUFFERS_ALLOCATED_TO_FIFO);
   }

   /**
    * Get Mailbox Mask array.
    * The result is formatted as an array of CanMailboxFilterMask.
    * These masks are applied to filtering of Received messages into the mailboxes.
    *
    * @return Pointer to start of filter mask table array
    */
   static CanMailboxFilterMask &getMailboxFilterMask(unsigned index) {
      return ((CanMailboxFilterMask *) (can->RXIMR + MESSAGE_BUFFERS_ALLOCATED_TO_FIFO))[index];
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    *  Configure the CAN with default settings
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to peripheral
      Info::enableClock();
      __DMB();
   }

   /**
    * Configure for individual mailbox use only (no FIFO)
    *
    * A series of mailboxes are available for transmit or receive messages.
    * Each mailbox structure has its own selection filter (Rx only).
    * They also have individual acceptance filter masks as an entry in a separate table.
    *
    * @param[in] canParameters         CAN communication parameters
    *
    * @note The CAN interface is left stopped (in FREEZE mode).  Use start() to commence CAN operation.
    */
   static void configure(const CanParameters &canParameters) {
      static_assert(NUM_FIFO_MESSAGE_FILTERS==0, "No FIFO filters may be allocated in non-FIFO mode");

      CanParameters modifiedCanParameters(canParameters);

      modifiedCanParameters.rfen  = false;
      common_configure(modifiedCanParameters);
   }

   /**
    * Configure for Receive FIFO use (with FIFO and optional mailboxes)
    *
    * In this mode received packets can be stored in a receive FIFO.
    * The received messages are accepted/rejected for entry to the FIFO using an acceptance filter table (fifoIdFilters).
    * The entries in the table may have one of 3 formats (canAcceptanceMode).  These formats are a trade-off between
    * the number of filters and their filtering capability - mainly the number of ID bits included in the filter matching.
    * The acceptance filters are masked by a FIFO filter mask table (fifoIdFilterMasks) or a default mask (fifoDefaultFilterMask).
    * Note that, due to memory arrangements, not all FIFO filters will have their own mask (fifoIdFilterMasks).
    * The remaining entries use a shared mask (fifoDefaultFilterMask).
    * AND
    * A series of mailboxes are also available for transmit or receive messages.
    * Each mailbox structure has its own selection filter (Rx only).
    * They also have individual acceptance filter masks as a separate table (mailboxFilterMasks).
    * The number of mailboxes is reduced as the number of the FIFO filters increases.
    * Mailboxes are configured individually.
    *
    * @param[in] canParameters            CAN communication parameters
    * @param[in] canAcceptanceMode        Format for FIFO acceptance filters (A=1x,B=2x,C=4x/Entry)
    * @param[in] fifoIdFilters            FIFO Acceptance filters [NUM_FIFO_MESSAGE_FILTERS]
    * @param[in] fifoIdFilterMasks        Masks applied to FIFO acceptance filters [NUM_FIFO_MESSAGE_FILTER_MASKS]
    * @param[in] fifoDefaultIdFilterMask  Mask applied to FIFO acceptance filters not covered by fifoIdFilterMasks
    *
    * @note The CAN interface is left stopped (in FREEZE mode).  Use start() to commence CAN operation.
    *       This is necessary to allow mailbox to be configured etc. before starting operation.
    */
   static void configure(
         const CanParameters           &canParameters,
         const CanAcceptanceMode       canAcceptanceMode,
         const CanFifoIdFilter         fifoIdFilters[/* NUM_FIFO_MESSAGE_FILTERS */],
         const CanFifoIdFilterMask     fifoIdFilterMasks[/* NUM_FIFO_MESSAGE_FILTER_MASKS */],
         const CanFifoIdFilterMask     fifoDefaultIdFilterMask
   ) {
#ifdef CAN_MCR_FDEN_MASK
//      static_assert(NUM_FIFO_MESSAGE_FILTERS>=8,"Must be at least 8 FIFO filters");
#endif
      CanParameters modifiedCanParameters(canParameters);

      modifiedCanParameters.idam  = canAcceptanceMode;
      modifiedCanParameters.rfen  = true;

      common_configure(modifiedCanParameters);

      // Set up individual FIFO ID filters
      auto filters = Can_T::getFifoFilterTable();
      for (unsigned index=0; index<Info::NumberOfFifoMessageFilters; index++) {
         filters[index] = fifoIdFilters[index];
      }

      // Individual FIFO ID filter masks
      auto fifoMasks = Can_T::getFifoFilterMaskTable();
      unsigned fifoMaskCount = calculateMessageBuffersRequiredForFIFO(Info::NumberOfFifoMessageFilters);
      for (unsigned index=0; index<fifoMaskCount; index++) {
         fifoMasks[index] = fifoIdFilterMasks[index];
      }
      /*
       * Mask for Receive FIFO ID Filter Table elements not covered by an
       * individual masks or if individual masks are disabled (IRQM=0)
       */
      can->RXFGMASK = fifoDefaultIdFilterMask.raw;
   }

protected:
   /**
    * Configure CAN with given settings
    *
    * @param[in] canParameters
    *
    * @note The CAN interface is left stopped (in FREEZE mode).  Use start() to commence CAN operation.
    */
   static void common_configure(CanParameters &canParameters) {
#ifdef CAN_MCR_FDEN_MASK
      usbdm_assert(!canParameters.fden,"Flexible Data Rate not supported");
#endif
      usbdm_assert(canParameters.irmq,"Legacy masking not supported");

      // Release all mailboxes
      allocatedMailboxes = (1<<NUM_MAILBOXES)-1;

      enable();

      usbdm_assert(
            calculateMessageBuffersRequired(Info::NumberOfFifoMessageFilters, Info::NumberOfIndividualMailboxes)<=Info::MaxNumberOfMessageBuffers,
            "Too many FIFO filters and Mailboxes");

      for(unsigned index=0; index<(sizeof(sCallbacks)/sizeof(sCallbacks[0])); index++) {
         if (sCallbacks[index] == nullptr) {
            sCallbacks[index] = Can_T<Info>::noHandlerCallback;
         }
      }

      canParameters.rffn  = (Info::NumberOfFifoMessageFilters<8)?0:(Info::NumberOfFifoMessageFilters/8) - 1;
      canParameters.maxmb = calculateMessageBuffersRequired(Info::NumberOfFifoMessageFilters, Info::NumberOfIndividualMailboxes) - 1;

      // Make sure disabled so CLKSRC can be set
      can->MCR = CAN_MCR_MDIS(1);

      // Wait until in LP mode
      while (!(can->MCR & CAN_MCR_LPMACK_MASK)) {
         __asm__("nop");
      }

      can->CTRL1 = canParameters.ctrl1 & CAN_CTRL1_CLKSRC_MASK;

      // Enable
      can->MCR = CAN_MCR_MDIS(0)|CAN_MCR_FRZ(1);

      // Wait until not in LP mode
      while (can->MCR & CAN_MCR_LPMACK_MASK) {
         __asm__("nop");
      }

      // Apply software reset and wait until complete
      can->MCR |= CAN_MCR_SOFTRST(1);
      while (can->MCR & CAN_MCR_SOFTRST_MASK) {
         __asm__("nop");
      }
      // Wait until in Freeze mode
      while ((can->MCR & CAN_MCR_FRZACK_MASK)==0) {
         __asm__("nop");
      }

      // Clear message buffers
      // This will also clear the FIFO as it overlaps
      memset((void*)(can->MB),     0, Info::MaxNumberOfMessageBuffers*sizeof(can->MB[0]));
      // Disable message buffer/FIFO ID filter masks
      memset((void*)(can->RXIMR), -1, Info::MaxNumberOfMessageBuffers*sizeof(can->RXIMR[0]));

      // Clear any pending flags
      can->IFLAG1 = ~0;

      can->CTRL1 = canParameters.ctrl1;

      can->CTRL2 = canParameters.ctrl2;

      // Configure CAN
      can->MCR = canParameters.mcr|
            CAN_MCR_HALT(1) |            // Stay in Freeze
            CAN_MCR_FRZ(1);
   }

public:
   /**
    * Starts CAN interface (clears FREEZE mode)
    */
   static void start() {
      // Negate Freeze mode
      can->MCR &= ~CAN_MCR_HALT_MASK;
   }

   /**
    * Stop CAN interface (sets FREEZE mode)
    */
   static void stop() {
      // Set Freeze mode
      can->MCR |= CAN_MCR_HALT_MASK;

      // Wait until ack'ed
      while (can->MCR & CAN_MCR_FRZACK_MASK) {
         __asm__("nop");
      }
   }

   /**
    *   Disable the CAN
    */
   static void finalise(uint8_t channel) {
      // Halt CAN
      stop();

      Info::disableClock();
   }

   /**
    * Write value to 16-bit free running counter
    * The timer is clocked by CAN bit clock or an external clock and does not count
    * in Disable, Stop, Pretended Networking and Freeze modes.
    *
    * The timer starts from 0x0 after Reset, counts linearly to 0xFFFF, and wraps around.
    * The timer value is captured when the second bit of the identifier field of any frame is on
    * the CAN bus. This captured value is written into the Time Stamp entry in a message
    * buffer after a successful reception or transmission of a message.
    * If CTRL1[TSYN] is asserted, the Timer is reset whenever a message is received in the
    * first available Mailbox, according to CAN_CTRL2[RFFN] setting.
    * The CPU can write to this register any time. However, if the write occurs at the same time
    * that the Timer is being reset by a reception in the first Mailbox, then the write value is
    * discarded.
    *
    * @param value
    */
   static void writeTimer(uint16_t value) {
      can->TIMER = value;
   }

   /**
    * Read value from 16-bit free running counter
    *
    * @return Timer value
    */
   static uint16_t readTimer() {
      return can->TIMER;
   }

   /**
    * Set FIFO Message Buffer Mask\n
    * Used to mask the Receive FIFO ID Filter Table elements that do
    * not have a corresponding RXIMR according to CAN_CTRL2[RFFN]
    * field setting.
    *
    * @param mask
    */
   static void setFifoMessageBufferMask(uint16_t mask) {
      can->RXFGMASK = mask;
   }

   /**
    * Set Global Message Buffer Mask\n
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields of all Receive MBs, excluding MBs 14-15, which
    * have individual mask registers
    *
    * @param mask
    */
   static void setMailboxGlobalMask(uint16_t mask) {
      can->RXMGMASK = mask;
   }

   /**
    * Set Message Buffer 14 Message Buffer Mask
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields in Mailbox 14.
    *
    * @param mask
    */
   static void setMailbox14Mask(uint16_t mask) {
      can->RX14MASK = mask;
   }

   /**
    * Set Message Buffer 15 Message Buffer Mask
    * If individual filter masks are not used (MCR.IRMQ=0) this sets the mask to
    * filter fields in Mailbox 15.
    *
    * @param mask
    */
   static void setMailbox15Mask(uint16_t mask) {
      can->RX15MASK = mask;
   }

   /**
    * Get error counts
    *
    * @return Error counts
    */
   static CanErrorCounts getErrorCounters() {
      return (CanErrorCounts)can->ECR;
   }

   /**
    * Get Error Status
    *
    * @return Mask representing various errors.
    */
   static uint32_t getErrorStatus() {
      return can->ESR1;
   }

   /**
    * Clear Error Status
    *
    * @param flags Mask representing various errors to clear
    */
   static uint32_t clearErrorStatus(uint32_t flags) {
      return can->ESR1 = flags;
   }

   /**
    * Enable interrupt from given mailbox.
    *
    * @param[in] mailboxNumber Number of mailbox to modify.
    *
    * @note The mailboxNumber takes into account the buffers allocated to the FIFO.
    */
   static void enableMailboxInterrupt(unsigned mailboxNumber) {
      can->IMASK1 |= (1<<(mailboxNumber+MESSAGE_BUFFERS_ALLOCATED_TO_FIFO));
   }

   /**
    * Disable interrupt from given mailbox
    *
    * @param[in] mailboxNumber Number of mailbox to modify.
    *
    * @note The mailboxNumber takes into account the buffers allocated to the FIFO.
    */
   static void disableMailboxInterrupt(unsigned mailboxNumber) {
      can->IMASK1 &= ~(1<<(mailboxNumber+MESSAGE_BUFFERS_ALLOCATED_TO_FIFO));
   }

   /**
    * Clear interrupt from given mailbox
    *
    * @param[in] mailboxNumber Number of mailbox to modify.
    *
    * @note The mailboxNumber takes into account the buffers allocated to the FIFO.
    */
   static void clearMailboxFlag(unsigned mailboxNumber) {
      can->IFLAG1 = (1<<(mailboxNumber+MESSAGE_BUFFERS_ALLOCATED_TO_FIFO));
   }

   /**
    * Enable interrupts from selected mail boxes
    *
    * @param[in] mask 1's in the mask enable interrupts from the corresponding message buffer.
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void enableMailboxInterrupts(uint32_t mask) {
      can->IMASK1 |= (mask<<MESSAGE_BUFFERS_ALLOCATED_TO_FIFO);
   }

   /**
    * Disable interrupts from selected mail boxes
    *
    * @param[in] mask 1's in the mask disable interrupts from the corresponding message buffer.
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void disableMailboxInterrupts(uint32_t mask) {
      can->IMASK1 &= ~(mask<<MESSAGE_BUFFERS_ALLOCATED_TO_FIFO);
   }

   /**
    * Get message buffer flags.
    * Each bit represents the flags from a mail boxes
    *
    * @return Bitmask representing the flags from mail boxes
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static uint32_t getMailboxFlags() {
      return (can->IFLAG1>>MESSAGE_BUFFERS_ALLOCATED_TO_FIFO);
   }

   /**
    * Clear mail box flags.
    * Each bit represents a mail boxes flag to clear
    *
    * @param[in] mask 1's in the mask clear the flag from the corresponding mailbox
    *
    * @note The mask is realigned to take in to account the buffers allocated to the FIFO.
    */
   static void clearMailboxFlags(uint32_t mask) {
      can->IFLAG1 = mask<<MESSAGE_BUFFERS_ALLOCATED_TO_FIFO;
   }

   /**
    * Enable interrupts from FIFO
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask clear flags as shown:
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void enableFifoInterrupts(uint32_t mask) {
      can->IMASK1 |= mask & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Disable interrupts from FIFO
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask disable flags as shown:
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void disableFifoInterrupts(uint32_t mask) {
      can->IMASK1 &= ~(mask & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK));
   }

   /**
    * Get FIFO flags.
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @return bit mask\n
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static uint32_t getFifoFlags() {
      return can->IFLAG1 & (CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Clear FIFO flags.
    * Bits 7, 6 and 5 represent FIFO flags.
    *
    * @param[in] mask 1's in the mask clear flags as shown:
    *  7 : Receive FIFO Overflow   - A message was lost
    *  6 : Receive FIFO Warning    - The FIFO is nearly full (set 4->5 messages)
    *  5 : Receive frame available - At least 1 frame available in Receive FIFO
    */
   static void clearFifoFlags(uint32_t mask) {
      can->IFLAG1 = mask&(CAN_IFLAG1_BUF7I_MASK|CAN_IFLAG1_BUF6I_MASK|CAN_IFLAG1_BUF5I_MASK);
   }

   /**
    * Get FIFO information.\n
    *
    * This indicates which Identifier Acceptance Filter was hit by the received message that is in the output
    * of the Receive FIFO. If multiple filters match the incoming message ID then the first matching IDAF found
    * (lowest number) by the matching process is indicated. This field is valid only while the CAN_IFLAG1[BUF5I]
    * is asserted.
    *
    * @return The index of the matching acceptance filter
    */
   static uint32_t getFifoAcceptanceFilterHit() {
      return can->RXFIR & CAN_RXFIR_IDHIT_MASK;
   }

#ifdef CAN_CBT_EPSEG1
   /**
    * Set extended timing
    *
    * @param phaseSegment1           Phase Buffer Segment 1 = phaseSegment1 x S-clock.
    * @param phaseSegment2           Phase Buffer Segment 2 = phaseSegment2 x S-clock.
    * @param propagationSegment      Propagation Segment Time = propagationSegment x S-clock.
    * @param resyncJumpWidth         Resynchronisation Jump Width = resyncJumpWidth x S-clock.
    * @param prescalerDivisionFactor S-clock frequency = PE clock frequency / prescalerDivisionFactor
    */
   static void setExtendedTiming(
         unsigned phaseSegment1,
         unsigned phaseSegment2,
         unsigned propagationSegment,
         unsigned resyncJumpWidth,
         unsigned prescalerDivisionFactor
   ) {
      can->CBT =
            CAN_CBT_EPSEG1(phaseSegment1-1) |
            CAN_CBT_EPSEG2(phaseSegment2-1) |
            CAN_CBT_EPROPSEG(propagationSegment-1) |
            CAN_CBT_ERJW(resyncJumpWidth-1) |
            CAN_CBT_EPRESDIV(prescalerDivisionFactor-1);
   }
#endif

   /**
    * Get CRC value for last transmitted buffer
    *
    * @return CRC value and buffer number
    */
   static CanCrc15 getTransmittedCrc() {
      return (CanCrc15)(can->CRCR);
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableWakeupNvicInterrupts() {
      static_assert(Info::Wakeup_IrqNumIndex>0, "Wakeup not supported");
      NVIC_EnableIRQ(Info::irqNums[Info::Wakeup_IrqNumIndex]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableWakeupNvicInterrupts(uint32_t nvicPriority) {
      static_assert(Info::Wakeup_IrqNumIndex>0, "Wakeup not supported");
      enableNvicInterrupt(Info::irqNums[Info::Wakeup_IrqNumIndex], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableWakeupNvicInterrupts() {
      static_assert(Info::Wakeup_IrqNumIndex>0, "Wakeup not supported");
      NVIC_DisableIRQ(Info::irqNums[Info::Wakeup_IrqNumIndex]);
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableErrorNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[Info::Error_IrqNumIndex]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableErrorNvicInterrupts(uint32_t nvicPriority) {
      enableNvicInterrupt(Info::irqNums[Info::Error_IrqNumIndex], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableErrorNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[Info::Error_IrqNumIndex]);
   }

$(/CAN/NvicControl)

protected:
   static constexpr unsigned MailboxNone = NUM_MAILBOXES;

   /**
    * Allocate CAN Mailbox.
    *
    * @return MailboxNone  No available mailbox.  Error code set.
    * @return Otherwise    Mailbox number
    */
   static unsigned allocateMailbox() {
      unsigned mailboxNum = __builtin_ffs(allocatedMailboxes);
      if ((mailboxNum == 0)||(--mailboxNum>=NUM_MAILBOXES)) {
         setErrorCode(E_NO_RESOURCE);
         return MailboxNone;
      }
      allocatedMailboxes &= ~(1<<mailboxNum);
      return mailboxNum;
   }

   /**
    * Free CAN Mailbox.
    *
    * @param mailboxNumber CAN mailbox to release
    */
   static void freeMailbox(unsigned mailboxNumber) {
      usbdm_assert((mailboxNumber<NUM_MAILBOXES), "Illegal mailbox number");

      const uint32_t mailboxMask = (1<<mailboxNumber);
      usbdm_assert((allocatedMailboxes & mailboxMask) == 0,          "Freeing unallocated mailbox");

      volatile CanMessageBuffer8 *mb = Can_T<Info>::getMailbox(mailboxNumber);
      mb->CS = CanControlStatus(CanMessageCode_RxInactive);
      allocatedMailboxes |= mailboxMask;
   }

};

/**
 * Callback table for programmatically set handlers
 */
template<class Info> CanCallbackFunction Can_T<Info>::sCallbacks[]      = {0};

template<class Info>
uint32_t Can_T<Info>::allocatedMailboxes = (1<<NUM_MAILBOXES)-1;

typedef void (*CanMailboxCallbackFunction)(unsigned);

/**
 * @brief Class representing a Controller Area Network (CAN) interface.
 *        This class includes individual handlers for each mailbox.
 *
 * @tparam Info            Can information structure
 * @tparam mailboxCount    Number of mailboxes to allocate
 *
 * <b>Example</b>
 * @code
 * using can = Can_T<Can0Info>;
 *
 *  can::configure(12500);
 *
 * @endcode
 */
template<class Info>
class CanHandler_T : public Can_T<Info> {
public:
   //! Inherit Can Parameters
   using typename Can_T<Info>::CanParameters;
   //! Maximum number of Message buffers (determined by hardware, shared b/w FIFO use and mailboxes)
   using Can_T<Info>::MAX_NUM_MESSAGE_BUFFERS;
   //! Maximum number of Message Buffer filters (determined by hardware, shared b/w FIFO use and mailboxes)
   using Can_T<Info>::MAX_NUM_FIFO_MESSAGE_FILTERS;
   //! Number of Mailbox buffers allocated
   using Can_T<Info>::NUM_MAILBOXES;
   //! Number of FIFO Message filters
   using Can_T<Info>::NUM_FIFO_MESSAGE_FILTERS;
   //! Number of FIFO Message filter masks (remaining filters use a shared mask)
   using Can_T<Info>::NUM_FIFO_MESSAGE_FILTER_MASKS;
   //! Number of Mailbox filter masks (remaining filters use a shared mask)
   using Can_T<Info>::NUM_MAILBOX_FILTER_MASKS;

public:
   class CanMailboxInfo {

      // Only CanHandler_T can allocate
      friend CanHandler_T<Info>;

   private:
      // CAN mailbox number (also index in mailboxInformation[])
      unsigned mailboxNumber;

      // Associated CAN mailbox
      volatile CanMessageBuffer8 *mailbox;

      // Callback to execute on mailbox event
      CanMailboxCallbackFunction callback;

      /**
       * Constructor
       * The mailbox will not be associated with a CAN mailbox.
       */
      constexpr CanMailboxInfo() :
            mailboxNumber(NUM_MAILBOXES),
            mailbox(nullptr),
            callback((CanMailboxCallbackFunction)Can_T<Info>::noHandlerCallback) {
      }

      /**
       * Destructor
       */
      ~CanMailboxInfo() {};

      /**
       * Initialises the Mailbox Information.
       * This assumes the CAN mailbox has been allocated.
       *
       * @param mailBoxNum CAN Mailbox number that has been allocated.
       */
      void initialise(unsigned mailBoxNum) {
         mailboxNumber = mailBoxNum;
         mailbox       = Can_T<Info>::getMailbox(mailBoxNum);
         disableInterrupt();
         setCallback(nullptr);
      }

      /**
       * Initialises the Mailbox Information.
       */
      void initialise() {
         mailboxNumber = NUM_MAILBOXES;
         mailbox       = nullptr;
         setCallback(nullptr);
      }

   public:
      /**
       * Check if mailbox is valid (allocated successfully)
       *
       * @return
       */
      bool isValid() {
         return mailbox != nullptr;
      }

      /**
       * Releases the associated CAN mailbox
       */
      void release() {
         disableInterrupt();
         Can_T<Info>::freeMailbox(mailboxNumber);
         mailbox = nullptr;
         setCallback(nullptr);
         mailboxNumber = NUM_MAILBOXES;
      }

      /**
       * Set callbacks to execute on Mailbox event.
       * Use nullptr to remove handler.
       *
       * @param callback The function to call on Mailbox event
       */
      void setCallback(CanMailboxCallbackFunction callback) {
         static_assert(Info::irqHandlerInstalled, "CAN not configured for interrupts");
         usbdm_assert((mailbox != nullptr)||(callback == nullptr), "CanMailboxInfo in invalid state");
         if (callback == nullptr) {
            callback = (CanMailboxCallbackFunction)Can_T<Info>::noHandlerCallback;
         }
         this->callback = callback;
      }

      /**
       * Get Mailbox filter mask
       * These masks are applied to filtering of received messages into the mailbox.
       *
       * @return Reference to mask
       *
       * @note Can only be accessed in Freeze mode.
       */
      CanMailboxFilterMask &getMailboxFilterMask() {
         return Can_T<Info>::getMailboxFilterMask(mailboxNumber);
      }

      /**
       * Get pointer to CAN message buffer for the mailbox assuming default size (8 data bytes)
       *
       * @return Pointer to mailbox
       */
      volatile CanMessageBuffer8 &getMailbox() {
         usbdm_assert(mailbox != nullptr, "CanMailboxInfo in invalid state");
         return *mailbox;
      };

      /**
       * Obtain mailbox number
       *
       * @return Mailbox Number
       */
      unsigned getMailboxNumber() {
         usbdm_assert(mailboxNumber < Can_T<Info>::NUM_MAILBOXES, "CanMailboxInfo in invalid state");
         return mailboxNumber;
      }

      /**
       * Enable interrupt associated with this mail box
       */
      void enableInterrupt() {
         usbdm_assert(mailboxNumber < Can_T<Info>::NUM_MAILBOXES, "CanMailboxInfo in invalid state");
         Can_T<Info>::enableMailboxInterrupt(mailboxNumber);
      }

      /**
       * Disable interrupt associated with this mail box
       */
      void disableInterrupt() {
         usbdm_assert(mailboxNumber < Can_T<Info>::NUM_MAILBOXES, "CanMailboxInfo in invalid state");
         Can_T<Info>::disableMailboxInterrupt(mailboxNumber);
      }
   };

private:
   static CanMailboxInfo mailboxInformation[NUM_MAILBOXES];

   static CanMailboxInfo MailboxNone;

public:
   /**
    * Configure for individual mailbox use only (no FIFO)
    *
    * A series of mailboxes are available for transmit or receive messages.
    * Each mailbox structure has its own selection filter (Rx only).
    * They also have individual acceptance filter masks as a separate table (mailboxFilterMasks).
    *
    * @param[in] canParameters         CAN communication parameters
    *
    * @note The CAN interface is left stopped (in FREEZE mode).  Use start() to commence CAN operation.
    */
   static void configure(const CanParameters &canParameters) {
      for(unsigned index=0; index<NUM_MAILBOXES; index++) {
         mailboxInformation[index].initialise();
      }
      Can_T<Info>::configure(canParameters);
   }

   /**
    * Configure for Receive FIFO use (with mailboxes)
    * Mailboxes have individual interrupt handlers.
    *
    * In this mode received packets can be stored in a receive FIFO.
    * The received messages are accepted/rejected for entry to the FIFO using an acceptance filter table (fifoIdFilters).
    * The filter table (fifoIdFilters) is of size fifoIdFilterCount.
    * The entries in the table may have one of 3 formats (canAcceptanceMode).  These formats are a trade-off between
    * the number of filters and their filtering capability - mainly the number of ID bits included in the filter matching.
    * The acceptance filters are masked by a FIFO filter mask table (fifoIdFilterMasks) and/or a default mask (fifoDefaultFilterMask).
    * Note that, due to memory arrangements, not all FIFO filters will have their own mask (fifoIdFilterMasks).
    * The remaining entries use a shared mask (fifoDefaultFilterMask).
    * AND
    * A series of mailboxes are also available for transmit or receive messages.
    * These have their own mailbox acceptance filter (mailboxFilterMasks).
    * The number of mailboxes is reduced as the number of the FIFO filters increases.
    *
    * @param[in] canParameters         CAN communication parameters
    * @param[in] canAcceptanceMode     Format for FIFO acceptance filters
    * @param[in] fifoIdFilters         FIFO Acceptance filters [fifoIdFilterCount]
    * @param[in] fifoIdFilterMasks     Masks applied to FIFO acceptance filters [calculateMessageBuffersRequiredForFIFO(fifoIdFilterCount)]
    * @param[in] fifoDefaultFilterMask Mask applied to FIFO acceptance filters not covered by fifoIdFilterMasks
    *
    * @note The CAN interface is left stopped (in FREEZE mode).  Use start() to commence CAN operation.
    */
   static void configure(
         const CanParameters           &canParameters,
         const CanAcceptanceMode       canAcceptanceMode,
         const CanFifoIdFilter         fifoIdFilters[/* fifoIdFilterCount */],
         const CanFifoIdFilterMask     fifoIdFilterMasks[/* calculateMessageBuffersRequiredForFIFO(fifoIdFilterCount)*/],
         const CanFifoIdFilterMask     fifoDefaultFilterMask
   ) {
      for(unsigned index=0; index<NUM_MAILBOXES; index++) {
         mailboxInformation[index].initialise();
      }
      Can_T<Info>::configure(
            canParameters,
            canAcceptanceMode,
            fifoIdFilters,
            fifoIdFilterMasks,
            fifoDefaultFilterMask);
   }

   /**
    * Allocate CAN Mailbox.
    *
    * @return MailboxNone  No available mailbox.  Error code set.
    * @return Otherwise    Mailbox object
    */
   static CanMailboxInfo &allocateMailbox() {
      int mailboxNum = Can_T<Info>::allocateMailbox();
      if (mailboxNum == Can_T<Info>::MailboxNone) {
         setErrorCode(E_NO_RESOURCE);
         return MailboxNone;
      }
      CanMailboxInfo &mailboxInfo = mailboxInformation[mailboxNum];
      mailboxInfo.initialise(mailboxNum);
      return mailboxInfo;
   }

   /**
    * Free CAN Mailbox.
    *
    * @param mailboxInfo Channel to release
    */
   static void freeMailbox(CanMailboxInfo mailboxInfo) {
      mailboxInfo.release();
   }

   /**
    * Set callback for FIFO ISR
    *
    * @param callback The function to call from stub ISR
    */
   static void setFifoCallback(CanCallbackFunction callback) {
      Can_T<Info>::setCallback(callback, Can_T<Info>::MAILBOX_HANDLER_INDEX);
   }

   /**
    * CAN message buffer interrupt handler
    * Used for FIFO and Mailbox interrupts.
    *
    * Dispatches to individual mailbox handler or FIFO handler.
    */
   static void messageBufferIrqHandler() {
      uint32_t flags = Can_T<Info>::getMailboxFlags();

      // Find lowest numbered busy Mailbox
      int channelNum = __builtin_ffs(flags);

      if (channelNum==0) {
         // Pass to FIFO handler
         Can_T<Info>::sCallbacks[Can_T<Info>::MAILBOX_HANDLER_INDEX]();
      }
      else {
         // Pass to mailbox handler
         channelNum--;
         mailboxInformation[channelNum].callback(channelNum);
      }
   }
};

template<class Info>
typename CanHandler_T<Info>::CanMailboxInfo CanHandler_T<Info>::mailboxInformation[NUM_MAILBOXES];

template<class Info>
typename CanHandler_T<Info>::CanMailboxInfo CanHandler_T<Info>::MailboxNone;

#if defined(USBDM_CAN0_IS_DEFINED)
using Can0 = CanHandler_T<Can0Info>;
#endif

#if defined(USBDM_CAN1_IS_DEFINED)
using Can1 = CanHandler_T<Can1Info>;
#endif

#if defined(USBDM_CAN2_IS_DEFINED)
using Can2 = CanHandler_T<Can2Info>;
#endif
/**
 * @}
 */
} // End namespace USBDM

#endif /* PROJECT_HEADERS_CAN_H_ */

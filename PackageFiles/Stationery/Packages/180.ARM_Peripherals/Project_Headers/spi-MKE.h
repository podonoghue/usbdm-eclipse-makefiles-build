/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MKE.h)
 * @brief    Serial Peripheral Interface
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "pin_mapping.h"
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

#if $(/SPI/_BasicInfoGuard) // /SPI/_BasicInfoGuard

namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */
$(/SPI/peripheral_h_definition:// $/SPI/peripheral_h_definition not found)

/**
 * Type definition for completion call back
 *
 * @param status E_NOERROR on success else error code
 */
typedef void (*SpiCallbackFunction)(ErrorCode status);

/**
 * Note on MODFEN/SSOE use
 *  SSOE  MODFEN     MASTER      SLAVE
 *   0     0         GPIO        SS-in
 *   0     1         FAULT-in    SS-in
 *   1     0         GPIO        SS-in
 *   1     1         SS-out      SS-in
 */

/**
 * Slave Select pin function in master mode
 */
enum SpiPinSelect {
   SpiPinSelect_Disabled    = SPI_C1_SSOE(0)|SPI_C2_MODFEN(0),  //!< SS pin acts as GPIO when Master
   SpiPinSelect_FaultIn     = SPI_C1_SSOE(0)|SPI_C2_MODFEN(1),  //!< SS pin acts as FAULT in when Master
   SpiPinSelect_SlaveSelect = SPI_C1_SSOE(1)|SPI_C2_MODFEN(1),  //!< SS pin acts as SlaveSelect when Master
};

/**
 * Controls operation in Low Power mode
 */
enum SpiLowPower {
   SpiLowPower_Disabled = SPI_C2_SPISWAI(0), //!< SPI disabled in Low Power mode
   SpiLowPower_Enabled  = SPI_C2_SPISWAI(1), //!< SPI enabled in Low Power mode
};

/**
 * @brief Base class for representing an SPI interface
 */
class Spi : public SpiBasicInfo {

protected:
   // Pointer to hardware
   const HardwarePtr<SPI_Type> spi;  //!< SPI hardware

   // Number of bytes remaining in current transaction
   volatile uint32_t bytesRemaining;

   // Receive buffer pointer
   uint8_t  *rxDataPtr;

   // Transmit buffer pointer
   const    uint8_t  *txDataPtr;

   /**
    * Constructor
    *
    * @param[in]  baseAddress    Base address of SPI
    */
   constexpr Spi(uint32_t baseAddress) :
      spi(baseAddress), bytesRemaining(0), rxDataPtr(nullptr), txDataPtr(nullptr) {
   }

   /**
    * Destructor
    */
   virtual ~Spi() {
   }

   /**
    * Get SPI input clock frequency
    *
    * @return Clock frequency in Hz
    */
   virtual uint32_t getClockFrequency() = 0;

   /**
    * Calculate communication BR value for SPI
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * @return BR register value
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint8_t calculateBr(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Calculates speed from SPI clock frequency and SPI clock factors
    *
    * @param[in] clockFrequency   SPI input clock frequency
    * @param[in] clockFactors     SPI clock factors
    *
    * @return SPI frequency
    */
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t clockFactors);

#if defined(__CMSIS_RTOS)
   /**
    * Obtain SPI mutex
    *
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus getMutex(int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus releaseMutex() = 0;
#endif

   /**
    * Send 1st byte in a transmission
    */
   void sendFirstByte() {
      // Dummy status read
      (void)spi->S;
      if (bytesRemaining>0) {
         // Transmit byte
         if (txDataPtr != nullptr) {
            spi->D = *txDataPtr++;
         }
         else {
            // Dummy byte
            spi->D = 0xFF;
         }
      }
   }

   /**
    * Stop transmission
    */
   void stopTransaction() {
      spi->C1 = spi->C1 & ~SPI_C1_SPIE_MASK;
      rxDataPtr = nullptr;
      txDataPtr = nullptr;
   }

$(/SPI/private: // /SPI/private not found)
public:

$(/SPI/public: // /SPI/public not found)
#if defined(__CMSIS_RTOS)
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   osStatus startTransaction(SpiBasicInfo::Init &configuration, int milliseconds=osWaitForever) {
      // Obtain mutex
      osStatus status = getMutex(milliseconds);
      if (status == osOK) {
         // Change configuration for this transaction
         setConfiguration(configuration);
      }
      return status;
   }

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   osStatus startTransaction(int milliseconds=osWaitForever) {
      // Obtain mutex
      return getMutex(milliseconds);
   }

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   osStatus endTransaction() {
      // Release mutex
      return releaseMutex();
   }
#else
   /**
    * Obtain SPI and set SPI configuration
    *
    * @param[in] configuration The configuration values to set for the transaction.
    */
   int startTransaction(SpiBasicInfo::Init &configuration, int =0) {
      setConfiguration(configuration);
      return 0;
   }
   /**
    * Obtain SPI
    */
   int startTransaction(int =0) {
      return 0;
   }
   /**
    * Release SPI - dummy routine (non RTOS)
    */
   int endTransaction() {
      return 0;
   }
#endif

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(int frequency) {
      spi->BR = calculateBr(getClockFrequency(), frequency);
   }
   
#if $(/PCR/_present:false) // /PCR/_present   
   /**
    * Enable pins used by SPI
    */
   virtual void enablePins(bool enable=true) = 0;
#endif // /PCR/_present

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(Hertz frequency) {
      spi->BR = calculateBr(getClockFrequency(), uint32_t(frequency));
   }

   /**
    * Get communication speed of SPI
    *
    * @return Frequency in Hz
    */
   uint32_t getSpeed() {
      return calculateSpeed(getClockFrequency(), spi->BR);
   }

   /**
    *  Set Configuration\n
    *  This is a lightweight version that only does timing settings, \n
    *  word length and transmit order.\n
    *  It does not enable clock or calculate baud factors from speed.
    *  Assumes the interface is already acquired through startTransaction
    *
    *  @note The SPI is left disabled.
    *
    * @param[in]  configuration Configuration value
    */
   void setConfiguration(const SpiBasicInfo::Init &configuration) {
      spi->C1  = configuration.c1|SPI_C1_SPE_MASK;
      spi->C2  = configuration.c2;
      spi->BR  = configuration.br;
   }

   /**
    *  Get SPI configuration\n
    *  This includes timing settings, word length and transmit order
    *
    * @return Configuration value
    *
    * @note Typically used with startTransaction()
    */
   SpiBasicInfo::Init getConfiguration() {
      return SpiBasicInfo::Init(spi->C1, spi->C2, spi->BR);
   }

   /**
    *  Set SS Pin function
    *
    *  @param spiPinSelect Slave Select pin function in master mode
    */
   void setSlaveSelect(SpiPinSelect spiPinSelect) {
      spi->C1 = (spi->C1&~SPI_C1_SSOE_MASK)  |(spiPinSelect&SPI_C1_SSOE_MASK);
      spi->C2 = (spi->C2&~SPI_C2_MODFEN_MASK)|(spiPinSelect&SPI_C2_MODFEN_MASK);
   }

   /**
    * Controls operation in Low Power mode
    *
    * @param spiLowPower Options for low power mode
    */
   void setLowPowerMode(SpiLowPower spiLowPower) {
      spi->C2 = (spi->C2&~SPI_C2_SPISWAI_MASK)|(spiLowPower&SPI_C2_SPISWAI_MASK);
   }

   /**
    * Gets and clears status flags.
    *
    * @return status valkue (SPI->SR)
    */
   uint32_t getStatus() {
      // Capture interrupt status
      uint32_t status = spi->S;
      // Clear captured flags
      spi->S = status;
      // Return status
      return status;
   }

   /**
    *  Transmit and receive a series of bytes
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit bytes (may be nullptr for Receive only)
    *  @param[out] rxData    Receive byte buffer (may be nullptr for Transmit only)
    *
    *  @note: rxData may use same buffer as txData
    *  @note: Size of txData and rxData should be appropriate for transmission size.
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   ErrorCode txRx(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=nullptr) {
//      assert((txData != nullptr)||(rxData != nullptr));
      ErrorCode rc = E_NO_ERROR;

      bytesRemaining = dataSize;
      txDataPtr      = txData;
      rxDataPtr      = rxData;
      if constexpr (SpiBasicInfo::irqHandlerInstalled) {
         spi->C1 = spi->C1 | SPI_C1_SPE_MASK | SPI_C1_SPIE_MASK;
      }
      else {
         spi->C1 = spi->C1 | SPI_C1_SPE_MASK;
      }
      sendFirstByte();
      if (!SpiBasicInfo::irqHandlerInstalled) {
         // If not using interrupts then wait for completion
         do {
            rc = poll();
         } while (rc == E_BUSY);
      }
      return rc;
   }

   /**
    *  Transmit and receive a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[in]  txData    Transmit bytes
    *  @param[out] rxData    Receive byte buffer
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline))  ErrorCode txRx(uint8_t (&txData)[N], uint8_t (&rxData)[N]) {
      return txRx(N, txData, rxData);
   }

   /**
    *  Transmit a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[in]  txData    Transmit bytes
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline))  ErrorCode transmit(uint8_t (&txData)[N]) {
      return txRx(N, txData, nullptr);
   }

   /**
    *  Receive a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[out] rxData    Receive byte buffer
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline)) ErrorCode receive(uint8_t (&rxData)[N]) {
      return txRx(N, nullptr, rxData);
   }

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (8/16 bits)
    *
    * @return Data received
    */
   uint32_t txRx(uint32_t data) {
      while ((spi->S & SPI_S_SPTEF_MASK)==0) {
         __asm__("nop");
      }
      spi->D  = data;
      while ((spi->S & SPI_S_SPRF_MASK)==0) {
         __asm__("nop");
      }
      return spi->D; // Return read data
   }

};

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info  Class describing SPI hardware
 */
template<class Info>
class SpiBase_T : public Spi, public Info {

private:
   SpiBase_T() = delete;

   static SpiBase_T<Info> *thisPtr;

#ifdef __CMSIS_RTOS
   static CMSIS::Mutex mutex;
#endif

public:

   // Disambiguate Init
   using Init = Spi::Init;

   /**
    * IRQ handler
    */
   static void irqHandler() {
      thisPtr->_irqHandler();
   }

#ifdef __CMSIS_RTOS
protected:
   /**
    * Obtain SPI mutex
    *
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus getMutex(int milliseconds=osWaitForever) override {
      return mutex.wait(milliseconds);
   }

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus releaseMutex() override {
      return mutex.release();
   }
#endif

   /**
    * Get SPI input clock frequency
    *
    * @return Clock frequency in Hz
    */
   uint32_t getClockFrequency() override {
      return Info::getClockFrequency();
   }

public:
#if 0
   /** SPI SCK (clock) Pin */
   using sckGpio  = GpioTable_T<Info, 0, ActiveHigh>;

   /** SPI SIN (data in = usually MISO) Pin */
   using sinGpio  = GpioTable_T<Info, 1, ActiveHigh>;

   /** SPI SOUT (data out = usually MOSI) Pin */
   using soutGpio = GpioTable_T<Info, 2, ActiveHigh>;
#endif

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

$(/SPI/InitMethod: // /SPI/InitMethod not found)
#if $(/PCR/_present:false) // /PCR/_present   
   /**
    * Map/Unmap pins for peripheral
    *
    * @param enable
    */
   virtual void enablePins(bool enable) override {
      if (enable) {
         // Configure pins
         Info::initPCRs();
      }
      else {
         // Configure SPI pins to mux=0
         Info::clearPCRs();
      }
   }
#endif // /PCR/_present   

   /**
    * Constructor
    */
   SpiBase_T(const SpiBasicInfo::Init &init) : Spi(Info::baseAddress) {

#if $(/PCR/_present:false) // /PCR/_present   
#ifdef DEBUG_BUILD
      // Check pin assignments
      static_assert(Info::info[0].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - change in Configure.usbdmProject");
      static_assert(Info::info[1].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - change in Configure.usbdmProject");
      static_assert(Info::info[2].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - change in Configure.usbdmProject");
#endif

      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }
#endif // /PCR/_present   

      // Record this pointer for IRQ handler
      thisPtr = this;

      // Configure from supplied settings
      configure(init);
   }

   /**
    * Destructor
    */
   ~SpiBase_T() override {
   }

};

template<class Info> SpiBase_T<Info> *SpiBase_T<Info>::thisPtr = nullptr;
#ifdef __CMSIS_RTOS
template<class Info> CMSIS::Mutex     SpiBase_T<Info>::mutex;
#endif

$(/SPI/declarations)
/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM

#endif // /SPI/_BasicInfoGuard

#endif /* INCLUDE_USBDM_SPI_H_ */

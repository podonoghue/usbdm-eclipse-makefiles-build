/**
 * @file     rtc.h (180.ARM_Peripherals/Project_Headers/rtc.h)
 * @brief    Real Time Clock
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_RTC_H
#define HEADER_RTC_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */

/**
 * Type definition for RTC interrupt callback.
 * This is used for seconds and alarm callbacks.
 *
 *  @param[in]  timeSinceEpoch - Time since the epoch in seconds
 */
typedef void (*RtcCallbackFunction)(uint32_t timeSinceEpoch);

/**
 * Template class providing interface to Real Time Clock
 *
 * @tparam info      Information class for RTC
 *
 * @code
 * using rtc = RtcBase_T<RtcInfo>;
 *
 *  rtc::enableAlarmInterrupts();
 *
 * @endcode
 */
template <class Info>
class RtcBase_T {

public:
   /** Handler for unexpected interrupts */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

protected:
   /** Callback function for alarm ISR */
   static RtcCallbackFunction sAlarmCallback;

   /** Callback function for seconds ISR */
   static RtcCallbackFunction sSecondsCallback;

public:
   /**
    * Alarm IRQ handler
    */
   static void irqAlarmHandler(void) {
      // Clear alarm
      RtcBase_T<Info>::rtc->TAR   = 0;
      // Call handler
      sAlarmCallback(RtcBase_T<Info>::rtc->TSR);
   }

   /**
    * Alarm IRQ handler
    */
   static void irqSecondsHandler(void) {
      // Call handler
      sSecondsCallback(RtcBase_T<Info>::rtc->TSR);
   }

   /**
    * Enable/disable RTC Alarm interrupts
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableAlarmInterrupts(bool enable=true) {
      if (enable) {
         rtc->IER   |= RTC_IER_TAIE_MASK;
      }
      else {
         rtc->IER   &= ~RTC_IER_TAIE_MASK;
      }
   }
   /**
    * Enable/disable RTC Seconds interrupts
    *
    * @param[in]  enable True=>enable, False=>disable
    */
   static void enableSecondsInterrupts(bool enable=true) {
      if (enable) {
         rtc->IER   |= RTC_IER_TSIE_MASK;
      }
      else {
         rtc->IER   &= ~RTC_IER_TSIE_MASK;
      }
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match RtcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Rtc::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Rtc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t), T &object>
   static RtcCallbackFunction wrapCallback() {
      static RtcCallbackFunction fn = [](uint32_t timeSinceEpoch) {
         (object.*callback)(timeSinceEpoch);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match RtcCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Rtc::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Rtc::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t)>
   static RtcCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static RtcCallbackFunction fn = [](uint32_t timeSinceEpoch) {
         (obj.*callback)(timeSinceEpoch);
      };
      return fn;
   }

   /**
    * Set Alarm callback function
    *
    *  @param[in]  callback  Callback function to be executed on alarm interrupt.\n
    *                        Use nullptr to remove callback.
    */
   static void setAlarmCallback(RtcCallbackFunction callback) {
      static_assert(Info::irqAlarmHandlerInstalled, "RTC not configure for alarm interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sAlarmCallback = callback;
   }

   /**
    * Set Seconds callback function
    *
    *  @param[in]  callback  Callback function to be executed on seconds interrupt.\n
    *                        Use nullptr to remove callback.
    */
   static void setSecondsCallback(RtcCallbackFunction callback) {
      static_assert(Info::irqSecondsHandlerInstalled, "RTC not configure for seconds interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sSecondsCallback = callback;
   }


protected:
   /** Hardware instance */
   static constexpr HardwarePtr<RTC_Type> rtc = Info::baseAddress;

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Initialise RTC to default settings.
    * Configures all RTC pins
    */
   static void defaultConfigure() {

      // Enable clock to RTC interface
      // (RTC used its own clock internally)
      Info::enableClock();

#ifdef RTC_CR_OSCE_MASK
      if ((Info::cr&RTC_CR_OSCE_MASK) == 0) {
         // RTC disabled
         return;
      }
#endif

      configureAllPins();

      // Enable to debug RTX startup
#if defined(DEBUG_BUILD) && 0
      // Software reset RTC - trigger cold start
      rtc->CR  = RTC_CR_SWR_MASK;
      rtc->CR  = 0;

      // Disable interrupts
      rtc->IER  = 0;
#endif

      if ((rtc->SR&RTC_SR_TIF_MASK) != 0) {
         // RTC not running yet or invalid - re-initialise

         // Software reset RTC
         rtc->CR  = RTC_CR_SWR_MASK;
         rtc->CR  = 0;

         // Configure oscillator
         // Note - on KL25 this will disable the standard oscillator
         rtc->CR  = Info::cr;

         // Wait startup time
         for (int i=0; i<100000; i++) {
            __asm__("nop");
         }

         // Set current time
         rtc->TSR = Info::coldStartTime;
         rtc->SR  = RTC_SR_TCE_MASK;

         // Time compensation values
         rtc->TCR = RtcInfo::tcr;

         // Lock registers
         rtc->LR  = RtcInfo::lr;

#ifdef RTC_WAR_IERW_MASK
         // Write access
         rtc->WAR = RtcInfo::war;
#endif
#ifdef RTC_RAR_IERR_MASK
         // Read access
         rtc->RAR = RtcInfo::rar;
#endif
      }

      // Update settings
      rtc->CR   = Info::cr;
   }

   /**
    * Set up the RTC out of reset.
    */
   static void initialise() {
      if (RtcInfo::configure_rtc) {
         defaultConfigure();
      }
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
      if (Info::irqCount>1) {
         NVIC_EnableIRQ(Info::irqNums[1]);
      }
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
      if (Info::irqCount>1) {
         enableNvicInterrupt(Info::irqNums[1], nvicPriority);
      }
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
      if (Info::irqCount>1) {
         NVIC_DisableIRQ(Info::irqNums[1]);
      }
   }

   /**
    * Sets the system RTC time
    *
    *  @param[in]  timeSinceEpoch - time since the epoch in seconds
    */
   static void setTime(uint32_t timeSinceEpoch) {
      rtc->SR  = 0;
      rtc->TSR = timeSinceEpoch;
      rtc->SR  = RTC_SR_TCE_MASK;
   }

   /**
    *  Get current alarm time
    *
    *  @return alarm time as 32-bit number
    */
   static uint32_t getTime(void) {
      return rtc->TSR;
   }

   /**
    *  Get current alarm time
    *
    *  @return Alarm time in seconds relative to the epoch
    */
   static uint32_t getAlarmTime(void) {
      return rtc->TAR;
   }

   /**
    *  Set alarm time
    *
    *  @param[in]  timeSinceEpoch - Alarm time in seconds relative to the epoch
    */
   static void setAlarmTime(uint32_t timeSinceEpoch) {
      rtc->TAR = timeSinceEpoch;
   }

};

template<class Info> RtcCallbackFunction RtcBase_T<Info>::sAlarmCallback   = unhandledCallback;
template<class Info> RtcCallbackFunction RtcBase_T<Info>::sSecondsCallback = unhandledCallback;

#ifdef USBDM_RTC_IS_DEFINED
/**
 * Class representing RTC
 */
class Rtc : public RtcBase_T<RtcInfo>{};
#endif

/**
 * End RTC_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_RTC_H */

/**
 * @file     dac.h (180.ARM_Peripherals/Project_Headers/dac.h)
 * @brief    Abstraction layer for DAC interface
 */

#ifndef HEADERS_DAC_H_
#define HEADERS_DAC_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

$(/DAC/peripheral_h_definition:// $/DAC/peripheral_h_definition not found)
/**
 * @addtogroup DAC_Group DAC, Digital-to-Analogue Converter
 * @brief Pins used for Digital-to-Analogue Converter
 * @{
 */

/**
 * Template class representing a Digital to Analogue Converter
 *
 * @tparam info      Information class for DAC
 *
 * @code
 * using dac = Dac_T<Dac0Info>;
 *
 *  dac::configure();
 *
 * @endcode
 */
template<class Info>
class DacBase_T : public Info {

protected:

   /** Class to static check output is mapped to a pin - Assumes existence */
   template<int dacOutput> class CheckOutputIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[dacOutput].gpioBit >= 0);

      static_assert(Test1, "DAC output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

protected:
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback(uint8_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   using Info::configure;

   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static constexpr HardwarePtr<DAC_Type> dac = Info::baseAddress;

   /** Get base address of DAC hardware as uint32_t */
   static constexpr uint32_t dacBase() { return Info::baseAddress; }

   /** Get base address of DAC.DATA register as uint32_t */
   static constexpr uint32_t dacData() { return dacBase() + offsetof(DAC_Type, DATA[0]); }

   /** Get base address of DAC.DATA[index] register as uint32_t */
   static constexpr uint32_t dacData(unsigned index) { return dacBase() + offsetof(DAC_Type, DATA) + index*sizeof(DAC_Type::DATA[0]); }
$(/DAC/classInfo: // No class Info found)

$(/DAC/InitMethod: // /DAC/InitMethod not found)

   /**
    * Configure DAC.
    * Interrupts are initially disabled.
    *
    * @param dacReferenceSelect     Reference Select
    * @param dacPower               Power control
    * @param dacTriggerSelect       Trigger Select
    */
   static void configure(
         DacReferenceSelect dacReferenceSelect = DacReferenceSelect_Vdda,
         DacPower           dacPower           = DacPower_Low,
         DacTriggerSelect   dacTriggerSelect   = DacTriggerSelect_Software) {

      Info::enable();
      dac->C0 = DAC_C0_DACEN_MASK|dacReferenceSelect|dacTriggerSelect|dacPower;
   }

#ifdef DAC_C1_DACBFWM
   /**
    *  Configure DAC buffer operation
    *
    * @param dacBufferMode  Select if buffer is used and how the buffer pointer changes.
    * @param dacWaterMark   Selects water mark level for buffer.
    */
   static void configureBuffer(
         DacBufferMode dacBufferMode  = DacBufferMode_Disabled,
         DacWaterMark  dacWaterMark   = DacWaterMark_Normal_1
          ) {
      dac->C1 =
            (dac->C1&~(DAC_C1_DACBFEN_MASK|DAC_C1_DACBFMD_MASK|DAC_C1_DACBFWM_MASK))|
            dacBufferMode|dacWaterMark;
   }
#else
   /**
    *  Configure DAC buffer operation
    *
    * @param dacBufferMode  Select if buffer is used and how the buffer pointer changes.
    */
   static void configureBuffer(
         DacBufferMode dacBufferMode  = DacBufferMode_Disabled
          ) {
      dac->C1 =
            (dac->C1&~(DAC_C1_DACBFEN_MASK|DAC_C1_DACBFMD_MASK))|
            dacBufferMode;
   }
#endif

   /**
    * Get output range of DAC
    *
    * @return Range of DAC e.g. 2^12-1
    */
   static constexpr unsigned getRange() {
      return DAC_DATA_DATA_MASK;
   }

   /**
    * Get size of ADC buffer
    *
    * @return size in entries
    */
   static constexpr unsigned getBufferSize() {
      return sizeofArray(dac->DATA);
   }

   /**
    * Used to modify the FIFO read and write pointers in FIFO mode.
    *
    * @param writePtr  Write pointer
    * @param readPtr   Read pointer
    */
   static void setFifoPointers(uint8_t writePtr, uint8_t readPtr) {
      usbdm_assert(readPtr<getBufferSize(), "Illegal read pointer");
      usbdm_assert(writePtr<getBufferSize(),"Illegal write pointer");
      dac->C2 = DAC_C2_DACBFRP(readPtr)|DAC_C2_DACBFUP(writePtr);
   }

   /**
    * Clear (empty) FIFO.
    */
   static void clearFifo() {
      dac->C2 = DAC_C2_DACBFRP(0)|DAC_C2_DACBFUP(0);
   }

   /**
    * Set buffer upper limit in buffered modes.
    *
    * @param limit Upper limit for buffer index (inclusive)
    */
   static void setBufferLimit(uint8_t limit) {
      usbdm_assert(limit<getBufferSize(),"Illegal limit value");
      dac->C2 = (dac->C2&~DAC_C2_DACBFUP_MASK)|DAC_C2_DACBFUP(limit);
   }

   /**
    * Set buffer write index in buffered modes.
    *
    * @param index Write index (0..N)
    */
   static void setBufferWritePointer(uint8_t index) {
      usbdm_assert(index<getBufferSize(),"Illegal write index");
      dac->C2 = (dac->C2&~DAC_C2_DACBFRP_MASK)|DAC_C2_DACBFRP(index);
   }

   /**
    * Enable DMA mode
    */
   static void enableDma() {
      dac->C1 = dac->C1 | DAC_C1_DMAEN_MASK;
   }

   /**
    * Disable DMA mode
    */
   static void disableDma() {
      dac->C1 = dac->C1 & ~DAC_C1_DMAEN_MASK;
   }

   /**
    * Do a software trigger on the DAC.
    * If DAC software trigger is selected and buffer is enabled then
    * the buffer read pointer will be advanced once.
    */
   static void softwareTrigger() {
      dac->C0 = dac->C0 | DAC_C0_DACSWTRG_MASK;
   }

   /**
    * Enable DAC output pin as output.
    * Configures all Pin Control Register (PCR) values
    */
   static void setOutput() {

      CheckOutputIsMapped<Info::outputPin>::check();

      using Pcr = PcrTable_T<Info, Info::outputPin>;

      // Enable and map pin to CMP_OUT
      Pcr::setPCR();
   }

   /**
    * Get DAC status
    *
    * @return DAC status value see DacStatus
    */
   static uint8_t getStatus() {
      return dac->SR;
   }

   /**
    *   Disable the DAC
    */
   static void finalise() {
      // Enable timer
      dac->C0 = 0;
      dac->C1 = 0;
      Info::disableClock();
   }
   /**
    * Write output value for non-buffered mode or write value to FIFO for FIFO mode.
    *
    * @param value 12-bit value to write to DAC or FIFO
    */
   static void writeValue(uint16_t value) {
      dac->DATA[0] = DAC_DATA_DATA(value);
   }

   /**
    * Write DAC value to buffer (for buffered non-FIFO modes).
    *
    * @param index Index value for output buffer
    * @param value 12-bit value to write to DAC output buffer
    */
   static void writeValue(unsigned index, uint16_t value) {
      usbdm_assert(index<getBufferSize(), "Buffer index out of range");
      dac->DATA[index] = DAC_DATA_DATA(value);
   }

};

$(/DAC/declarations: // No declarations found)
/**
 * End DAC_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADERS_DAC_H_ */

/**
 * @file     dac.h (180.ARM_Peripherals/Project_Headers/dac.h)
 * @brief    Abstraction layer for DAC interface
 *
 * @version  V4.12.1.240
 * @date     28/10/2018
 */

#ifndef HEADERS_DAC_H_
#define HEADERS_DAC_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * DAC status value as individual flags
 */
union DacStatus {
   uint8_t raw;
   struct {
      bool     readPointerBottomFlag:1;
      bool     readPointerTopFlag:1;
#ifdef DAC_C0_DACBWIEN
      bool     watermarkFlag:1;
#endif
   };
   constexpr DacStatus(uint8_t value) : raw(value) {
   }
};

/**
 * @addtogroup DAC_Group DAC, Digital-to-Analogue Converter
 * @brief Pins used for Digital-to-Analogue Converter
 * @{
 */
/**
 * Type definition for DAC interrupt call back
 */
typedef void (*DacCallbackFunction)(DacStatus);

/**
 * Template class representing a Digital to Analogue Converter
 *
 * @tparam info      Information class for DAC
 *
 * @code
 * using dac = Dac_T<Dac0Info>;
 *
 *  dac::configure();
 *
 * @endcode
 */
template<class Info>
class DacBase_T {

protected:

   /** Class to static check output is mapped to a pin - Assumes existence */
   template<int dacOutput> class CheckOutputIsMapped {

      // Check mapping - no need to check existence
      static constexpr bool Test1 = (Info::info[dacOutput].gpioBit >= 0);

      static_assert(Test1, "DAC output is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback(DacStatus) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static DacCallbackFunction sCallback;

public:
   /**
    * Hardware instance pointer
    *
    * @return Reference to CMT hardware
    */
   static constexpr HardwarePtr<DAC_Type> dac = Info::baseAddress;

   /** Get base address of DAC hardware as uint32_t */
   static constexpr uint32_t dacBase() { return Info::baseAddress; }

   /** Get base address of DAC.DATA register as uint32_t */
   static constexpr uint32_t dacData() { return dacBase() + offsetof(DAC_Type, DATA[0]); }

   /** Get base address of DAC.DATA[index] register as uint32_t */
   static constexpr uint32_t dacData(unsigned index) { return dacBase() + offsetof(DAC_Type, DATA) + index*sizeof(DAC_Type::DATA[0]); }

   /**
    * IRQ handler
    */
   static void irqHandler() {
      // Call handler
      sCallback(getAndClearStatus());
   }

$(/DAC/classInfo: // No class Info found)
   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match DacCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Dac::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Dac::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(DacStatus), T &object>
   static DacCallbackFunction wrapCallback() {
      static DacCallbackFunction fn = [](DacStatus status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match DacCallbackFunction
    *    void callback() {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Pit::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Dac::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(DacStatus)>
   static DacCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static DacCallbackFunction fn = [](DacStatus status) {
         (obj.*callback)(status);
      };
      return fn;
   }

   /**
    * Set callback function
    *
    * @param[in] callback Callback function to execute on interrupt.\n
    *                     Use nullptr to remove callback.
    */
   static void setCallback(DacCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "DAC not configured for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallback = callback;
   }

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Initialise hardware
      dac->C0 = Info::c0|DAC_C0_DACEN_MASK;
      dac->C1 = Info::c1;
      dac->C2 = Info::c2;
   }

   /**
    * Configure DAC.
    * Interrupts are initially disabled.
    *
    * @param dacReferenceSelect     Reference Select
    * @param dacPower               Power control
    * @param dacTriggerSelect       Trigger Select
    */
   static void configure(
         DacReferenceSelect dacReferenceSelect = DacReferenceSelect_Vdda,
         DacPower           dacPower           = DacPower_Low,
         DacTriggerSelect   dacTriggerSelect   = DacTriggerSelect_Software) {

      enable();
      dac->C0 = DAC_C0_DACEN_MASK|dacReferenceSelect|dacTriggerSelect|dacPower;
   }

#ifdef DAC_C1_DACBFWM
   /**
    *  Configure DAC buffer operation
    *
    * @param dacBufferMode  Select if buffer is used and how the buffer pointer changes.
    * @param dacWaterMark   Selects water mark level for buffer.
    */
   static void configureBuffer(
         DacBufferMode dacBufferMode  = DacBufferMode_Disabled,
         DacWaterMark  dacWaterMark   = DacWaterMark_Normal_1
          ) {
      dac->C1 =
            (dac->C1&~(DAC_C1_DACBFEN_MASK|DAC_C1_DACBFMD_MASK|DAC_C1_DACBFWM_MASK))|
            dacBufferMode|dacWaterMark;
   }
#else
   /**
    *  Configure DAC buffer operation
    *
    * @param dacBufferMode  Select if buffer is used and how the buffer pointer changes.
    */
   static void configureBuffer(
         DacBufferMode dacBufferMode  = DacBufferMode_Disabled
          ) {
      dac->C1 =
            (dac->C1&~(DAC_C1_DACBFEN_MASK|DAC_C1_DACBFMD_MASK))|
            dacBufferMode;
   }
#endif

   /**
    * Get output range of DAC
    *
    * @return Range of DAC e.g. 2^12-1
    */
   static constexpr unsigned getRange() {
      return DAC_DATA_DATA_MASK;
   }

   /**
    * Get size of ADC buffer
    *
    * @return size in entries
    */
   static constexpr unsigned getBufferSize() {
      return sizeof(dac->DATA)/sizeof(dac->DATA[0]);
   }

   /**
    * Used to modify the FIFO read and write pointers in FIFO mode.
    *
    * @param writePtr  Write pointer
    * @param readPtr   Read pointer
    */
   static void setFifoPointers(uint8_t writePtr, uint8_t readPtr) {
      usbdm_assert(readPtr<getBufferSize(), "Illegal read pointer");
      usbdm_assert(writePtr<getBufferSize(),"Illegal write pointer");
      dac->C2 = DAC_C2_DACBFRP(readPtr)|DAC_C2_DACBFUP(writePtr);
   }

   /**
    * Clear (empty) FIFO.
    */
   static void clearFifo() {
      dac->C2 = DAC_C2_DACBFRP(0)|DAC_C2_DACBFUP(0);
   }

   /**
    * Set buffer upper limit in buffered modes.
    *
    * @param limit Upper limit for buffer index (inclusive)
    */
   static void setBufferLimit(uint8_t limit) {
      usbdm_assert(limit<getBufferSize(),"Illegal limit value");
      dac->C2 = (dac->C2&~DAC_C2_DACBFUP_MASK)|DAC_C2_DACBFUP(limit);
   }

   /**
    * Set buffer write index in buffered modes.
    *
    * @param index Write index (0..N)
    */
   static void setBufferWritePointer(uint8_t index) {
      usbdm_assert(index<getBufferSize(),"Illegal write index");
      dac->C2 = (dac->C2&~DAC_C2_DACBFRP_MASK)|DAC_C2_DACBFRP(index);
   }

   /**
    * Enable DMA mode
    */
   static void enableDma() {
      dac->C1 = dac->C1 | DAC_C1_DMAEN_MASK;
   }

   /**
    * Disable DMA mode
    */
   static void disableDma() {
      dac->C1 = dac->C1 & ~DAC_C1_DMAEN_MASK;
   }

   /**
    * Do a software trigger on the DAC.
    * If DAC software trigger is selected and buffer is enabled then
    * the buffer read pointer will be advanced once.
    */
   static void softwareTrigger() {
      dac->C0 = dac->C0 | DAC_C0_DACSWTRG_MASK;
   }

#ifdef DAC_C0_DACBWIEN_MASK
   /**
    * Enable or disable interrupts.
    * The flags are cleared first.
    *
    * @param dacTopFlagIrq       Interrupt Enable for buffer read pointer is zero.
    * @param dacBottomFlagIrq    Interrupt Enable for buffer read pointer is equal to buffer limit C2.DACBFUP.
    * @param dacWatermarkIrq     Interrupt Enable for buffer read pointer has reached the watermark level.
    */
   static void enableInterrupts(
         DacTopFlagIrq      dacTopFlagIrq,
         DacBottomFlagIrq   dacBottomFlagIrq,
         DacWatermarkIrq    dacWatermarkIrq   = DacWatermarkIrq_Disabled) {

      // Clear flags
      dac->SR = DAC_SR_DACBFRPBF_MASK|DAC_SR_DACBFRPTF_MASK|DAC_SR_DACBFWMF_MASK;

      // Enable/disable flags
      dac->C0 = (dac->C0&~(DAC_C0_DACBWIEN_MASK|DAC_C0_DACBTIEN_MASK|DAC_C0_DACBBIEN_MASK)) |
            dacTopFlagIrq|dacBottomFlagIrq|dacWatermarkIrq;
   }
#else
   /**
    * Enable or disable interrupts.
    * The flags are cleared first.
    *
    * @param dacTopFlagIrq       Buffer Read Pointer Top Flag Interrupt Enable
    * @param dacBottomFlagIrq    Buffer Read Pointer Bottom Flag Interrupt Enable
    */
   static void enableInterrupts(
         DacTopFlagIrq      dacTopFlagIrq,
         DacBottomFlagIrq   dacBottomFlagIrq) {

      // Clear flags
      dac->SR = 0;

      // Enable/disable flags
      dac->C0 = (dac->C0&~(DAC_C0_DACBTIEN_MASK|DAC_C0_DACBBIEN_MASK)) |
            dacTopFlagIrq|dacBottomFlagIrq;
   }
#endif

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable DAC output pin as output.
    * Configures all Pin Control Register (PCR) values
    */
   static void setOutput() {

      CheckOutputIsMapped<Info::outputPin>::check();

      using Pcr = PcrTable_T<Info, Info::outputPin>;

      // Enable and map pin to CMP_OUT
      Pcr::setPCR();
   }

   /**
    * Get DAC status
    *
    * @return DAC status value see DacStatus
    */
   static DacStatus getStatus() {
      return (DacStatus)dac->SR;
   }

   /**
    * Get and clear DAC status
    *
    * @return DAC status value see DacStatus
    */
   static DacStatus getAndClearStatus() {
      // Get status
      uint8_t status = dac->SR;
      // Clear set flags
      dac->SR = ~status;
      // return original status
      return (DacStatus)status;
   }
   /**
    *   Disable the DAC
    */
   static void finalise() {
      // Enable timer
      dac->C0 = 0;
      dac->C1 = 0;
      Info::disableClock();
   }
   /**
    * Write output value for non-buffered mode or write value to FIFO for FIFO mode.
    *
    * @param value 12-bit value to write to DAC or FIFO
    */
   static void writeValue(uint16_t value) {
      dac->DATA[0] = DAC_DATA_DATA(value);
   }

   /**
    * Write DAC value to buffer (for buffered non-FIFO modes).
    *
    * @param index Index value for output buffer
    * @param value 12-bit value to write to DAC output buffer
    */
   static void writeValue(unsigned index, uint16_t value) {
      usbdm_assert(index<getBufferSize(), "Buffer index out of range");
      dac->DATA[index] = DAC_DATA_DATA(value);
   }

};

/**
 * Callback table for programmatically set handlers
 */
template<class Info> DacCallbackFunction DacBase_T<Info>::sCallback =  DacBase_T<Info>::unhandledCallback;

$(/DAC/declarations: // No declarations found)
/**
 * @}
 */
} // End namespace USBDM

#endif /* HEADERS_DAC_H_ */

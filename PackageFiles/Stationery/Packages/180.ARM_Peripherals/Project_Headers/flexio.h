/**
 * @file     flexio.h (180.ARM_Peripherals/Project_Headers/flexio.h)
 * @brief    Flexible I/O
 *
 * @version  V4.12.1.240
 * @date     14 November 2021
 */

#ifndef HEADER_FLEXIO_H
#define HEADER_FLEXIO_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"

namespace USBDM {

/**
 * @addtogroup FLEXIO_Group FLEXIO, Flexible I/O
 * @brief Abstraction for Flexible I/O
 * @{
 */
 
/**
 * Doze Enable
 * Controls disabling of FlexIO operation in Doze modes.
 * The FlexIO always disabled in low-leakage stop modes.
 */
enum FlexioPower {
   FlexioPower_DisabledInDoze = FLEXIO_CTRL_DOZEN(1), /**< FlexIO disabled in Doze modes.*/
   FlexioPower_EnabledInDoze  = FLEXIO_CTRL_DOZEN(0), /**< FlexIO enabled in Doze modes. */
};

/**
 * Debug Enable
 * Enables FlexIO operation in Debug mode.
 */
enum FlexioDebug {
   FlexioDebug_Disabled = FLEXIO_CTRL_DBGE(0), /**< FlexIO is disabled in debug modes */
   FlexioDebug_Enabled  = FLEXIO_CTRL_DBGE(0), /**< FlexIO is enabled in debug modes */
};

/**
 * Fast Access
 * Enables fast register accesses to FlexIO registers, but requires the FlexIO clock to be
 * at least twice the frequency of the bus clock.
 */
enum FlexioFastAccess {
   FlexioFastAccess_Disabled = FLEXIO_CTRL_FASTACC(0),  /**< Configures for normal register accesses to FlexIO */
   FlexioFastAccess_Enabled  = FLEXIO_CTRL_FASTACC(1),  /**< Configures for fast register accesses to FlexIO */
};

/**
 * FlexIO Enable
 */
enum FlexioEnable {
   Flexio_Enabled  = FLEXIO_CTRL_FLEXEN(0),  /**< FlexIO module is disabled. */
   Flexio_Disabled = FLEXIO_CTRL_FLEXEN(1),  /**< FlexIO module is enabled. */
};

/**
 * Shifter Select.
 * Selects which Shifter is used
 */
enum FlexioShifterSelect {
   FlexioShifterSelect_0 = 0,
   FlexioShifterSelect_1 = 1,
#if FLEXIO_SHIFTER_COUNT >= 2
   FlexioShifterSelect_2 = 2,
   FlexioShifterSelect_3 = 3,
#endif
#if FLEXIO_SHIFTER_COUNT >= 4
   FlexioShifterSelect_4 = 4,
   FlexioShifterSelect_5 = 5,
#endif
#if FLEXIO_SHIFTER_COUNT >= 6
   FlexioShifterSelect_6 = 6,
   FlexioShifterSelect_7 = 7,
#endif
};

/**
 * Timer Select.
 * Selects which Timer is used for controlling the logic/shift register and generating the Shift clock.
 */
enum FlexioTimerSelect {
   FlexioTimerSelect_0 = 0,
   FlexioTimerSelect_1 = 1,
#if FLEXIO_TIMER_COUNT >= 2
   FlexioTimerSelect_2 = 2,
   FlexioTimerSelect_3 = 3,
#endif
#if FLEXIO_TIMER_COUNT >= 4
   FlexioTimerSelect_4 = 4,
   FlexioTimerSelect_5 = 5,
#endif
#if FLEXIO_TIMER_COUNT >= 6
   FlexioTimerSelect_6 = 6,
   FlexioTimerSelect_7 = 7,
#endif
};

/**
 * Timer Polarity.
 */
enum FlexioTimerEdge {
   FlexioTimerEdge_Rising  = FLEXIO_SHIFTCTL_TIMPOL(0), /**< Shift on rising clock edge */
   FlexioTimerEdge_Falling = FLEXIO_SHIFTCTL_TIMPOL(1), /**< Shift on falling clock edge */
};

/**
 * Shifter/Timer Pin Configuration
 *
 * This assumes TIMCTL and SHIFTCTL select the pin configuration identically.
 */
#if FLEXIO_SHIFTCTL_PINCFG_MASK != FLEXIO_TIMCTL_PINCFG_MASK
#error "Assumed FLEXIO_SHIFTCTL_PINCFG == FLEXIO_TIMCTL_PINCFG failed"
#endif
enum FlexioPinAction {
   FlexioPinAction_Disabled      = FLEXIO_SHIFTCTL_PINCFG(0b00),  /**< Shifter/Timer pin output disabled */
   FlexioPinAction_OutputEnable  = FLEXIO_SHIFTCTL_PINCFG(0b01),  /**< Shifter/Timer pin open drain or bidirectional output enable */
   FlexioPinAction_InputOutput   = FLEXIO_SHIFTCTL_PINCFG(0b10),  /**< Shifter/Timer pin bidirectional output data */
   FlexioPinAction_Output        = FLEXIO_SHIFTCTL_PINCFG(0b11),  /**< Shifter/Timer pin output */
};

/**
 * Shifter Pin Select.
 * Selects which pin is used by the Shifter input or output, or timer trigger select.
 *
 * This assumes TIMCTL and SHIFTCTL select the pin identically.
 */
#if FLEXIO_SHIFTCTL_PINSEL_MASK != FLEXIO_TIMCTL_PINSEL_MASK
#error "Assumed FLEXIO_SHIFTCTL_PINSEL == FLEXIO_TIMCTL_PINSEL failed"
#endif
enum FlexioPinSel {
   FlexioPinSel_0  = FLEXIO_SHIFTCTL_PINSEL(0 ), FlexioPinSel_1  = FLEXIO_SHIFTCTL_PINSEL(1 ),
   FlexioPinSel_2  = FLEXIO_SHIFTCTL_PINSEL(2 ), FlexioPinSel_3  = FLEXIO_SHIFTCTL_PINSEL(3 ),
#if FLEXIO_PIN_COUNT >= 4
   FlexioPinSel_4  = FLEXIO_SHIFTCTL_PINSEL(4 ), FlexioPinSel_5  = FLEXIO_SHIFTCTL_PINSEL(5 ),
   FlexioPinSel_6  = FLEXIO_SHIFTCTL_PINSEL(6 ), FlexioPinSel_7  = FLEXIO_SHIFTCTL_PINSEL(7 ),
#endif
#if FLEXIO_PIN_COUNT >= 8
   FlexioPinSel_8  = FLEXIO_SHIFTCTL_PINSEL(8 ), FlexioPinSel_9  = FLEXIO_SHIFTCTL_PINSEL(9 ),
   FlexioPinSel_10 = FLEXIO_SHIFTCTL_PINSEL(10), FlexioPinSel_11 = FLEXIO_SHIFTCTL_PINSEL(11),
#endif
#if FLEXIO_PIN_COUNT >= 12
   FlexioPinSel_12 = FLEXIO_SHIFTCTL_PINSEL(12), FlexioPinSel_13 = FLEXIO_SHIFTCTL_PINSEL(13),
   FlexioPinSel_14 = FLEXIO_SHIFTCTL_PINSEL(14), FlexioPinSel_15 = FLEXIO_SHIFTCTL_PINSEL(15),
#endif
#if FLEXIO_PIN_COUNT >= 16
   FlexioPinSel_16 = FLEXIO_SHIFTCTL_PINSEL(16), FlexioPinSel_17 = FLEXIO_SHIFTCTL_PINSEL(17),
   FlexioPinSel_18 = FLEXIO_SHIFTCTL_PINSEL(18), FlexioPinSel_19 = FLEXIO_SHIFTCTL_PINSEL(19),
   FlexioPinSel_20 = FLEXIO_SHIFTCTL_PINSEL(20), FlexioPinSel_21 = FLEXIO_SHIFTCTL_PINSEL(21),
   FlexioPinSel_22 = FLEXIO_SHIFTCTL_PINSEL(22), FlexioPinSel_23 = FLEXIO_SHIFTCTL_PINSEL(23),
#endif
#if FLEXIO_PIN_COUNT >= 24
   FlexioPinSel_24 = FLEXIO_SHIFTCTL_PINSEL(24), FlexioPinSel_25 = FLEXIO_SHIFTCTL_PINSEL(25),
   FlexioPinSel_26 = FLEXIO_SHIFTCTL_PINSEL(26), FlexioPinSel_27 = FLEXIO_SHIFTCTL_PINSEL(27),
   FlexioPinSel_28 = FLEXIO_SHIFTCTL_PINSEL(28), FlexioPinSel_29 = FLEXIO_SHIFTCTL_PINSEL(29),
   FlexioPinSel_30 = FLEXIO_SHIFTCTL_PINSEL(30), FlexioPinSel_31 = FLEXIO_SHIFTCTL_PINSEL(31),
#endif
$(/FLEXIO/PinList: // No mapped pins found)
};

/**
 * Shifter/Timer Pin Polarity
 *
 * This assumes TIMCTL and SHIFTCTL select the pin polarity identically.
 */
#if FLEXIO_SHIFTCTL_PINPOL_MASK != FLEXIO_TIMCTL_PINPOL_MASK
#error "Assumed FLEXIO_SHIFTCTL_PINPOL == FLEXIO_TIMCTL_PINPOL failed"
#endif
enum FlexioPinPolarity {
   FlexioPinPolarity_ActiveHigh = FLEXIO_SHIFTCTL_PINPOL(0), /**< Pin is ActiveHigh */
   FlexioPinPolarity_ActiveLow  = FLEXIO_SHIFTCTL_PINPOL(1), /**< Pin is ActiveLow */
};

/**
 * Shifter Mode.
 * Configures the mode of the Shifter.
 */
enum FlexioShiftMode {
   /**< Disabled. */
   FlexioShiftMode_Disabled         = FLEXIO_SHIFTCTL_SMOD(0b000),
   /**< Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer. */
   FlexioShiftMode_Receive          = FLEXIO_SHIFTCTL_SMOD(0b001),
   /**< Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer. */
   FlexioShiftMode_Transmit         = FLEXIO_SHIFTCTL_SMOD(0b010),
   /**< Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer. */
   FlexioShiftMode_Match_Store      = FLEXIO_SHIFTCTL_SMOD(0b100),
   /**< Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents. */
   FlexioShiftMode_Match_Continuous = FLEXIO_SHIFTCTL_SMOD(0b101),
   /**< State mode. SHIFTBUF contents are used for storing programmable state attributes. */
   FlexioShiftMode_State            = FLEXIO_SHIFTCTL_SMOD(0b110),
   /**< Logic mode. SHIFTBUF contents are used for implementing programmable logic look up table. */
   FlexioShiftMode_Logic            = FLEXIO_SHIFTCTL_SMOD(0b111),
};

/**
 * Parallel Width.
 * For all Shifters, this register field configures the number of bits to be shifted on each Shift clock.
 *
 * For Shifters which support parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHIFTER3,SHIFTER7),
 * this register field, together with PSEL, also selects the pins to be driven or sampled on each
 * shift clock as follows:
 *    FXIO_D[PSEL+PWIDTH-1]:FXIO_D[PSEL]
 *
 * For SMOD=State, this field is used to disable state outputs. See 'State Mode' section for more detail.
 */
enum FlexioShiftBy {
   /** 1 bit shift */
   FlexioShiftBy_1  = FLEXIO_SHIFTCFG_PWIDTH(0 ),

   /** 4 bit shift */
   FlexioShiftBy_2  = FLEXIO_SHIFTCFG_PWIDTH(1 ), FlexioShiftBy_3  = FLEXIO_SHIFTCFG_PWIDTH(2 ),
   FlexioShiftBy_4  = FLEXIO_SHIFTCFG_PWIDTH(3 ),

   /** 8 bit shift */
   FlexioShiftBy_5  = FLEXIO_SHIFTCFG_PWIDTH(4 ), FlexioShiftBy_6  = FLEXIO_SHIFTCFG_PWIDTH(5 ),
   FlexioShiftBy_7  = FLEXIO_SHIFTCFG_PWIDTH(6 ), FlexioShiftBy_8  = FLEXIO_SHIFTCFG_PWIDTH(7 ),

   /** 16 bit shift */
   FlexioShiftBy_9  = FLEXIO_SHIFTCFG_PWIDTH(8 ), FlexioShiftBy_10 = FLEXIO_SHIFTCFG_PWIDTH(9 ),
   FlexioShiftBy_11 = FLEXIO_SHIFTCFG_PWIDTH(10), FlexioShiftBy_12 = FLEXIO_SHIFTCFG_PWIDTH(11),
   FlexioShiftBy_13 = FLEXIO_SHIFTCFG_PWIDTH(12), FlexioShiftBy_14 = FLEXIO_SHIFTCFG_PWIDTH(13),
   FlexioShiftBy_15 = FLEXIO_SHIFTCFG_PWIDTH(14), FlexioShiftBy_16 = FLEXIO_SHIFTCFG_PWIDTH(15),

   /** 32 bit shift */
   FlexioShiftBy_17 = FLEXIO_SHIFTCFG_PWIDTH(16), FlexioShiftBy_18 = FLEXIO_SHIFTCFG_PWIDTH(17),
   FlexioShiftBy_19 = FLEXIO_SHIFTCFG_PWIDTH(18), FlexioShiftBy_20 = FLEXIO_SHIFTCFG_PWIDTH(19),
   FlexioShiftBy_21 = FLEXIO_SHIFTCFG_PWIDTH(20), FlexioShiftBy_22 = FLEXIO_SHIFTCFG_PWIDTH(21),
   FlexioShiftBy_23 = FLEXIO_SHIFTCFG_PWIDTH(22), FlexioShiftBy_24 = FLEXIO_SHIFTCFG_PWIDTH(23),
   FlexioShiftBy_25 = FLEXIO_SHIFTCFG_PWIDTH(24), FlexioShiftBy_26 = FLEXIO_SHIFTCFG_PWIDTH(25),
   FlexioShiftBy_27 = FLEXIO_SHIFTCFG_PWIDTH(26), FlexioShiftBy_28 = FLEXIO_SHIFTCFG_PWIDTH(27),
   FlexioShiftBy_29 = FLEXIO_SHIFTCFG_PWIDTH(28), FlexioShiftBy_30 = FLEXIO_SHIFTCFG_PWIDTH(29),
   FlexioShiftBy_31 = FLEXIO_SHIFTCFG_PWIDTH(30), FlexioShiftBy_32 = FLEXIO_SHIFTCFG_PWIDTH(31),
};

/**
 * Input Source
 * Selects the input source for the shifter.
 */
enum FlexioInputSource {
   FlexioInputSource_Pin     = FLEXIO_SHIFTCFG_INSRC(0), /**< Pin */
   FlexioInputSource_Shufter = FLEXIO_SHIFTCFG_INSRC(1), /**< Shifter N+1 Output */
};

/**
 * Shifter Stop bit.
 *
 * - SMOD=Transmit
 *   This field allows automatic stop bit insertion if the selected timer has also enabled a stop bit.
 * - SMOD=Receive or Match Store
 *   This field allows automatic stop bit checking if the selected timer has also enabled a stop bit.
 * - SMOD=State
 *   This field is used to disable state outputs. See 'State Mode' section for more detail.
 * - SMOD=Logic
 *   This field is used to mask logic pin inputs. See 'Logic Mode' section for more detail.
 */
enum FlexioStopBit {
   /** Stop bit disabled for transmitter/receiver/match store */
   FlexioStopBit_Disabled = FLEXIO_SHIFTCFG_SSTOP(0b00),
   /** Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0 */
   FlexioStopBit_0        = FLEXIO_SHIFTCFG_SSTOP(0b10),
   /** Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1 */
   FlexioStopBit_1        = FLEXIO_SHIFTCFG_SSTOP(0b11),
};

/**
 * Shifter Start bit.
 *
 *  - SMOD=Transmit
 *    This field allows automatic start bit insertion if the selected timer has also enabled a start bit.
 *  - SMOD=Receive or Match Store
 *    This field allows automatic start bit checking if the selected timer has also enabled a start bit.
 *  - SMOD=State
 *    This field is used to disable state outputs. See 'State Mode' section for more detail.
 *  - SMOD=Logic
 *    This field is used to mask logic pin inputs. See 'Logic Mode' section for more detail.
 */
enum FlexioStartBit {
   /** Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable */
   FlexioStartBit_LoadOnEnable = FLEXIO_SHIFTCFG_SSTART(0b00),
   /** Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift */
   FlexioStartBit_LoadOnShift  = FLEXIO_SHIFTCFG_SSTART(0b01),
   /** Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0 */
   FlexioStartBit_0            = FLEXIO_SHIFTCFG_SSTART(0b10),
   /** Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1 */
   FlexioStartBit_1            = FLEXIO_SHIFTCFG_SSTART(0b11),
};


/**
 * Timer external trigger sources for use with  @ref USBDM::FlexioBase_T< Info >::setTimerControl()
 */
enum FlexioTriggerSel : uint32_t {
   FlexioTriggerSel_External0  = FLEXIO_TIMCTL_TRGSEL(0 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External0 */
   FlexioTriggerSel_External1  = FLEXIO_TIMCTL_TRGSEL(1 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External1 */
   FlexioTriggerSel_External2  = FLEXIO_TIMCTL_TRGSEL(2 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External2 */
   FlexioTriggerSel_External3  = FLEXIO_TIMCTL_TRGSEL(3 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External3 */
   FlexioTriggerSel_External4  = FLEXIO_TIMCTL_TRGSEL(4 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External4 */
   FlexioTriggerSel_External5  = FLEXIO_TIMCTL_TRGSEL(5 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External5 */
   FlexioTriggerSel_External6  = FLEXIO_TIMCTL_TRGSEL(6 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External6 */
   FlexioTriggerSel_External7  = FLEXIO_TIMCTL_TRGSEL(7 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External7 */
   FlexioTriggerSel_External8  = FLEXIO_TIMCTL_TRGSEL(8 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External8 */
   FlexioTriggerSel_External9  = FLEXIO_TIMCTL_TRGSEL(9 )|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External9 */
   FlexioTriggerSel_External10 = FLEXIO_TIMCTL_TRGSEL(10)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External10 */
   FlexioTriggerSel_External11 = FLEXIO_TIMCTL_TRGSEL(11)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External11 */
   FlexioTriggerSel_External12 = FLEXIO_TIMCTL_TRGSEL(12)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External12 */
   FlexioTriggerSel_External13 = FLEXIO_TIMCTL_TRGSEL(13)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External13 */
   FlexioTriggerSel_External14 = FLEXIO_TIMCTL_TRGSEL(14)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External14 */
   FlexioTriggerSel_External15 = FLEXIO_TIMCTL_TRGSEL(15)|FLEXIO_TIMCTL_TRGSRC(0),  /**< FlexioTriggerSel_External15 */
//      // No triggers found
};

/**
 * Modifier for internal trigger sources for use with @ref flexioTriggerSel()
 */
enum FlexioTriggerModify : uint8_t {
   FlexioTriggerModify_Pin2N_Input        = 0b00, /**< Pin 2N input */
   FlexioTriggerModify_Pin2NPlus1_Input   = 0b10, /**< Pin 2N+1 input */
   FlexioTriggerModify_ShifterN_status    = 0b01, /**< Shifter N status flag */
   FlexioTriggerModify_TimerN_triggerOut  = 0b11, /**< Timer N trigger output */
};

/**
 * Construct an internal trigger value for use with @ref FlexioBase_T::setTimerControl()
 *
 * The internal trigger selection is configured dependent upon the flexioTriggerModifier value as follows:
 * - FlexioTriggerModify_Pin2N_Input          pin 2N input
 * - FlexioTriggerModify_ShifterN_status      shifter N status flag
 * - FlexioTriggerModify_Pin2NPlus1_Input     pin 2N+1 input
 * - FlexioTriggerModify_TimerN_triggerOut    timer N trigger output
 *
 * @param flexioTriggerModify  Trigger modifier
 * @param N                    Trigger source number as indicated above
 *
 * @return Trigger value
 */
static constexpr FlexioTriggerSel flexioTriggerSel(FlexioTriggerModify flexioTriggerModify, unsigned N) {
   return (FlexioTriggerSel)(FLEXIO_TIMCTL_TRGSEL((N<<2)|flexioTriggerModify)|FLEXIO_TIMCTL_TRGSRC(1));
}

enum FlexioTriggerPolarity {
   FlexioTriggerPolarity_ActiveHigh = FLEXIO_TIMCTL_TRGPOL(0),
   FlexioTriggerPolarity_ActiveLow  = FLEXIO_TIMCTL_TRGPOL(1),
};

/**
 * Timer Mode
 *
 * In 8-bit counter mode, the lower 8-bits of the counter and compare register are used to configure the baud
 * rate of the timer shift clock and the upper 8-bits are used to configure the shifter bit count.
 *
 * In 8-bit PWM mode, the lower 8-bits of the counter and compare register are used to configure the high
 * period of the timer shift clock and the upper 8-bits are used to configure the low period of the timer shift
 * clock. The shifter bit count is configured using another timer or external signal.
 *
 * In 16-bit counter mode, the full 16-bits of the counter and compare register are used to configure either the
 * baud rate of the shift clock or the shifter bit count.
 */
enum FlexioTimerMode {
   FlexioTimerMode_Disabled   = FLEXIO_TIMCTL_TIMOD(0b00),  /**< Timer Disabled. */
   FlexioTimerMode_BaudBit    = FLEXIO_TIMCTL_TIMOD(0b01),  /**< Dual 8-bit counters baud/bit mode. */
   FlexioTimerMode_PWM        = FLEXIO_TIMCTL_TIMOD(0b10),  /**< Dual 8-bit counters PWM mode. */
   FlexioTimerMode_Counter    = FLEXIO_TIMCTL_TIMOD(0b11),  /**< Single 16-bit counter mode. */
};


/**
 * Timer Output
 *
 * Configures the initial state of the Timer Output and whether it is affected by the Timer reset.
 */
enum FlexioTimerOutput {
   /** Timer output is logic one when enabled and not affected by timer reset */
   FlexioTimerOutput_1_WhenEnabled         = FLEXIO_TIMCFG_TIMOUT(0b00),
   /** Timer output is logic zero when enabled and not affected by timer reset */
   FlexioTimerOutput_0_WhenEnabled         = FLEXIO_TIMCFG_TIMOUT(0b01),
   /** Timer output is logic one when enabled and on timer reset */
   FlexioTimerOutput_1_WhenEnabledOrReset  = FLEXIO_TIMCFG_TIMOUT(0b10),
   /** Timer output is logic zero when enabled and on timer reset */
   FlexioTimerOutput_0_WhenEnabledOrReset  = FLEXIO_TIMCFG_TIMOUT(0b11),
};

/**
 * Timer Decrement
 *
 * Configures the source of the Timer decrement and the source of the Shift clock.
 */
enum FlexioTimerDec {
   /**< Decrement counter on FlexIO clock, Shift clock equals Timer output. */
   FlexioTimerDec_OnFlexioClock_ShiftOnTimerInput     = FLEXIO_TIMCFG_TIMDEC(0b00),
   /**< Decrement counter on Trigger input (both edges), Shift clock equals Timer output. */
   FlexioTimerDec_OnTriggerInput_ShiftOnTimerOutput   = FLEXIO_TIMCFG_TIMDEC(0b01),
   /**< Decrement counter on Pin input (both edges), Shift clock equals Pin input. */
   FlexioTimerDec_OnPinInput_ShiftOnPinInput          = FLEXIO_TIMCFG_TIMDEC(0b10),
   /**< Decrement counter on Trigger input (both edges), Shift clock equals Trigger input. */
   FlexioTimerDec_OnTriggerInput_ShiftOnTriggerInput  = FLEXIO_TIMCFG_TIMDEC(0b11),
};

/**
 * Timer Reset
 *
 *  Configures the condition that causes the timer counter (and optionally the timer output)
 *  to be reset.
 *  In 8-bit counter mode, the timer reset will only reset the lower 8-bits
 *  that configure the baud rate.
 *  In all other modes, the timer reset will reset the full 16-bits of the counter.
 */
enum FlexioTimerReset {
   FlexioTimerReset_Never                    = FLEXIO_TIMCFG_TIMRST(0b000),  /**< Timer never reset */
   FlexioTimerReset_TimerPinEqualTimerOutput = FLEXIO_TIMCFG_TIMRST(0b010),  /**< Timer reset on Timer Pin equal to Timer Output */
   FlexioTimerReset_TriggerEqualTimerOutput  = FLEXIO_TIMCFG_TIMRST(0b011),  /**< Timer reset on Timer Trigger equal to Timer Output */
   FlexioTimerReset_TimerPinRising           = FLEXIO_TIMCFG_TIMRST(0b100),  /**< Timer reset on Timer Pin rising edge */
   FlexioTimerReset_TriggerRising            = FLEXIO_TIMCFG_TIMRST(0b110),  /**< Timer reset on Trigger rising edge */
   FlexioTimerReset_TriggerEitherEdge        = FLEXIO_TIMCFG_TIMRST(0b111),  /**< Timer reset on Trigger rising or falling edge */
};

/**
 *  Timer Disable
 *
 *  Configures the condition that causes the Timer to be disabled and stop decrementing.
 */
enum FlexioTimerDisable {
   FlexioTimerDisable_Never                         = FLEXIO_TIMCFG_TIMDIS(0b000),  /**< Timer never disabled */
   FlexioTimerDisable_OnTimerNminus1Disable         = FLEXIO_TIMCFG_TIMDIS(0b001),  /**< Timer disabled on Timer N-1 disable */
   FlexioTimerDisable_OnTimerCompare                = FLEXIO_TIMCFG_TIMDIS(0b010),  /**< Timer disabled on Timer compare */
   FlexioTimerDisable_OnTimerCompareAndTriggerLow   = FLEXIO_TIMCFG_TIMDIS(0b011),  /**< Timer disabled on Timer compare and Trigger Low */
   FlexioTimerDisable_OnPinEitherEdge               = FLEXIO_TIMCFG_TIMDIS(0b100),  /**< Timer disabled on Pin rising or falling edge */
   FlexioTimerDisable_OnPinEitherEdgeAndTriggerHigh = FLEXIO_TIMCFG_TIMDIS(0b101),  /**< Timer disabled on Pin rising or falling edge provided Trigger is high */
   FlexioTimerDisable_OnTriggerFalling              = FLEXIO_TIMCFG_TIMDIS(0b110),  /**< Timer disabled on Trigger falling edge */
};

/**
 *  Timer Enable
 *
 *  Configures the condition that causes the Timer to be enabled and start decrementing.
 */
enum FlexioTimerEnable {
   FlexioTimerEnable_Always                   = FLEXIO_TIMCFG_TIMENA(0b000),  /**< Timer always enabled */
   FlexioTimerEnable_OnTimerNminus1Enable       = FLEXIO_TIMCFG_TIMENA(0b001),  /**< Timer enabled on Timer N-1 enable */
   FlexioTimerEnable_OnTriggerHigh              = FLEXIO_TIMCFG_TIMENA(0b010),  /**< Timer enabled on Trigger high */
   FlexioTimerEnable_OnTriggerHighandPinHigh    = FLEXIO_TIMCFG_TIMENA(0b011),  /**< Timer enabled on Trigger high and Pin high */
   FlexioTimerEnable_OnPinRising                = FLEXIO_TIMCFG_TIMENA(0b100),  /**< Timer enabled on Pin rising edge */
   FlexioTimerEnable_OnPinRisingAndTriggerHigh  = FLEXIO_TIMCFG_TIMENA(0b101),  /**< Timer enabled on Pin rising edge and Trigger high */
   FlexioTimerEnable_OnTriggerRising            = FLEXIO_TIMCFG_TIMENA(0b110),  /**< Timer enabled on Trigger rising edge */
   FlexioTimerEnable_OnTriggerEitherEdge        = FLEXIO_TIMCFG_TIMENA(0b111),  /**< Timer enabled on Trigger rising or falling edge */
};

/**
 *  Timer Stop Bit
 *
 *  The stop bit can be added on a timer compare (between each word) or on a timer disable.
 *  When stop bit is enabled, configured shifters will output the contents of the stop bit
 *  when the timer is disabled.
 *  When stop bit is enabled on timer disable, the timer remains disabled until the next
 *  rising edge of the shift clock. If configured for both timer compare and timer disable,
 *  only one stop bit is inserted on timer disable.
 */
enum FlexioTimerStopBit {
   FlexioTimerStopBit_Disabled               = FLEXIO_TIMCFG_TSTOP(0b00),  /**< Stop bit disabled */
   FlexioTimerStopBit_EnabledOnTimerCompare  = FLEXIO_TIMCFG_TSTOP(0b01),  /**< Stop bit is enabled on timer compare */
   FlexioTimerStopBit_EnabledOnTimerDisable  = FLEXIO_TIMCFG_TSTOP(0b10),  /**< Stop bit is enabled on timer disable */
   FlexioTimerStopBit_EnabledOnTimerBoth     = FLEXIO_TIMCFG_TSTOP(0b11),  /**< Stop bit is enabled on timer compare and timer disable */
};

/**
 *  Timer Start Bit
 *
 *  When start bit is enabled, configured shifters will output the contents of the start bit
 *  when the timer is enabled and the timer counter will reload from the compare register on
 *  the first rising edge of the shift clock.
 */
enum FlexioTimerStartBit {
   FlexioTimerStartBit_Disabled = FLEXIO_TIMCFG_TSTART(0b0),  /**< Start bit disabled */
   FlexioTimerStartBit_Enabled  = FLEXIO_TIMCFG_TSTART(0b1),  /**< Start bit enabled */
};

/**
 * Type definition for FLEXIO interrupt call back
 *
 * @param[in]  status Struct indicating interrupt source and state
 */
typedef void (*FLEXIOCallbackFunction)();


/**
 * Virtual Base class for FLEXBUS interface
 */
class FlexioBase {

private:
   /**
    * This class is not intended to be instantiated by copy
    */
   FlexioBase(const FlexioBase&) = delete;
   FlexioBase(FlexioBase&&) = delete;

protected:
   const HardwarePtr<FLEXIO_Type> flexio;                 //!< FLEXIO hardware instance
   
   /**
    * Construct FLEXBUS interface
    *
    * @param[in]  flexio     Base address of FLEXIO hardware
    */
   constexpr FlexioBase(uint32_t flexio) : flexio(flexio) {
   }
};

/**
 * @brief Template class representing an FLEXIO interface
 *
 * <b>Example</b>
 *
 * @code
 *  @endcode
 *
 * @tparam Info            Class describing FLEXIO hardware
 */
template<class Info> 
class FlexioBase_T : public FlexioBase {

private:
   /**
    * This class is not intended to be instantiated by copy
    */
   FlexioBase_T(const FlexioBase_T&) = delete;
   FlexioBase_T(FlexioBase_T&&) = delete;

protected:
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /** Callback function for ISR */
   static FLEXIOCallbackFunction callback;

public:
   /** Class to static check channel exists and is mapped to a pin */
   template<int pin> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (pin>=0) && (pin<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[pin].gpioBit != UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[pin].gpioBit >= 0);

      static_assert(Test1, "Illegal FLEXIO pin - Check Configure.usbdm for available pin");
      static_assert(Test2, "FLEXIO output is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "FLEXIO pin doesn't exist in this device/package - Check Configure.usbdm for available outputs pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Hardware instance pointer
    *
    * @return Reference to FLEXIO hardware
    */
   static constexpr HardwarePtr<FLEXIO_Type> flexio = Info::baseAddress;

   /**
    * Construct FLEXBUS interface
    */
   constexpr FlexioBase_T() : FlexioBase(Info::baseAddress) {
   }

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Basic enable of module.
    * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to hardware
      Info::enableClock();
   }

   /**
      * Get FLEXIO input clock frequency
      *
      * @return Frequency as a uint32_t in Hz
      */
   static uint32_t getClockFrequency() {
      return SimInfo::getFlexioClock();
   }

   /**
    * Basic configuration of module
    *
    * @param flexioPower      Operation in low-power mode
    * @param flexioDebug      Operation in debug mode
    * @param flexioFastAccess Fast register access
    */
   static void configure(
         FlexioPower       flexioPower      = FlexioPower_EnabledInDoze,
         FlexioDebug       flexioDebug      = FlexioDebug_Disabled,
         FlexioFastAccess  flexioFastAccess = FlexioFastAccess_Disabled
   ) {
      enable();
      flexio->CTRL = flexioPower|flexioDebug|flexioFastAccess|FLEXIO_CTRL_FLEXEN(1);
   }

   /**
    * Enable with default settings.
    */
   static void defaultConfigure() {
      enable();
   }

   /**
    * Disable interface to FLEXIO.
    */
   static void disable() {
      Info::disableClock();
   }

   /**
    * Get Flexio parameters
    *
    * @param triggerNumber    Number of external triggers implemented.
    * @param pinNumber        Number of Pins implemented.
    * @param timerNumber      Number of Timers implemented.
    * @param shifterNumber    Number of Shifters implemented.
    */
   static void getParams(unsigned &triggerNumber, unsigned &pinNumber, unsigned &timerNumber, unsigned &shifterNumber) {
      triggerNumber  = (flexio->PARAM&FLEXIO_PARAM_TRIGGER_MASK)>>FLEXIO_PARAM_TRIGGER_SHIFT;
      pinNumber      = (flexio->PARAM&FLEXIO_PARAM_PIN_MASK)>>FLEXIO_PARAM_PIN_SHIFT;
      timerNumber    = (flexio->PARAM&FLEXIO_PARAM_TIMER_MASK)>>FLEXIO_PARAM_TIMER_SHIFT;
      shifterNumber  = (flexio->PARAM&FLEXIO_PARAM_SHIFTER_MASK)>>FLEXIO_PARAM_SHIFTER_SHIFT;
   }

   /**
    * Software Reset
    *
    * The FlexIO Control Register is not affected by the software reset, all other logic in the FlexIO
    * is affected by the software reset.
    */
   static void softwareReset() {
      flexio->CTRL |= FLEXIO_CTRL_SWRST_MASK;
      while ((flexio->CTRL & FLEXIO_CTRL_SWRST_MASK) == 0) {};
      flexio->CTRL &= ~FLEXIO_CTRL_SWRST_MASK;
      while ((flexio->CTRL & FLEXIO_CTRL_SWRST_MASK) != 0) {};
   }

   /**
    * Read Pin Data Input
    *
    * @return Returns the input data on each of the FlexIO pins as a bitmask.
    */
   static uint32_t readPins() {
      return flexio->PIN;
   }

   /**
    * Read shifter status.
    *
    * A shifter status flag is updated when one of the following events occurs:
    * - SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with data from Shifter
    *   (SHIFTBUF is full), and the status flag is cleared when SHIFTBUF register is read.
    *
    * - SMOD=Transmit, the status flag is set when SHIFTBUF data has been transferred to the Shifter
    *   (SHIFTBUF is empty) or when initially configured for SMOD=Transmit, and the status flag is cleared when
    *   the SHIFTBUF register is written.
    *
    * - SMOD=Match Store, the status flag is set when a match has occurred between SHIFTBUF and Shifter,
    *   and the status flag is cleared when the SHIFTBUF register is read.
    *
    * - SMOD=Match Continuous, returns the current match result between the SHIFTBUF and Shifter.
    *
    * - SMOD=State, the status flag for a shifter will set when it is selected by the current state pointer.
    *
    * - SMOD=Logic, returns the current value of the programmable logic block output.
    *
    *   The status flag can also be cleared by writing a logic one to the flag for all modes except Match
    *   Continuous/State/Logic.
    *
    * @return Bitmask representing the status of each shifter
    */
   static uint32_t readShifterStatus() {
      return flexio->SHIFTSTAT;
   }

   /**
    * Clear shifter status.
    *
    * A shifter status flag is updated when one of the following events occurs:
    * - SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with data from Shifter
    *   (SHIFTBUF is full), and the status flag is cleared when SHIFTBUF register is read.
    *
    * - SMOD=Transmit, the status flag is set when SHIFTBUF data has been transferred to the Shifter
    *   (SHIFTBUF is empty) or when initially configured for SMOD=Transmit, and the status flag is cleared when
    *   the SHIFTBUF register is written.
    *
    * - SMOD=Match Store, the status flag is set when a match has occurred between SHIFTBUF and Shifter,
    *   and the status flag is cleared when the SHIFTBUF register is read.
    *
    * - SMOD=Match Continuous, returns the current match result between the SHIFTBUF and Shifter.
    *
    * - SMOD=State, the status flag for a shifter will set when it is selected by the current state pointer.
    *
    * - SMOD=Logic, returns the current value of the programmable logic block output.
    *
    *   The status flag can also be cleared by writing a logic one to the flag for all modes except Match
    *   Continuous/State/Logic.
    *
    * @param clearMask Bitmask representing the status flag of each shifter to clear
    */
   static void clearShifterStatus(uint32_t clearMask=(uint32_t)-1) {
      flexio->SHIFTSTAT = clearMask;
   }

   /**
    * Read and clear shifter status.
    * Only flags found to be initially set will be cleared.
    *
    * A status flag will not be cleared for Match Continuous/State/Logic.
    *
    * A shifter status flag is updated when one of the following events occurs:
    * - SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with data from Shifter
    *   (SHIFTBUF is full), and the status flag is cleared when SHIFTBUF register is read.
    *
    * - SMOD=Transmit, the status flag is set when SHIFTBUF data has been transferred to the Shifter
    *   (SHIFTBUF is empty) or when initially configured for SMOD=Transmit, and the status flag is cleared when
    *   the SHIFTBUF register is written.
    *
    * - SMOD=Match Store, the status flag is set when a match has occurred between SHIFTBUF and Shifter,
    *   and the status flag is cleared when the SHIFTBUF register is read.
    *
    * - SMOD=Match Continuous, returns the current match result between the SHIFTBUF and Shifter.
    *
    * - SMOD=State, the status flag for a shifter will set when it is selected by the current state pointer.
    *
    * - SMOD=Logic, returns the current value of the programmable logic block output.
    *
    * @return Bitmask representing the initial status flags of each shifter before clearing.
    */
   static uint32_t readAndClearShifterStatus() {
      uint32_t t = flexio->SHIFTSTAT;
      flexio->SHIFTSTAT = t;
      return t;
   }

   /**
    * Read shifter error flags
    *
    * A shifter error flag is set when one of the following events occurs:
    * - SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before the previous
    *   data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates that the received start or stop bit does
    *   not match the expected value.
    * - SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new data had
    *   been written into SHIFTBUF (SHIFTBUF underrun).
    * - SMOD=Match Store, indicates a match event occurred before the previous match data was read from
    *   SHIFTBUF (SHIFTBUF Overrun).
    * - SMOD=Match Continuous, the error flag is set when a match has occurred between SHIFTBUF and Shifter.
    * - SMOD=Logic, the error flag is set when the output of the programmable logic block has asserted.
    *
    *   Error flags can be cleared by writing logic one to the flag.
    *   For SMOD=Match Continuous, can also be cleared when the SHIFTBUF register is read.
    *
    * @return Bitmask representing the error state of each shifter
    */
   static uint32_t readShifterErrors() {
      return flexio->SHIFTERR;
   }

   /**
    * Clear shifter error flags
    *
    * A shifter error flag is set when one of the following events occurs:
    * - SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before the previous
    *   data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates that the received start or stop bit does
    *   not match the expected value.
    * - SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new data had
    *   been written into SHIFTBUF (SHIFTBUF underrun).
    * - SMOD=Match Store, indicates a match event occurred before the previous match data was read from
    *   SHIFTBUF (SHIFTBUF Overrun).
    * - SMOD=Match Continuous, the error flag is set when a match has occurred between SHIFTBUF and Shifter.
    * - SMOD=Logic, the error flag is set when the output of the programmable logic block has asserted.
    *
    *   Error flags can be cleared by writing logic one to the flag.
    *   For SMOD=Match Continuous, can also be cleared when the SHIFTBUF register is read.
    *
    * @param clearMask Bitmask representing the error flag of each shifter to clear
    */
   static void clearShifterErrors(uint32_t clearMask=(uint32_t)-1) {
      flexio->SHIFTERR = clearMask;
   }

   /**
    * Read and clear shifter error flags.
    * Only flags found to be initially set will be cleared.
    *
    * A shifter error flag is set when one of the following events occurs:
    * - SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before the previous
    *   data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates that the received start or stop bit does
    *   not match the expected value.
    * - SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new data had
    *   been written into SHIFTBUF (SHIFTBUF underrun).
    * - SMOD=Match Store, indicates a match event occurred before the previous match data was read from
    *   SHIFTBUF (SHIFTBUF Overrun).
    * - SMOD=Match Continuous, the error flag is set when a match has occurred between SHIFTBUF and Shifter.
    * - SMOD=Logic, the error flag is set when the output of the programmable logic block has asserted.
    *
    *   For SMOD=Match Continuous, can also be cleared when the SHIFTBUF register is read.
    *
    * @return Bitmask representing the error state of each shifter before clearing.
    */
   static uint32_t readAndClearShifterErrors() {
      uint32_t t = flexio->SHIFTERR;
      flexio->SHIFTERR = t;
      return t;
   }

   /**
    * Shifter Status Interrupt Enable.
    * Enables interrupt generation when corresponding SSF is set.
    *
    * @param enableMask Bitmask for each shifter status interrupt to enable
    */
   static void enableShiftStatusInterrupts(uint32_t enableMask) {
      flexio->SHIFTSIEN |= enableMask;
   }

   /**
    * Shifter Status Interrupt Disable.
    * Disables interrupt generation when corresponding SSF is set.
    *
    * @param disableMask Bitmask for each shifter status interrupt to disable
    */
   static void disableShiftStatusInterrupts(uint32_t disableMask) {
      flexio->SHIFTSIEN &= ~disableMask;
   }

   /**
    * Shifter Error Interrupt Enable
    * Enables interrupt generation when corresponding SEF is set.
    *
    * @param enableMask Bitmask for each shifter error interrupt to enable
    */
   static void enableShiftErrorInterrupts(uint32_t enableMask) {
      flexio->SHIFTEIEN |= enableMask;
   }

   /**
    * Shifter Error Interrupt Disable
    * Enables interrupt generation when corresponding SEF is set.
    *
    * @param disableMask Bitmask for each shifter error interrupt to disable
    */
   static void disableShiftErrorInterrupts(uint32_t disableMask) {
      flexio->SHIFTEIEN &= ~disableMask;
   }

   /**
    * Timer Status Interrupt Enable.
    * Enables interrupt generation when corresponding TSF is set.
    *
    * @param enableMask Bitmask for each shifter status interrupt to enable
    */
   static void enableTimerStatusInterrupts(uint32_t enableMask) {
      flexio->TIMIEN |= enableMask;
   }

   /**
    * Timer Status Interrupt Disable.
    * Disables interrupt generation when corresponding TSF is set.
    *
    * @param disableMask Bitmask for each shifter status interrupt to disable
    */
   static void disableTimerStatusInterrupts(uint32_t disableMask) {
      flexio->TIMIEN &= ~disableMask;
   }

   /**
    * Shifter Status DMA Enable.
    * Enables DMA request generation when corresponding SSF is set.
    *
    * @param enableMask Bitmask for each shifter DMA request to enable
    */
   static void enableShifterStatusDmaReq(uint32_t enableMask) {
      flexio->SHIFTSDEN |= enableMask;
   }

   /**
    * Shifter Status DMA Disable.
    * Disables DMA request generation when corresponding SSF is set.
    *
    * @param disableMask Bitmask for each shifter DMA request to disable
    */
   static void disableShifterStatusDmaReq(uint32_t disableMask) {
      flexio->SHIFTSDEN &= ~disableMask;
   }

   /**
    * Read Current State Pointer
    * The current state field maintains a pointer to keep track of the current Shifter (configured
    * for State mode) enabled to drive outputs and compute the next state.
    *
    * @return Current state pointer
    */
   static uint8_t readShifterState() {
      return flexio->SHIFTSTATE;
   }

   /**
    * Combine Shifter Control options
    *
    * @param flexioShiftMode     Shifter Mode.
    * @param flexioTimerSelect   Selects which timer is used for controlling the logic/shift register
    * @param flexioPinAction     Shifter Pin Configuration
    * @param flexioPinSel        Selects which pin is used by the Shifter input or output.
    * @param flexioTimerEdge     Timer Polarity.
    * @param flexioPinPolarity   Shifter Pin Polarity
    *
    * @return Value constructed from options
    */
   static constexpr uint32_t makeShifterControlValue(
         FlexioShiftMode      flexioShiftMode,
         FlexioTimerSelect    flexioTimerSelect,
         FlexioPinAction      flexioPinAction,
         FlexioPinSel         flexioPinSel,
         FlexioTimerEdge      flexioTimerEdge   = FlexioTimerEdge_Rising,
         FlexioPinPolarity    flexioPinPolarity = FlexioPinPolarity_ActiveHigh ) {
      return flexioShiftMode|FLEXIO_SHIFTCTL_TIMSEL(flexioTimerSelect)|flexioTimerEdge|flexioPinAction|flexioPinSel|flexioPinPolarity;
   }

   /**
    * Set Shifter Control value
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Value to use
    */
   static void setShifterControl(FlexioShifterSelect  flexioShifterSelect, uint32_t value) {
      flexio->SHIFTCTL[flexioShifterSelect] = value;
   }

   /**
    * Set Shifter control value
    *
    * @param flexioShifterSelect Shifter to modify
    * @param flexioShiftMode     Shifter Mode.
    * @param flexioTimerSelect   Selects which timer is used for controlling the logic/shift register
    * @param flexioPinAction     Shifter Pin Configuration
    * @param flexioPinSel        Selects which pin is used by the Shifter input or output.
    * @param flexioTimerEdge     Timer Polarity.
    * @param flexioPinPolarity   Shifter Pin Polarity
    */
   static void setShifterControl(
         FlexioShifterSelect  flexioShifterSelect,
         FlexioShiftMode      flexioShiftMode,
         FlexioTimerSelect    flexioTimerSelect,
         FlexioPinAction      flexioPinAction,
         FlexioPinSel         flexioPinSel,
         FlexioTimerEdge      flexioTimerEdge   = FlexioTimerEdge_Rising,
         FlexioPinPolarity    flexioPinPolarity = FlexioPinPolarity_ActiveHigh ) {
      flexio->SHIFTCTL[flexioShifterSelect] = flexioShiftMode|FLEXIO_SHIFTCTL_TIMSEL(flexioTimerSelect)|flexioTimerEdge|flexioPinAction|flexioPinSel|flexioPinPolarity;
   }

   /**
    * Combine Shifter Configuration options
    *
    * @param flexioStartBit      Shifter Start bit.
    * @param flexioStopBit       Shifter Stop bit.
    * @param flexioShiftBy       Configures the number of bits to be shifted on each Shift
    * @param flexioInputSource   Selects the input source for the shifter.
    *
    * @return Value constructed from options
    */
   static constexpr uint32_t makeShifterConfigValue (
         FlexioStartBit       flexioStartBit,
         FlexioStopBit        flexioStopBit,
         FlexioShiftBy        flexioShiftBy       = FlexioShiftBy_1,
         FlexioInputSource    flexioInputSource   = FlexioInputSource_Pin) {
      return flexioShiftBy|flexioInputSource|flexioStartBit|flexioStopBit;
   }

   /**
    * Set Shifter Config value
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Value to use
    */
   static void setShifterConfig(FlexioShifterSelect  flexioShifterSelect, uint32_t value) {
      flexio->SHIFTCFG[flexioShifterSelect] = value;
   }

   /**
    * Set Shifter Config value
    *
    * @param flexioShifterSelect Shifter to modify
    * @param flexioStartBit      Shifter Start bit.
    * @param flexioStopBit       Shifter Stop bit.
    * @param flexioShiftBy       Configures the number of bits to be shifted on each Shift
    * @param flexioInputSource   Selects the input source for the shifter.
    */
   static void setShifterConfig (
         FlexioShifterSelect  flexioShifterSelect,
         FlexioStartBit       flexioStartBit,
         FlexioStopBit        flexioStopBit,
         FlexioShiftBy        flexioShiftBy       = FlexioShiftBy_1,
         FlexioInputSource    flexioInputSource   = FlexioInputSource_Pin) {
      flexio->SHIFTCFG[flexioShifterSelect] = flexioShiftBy|flexioInputSource|flexioStartBit|flexioStopBit;
   }

   /**
    * Combine Timer Control options
    *
    * @param flexioTimerMode           Timer Mode
    * @param flexioTriggerSel          Timer trigger source
    * @param flexioTriggerPolarity     Timer trigger polarity
    * @param flexioPinAction           Timer pin action
    * @param flexioPinSel              Pin to use (if any)
    * @param flexioPinPolarity         Timer pin polarity
    *
    * @return Value constructed from options
    */
   static constexpr uint32_t makeTimerControlValue(
         FlexioTimerMode         flexioTimerMode,
         FlexioTriggerSel        flexioTriggerSel,
         FlexioTriggerPolarity   flexioTriggerPolarity,
         FlexioPinAction         flexioPinAction,
         FlexioPinSel            flexioPinSel,
         FlexioPinPolarity       flexioPinPolarity) {
      return flexioTriggerSel|flexioTriggerPolarity|flexioPinAction|flexioPinSel|flexioPinPolarity|flexioTimerMode;
   }

   /**
    * Set Timer Control value
    *
    * @param flexioTimerSelect   Timer being modified
    * @param value               Value to use
    */
   static void setTimerControl(FlexioTimerSelect flexioTimerSelect, uint32_t value) {
      flexio->TIMCTL[flexioTimerSelect] = value;
   }

   /**
    * Set Timer Control
    *
    * @param flexioTimerSelect         Timer being modified
    * @param flexioTimerMode           Timer Mode
    * @param flexioTriggerSel          Timer trigger source
    * @param flexioTriggerPolarity     Timer trigger polarity
    * @param flexioPinAction           Timer pin action
    * @param flexioPinSel              Pin to use (if any)
    * @param flexioPinPolarity         Timer pin polarity
    */
   static void setTimerControl(
         FlexioTimerSelect       flexioTimerSelect,
         FlexioTimerMode         flexioTimerMode,
         FlexioTriggerSel        flexioTriggerSel,
         FlexioTriggerPolarity   flexioTriggerPolarity,
         FlexioPinAction         flexioPinAction,
         FlexioPinSel            flexioPinSel,
         FlexioPinPolarity       flexioPinPolarity) {
      flexio->TIMCTL[flexioTimerSelect] = flexioTriggerSel|flexioTriggerPolarity|flexioPinAction|flexioPinSel|flexioPinPolarity|flexioTimerMode;
   }

   /**
    * Combine Timer Configuration options
    *
    * The options to enable or disable the timer using the Timer N-1 enable or disable are
    * reserved when N is evenly divisible by 4 (eg: Timer 0).
    *
    * @param flexioTimerDisable  When timer is disabled
    * @param flexioTimerEnable   When timer is enabled
    * @param flexioTimerReset    When timer is reset
    * @param flexioTimerStartBit Start bit control
    * @param flexioTimerStopBit  Stop bit control
    * @param flexioTimerDec      When timer is to decrement
    * @param flexioTimerOutput   Timer output control
    *
    * @return Value constructed from options
    */
   static constexpr uint32_t makeTimerConfigValue(
         FlexioTimerEnable    flexioTimerEnable,
         FlexioTimerDisable   flexioTimerDisable,
         FlexioTimerReset     flexioTimerReset,
         FlexioTimerStartBit  flexioTimerStartBit,
         FlexioTimerStopBit   flexioTimerStopBit,
         FlexioTimerDec       flexioTimerDec,
         FlexioTimerOutput    flexioTimerOutput ) {
      return flexioTimerDisable|flexioTimerEnable|flexioTimerReset|flexioTimerStartBit|flexioTimerStopBit|flexioTimerDec|flexioTimerOutput;
   }

   /**
    * Set Timer Configuration value
    *
    * @param flexioTimerSelect   Timer being modified
    * @param value               Value to use
    */
   static void setTimerConfig(FlexioTimerSelect flexioTimerSelect, uint32_t value) {
      flexio->TIMCFG[flexioTimerSelect] = value;
   }

   /**
    * Set Timer Configuration
    *
    * The options to enable or disable the timer using the Timer N-1 enable or disable are
    * reserved when N is evenly divisible by 4 (eg: Timer 0).
    *
    * @param flexioTimerSelect   Timer being modified
    * @param flexioTimerDisable  When timer is disabled
    * @param flexioTimerEnable   When timer is enabled
    * @param flexioTimerReset    When timer is reset
    * @param flexioTimerStartBit Start bit control
    * @param flexioTimerStopBit  Stop bit control
    * @param flexioTimerDec      When timer is to decrement
    * @param flexioTimerOutput   Timer output control
    */
   static void setTimerConfig(
         FlexioTimerSelect    flexioTimerSelect,
         FlexioTimerEnable    flexioTimerEnable,
         FlexioTimerDisable   flexioTimerDisable,
         FlexioTimerReset     flexioTimerReset,
         FlexioTimerStartBit  flexioTimerStartBit,
         FlexioTimerStopBit   flexioTimerStopBit,
         FlexioTimerDec       flexioTimerDec,
         FlexioTimerOutput    flexioTimerOutput ) {
      flexio->TIMCFG[flexioTimerSelect] = flexioTimerDisable|flexioTimerEnable|flexioTimerReset|flexioTimerStartBit|flexioTimerStopBit|flexioTimerDec|flexioTimerOutput;
   }

   /**
    * Write Timer Compare Value
    *
    * The timer compare value is loaded into the timer counter when the timer is first enabled,
    * when the timer is reset and when the timer decrements down to zero.
    *
    * In dual 8-bit counters baud/bit mode:\n
    *  - The lower 8-bits configures the baud rate divider equal to (CMP[7:0] + 1) * 2.
    *  - The upper 8-bits configure the number of bits in each word equal to (CMP[15:8] + 1) / 2.
    *
    * In dual 8-bit counters PWM mode:\n
    *  - The lower 8-bits configure the high period of the output to (CMP[7:0] + 1) and,
    *  - The upper 8-bits configure the low period of the output to (CMP[15:8] + 1).
    *
    * In 16-bit counter mode:\n
    *  -  The compare value can be used to generate the baud rate divider (if shift clock source
    *  -  is timer output) to equal (CMP[15:0] + 1) * 2.
    *
    * When the shift clock source is a pin or trigger input, the compare register is used
    *    to set the number of bits in each word equal to (CMP[15:0] + 1) / 2.
    *
    * @param flexioTimerSelect   Timer being modified
    * @param timerValue          Timer value to write
    */
   static void setTimerCompareValue(FlexioTimerSelect flexioTimerSelect, uint16_t timerValue) {
      flexio->TIMCMP[flexioTimerSelect] = timerValue;
   }

   /**
    * Set Timer Compare Value
    *
    * This routine assumes the timer has been configured in dual 8-bit counters baud/bit mode:\n
    *   - The lower 8-bits configures the baud rate divider equal to (CMP[7:0] + 1) * 2.
    *   - The upper 8-bits configure the number of bits in each word equal to (CMP[15:8] + 1) / 2.
    *
    * @param flexioTimerSelect   Timer being modified
    * @param bits                The number of bits being received/transmitted
    * @param baudRate            The desired baud rate
    *
    * @note The Flexio clock source should be set by @ref SimInfo::setFlexioClock() first
    *
    * @return E_NO_ERROR on success
    * @return E_ILLEGAL_PARAM on failure (baud rate is out of range)
    */
   static ErrorCode setTimerCompareValue(FlexioTimerSelect flexioTimerSelect, unsigned bits, unsigned baudRate) {
      // Set TIMCMP[15:8] = (N x 2) - 1
      // Set TIMCMP[7:0]  = (baud rate divider/2) - 1
      uint32_t value = getClockFrequency();
      value  = (value/baudRate/2)-1;
      if (value>0xFF) {
         return setAndCheckErrorCode(E_ILLEGAL_PARAM);
      }
      value |= ((2*bits)-1)<<8;
      setTimerCompareValue(flexioTimerSelect, value);
      return E_NO_ERROR;
   }

   /**
    * Read Timer Compare Value
    *
    * The timer compare value is loaded into the timer counter when the timer is first enabled,
    * when the timer is reset and when the timer decrements down to zero.
    *
    * In dual 8-bit counters baud/bit mode:\n
    *  - The lower 8-bits configures the baud rate divider equal to (CMP[7:0] + 1) * 2.
    *  - The upper 8-bits configure the number of bits in each word equal to (CMP[15:8] + 1) / 2.
    *
    * In dual 8-bit counters PWM mode:\n
    *  - The lower 8-bits configure the high period of the output to (CMP[7:0] + 1) and,
    *  - The upper 8-bits configure the low period of the output to (CMP[15:8] + 1).
    *
    * In 16-bit counter mode:\n
    *  - The compare value can be used to generate the baud rate divider (if shift clock source
    *  - is timer output) to equal (CMP[15:0] + 1) * 2.
    *
    * When the shift clock source is a pin or trigger input, the compare register is used
    *    to set the number of bits in each word equal to (CMP[15:0] + 1) / 2.
    *
    * @return Timer value read
    */
   static uint16_t getTimerCompareValue(FlexioTimerSelect flexioTimerSelect) {
      return flexio->TIMCMP[flexioTimerSelect];
   }

   /**
    * Writer shifter buffer
    *
    * Shift buffer data is used for a variety of functions depending on the SMOD setting:
    * - SMOD=Receive
    *   Shifter data is transferred into SHIFTBUF at the expiration of Timer.
    *
    * - SMOD=Transmit
    *   SHIFTBUF data is transferred into the Shifter before the Timer begins.
    *
    * - SMOD=Match Store/Continuous
    *   SHIFTBUF[31:16] contains the data to be matched with the Shifter contents.
    *   The Match is checked either continuously (Match Continuous mode) or when the Timer expires
    *   (Match Store mode).
    *   SHIFTBUF[15:0] can be used to mask the match result (1=mask, 0=no mask).
    *   In Match Store mode, Shifter data [31:16] is written to SHIFTBUF[31:16] whenever a match event occurs.
    *
    * - SMOD=Logic
    *   SHIFTBUF[31:0] is used to implement a 5-input, 32-bit programmable logic look-up table.
    *   See 'Logic Mode' section for more detail.
    * - SMOD=State
    *   SHIFTBUF[31:24] is used to drive the output value when this shifter is selected by the
    *   current state pointer and SHIFTBUF[23:0] is used to configure the value of the next
    *   state transition.
    *   See 'State Mode' section for more detail.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Value to write
    */
   static void writeShifterBuffer(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUF[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer
    *
    * Shift buffer data is used for a variety of functions depending on the SMOD setting:
    * - SMOD=Receive
    *   Shifter data is transferred into SHIFTBUF at the expiration of Timer.
    *
    * - SMOD=Transmit
    *   SHIFTBUF data is transferred into the Shifter before the Timer begins.
    *
    * - SMOD=Match Store/Continuous
    *   SHIFTBUF[31:16] contains the data to be matched with the Shifter contents.
    *   The Match is checked either continuously (Match Continuous mode) or when the Timer expires
    *   (Match Store mode).
    *   SHIFTBUF[15:0] can be used to mask the match result (1=mask, 0=no mask).
    *   In Match Store mode, Shifter data [31:16] is written to SHIFTBUF[31:16] whenever a match event occurs.
    *
    * - SMOD=Logic
    *   SHIFTBUF[31:0] is used to implement a 5-input, 32-bit programmable logic look-up table.
    *   See 'Logic Mode' section for more detail.
    * - SMOD=State
    *   SHIFTBUF[31:24] is used to drive the output value when this shifter is selected by the
    *   current state pointer and SHIFTBUF[23:0] is used to configure the value of the next
    *   state transition.
    *   See 'State Mode' section for more detail.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Value from buffer
    */
   static uint32_t readShifterBuffer(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUF[flexioShifterSelect];
   }

   /**
    * Writer shifter buffer bit swapped
    *
    * Equivalent to @ref writeShifterBuffer, except bit swapped.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Bit swapped value to write [0:31].
    */
   static void writeShifterBufferBitSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFBIS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer bit swapped
    *
    * Equivalent to @ref readShifterBuffer, except bit swapped.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Bit swapped value from buffer [0:31].
    */
   static uint32_t readShifterBufferBitSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFBIS[flexioShifterSelect];
   }


   /**
    * Writer shifter buffer byte swapped
    *
    * Equivalent to @ref writeShifterBuffer, except byte swapped.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Byte swapped value to write { [7:0], [15:8], [23:16], [31:24] }.
    */
   static void writeShifterBufferByteSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFBIS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer byte swapped
    *
    * Equivalent to @ref readShifterBuffer, except byte swapped.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Byte swapped value from buffer { [7:0], [15:8], [23:16], [31:24] }.
    */
   static uint32_t readShifterBufferByteSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFBIS[flexioShifterSelect];
   }

   /**
    * Writer shifter buffer bit swapped within each byte
    *
    * Equivalent to @ref writeShifterBuffer, except bit swapped within each byte.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Bit swapped value to write { [24:31], [16:23], [8:15], [0:7] }.
    */
   static void writeShifterBufferBitsInByteSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFBBS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer bit swapped within each byte
    *
    * Equivalent to @ref readShifterBuffer, except bit swapped within each byte.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Bit swapped value from buffer { [24:31], [16:23], [8:15], [0:7] }.
    */
   static uint32_t readShifterBufferBitsInByteSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFBBS[flexioShifterSelect];
   }

   /**
    * Writer shifter buffer nibble swapped within each byte
    *
    * Equivalent to @ref writeShifterBuffer, nibble swapped within each byte.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Nibble swapped value to write { [27:24], [31:28], [19:16], [23:20], [11:8], [15:12], [3:0], [7:4] }.
    */
   static void writeShifterBufferNibblesInByteSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFNBS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer nibble swapped within each byte
    *
    * Equivalent to @ref readShifterBuffer, except nibble swapped within each byte.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Nibble swapped value from buffer { [27:24], [31:28], [19:16], [23:20], [11:8], [15:12], [3:0], [7:4] }.
    */
   static uint32_t readShifterBufferNibblesInByteSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFNBS[flexioShifterSelect];
   }

   /**
    * Writer shifter buffer half word swapped.
    *
    * Equivalent to @ref writeShifterBuffer, half word swapped.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Half word swapped value to write { [15:0], [31:24] }.
    */
   static void writeShifterBufferHalfWordSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFHWS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer half word swapped.
    *
    * Equivalent to @ref readShifterBuffer, half word swapped.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Half word swapped value from buffer { [15:0], [31:24] }.
    */
   static uint32_t readShifterBufferHalfWordSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFHWS[flexioShifterSelect];
   }

   /**
    * Writer shifter buffer nibble swapped.
    *
    * Equivalent to @ref writeShifterBuffer, nibble swapped.
    *
    * @param flexioShifterSelect Shifter to modify
    * @param value               Nibble swapped value to write { [3:0], [7:4], [11:8], [15:12], [19:16], [23:20], [27:24], [31:28] }.
    */
   static void writeShifterBufferNibbleSwapped(FlexioShifterSelect flexioShifterSelect, uint32_t value) {
      flexio->SHIFTBUFNIS[flexioShifterSelect] = value;
   }

   /**
    * Read shifter buffer nibble swapped.
    *
    * Equivalent to @ref readShifterBuffer, nibble swapped.
    *
    * @param flexioShifterSelect Shifter to access
    *
    * @return Nibble swapped value from buffer { [3:0], [7:4], [11:8], [15:12], [19:16], [23:20], [27:24], [31:28] }.
    */
   static uint32_t readShifterBufferNibbleSwapped(FlexioShifterSelect flexioShifterSelect) {
      return flexio->SHIFTBUFNIS[flexioShifterSelect];
   }

   /**
    * Clear interrupt flag.
    */
   static void clearInterruptFlag() {
   }
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * IRQ handler
    */
   static void irqHandler() {
      // Call handler
      callback();
   }

   /**
    * Set callback function
    *
    * @param[in]  theCallback Callback function to execute on interrupt
    */
   static void setCallback(FLEXIOCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         theCallback = unhandledCallback;
      }
      callback = theCallback;
   }
};

template<class Info> FLEXIOCallbackFunction FlexioBase_T<Info>::callback = FlexioBase_T<Info>::unhandledCallback;

#if defined(USBDM_FLEXIO_IS_DEFINED)
class Flexio : public FlexioBase_T<FlexioInfo> {};
#endif

#if defined(USBDM_FLEXIO0_IS_DEFINED)
class Flexio0 : public FlexioBase_T<Flexio0Info> {};
#endif

/**
 * End FLEXIO_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_FLEXIO_H */

/**
 * @file     pit.h (180.ARM_Peripherals/Project_Headers/pit-MK.h)
 * @brief    Programmable Interrupt Timer interface
 */

#ifndef INCLUDE_USBDM_PIT_H_
#define INCLUDE_USBDM_PIT_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "math.h"
#include "derivative.h"
#include "system.h"
#include "pin_mapping.h"
#include "dma.h"

#if $(/PIT/enablePeripheralSupport) // /PIT/enablePeripheralSupport

namespace USBDM {

/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
$(/PIT/peripheral_h_definition:// $/PIT/peripheral_h_definition not found)

/**
 * Calculate a PIT channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  PIT channel number calculated from channel+offset
 */
constexpr PitChannelNum inline operator+(PitChannelNum pitChannelNum, unsigned offset) {
   return PitChannelNum(unsigned(pitChannelNum) + offset);
}

/**
 * Calculate a PIT channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  PIT channel number calculated from channel+offset
 */
constexpr PitChannelNum inline operator+(PitChannelNum pitChannelNum, int offset) {
   return PitChannelNum(unsigned(pitChannelNum) + unsigned(offset));
}

/**
 * @brief Class representing a Programmable Interrupt  Timer
 *
 * <b>Example</b>
 * @code
 *
 * @endcode
 */
template<class Info>
class PitBase_T : public Info {

private:
   /**
    * This class is not intended to be instantiated
    */
   PitBase_T(const PitBase_T&) = delete;
   PitBase_T(PitBase_T&&) = delete;

protected:

   /** Default TCTRL value for timer channel */
   static constexpr uint32_t PIT_TCTRL_DEFAULT_VALUE = (PIT_TCTRL_TEN_MASK);

   // Reduce clutter
   using Info::allocatedChannels;
   using Info::NumChannels;

$(/PIT/protectedMethods: // /PIT/protectedMethods not found)
public:

   using IrqNum = PitBasicInfo::IrqNum;

   /// Defaulted constructor
   constexpr PitBase_T() = default;

$(/PIT/publicMethods: // /PIT/publicMethods not found)
   /**
    * Allocate PIT channel.
    *
    * @return PitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static PitChannelNum allocateChannel() {
      CriticalSection cs;
      unsigned channelNum = __builtin_ffs(allocatedChannels);
      if ((channelNum == 0)||(--channelNum>=NumChannels)) {
         setErrorCode(E_NO_RESOURCE);
         return PitChannelNum_None;
      }
      allocatedChannels &= ~(1<<channelNum);
      return (PitChannelNum) channelNum;
   }

#if $(/DMA/enablePeripheralSupport:false) // (/DMA/enablePeripheralSupport)
   /**
    * Allocate PIT channel associated with DMA channel.
    * This is a channel that may be used to throttle the associated DMA channel.
    *
    * @param dmaChannelNum DMA channel being used.
    *
    * @return PitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static PitChannelNum allocateDmaAssociatedChannel(DmaChannelNum dmaChannelNum) {
      const uint32_t channelMask = (1<<dmaChannelNum);
      usbdm_assert(dmaChannelNum<NumChannels, "No PIT channel associated with DMA channel");
      CriticalSection cs;
      usbdm_assert((allocatedChannels & channelMask) != 0, "PIT channel already allocated");
      if ((allocatedChannels & channelMask) == 0) {
         setErrorCode(E_NO_RESOURCE);
         return PitChannelNum_None;
      }
      allocatedChannels &= ~channelMask;
      return (PitChannelNum) dmaChannelNum;
   }
#endif // (/DMA/enablePeripheralSupport)

   /**
    * Free PIT channel.
    * Disables the channel.
    *
    * @param pitChannelNum Channel to release
    */
   static void freeChannel(PitChannelNum pitChannelNum) {
      if (pitChannelNum == PitChannelNum_None) {
         return;
      }
      const uint32_t channelMask = (1<<pitChannelNum);
      usbdm_assert(pitChannelNum<NumChannels, "Illegal PIT channel");
      usbdm_assert((allocatedChannels & channelMask) == 0, "Freeing unallocated PIT channel");

      disableChannel(pitChannelNum);
      CriticalSection cs;
      allocatedChannels |= channelMask;
   }

   /**
    * Enable/disable channel interrupts
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  enable  True => enable, False => disable
    */
   static void setChannelAction(PitChannelNum pitChannelNum, PitChannelAction pitChannelAction) {
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL | pitChannelAction;
   }

protected:
   /** Pointer to hardware */
   static constexpr HardwarePtr<PIT_Type> pit = Info::baseAddress;

public:
   /**
    * Basic enable of PIT
    */
   static void enable() {
      // Enable clock
      Info::enableClock();
      __DMB();
   }

   /**
    *   Disable the PIT (all channels)
    */
   static void disable() {
      pit->MCR = PIT_MCR_MDIS(1);
      Info::disableClock();
   }

   /**
    *  Enable the PIT channel
    *
    *  @param[in]  pitChannelNum   Channel to enable
    */
   static void enableChannel(const PitChannelNum pitChannelNum) {
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL | PIT_TCTRL_TEN_MASK;
   }

   /**
    *   Disable the PIT channel
    *
    *   @param[in]  pitChannelNum Channel to disable
    */
   static void disableChannel(PitChannelNum pitChannelNum) {

      // Disable timer channel
      pit->CHANNEL[pitChannelNum].TCTRL = pit->CHANNEL[pitChannelNum].TCTRL & ~PIT_TCTRL_TEN_MASK;
   }

   /**
    * Clear channel interrupt flag
    */
   static void clearInterruptFlag(PitChannelNum pitChannelNum)  {
      pit->CHANNEL[pitChannelNum].TFLG = PIT_TFLG_TIF_MASK;
   }

   /**
    *  Configure the PIT channel
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    *  @param[in]  pitChannelAction  Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         PitChannelNum     pitChannelNum,
         Ticks             tickInterval,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      usbdm_assert((unsigned)tickInterval>0, "Interval too short");

      pit->CHANNEL[pitChannelNum].TCTRL = 0;
      pit->CHANNEL[pitChannelNum].LDVAL = (unsigned)tickInterval-1;
      pit->CHANNEL[pitChannelNum].TFLG  = PIT_TFLG_TIF_MASK;
      pit->CHANNEL[pitChannelNum].TCTRL = pitChannelAction|PIT_TCTRL_TEN(1);
   }

#if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
   /**
    *  Configure the PIT channel in seconds
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  intervalInSeconds Interval in seconds
    *  @param[in]  pitChannelAction  Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         PitChannelNum     pitChannelNum,
         Seconds           intervalInSeconds,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, Info::convertSecondsToTicks(intervalInSeconds), pitChannelAction);
   }
#endif // /PIT/secondsSupport

   /**
    *  Configure the PIT channel in milliseconds
    *
    *  @param[in]  pitChannelNum    Channel to configure
    *  @param[in]  milliseconds     Interval in seconds
    *  @param[in]  pitChannelAction Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInMilliseconds(
         PitChannelNum     pitChannelNum,
         unsigned          milliseconds,
         PitChannelAction  pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, convertMillisecondsToTicks(milliseconds), pitChannelAction);
   }

   /**
    *  Configure the PIT channel in microseconds
    *
    *  @param[in]  pitChannelNum    Channel to configure
    *  @param[in]  microseconds     Interval in microseconds
    *  @param[in]  pitChannelAction Action to take on timer event
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInMicroseconds(
         PitChannelNum     pitChannelNum,
         unsigned          microseconds,
         PitChannelAction     pitChannelAction=PitChannelAction_None) {

      configureChannel(pitChannelNum, convertMicrosecondsToTicks(microseconds), pitChannelAction);
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time interval in microseconds
    */
   static unsigned convertTicksToMilliseconds(Ticks ticks) {
      return (unsigned)((1000UL * (unsigned)ticks)/Info::getClockFrequency());
   }

   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] ticks Time interval in ticks
    *
    * @return Time interval in milliseconds
    */
   static unsigned convertTicksToMicroseconds(Ticks ticks) {
      return (unsigned)((1000000UL * (unsigned)ticks)/Info::getClockFrequency());
   }

   /**
    * Converts time in milliseconds to time in ticks
    *
    * @param[in] milliseconds Time interval in milliseconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static Ticks convertMillisecondsToTicks(unsigned milliseconds) {
      unsigned long intervalInTicks = milliseconds*(Info::getClockFrequency()/1000);
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return Ticks((unsigned)intervalInTicks);
   }

   /**
    * Converts time in microseconds to time in ticks
    *
    * @param[in] microseconds Time interval in microseconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static Ticks convertMicrosecondsToTicks(unsigned microseconds) {
      unsigned long intervalInTicks = microseconds*(Info::getClockFrequency()/1000000);
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return Ticks((unsigned)intervalInTicks);
   }

   /**
    * Set period in Ticks
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  ticks         Interval in ticks
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(PitChannelNum pitChannelNum, Ticks ticks) {
      pit->CHANNEL[pitChannelNum].LDVAL = (unsigned)ticks-1;
   }

   /**
    * Set period in microseconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  microseconds  Interval in microseconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInMicroseconds(PitChannelNum pitChannelNum, uint32_t microseconds) {
      setPeriod(pitChannelNum, convertMicrosecondsToTicks(microseconds));
   }

   /**
    * Set period in milliseconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  milliseconds  Interval in milliseconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInMilliseconds(PitChannelNum pitChannelNum, uint32_t milliseconds) {
      setPeriod(pitChannelNum, convertMillisecondsToTicks(milliseconds));
   }

#if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
   /**
    * Set period in seconds
    *
    * @param[in]  pitChannelNum Channel being modified
    * @param[in]  interval Interval in seconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(PitChannelNum pitChannelNum, Seconds interval) {
      setPeriod(pitChannelNum, Ticks((float)interval*Info::getClockFrequency()));
   }
#endif // /PIT/secondsSupport

   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  pitChannelNum   Channel to use
    *  @param[in]  interval        Interval to wait in timer ticks (usually bus clock period)
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(PitChannelNum pitChannelNum, Ticks interval) {
      configureChannel(pitChannelNum, interval);
      while (pit->CHANNEL[pitChannelNum].TFLG == 0) {
         __NOP();
      }
      disableChannel(pitChannelNum);
   }

#if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
   /**
    *  Use a PIT channel to implement a busy-wait delay
    *
    *  @param[in]  pitChannelNum   Channel to use
    *  @param[in]  interval        Interval to wait in seconds
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(PitChannelNum pitChannelNum, Seconds interval) {
      configureChannel(pitChannelNum, interval);
      while (pit->CHANNEL[pitChannelNum].TFLG == 0) {
         __NOP();
      }
      disableChannel(pitChannelNum);
   }
#endif // /PIT/secondsSupport

#if $(/PIT/irqHandlingMethod:false) // /PIT/irqHandlingMethod

   using CallbackFunction = typename Info::CallbackFunction;
   
   /**
    * Set interrupt callback function.
    *
    *  @param pitChannelNum   Channel to configure
    *  @param callback        Callback function to execute on interrupt
    *                         Use nullptr to remove callback.
    */
   static void setCallback(PitChannelNum pitChannelNum, CallbackFunction callback) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
   }

   /**
    * Set interrupt callback function.
    *
    * @param pitIrqNum Used to identify peripheral interrupt
    * @param callback  Callback function to execute on interrupt
    *                  Use nullptr to remove callback.
    */
   static void setCallback(PitBasicInfo::IrqNum pitIrqNum, CallbackFunction callback) {
      Info::setCallback(pitIrqNum, callback);
   }

   /**
    * Set one-shot timer callback in microseconds
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  microseconds      Interval in milliseconds
    */
   static void oneShotInMicroseconds(PitChannelNum pitChannelNum, CallbackFunction callback, uint32_t microseconds) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      configureChannelInMicroseconds(pitChannelNum, microseconds, PitChannelAction_Interrupt);
      CriticalSection cs;
      Info::clearOnEvent |= (1<<pitChannelNum);
   }

   /**
    * Set one-shot timer callback in milliseconds
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  milliseconds      Interval in milliseconds
    */
   static void oneShotInMilliseconds(PitChannelNum pitChannelNum, CallbackFunction callback, uint32_t milliseconds) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      configureChannelInMilliseconds(pitChannelNum, milliseconds, PitChannelAction_Interrupt);
      CriticalSection cs;
      Info::clearOnEvent |= (1<<pitChannelNum);
   }

   /**
    * Set one-shot timer callback in Ticks
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    */
   static void oneShot(PitChannelNum pitChannelNum, CallbackFunction callback, Ticks tickInterval) {
      Info::setCallback(IrqNum(pitChannelNum), callback);
      CriticalSection cs;
      configureChannel(pitChannelNum, tickInterval, PitChannelAction_Interrupt);
      Info::clearOnEvent |= (1<<pitChannelNum);
   }
   
#if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
   /**
    * Set one-shot timer callback.
    *
    *  @note It is necessary to enable NVIC interrupts beforehand
    *
    *  @param[in]  pitChannelNum     Channel to configure
    *  @param[in]  callback          Callback function to be executed on timeout
    *  @param[in]  interval          Interval in seconds until callback is executed
    */
   static void oneShot(PitChannelNum pitChannelNum, CallbackFunction callback, Seconds interval) {
      oneShot(pitChannelNum, callback, Info::convertSecondsToTicks(interval));
   }
#endif // /PIT/secondsSupport
#endif // /PIT/irqHandlingMethod

   /**
    * Class representing a PIT channel.
    * This version may be instantiated and passed as a reference
    */
   class PitChannel {

   public:

      // PIT Owning this channel
      using Owner = PitBase_T<Info>;
      using ChannelInit = typename Info::ChannelInit;

      constexpr PitChannel(PitChannelNum channel) : chan(channel) {}

      /** Timer channel number */
      const PitChannelNum chan;

$(/PIT/memberFunctions: // /PIT/memberFunctions not found)
   };

   /**
    * Class representing a PIT channel
    * This version is a template and may not be instantiated.
    * It is a type only with static member methodes.
    *
    * @tparam channel Timer channel number
    */
   template <int channel>
   class Channel : public PitChannel, private Info {

   private:
      Channel(const Channel&) = delete;
      Channel(Channel&&) = delete;

   public:
      // Allow access to channel initialisation type
      using typename Info::ChannelInit;

      constexpr Channel() : PitChannel(CHANNEL) {};

      /** Timer channel number */
      static constexpr PitChannelNum CHANNEL = (PitChannelNum)channel;
      
$(/PIT/staticFunctions: // /PIT/staticFunctions not found)
   };
   
$(/PIT/InitMethod: // /PIT/InitMethod Not found)
}; // class PitBase_T

$(/PIT/declarations:  // No declarations found)
/**
 * @}
 */

} // End namespace USBDM

#endif // /PIT/enablePeripheralSupport

#endif /* INCLUDE_USBDM_PIT_H_ */

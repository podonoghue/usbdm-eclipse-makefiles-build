/**
 * @file     pcr.h (180.ARM_Peripherals/Project_Headers/pcr.h)
 * @brief    Port Control Register interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_PCR_H
#define HEADER_PCR_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <math.h>
#include <algorithm>
#include <climits>
#include <float.h>
#include "derivative.h"
#include "error.h"

#if __cplusplus <= 201703L
#define consteval constexpr
#endif

// Variable Argument Macro (VA_MACRO) up to 10 arguments
#define USBDM_COUNT_ARGUMENTS_(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, value, ...) value
#define USBDM_COUNT_ARGUMENTS(...) USBDM_COUNT_ARGUMENTS_( __VA_ARGS__ __VA_OPT__(,) 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define USBDM_CONCAT_(left, right) left ## right
#define USBDM_CONCAT(left, right)  USBDM_CONCAT_(left, right)

#define USBDM_VA_MACRO(MACRO, ...) USBDM_CONCAT(MACRO, USBDM_COUNT_ARGUMENTS(__VA_ARGS__))(__VA_ARGS__)

/*
 * Default port information
 */
namespace USBDM {

#if __GNUC__ > 10
// USBDM makes extensive use of enums as bit masks
#pragma GCC diagnostic ignored "-Wdeprecated-enum-enum-conversion"
#endif

#pragma GCC push_options
#pragma GCC optimize ("Os")

$(/PORT/Declarations: // #error /PORT/Declarations not found)
// Pin number for port pin within individual port e.g. GPIOB[31..0]
typedef uint8_t  PinNum;

#if ($(/HARDWARE/useTypeSystemForTimers)) // /HARDWARE/useTypeSystemForTimers
class Ticks {

private:
   unsigned value = 0;

public:
   constexpr Ticks()                   = default;
   constexpr Ticks(const Ticks& other) = default;

   constexpr Ticks(int value)          : value(value) {}
   constexpr Ticks(unsigned value)     : value(value) {}
   constexpr Ticks(long value)         : value((unsigned)value) {}
   constexpr Ticks(unsigned long value): value((unsigned)value) {}
   constexpr Ticks(float    value)     : value(std::round(value)) {}
   constexpr Ticks(double    value)    : value(std::round(value)) {}
   Ticks(const volatile Ticks& other)  : value(other.value) {}

   Ticks &operator =(const Ticks &other) = default;

   auto &operator =(float other)                  {value = other;       return *this; }
   auto &operator =(const volatile Ticks &other)  {
      if (this != &other) {
         value = other.value;
      }
      return *this;
   }

   void  operator =(const Ticks &other) volatile  {
      if (this != &other) {
         value = other.value;
      }
   }

   constexpr auto getValue() const { return value; }
   unsigned getValue() const volatile { return value; }

   constexpr auto operator *(unsigned other) const { return Ticks(value*other); }
   constexpr auto operator *(float    other) const { return Ticks(value*other); }

   constexpr auto operator /(unsigned other) const { return Ticks(value/other); }
   constexpr auto operator /(float    other) const { return Ticks(value/other); }
   constexpr auto operator /(Ticks    other) const { return (value/other.getValue()); }

   constexpr auto operator +(const Ticks &other)    const { return Ticks(value+other.value); }
   constexpr auto operator +(const unsigned other)  const { return Ticks(value+other); }
   constexpr auto operator +(const int other)       const { return Ticks(value+(unsigned)other); }

   constexpr auto operator -(const Ticks &other)    const { return Ticks(value-other.value); }
   constexpr auto operator -(const unsigned other)  const { return Ticks(value-other); }
   constexpr auto operator -(const int other)       const { return Ticks(value-(unsigned)other); }

   constexpr auto operator ==(const Ticks &other)   const { return value==other.value; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }

   constexpr auto operator !=(const Ticks &other)   const { return value!=other.value; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }

   constexpr operator unsigned() const { return value; }
   explicit operator unsigned() const volatile { return value; }
};

class Seconds {

private:
   float value = 0.0;

public:
   constexpr Seconds()                       = default;
   constexpr Seconds(const Seconds& other)   = default;

//   constexpr Seconds(int value)              : value((float)value) {}
//   constexpr Seconds(unsigned value)         : value((float)value) {}
//   constexpr Seconds(long value)             : value((float)value) {}
//   constexpr Seconds(unsigned long value)    : value((float)value) {}
   constexpr Seconds(double value)           : value((float)value) {}
   Seconds(const volatile Seconds& other)    : value(other.getValue()) {}

   Seconds &operator =(const Seconds &other) = default;

   auto &operator =(float other)                    {value = other;       return *this; }
   auto &operator =(const volatile Seconds &other)  {value = other.value; return *this; }

   void  operator =(const Seconds &other) volatile {value = other.value; }

   constexpr auto getValue() const { return value; }
   float getValue() const volatile { return value; }

   constexpr auto operator *(float other)    const { return Seconds(value*other); }
   constexpr auto operator *(unsigned other) const { return Seconds(value*other); }
   constexpr auto operator *(int other)      const { return Seconds(value*other); }

   constexpr auto operator /(float other)    const { return Seconds(value/other); }
   constexpr auto operator /(unsigned other) const { return Seconds(value/other); }
   constexpr auto operator /(int other)      const { return Seconds(value/other); }

   constexpr auto operator /(Seconds other) const { return float(value/other.getValue()); }

   constexpr auto operator +(Seconds other)  const { return Seconds(value+other.value); }
   constexpr auto operator +(float other)    const { return Seconds(value+other); }
   constexpr auto operator +(unsigned other) const { return Seconds(value+other); }
   constexpr auto operator +(int other)      const { return Seconds(value+other); }

   constexpr auto operator -(Seconds other)  const { return Seconds(value-other.value); }
   constexpr auto operator -(float other)    const { return Seconds(value-other); }
   constexpr auto operator -(unsigned other) const { return Seconds(value-other); }
   constexpr auto operator -(int other)      const { return Seconds(value-other); }

   constexpr auto operator ==(const Seconds &other) const { return value==other.value; }
   constexpr auto operator ==(const float other)    const { return value==other; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }
   constexpr auto operator ==(int other)            const { return value==other; }

   constexpr auto operator !=(const Seconds &other) const { return value!=other.value; }
   constexpr auto operator !=(const float other)    const { return value!=other; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }
   constexpr auto operator !=(int other)            const { return value!=other; }

   constexpr auto operator <(const Seconds &other) const { return value<other.value; }
   constexpr auto operator <(const float other)    const { return value<other; }
   constexpr auto operator <(const unsigned other) const { return value<other; }
   constexpr auto operator <(int other)            const { return value<other; }

   constexpr auto operator <=(const Seconds &other) const { return value<=other.value; }
   constexpr auto operator <=(const float other)    const { return value<=other; }
   constexpr auto operator <=(const unsigned other) const { return value<=other; }
   constexpr auto operator <=(int other)            const { return value<=other; }

   constexpr auto operator >(const Seconds &other) const { return value>other.value; }
   constexpr auto operator >(const float other)    const { return value>other; }
   constexpr auto operator >(const unsigned other) const { return value>other; }
   constexpr auto operator >(int other)            const { return value>other; }

   constexpr auto operator >=(const Seconds &other) const { return value>=other.value; }
   constexpr auto operator >=(const float other)    const { return value>=other; }
   constexpr auto operator >=(const unsigned other) const { return value>=other; }
   constexpr auto operator >=(int other)            const { return value>=other; }

   constexpr operator float()    const { return value; }
   explicit  operator float()    const volatile { return value; }
   constexpr operator unsigned() const { return (unsigned)std::round(value); }
   constexpr operator uint32_t() const { return (uint32_t)std::round(value); }
   constexpr operator signed()   const { return (signed)std::round(value); }
   constexpr operator int32_t()  const { return (int32_t)std::round(value); }

   constexpr unsigned round() const { return (unsigned)std::round(value); }
};

class Hertz {
private:
   float value = 0.0;

public:
   constexpr Hertz()                      = default;
   constexpr Hertz(const Hertz& other)    = default;

//   constexpr Hertz(int value)             : value((float)value) {}
//   constexpr Hertz(unsigned value)        : value((float)value) {}
//   constexpr Hertz(long value)            : value((float)value) {}
//   constexpr Hertz(unsigned long value)   : value((float)value) {}
//   constexpr Hertz(float value)           : value((float)value) {}
   constexpr Hertz(double value)          : value((float)value) {}
   Hertz(const volatile Hertz& other)     : value(other.value) {}

   Hertz &operator =(const Hertz &other) = default;

   auto &operator =(float other)                 {value = other;       return *this; }
   auto &operator =(const volatile Hertz &other) {value = other.value; return *this; }

   void  operator =(const Hertz &other) volatile {value = other.value; }

   constexpr auto getValue() const { return value; }
   float getValue() const volatile { return value; }

   constexpr auto operator *(float other)    const { return Hertz(value*other); }
   constexpr auto operator *(unsigned other) const { return Hertz(value*other); }
   constexpr auto operator *(int other)      const { return Hertz(value*other); }

   constexpr auto operator /(float other)    const { return Hertz(value/other); }
   constexpr auto operator /(unsigned other) const { return Hertz(value/other); }
   constexpr auto operator /(int other)      const { return Hertz(value/other); }

   constexpr auto operator /(Hertz other) const { return (float)(value/other.getValue()); }

   constexpr auto operator +(Hertz other) const { return Hertz(value+other.value); }
   constexpr auto operator -(Hertz other) const { return Hertz(value+other.value); }

   constexpr auto operator ==(const Hertz &other)   const { return value==other.value; }
   constexpr auto operator ==(const float other)    const { return value==other; }
   constexpr auto operator ==(const unsigned other) const { return value==other; }
   constexpr auto operator ==(int other)            const { return value==other; }

   constexpr auto operator !=(const Hertz &other)   const { return value!=other.value; }
   constexpr auto operator !=(const float other)    const { return value!=other; }
   constexpr auto operator !=(const unsigned other) const { return value!=other; }
   constexpr auto operator !=(int other)            const { return value!=other; }

   constexpr auto operator <(const Hertz &other)   const { return value<other.value; }
   constexpr auto operator <(const float other)    const { return value<other; }
   constexpr auto operator <(const unsigned other) const { return value<other; }
   constexpr auto operator <(int other)            const { return value<other; }

   constexpr auto operator <=(const Hertz &other)   const { return value<=other.value; }
   constexpr auto operator <=(const float other)    const { return value<=other; }
   constexpr auto operator <=(const unsigned other) const { return value<=other; }
   constexpr auto operator <=(int other)            const { return value<=other; }

   constexpr auto operator >(const Hertz &other)   const { return value>other.value; }
   constexpr auto operator >(const float other)    const { return value>other; }
   constexpr auto operator >(const unsigned other) const { return value>other; }
   constexpr auto operator >(int other)            const { return value>other; }

   constexpr auto operator >=(const Hertz &other)   const { return value>=other.value; }
   constexpr auto operator >=(const float other)    const { return value>=other; }
   constexpr auto operator >=(const unsigned other) const { return value>=other; }
   constexpr auto operator >=(int other)            const { return value>=other; }

   constexpr operator float()    const { return value; }
   constexpr operator unsigned() const { return (unsigned)std::round(value); }
   constexpr operator uint32_t() const { return (uint32_t)std::round(value); }
   constexpr operator signed()   const { return (signed)std::round(value); }
   constexpr operator int32_t()  const { return (int32_t)std::round(value); }

   constexpr unsigned round() const { return (unsigned)std::round(value); }
};

constexpr auto operator *(float left,     Seconds right)  { return Seconds(left*right.getValue()); }
constexpr auto operator *(unsigned left,  Seconds right)  { return Seconds(left*right.getValue()); }
constexpr auto operator *(int left,       Seconds right)  { return Seconds(left*right.getValue()); }

constexpr auto operator *(float left,     Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(unsigned left,  Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(int left,       Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(Ticks left,     Hertz right)    { return Hertz(left*right.getValue()); }
constexpr auto operator *(Seconds left,   Hertz right)    { return Ticks(left.getValue()*right.getValue()); }

constexpr auto operator /(float left,     Seconds right) { return Hertz(left/right.getValue()); }
constexpr auto operator /(unsigned left,  Seconds right) { return Hertz(left/right.getValue()); }
constexpr auto operator /(int left,       Seconds right) { return Hertz(left/right.getValue()); }

constexpr auto operator /(float left,     Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(unsigned left,  Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(int left,       Hertz right)   { return Seconds(left/right.getValue()); }
constexpr auto operator /(Ticks left,     Hertz right)   { return Seconds(left.getValue()/right.getValue()); }

using Percent  = float;

#else
enum Ticks : unsigned {

};
//   using Ticks    = unsigned;
   using Seconds  = float;
   using Hertz    = float;
   using Percent  = float;

   static inline constexpr Ticks operator+ (const Ticks &left, const Ticks &right) {
      return Ticks(unsigned(left)+unsigned(right));
   }

   static inline constexpr Ticks operator- (const Ticks &left, const Ticks &right) {
      return Ticks(unsigned(left)-unsigned(right));
   }

   static inline constexpr Ticks operator* (const Ticks &left, const int &right) {
      return Ticks(unsigned(left)*right);
   }

   static inline constexpr Ticks operator* (const int &left, const Ticks &right) {
      return Ticks((left)*unsigned(right));
   }

#endif

   /**
    * Create a value of type `To` from the bits of `from`.
    *
    * @tparam To       To type
    * @tparam From     From type
    * @param  from     Object to convert
    *
    * @return  object converted to target type
    */
   template<typename To, typename From>
   [[nodiscard]]
    constexpr To bit_cast(const From& from) noexcept {
      return __builtin_bit_cast(To, from);
   }

/**
 * Convenience class for sharing storage of time measurements in ticks and seconds
 */
union Seconds_Ticks {
   ///  Time in seconds or Ticks
   uint32_t value;

   constexpr Seconds_Ticks() : value(0) {}

   constexpr Seconds toSeconds() const { return bit_cast<float, unsigned>(value); }
   constexpr Ticks   toTicks()   const { return (Ticks)value; }

#if $(/HARDWARE/useTypeSystemForTimers) // /HARDWARE/useTypeSystemForTimers
   constexpr void fromSeconds(Seconds seconds) { value = bit_cast<unsigned, float>(seconds.getValue()); }
   constexpr void fromTicks(Ticks ticks)       { value = ticks.getValue(); }
#else
   constexpr void fromSeconds(Seconds seconds) { value = bit_cast<unsigned, float>(seconds); }
   constexpr void fromTicks(Ticks ticks)       { value = ticks; }
#endif

};

   /*
    * Allows writing numbers with units e.g. 100_ms
    */
   consteval auto operator"" _ticks(unsigned long long int num) { return static_cast<Ticks>((unsigned)num); };
   consteval auto operator"" _ticks(long double num)            { return static_cast<Ticks>((float)num); };

   consteval auto operator"" _s(unsigned long long int num)     { return static_cast<Seconds>((double)num); };
   consteval auto operator"" _s(long double num)                { return static_cast<Seconds>((double)num); };

   consteval auto operator"" _ms(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.001)); };
   consteval auto operator"" _ms(long double num)               { return static_cast<Seconds>((double)(num*0.001)); };

   consteval auto operator"" _us(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.000001)); };
   consteval auto operator"" _us(long double num)               { return static_cast<Seconds>((double)(num*0.000001)); };

   consteval auto operator"" _ns(unsigned long long int num)    { return static_cast<Seconds>((double)(num*0.000000001)); };
   consteval auto operator"" _ns(long double num)               { return static_cast<Seconds>((double)(num*0.000000001)); };

   consteval auto operator"" _Hz(unsigned long long int num)    { return static_cast<Hertz>((double)num); };
   consteval auto operator"" _Hz(long double num)               { return static_cast<Hertz>((double)num); };

   consteval auto operator"" _kHz(unsigned long long int num)   { return static_cast<Hertz>((double)(num*1000)); };
   consteval auto operator"" _kHz(long double num)              { return static_cast<Hertz>((double)(num*1000)); };

   consteval auto operator"" _MHz(unsigned long long int num)   { return static_cast<Hertz>((double)(num*1000000)); };
   consteval auto operator"" _MHz(long double num)              { return static_cast<Hertz>((double)(num*1000000)); };

   consteval auto operator"" _percent(unsigned long long int num)  { return static_cast<Percent>((num)*0.01); };
   consteval auto operator"" _percent(long double num)             { return static_cast<Percent>((num)*0.01); };

$(/PCR/nvicPriority: // /PCR/nvicPriority not found)
/**
 * Class to wrap a memory address as an array
 *
 * @tparam T         Type of array element
 * @tparam address   Memory address of start of array
 * @tparam size      Size of array (in elements)
 */
template<typename T, uint32_t address, size_t Size>
class MemoryAddressWrapper {

public:

   static constexpr size_t size = Size;

   /**
    * Array access
    *
    * @return Reference to element of type T
    *
    * @note The const below refers to the MemoryAddressWrapper being const not the implied array
    */
   constexpr T & __attribute__((always_inline)) operator[](size_t index) const {
      usbdm_assert(index<size, "Index out of range");
      return (reinterpret_cast<T *>(address))[index];
   }

};

/**
 * This is to allow use of hardware pointers in classes with a constexpr constructor !
 *
 * @tparam T  The type of the hardware to create a pointer for
 */
template<typename T>
class HardwarePtr {

private:
   HardwarePtr() = delete;
   HardwarePtr(const HardwarePtr&) = delete;
   HardwarePtr(HardwarePtr&&) = delete;

   // Address of hardware
   const uintptr_t ptr;

public:
   /**
    * Constructor for hardware pointer
    *
    * @param ptr  Address of hardware to be wrapped.
    */
   constexpr __attribute__((always_inline))  HardwarePtr(uintptr_t ptr) : ptr(ptr){};

   /**
    * Convert to pointer to the hardware
    *
    * @return Hardware pointer
    */
   constexpr auto __attribute__((always_inline))  operator->() const { return reinterpret_cast<volatile T *>(ptr);}

   /**
    * Convert to reference to the hardware
    *
    * @return Hardware pointer
    */
   constexpr auto & __attribute__((always_inline))  operator*() const { return *reinterpret_cast<volatile T *>(ptr);}

   /**
    * Convert to uint32_t
    *
    * @return uint32
    */
   constexpr __attribute__((always_inline))  operator uint32_t() const { return ptr; }

   /**
    * Get value as volatile pointer to hardware
    */
   constexpr __attribute__((always_inline))  operator volatile T *() const { return reinterpret_cast<volatile T *>(ptr);}
};

/**
 * Enable and set priority of interrupts in NVIC.
 *
 * @param[in]  irqNum        Interrupt number
 * @param[in]  nvicPriority  Interrupt priority
 *
 * @note Any pending interrupts are cleared before enabling.
 * @note NvicPriority_Disabled will actually disable interrupts
 */
void enableNvicInterrupt(IRQn_Type irqNum, NvicPriority nvicPriority);

/**
 * @addtogroup PeripheralPinTables Peripheral Information Classes
 * @brief Provides information about pins used by a peripheral
 * @{
 */

/**
 * Used to indicate or control the polarity of an I/O with selectable polarity
 */
enum Polarity : uint32_t {
   ActiveLow  = 0xFFFFFFFFU,  ///< Signal is active low i.e. Active => Low level, Inactive => High level
   ActiveHigh = 0x00000000U,  ///< Signal is active high i.e. Active => High level, Inactive => Low level
};


#ifdef PCC
/**
 * Enable clock to selected ports
 *
 * @param[in] pccAddress Address of PCC register for port to enable
 */
static inline void enablePortClocks(uint32_t pccAddress) {
   *(volatile uint32_t *)pccAddress = *(volatile uint32_t *)pccAddress | PCC_PCCn_CGC_MASK;
   __DMB();
};

/**
 * Disable clock to selected ports
 *
 * @param[in] pccAddress Address of PCC register for port to disable
 */
static inline void disablePortClocks(uint32_t pccAddress) {
   *(volatile uint32_t *)pccAddress = *(volatile uint32_t *)pccAddress & ~PCC_PCCn_CGC_MASK;
   __DMB();
};

#endif

#ifdef PORT_PCR_MUX_MASK

#ifndef PORT_PCR_LK
/**
 * Some devices don't have LK function on pin
 */
#define PORT_PCR_LK(x) (0)
#endif

#ifndef PORT_PCR_DSE
/**
 * Some devices don't have DSE function on pin
 */
#define PORT_PCR_DSE(x) (0)
#endif

#ifndef PORT_PCR_ODE
/**
 * Some devices don't have ODE function on pin
 * The open-drain mode is automatically selected when I2C function is selected for the pin
 */
#define PORT_PCR_ODE(x) 0
#endif

#ifndef PORT_PCR_PE
/**
 * Some devices don't have PE function on pin
 */
#define PORT_PCR_PE(x) 0
#endif

#ifndef PORT_PCR_PS
/**
 * Some devices don't have PS function on pin
 */
#define PORT_PCR_PS(x) 0
#endif

#ifndef PORT_PCR_SRE
/**
 * Some devices don't have PS function on pin
 */
#define PORT_PCR_SRE(x) 0
#endif

#ifndef PORT_PCR_PFE
/**
 * Some devices don't have PFE function on pin
 */
#define PORT_PCR_PFE(x) 0
#endif

/**
 * PCR value
 */
enum class PcrValue : uint32_t {
   // Using an ENUM prevents automatic conversions from uint32_t to PcrValue
};

constexpr uint32_t operator ~(PcrValue pcrValue) {
   return ~static_cast<uint32_t>(pcrValue);
}

constexpr uint32_t operator &(PcrValue pcrValue, uint32_t mask) {
   return static_cast<uint32_t>(pcrValue) & mask;
}

constexpr bool operator ==(PcrValue pcrValue, uint32_t mask) {
   return static_cast<uint32_t>(pcrValue) & mask;
}

$(/PCR/pcr_enums: // /PCR/pcr_enums not found)


template<typename ... V>
constexpr PcrValue pcrOr(const V &... v) {
  std::common_type_t<PcrValue> result = {};
  (void)std::initializer_list<uint32_t>{ (result = (result | v), 0U)... };
  return result;
}

/**
 * Force a PcrValue to refer to the GPIO function i.e. MUX field = PinMux_Gpio
 *
 * @param op   PCR value to base result on
 *
 * @return  Modified PCR value
 */
constexpr PcrValue gpioPcrValue(PcrValue op) {
   return (PcrValue)((op&~PORT_PCR_MUX_MASK)|PinMux_Gpio);
}

/**
 * Force a PcrValue to refer to the Analogue function i.e. MUX field = PinMux_Analogue
 *
 * @param op   PCR value to base result on
 *
 * @return  Modified PCR value
 */
constexpr PcrValue analoguePcrValue(PcrValue op) {
   return (PcrValue)((op&~PORT_PCR_MUX_MASK)|PinMux_Analogue);
}


$(/PCR/extra_methods: // /PCR/extra_methods Not found)
#if 0
/**
 * Port information
 * Information required to configure the PCR for a particular function
 */
class PortInfo {

private:
   PortInfo() = delete;
   PortInfo(const PortInfo&) = delete;
   PortInfo(PortInfo&&) = delete;

public:
   const NvicPriority  irqLevel;     ///< Interrupt priority level or NvicPriority_NotInstalled if handler not installed

   constexpr PortInfo(const NvicPriority  nvicPriority) :
               irqLevel(nvicPriority) {
   }
};
#endif

/**
 * Pin information
 */
class PinInfo {

private:
   PinInfo() = delete;
   PinInfo(const PinInfo&) = delete;
   PinInfo(PinInfo&&) = delete;

public:
   const PinIndex      pinIndex;     ///< Pin index for pin e.g. PTC3
   const PcrValue      pcrValue;     ///< Default PCR value for pin - Includes PinMux value which determines pin use in most cases

   /**
    * Constructor from portInfo etc.
    *
    * @param pinIndex      Pin index to determine associated GPIO
    * @param pcrValue      Default PCR value for pin
    */
   constexpr PinInfo(
         PinIndex        pinIndex,
         PcrValue        pcrValue) : pinIndex(pinIndex), pcrValue(pcrValue) {
   }
};

#ifdef PORT_DFCR_CS_MASK
   /**
    * Controls the Digital Pin Filter clock source
    */
   enum PinDigitalFilterClock {
      PinDigitalFilterClock_BusClock = PORT_DFCR_CS(0),///< Pin Digital Filter Clock = BusClock
      PinDigitalFilterClock_LpoClock = PORT_DFCR_CS(1),///< Pin Digital Filter Clock = Low Power Oscillator
   };
#endif

/**
 * Type definition for PORT interrupt call back.
 * This callback is shared by all port pins
 *
 * @param[in] status 32-bit value from ISFR (each bit indicates a pin interrupt source)
 */
typedef void (*PinCallbackFunction)();

/**
 * Provides common unhandledCallback for all PORTs
 */
class PcrBase {

public:
   /**
    * Limit index to permitted bit index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param bitNum   Index to limit
    *
    * @return Index limited to permitted range
    */
   static inline constexpr int limitIndex(int bitNum) {
      if (bitNum<0) {
         return 0;
      }
      if (bitNum>=(int)(sizeof(uint32_t)*CHAR_BIT)) {
         return int((sizeof(uint32_t)*CHAR_BIT)-1);
      }
      return bitNum;
   }

   /**
    * Class to static check signal exists and is mapped to a pin
    *
    * @tparam pinIndex Pin index to check
    */
   template<PinIndex pinIndex> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Function is not currently mapped to a pin
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);
      // Peripheral signal does not exit
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);
      // Peripheral signal mapped directly to pin - no PCR (not an error)
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);
      // Illegal value
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));

      static_assert(check1, "Peripheral signal is not mapped to a pin - Modify Configure.usbdm");
      static_assert(check2, "Peripheral signal doesn't exist in this device/package - Check Configure.usbdm for available signals");
      static_assert(check4, "Illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

#define CreatePinChecker(periph)                                                                                                                        \
   template<PinIndex pinIndex> class CheckPinExistsAndIsMapped {                                                                                        \
      /* Tests are chained so only a single assertion can fail so as to reduce noise */                                                                 \
                                                                                                                                                        \
      /* Function is not currently mapped to a pin */                                                                                                   \
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);                                                                              \
      /* Peripheral signal does not exit */                                                                                                             \
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);                                                                    \
      /* Peripheral signal mapped directly to pin - no PCR (not an error) */                                                                            \
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);                                                        \
      /* Illegal value */                                                                                                                               \
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));      \
                                                                                                                                                        \
      static_assert(check1, periph " signal is not mapped to a pin - Modify Configure.usbdm");                                                          \
      static_assert(check2, periph " signal doesn't exist in this device/package - Check Configure.usbdm for available signals");                       \
      static_assert(check4, periph " illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");                       \
                                                                                                                                                        \
   public:                                                                                                                                              \
      /** Dummy function to allow convenient in-line checking */                                                                                        \
      static constexpr void check() {}                                                                                                                  \
   };

#define CreatePeripheralPinChecker(periph)                                                                                                              \
   template<class Inf, int signalNum> class CheckPinExistsAndIsMapped {                                                                                \
                                                                                                                                                        \
      /* Check index is valid for peripheral INFO table */                                                                                              \
      static_assert(signalNum<Inf::numSignals, periph " illegal signal index");                                                                        \
                                                                                                                                                        \
      static constexpr PinIndex pinIndex = Inf::info[signalNum].pinIndex;                                                                              \
                                                                                                                                                        \
      /* Tests are chained so only a single assertion can fail so as to reduce noise */                                                                 \
                                                                                                                                                        \
      /* Function is not currently mapped to a pin */                                                                                                   \
      static constexpr bool check1 = (pinIndex != PinIndex::UNMAPPED_PCR);                                                                              \
      /* Peripheral signal does not exit */                                                                                                             \
      static constexpr bool check2 = !check1 || (pinIndex != PinIndex::INVALID_PCR);                                                                    \
      /* Peripheral signal mapped directly to pin - no PCR (not an error) */                                                                            \
      static constexpr bool check3 = !check1 || !check2 || (pinIndex != PinIndex::FIXED_NO_PCR);                                                        \
      /* Illegal value */                                                                                                                               \
      static constexpr bool check4 = !check1 || !check2 || !check3 || ((pinIndex>=PinIndex::MIN_PIN_INDEX) && (pinIndex<PinIndex::MAX_PIN_INDEX));      \
                                                                                                                                                        \
      static_assert(check1, periph " signal is not mapped to a pin - Modify Configure.usbdm");                                                          \
      static_assert(check2, periph " signal doesn't exist in this device/package - Check Configure.usbdm for available signals");                       \
      static_assert(check4, periph " illegal pin index - should be in range [PinIndex::MIN_PIN_INDEX..PinIndex::MAX_PIN_INDEX)");                       \
                                                                                                                                                        \
   public:                                                                                                                                              \
      /** Dummy function to allow convenient in-line checking */                                                                                        \
      static constexpr void check() {}                                                                                                                  \
   };

   /**
    * Class to static check signal mapping is valid for a peripheral
    * Conditions are chained so only a single assert is reported
    *
    * @tparam Info         Info table used for lookup
    * @tparam signalNum    Index into table
    */
   template<class Info, int signalNum> class CheckSignalMapping {

      static constexpr PinIndex pinIndex = Info::info[signalNum].pinIndex;

      /* Illegal index for table */
      static_assert(signalNum<Info::numSignals, "Illegal signal index for this peripheral");

   public:
      static void check() {
         CheckPinExistsAndIsMapped<pinIndex>::check();
      }
   };

private:
   /**
    * Restrict
    */
   PcrBase(const PcrBase&) = delete;
   PcrBase(PcrBase&&) = delete;

protected:
   PcrBase() = default;

public:
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   
$(/PORT/AccessFunctions: #error /PORT/AccessFunctions not found)

   /**
    * Get PCR from pinIndex
    *
    * @param pinIndex Pin index e.g. PinIndex::PTB3. Used to determine return value
    *
    * @return Pointer to relevant PORT
    */
   static constexpr uint32_t getPcrAddress(PinIndex pinIndex){

      return getPortAddress(mapPinToPort(pinIndex)) + offsetof(PORT_Type, PCR) + sizeof(PORT_Type::PCR[0])*(int(pinIndex)%32);
   }

   /**
    * Enable clock to selected port
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine port
    */
   static inline void enablePortClock(PinIndex pinIndex) {
      SIM->SCGC5 = SIM->SCGC5 | getClockMask(pinIndex);
      __DMB();
   }

   /**
    * Disable clock to selected port
    *
    * @param pinIndex Pin index e.g. PTB3. Used to determine port
    */
   static inline void disablePortClock(PinIndex pinIndex) {
      SIM->SCGC5 = SIM->SCGC5 & ~getClockMask(pinIndex);
      __DMB();
   }

   /**
    * Translate a bitNum within a PORT/GPIO to a pinIndex
    *
    * @param basePinIndex The pinIndex for the first bit of associated PORT/GPIO e.g. PTC0
    * @param bitNum       Bit number within the PORT/GPIO
    *
    * @return  PinIndex of the bit
    */
   static constexpr PinIndex pinIndexOf(PinIndex basePinIndex, int bitNum) {
      return PinIndex(int(basePinIndex)+bitNum);
   }
};

/**
 * Common PORT features shared across all port pins
 *
 * @tparam portIndex PortIndex used to determine associated port
 */
template<PortIndex portIndex>
class PcrBase_T : public PcrBase {

private:
   /**
    * This class is not intended to be instantiated
    */
   PcrBase_T(const PcrBase_T&) = delete;
   PcrBase_T(PcrBase_T&&) = delete;

public:

   // Empty Constructor
   constexpr PcrBase_T() = default;

#if defined(PORT_DFCR_CS_MASK)
   /// PORT hardware as pointer to struct
   static constexpr HardwarePtr<PORT_DFER_Type> port = PcrBase::getPortAddress(portIndex);
#else
   /// PORT hardware as pointer to struct
   static constexpr HardwarePtr<PORT_Type> port = PcrBase::getPortAddress(portIndex);
#endif

   /// Hardware IRQ number (Negative if interrupts are not supported by PORT)
   static constexpr IRQn_Type irqNum = PcrBase::getIrqNum(portIndex);

   /// Hardware IRQ index (Negative if interrupts are not supported by PORT or disabled)
   static constexpr PortIrqNum portIrqNum = PcrBase::getIrqIndex(portIndex);

   /// Indicates if USBDM port pin interrupt handler has been installed in vector table
   static constexpr bool HANDLER_INSTALLED = PcrBase::isHandlerInstalled(mapPortToPin(portIndex));

public:
#if $(/GPIO/_CommonInfoIrqGuard:false)   // /GPIO/_CommonInfoIrqGuard   
   /**
    * Set callback for Pin interrupts
    *
    * @param[in] pinCallback The function to call on Pin interrupt. \n
    *                        nullptr to indicate none
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note There is a single callback function for all pins on the related port.
    *       It is necessary to identify the originating pin in the callback
    */
   static void setPinCallback(PinCallbackFunction pinCallback) {
      static_assert(portIrqNum>=0, "Port doesn't support interrupts or they are disabled");
      PcrBase::setPinCallback(portIrqNum, pinCallback);
   }

   /**
    * Get pin change event flags
    *
    * @return status 32-bit value from ISFR (each bit indicates a pin interrupt source)
    */
   static uint32_t getPinEventFlags() {
      static_assert(portIrqNum>=0, "Port doesn't support interrupts or they are disabled");
      return port->ISFR;
   }
#endif // /GPIO/_CommonInfoIrqGuard

   /**
    * Enable Pin interrupts in NVIC.
    */
   static void enableNvicPinInterrupts() {
      static_assert(irqNum>=0, "Port doesn't support interrupts");
      NVIC_EnableIRQ(irqNum);
   }

   /**
    * Enable and set priority of Pin interrupts in NVIC.
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicPinInterrupts(NvicPriority nvicPriority) {
      static_assert(irqNum>=0, "Port doesn't support interrupts");
      enableNvicInterrupt(irqNum, nvicPriority);
   }

   /**
    * Disable Pin interrupts in NVIC.
    */
   static void disableNvicPinInterrupts() {
      static_assert(irqNum>=0, "Port doesn't support interrupts");
      NVIC_DisableIRQ(irqNum);
   }
   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PinCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::Pin<LlwuPin_0>::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Llwu::Pin<LlwuPin_0>::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t), T &object>
   static PinCallbackFunction wrapCallback() {
      static PinCallbackFunction fn = [](uint32_t status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match PinCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Llwu::Pin<LlwuPin_0>::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Llwu::Pin<LlwuPin_0>::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t)>
   static PinCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static PinCallbackFunction fn = [](uint32_t status) {
         (obj.*callback)(status);
      };
      return fn;
   }
};


/**
 * @brief Template representing a Pin Control Register (PCR)
 *
 * Code examples:
 * @code
 * // Create PCR type
 * using PortC_3 = USBDM::Pcr_T<USBDM::DEFAULT_PCR, PTC3>;
 *
 * // Configure PCR
 * PortC_3::setPCR(PinPull_Up,PinDriveStrength_High,PinDriveMode_PushPull,PinAction_None,PinFilter_None,PinSlewRate_Fast,PinMux_3);
 *
 * // Disable Port clock
 * PortC_3::disableClock();
 * @endcode
 *
 * @tparam defPcrValue           Default value for PCR (including MUX value)
 * @tparam pinIndex              Pin index e.g. PTA3
 */
template<PcrValue defPcrValue, PinIndex pinIndex>
class Pcr_T : public PcrBase_T<mapPinToPort(pinIndex)> {

protected:
   /// Default constructor used by derived classes only
   constexpr Pcr_T() {};

public:
   /// Bit number of bit being manipulated within underlying port hardware
   static constexpr int BITNUM = int(pinIndex)%32;

   /// Mask for the bit being manipulated within underlying port hardware
   static constexpr uint32_t BITMASK = makeBitMask(BITNUM);

   /// Default PCR value including PinMux value for peripheral
   static constexpr PcrInit defaultPcrValue = defPcrValue;

   /// Address of associated port
   static constexpr uint32_t portAddress = PcrBase::getPortAddress(mapPinToPort(pinIndex));

private:
   /**
    * This class is not intended to be instantiated
    */
   Pcr_T(const Pcr_T&) = delete;
   Pcr_T(Pcr_T&&) = delete;

   static constexpr HardwarePtr<uint32_t> PCR = PcrBase::getPcrAddress(pinIndex);

public:
   /**
    * Enable clock associated with PORT
    */
   static void enablePortClock() {
      if constexpr (portAddress != 0) {
         PcrBase::enablePortClock(pinIndex);
      }
   }

   /**
    * Disable clock associated with PORT
    */
   static void disablePortClock() {
      if constexpr (portAddress != 0) {
         PcrBase::disablePortClock(pinIndex);
      }
   }

   /**
    * Get Pin Control Register (PCR) value \n
    * The clock to the port will be enabled before reading the PCR
    *
    * @return pcrValue PCR value.
    */
   static uint32_t getPCR() {
      if constexpr (portAddress == 0) {
         return 0;
      }
      PcrBase::enablePortClock(pinIndex);
      return *PCR;
   }
   
$(/PCR/set_pcr: // /PCR/set_pcr not found)
$(/PCR/set_output: // /PCR/set_output not found)
$(/PCR/set_input: // /PCR/set_input not found)
$(/PCR/set_pcr_option: // /PCR/set_pcr_option not found)
   /**
    *  Disable Pin
    *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
    *
    *  @note The clock is left enabled as shared with other pins.
    *  @note Mux(0) is also the Analogue MUX setting
    */
   static void disablePin() {
      if constexpr (portAddress != 0) {
         enablePortClock();
         setPcrOption(PinMux_Disabled);
      }
   }

   /**
    * Clear pin change event flag.
    * Assumes clock to the port has already been enabled.
    */
   static void clearPinEventFlag() {
      if constexpr (portAddress != 0) {
         *PCR = *PCR | PORT_PCR_ISF_MASK;
      }
   }

#ifdef PORT_DFCR_CS_MASK
   /**
    * Configures Digital Pin Filter
    *
    * @param pinDigitalFilterClock  Clock source
    * @param filterLength           Filter length in clock ticks
    *
    * @note Not all ports support this feature
    * @note This affects the digital filter for all pins of this port
    */
   static void configureDigitalPinFilter(PinDigitalFilterClock pinDigitalFilterClock, int filterLength) {
      if constexpr (portAddress != 0) {
         // Disable all filtering before change
         uint32_t dfer = Pcr_T::port->DFER;
         Pcr_T::port->DFER = 0;

         Pcr_T::port->DFCR = pinDigitalFilterClock;
         Pcr_T::port->DFWR = PORT_DFWR_FILT(filterLength);

         // Restore filtering on pins
         Pcr_T::port->DFER = dfer;
      }
   }

   /**
    * Enable digital filter on the pin
    *
    * @note Not all ports support this feature
    */
   static void enableDigitalPinFilter() {
      if constexpr (portAddress != 0) {
         Pcr_T::port->DFER = Pcr_T::port->DFER | BITMASK;
      }
   }

   /**
    * Disable digital filter on the pin
    *
    * @note Not all ports support this feature
    */
   static void disableDigitalPinFilter() {
      if constexpr (portAddress != 0) {
         Pcr_T::port->DFER = Pcr_T::port->DFER & ~BITMASK;
      }
   }
#endif

};

/**
 * @brief Template function to set a PCR to the default value
 *
 * @tparam  Last PCR to modify
 */
template<typename Last>
void processPcrs() {
   Last::setPCR();
}
/**
 * @brief Template function to set a collection of PCRs to the default value
 *
 * @tparam  Pcr1 PCR to modify
 * @tparam  Pcr2 PCR to modify
 * @tparam  Rest Remaining PCRs to modify
 */
template<typename Pcr1, typename  Pcr2, typename  ... Rest>
void processPcrs() {
   processPcrs<Pcr1>();
   processPcrs<Pcr2, Rest...>();
}
/**
 * @brief Template function to set a PCR to a given value
 *
 * @param[in]   pcrValue PCR value to set
 *
 * @tparam  Last PCR to modify
 */
template<typename Last>
void processPcrs(uint32_t pcrValue) {
   Last::setPCR(pcrValue);
}

/**
 * @brief Template function to set a collection of PCRs to a given value
 *
 * @param[in] pcrValue PCR value to set
 *
 * @tparam  Pcr1 PCR to modify
 * @tparam  Pcr2 PCR to modify
 * @tparam  Rest Remaining PCRs to modify
 */
template<typename Pcr1, typename  Pcr2, typename  ... Rest>
void processPcrs(uint32_t pcrValue) {
   processPcrs<Pcr1>(pcrValue);
   processPcrs<Pcr2, Rest...>(pcrValue);
}

/**
 * @brief Template representing a Pin Control Register (PCR)\n
 * Makes use of an info[] table in a configuration class
 *
 * Code examples:
 * @code
 * // Create PCR type
 * PcrTable_T<spiInfo, 3> SpiMOSI;
 *
 * // Configure PCR
 * SpiMOSI::setPCR(PinPull_Up,PinDriveStrength_High,PinDriveMode_PushPull,PinAction_None,PinFilter_None,PinSlewRate_Fast,PinMux_3);
 *
 * // Disable clock to associated PORT
 * SpiMOSI::disableClock();
 *
 * // Alternatively the PCR may be manipulated directly
 * Pcr_T<spiInfo, 3>::setPCR(PORT_PCR_DSE_MASK|PORT_PCR_PE_MASK|PORT_PCR_PS_MASK);
 * @endcode
 *
 * @tparam info          Configuration class
 * @tparam index         Index of pin in configuration table within class
 */
template<class Info, uint8_t index>
class PcrTable_T : public Pcr_T<Info::info[index].pcrValue, Info::info[index].pinIndex> {
};
/**
 * @}
 ** PeripheralPinTables
 */

#endif // PORT_PCR_MUX_MASK

#if defined(RELEASE_BUILD)
// MACRO to do OR operation
#define USBDM_PCR_OR(...) USBDM_CONCAT(USBDM_OR, USBDM_COUNT_ARGUMENTS(__VA_ARGS__))(__VA_ARGS__)
#define USBDM_OR0()
#define USBDM_OR1(a)           (PcrValue)(a)
#define USBDM_OR2(a,b)         (PcrValue)(a|b)
#define USBDM_OR3(a,b,c)       (PcrValue)(a|b|c)
#define USBDM_OR4(a,b,c,d)     (PcrValue)(a|b|c|d)
#define USBDM_OR5(a,b,c,d,e)   (PcrValue)(a|b|c|d|e)
#define USBDM_OR6(a,b,c,d,e,f) (PcrValue)(a|b|c|d|e|f)
#endif

/**
 * Helper class to wrap member functions as static callback function
 *
 * @tparam T      Type of class containing callback
 * @tparam unique Type used to obtain unique instance
 * @tparam P      Parameters of callback
 */
template<typename T, typename unique, typename... P>
class CallbackWrapper {

   typedef  void(T::*TMemberFunction)(P...);

   inline static TMemberFunction memberFunction;
   inline static T*              classInstance;

private:
   /** No Default Constructor */
   constexpr CallbackWrapper() = delete;
   
   /** No Copy Constructor */
   constexpr CallbackWrapper(const CallbackWrapper &) = delete;

   /** No Copy-Assignment */
   CallbackWrapper& operator=(const CallbackWrapper&) = delete; 
   
public:
   /**
    * Function to wrap a member function as a static callback function
    *
    * @param classInstance    Reference to instance of class
    * @param memberFunction   Pointer to the member function
    *
    * @return  Wrapper
    */
   constexpr CallbackWrapper(T *classInstance, TMemberFunction memberFunction) {
      CallbackWrapper::classInstance  = classInstance;
      CallbackWrapper::memberFunction = memberFunction;
   }

   /**
    * Static callback function
    *
    * @param args
    */
   static void callback(P... args) {
      (classInstance->*memberFunction)(args...);
   }
};

/**
 * Function to wrap a member function as a static callback function
 *
 * @tparam T               Type of class containing callback (inferred)
 *
 * @param classInstance    Reference to instance of class
 * @param memberFunction   Pointer to the member function
 *
 * @return  Wrapper
 */
template<typename T>
inline auto wrapCallback(T &classInstance, void (T::*memberFunction)()) {
   static CallbackWrapper<T, PinIndex> sClass(&classInstance, memberFunction);
   return sClass.callback;
}

/**
 * Function to wrap a member function as a static callback function
 *
 * @tparam T               Type of class containing callback (inferred)
 *
 * @param classInstance    Pointer to instance of class
 * @param memberFunction   Pointer to the member function
 *
 * @return  Wrapper
 */
template<typename T>
inline auto wrapCallback(T *classInstance, void (T::*memberFunction)()) {
   static CallbackWrapper<T, PinIndex> sClass(classInstance, memberFunction);
   return sClass.callback;
}

/**
 * Function to wrap a member function as a static callback function
 *
 * @tparam T               Type of class containing callback (inferred)
 *
 * @param classInstance    Reference to instance of class
 * @param memberFunction   Pointer to the member function
 *
 * @return  Wrapper
 */
template<typename T, typename... P>
auto wrapCallback(T &classInstance, void (T::*memberFunction)(P...)) {
   static CallbackWrapper<T, PinIndex, P...> sClass(&classInstance, memberFunction);
   return sClass.callback;
}

/**
 * Function to wrap a member function as a static callback function
 *
 * @tparam T               Type of class containing callback (inferred)
 *
 * @param classInstance    Pointer to instance of class
 * @param memberFunction   Pointer to the member function
 *
 * @return  Wrapper
 */
template<typename T, typename... P>
auto wrapCallback(T *classInstance, void (T::*memberFunction)(P...)) {
   static CallbackWrapper<T, PinIndex, P...> sClass(classInstance, memberFunction);
   return sClass.callback;
}

#pragma GCC pop_options

} // End namespace USBDM

#endif /* HEADER_PCR_H */


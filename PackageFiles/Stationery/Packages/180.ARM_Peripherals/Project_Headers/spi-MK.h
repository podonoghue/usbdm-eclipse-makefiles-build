/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MK.h)
 * @brief    Serial Peripheral Interface
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#if $(/SPI/_BasicInfoGuard) // /SPI/_BasicInfoGuard

#include "pin_mapping.h"
#include "gpio.h"

#include "dma.h"

#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

$(/SPI/prototypes:// $/SPI/prototypes not found)

namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */
$(/SPI/peripheral_h_definition:// $/SPI/peripheral_h_definition not found)

#if $(/SPI/dmaSupport:false)
/**
 * Class to handle SPI DMA operations
 * It will create the required buffer to format data for the DMA transfer.
 * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
 * for each item transferred. Note that some later devices may not require this.
 * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
 * and add in the command values for each entry.
 *
 * @tparam itemCount Maximum size of buffer that can be expanded (in items)
 */
template<unsigned itemCount>
class SpiDmaHandlerBase {

protected:

   // Maximum number of items in buffer
   static constexpr unsigned MaxItemCount = itemCount;

   // Size of items (always 4 irrespective of actual data size)
   static constexpr unsigned SizeofItems = 4;

   // Expanded buffer with added command values
   union {
      uint32_t bits;
      struct {
         uint16_t data;
         uint16_t command;
      };
   } __attribute__((packed)) expandedBuffer[itemCount];

   // The final Tx value is sent individually to allow different PUSHR value
   uint32_t finalTxValue   = 0;

   // Dummy location for discarding Rx data
   uint32_t discardRxBuffer = 0;

   // Associated SPI
   Spi &spi;

   // Allocated DMA channels - released after transfer completes
   DmaChannelNum dmaTransmitChannel = DmaChannelNum_None;
   DmaChannelNum dmaReceiveChannel  = DmaChannelNum_None;

   /**
    * Constructor
    *
    * @param spi  Associated SPI
    */
   SpiDmaHandlerBase(Spi &spi) : spi(spi) {
   }

public:
   /**
    * Copy-expand data into internal DMA buffer
    * The final value is placed in finalTxValue
    *
    * @tparam T      Type for data (deduced)
    * @tparam N      Size of data array in items (deduced)
    *
    * @param dataIn  Data array to expand
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   template<typename T, unsigned N>
   void loadTxData(const T (&dataIn)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      static_assert(N<=itemCount, "dataIn is too large for buffer allocated");

      // Copy-expand data
      for (unsigned count=0; count<N; count++) {
         expandedBuffer[count].bits = dataIn[count]|spi.pushrMask;
      }
      finalTxValue = dataIn[N-1]|spi.pushrMaskFinal|SPI_PUSHR_EOQ_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer to clear transmit counter.
    *
    * The transmit counter will be cleared before transmission of the associated data.
    * This would usually be set on the first item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataToClearCounter(unsigned index=0) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_COMMAND_CTCNT_MASK;
   }

   /**
    * Mark data item in DMA transmit buffer as end-of-queue.
    *
    * Indicates the associated data value is End of Queue, the transmit and
    * receive operations will be disabled after this item completes transmission
    * This should only be set on the last item in the buffer.
    *
    * @param index   Index in transfer
    * @param data    Data to write
    *
    * @note It is necessary to set the transfer configuration in the SPI before using this
    *       routine as it will make use of information from the SPI to format data.
    */
   void markDataAsEoq(unsigned index) {

      usbdm_assert(index<MaxItemCount, "Array index error");

      expandedBuffer[index].bits |= SPI_PUSHR_EOQ_MASK;
   }

   ErrorCode allocateDmaChannels() {

      // deallocate any channels in use
      cleanUp();

      // Allocate DMA channel to use for transmission
      dmaTransmitChannel = Dma0::allocateChannel();
      if (dmaTransmitChannel == DmaChannelNum_None) {
         return setErrorCode(E_NO_RESOURCE);
      }

      // Allocate DMA channel to use for reception
      dmaReceiveChannel = Dma0::allocateChannel();
      if (dmaReceiveChannel == DmaChannelNum_None) {
         // Release successfully allocated channel as we can't use it now
         Dma0::freeChannel(dmaTransmitChannel);
         return setErrorCode(E_NO_RESOURCE);
      }
      return E_NO_ERROR;
   }

   /**
    * This TCD is chained from the main Tx TCD and
    * allows the last value transferred to have a individual PUSHR value
    */
   DmaTcd __attribute__((aligned(32)))  finalTcd = DmaTcd (
      {  /* Source */
         /* Address                  */ 0,                                           // Source address (filled in)
         /* Offset                   */ 0,                                           // Source address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit read from source address
      },
      {  /* Destination */
         /* Address                  */ 0,                                           // Destination address (filled in)
         /* Offset                   */ 0,                                           // Destination address doesn't change
         /* Size                     */ DmaSize_32bit,                               // 32-bit write to destination address
      },
      /* Minor loop byte count    */ sizeof(uint32_t),                               // Total transfer in one minor-loop
      /* Major loop count         */ 1,                                              // Transfer single item

      {  // CSR
         /* Disable Req. on complete */ DmaStopOnComplete_Enabled,                   // Clear hardware request when major loop completed
         /* IRQ on major complete    */ DmaIntMajor_Enabled,                         // Interrupt
      }
   );

   /*
    * Initialises the final Tx transfer to SPI.
    * This sets up a TCD that is chained from the main Tx TCD
    * and allows the last value transferred to have a individual PUSHR
    */
   ErrorCode initialiseFinalTransfer() {
      finalTcd.SADDR = (uint32_t)&finalTxValue;
      finalTcd.DADDR = (uint32_t)spi.spi+offsetof(SPI_Type, PUSHR);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Tx channel
    * - Configures DMA TCD for Tx
    * No transfers are actually started
    *
    * @param numElements         Number of elements to transfer
    * @param advanceReadAddress  Whether to advance DMA read pointer during transfer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseTxDma(unsigned numElements, bool advanceReadAddress) {

      int32_t   offset          = advanceReadAddress?0:SizeofItems;
      uint32_t  spiPushrAddress = spi.spi+offsetof(SPI_Type, PUSHR);
      /**
       * Structure to define the Transmit DMA transfer
       *
       * Note: This uses a 32-bit transfer even though the transmit data may only be 8 or 16-bit
       */
      DmaTcd txTcd = DmaTcd (
         {  /* Source */
            /* Address                  */ (uint32_t)(expandedBuffer),  // Source is array
            /* Offset                   */ offset,                      // Source address advances 0/1 element per request
            /* Size                     */ DmaSize_32bit,               // 32-bit read from source address
         },
         {  /* Destination */
            /* Address                  */ spiPushrAddress,             // Destination is SPI.PUSHR data register
            /* Offset                   */ 0,                           // Destination address doesn't change
            /* Size                     */ DmaSize_32bit,               // 32-bit write to destination address
            /* ScatterGather address    */ (int32_t) &finalTcd,         // Chain to finalTcd
         },
         /* Minor loop byte count       */ dmaNBytes(SizeofItems),      // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements-1),     // Transfer entire buffer

         {  // CSR
           /* Scatter/Gather enable     */ DmaScatterGather_Enabled     // Chain to finalTcd
         }
      );

      // Connect DMA channel to SPI Tx
      DmaMux0::configure(dmaTransmitChannel, Dma0Slot_SPI0_Tx, DmaMuxEnable_Continuous);

      // Configure the Tx transfer
      Dma0::configureTransfer(dmaTransmitChannel, txTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Configure DMA Mux for Rx channels
    * - Configures DMA TCD for Rx
    * No transfers are actually started
    *
    * @param rxBuffer     Buffer for received data (may be null)
    * @param rxDataSize   Size of elements in rxBuffer (either 1 or 2 bytes)
    * @param numElements  Number of elements in rxBuffer
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   ErrorCode initialiseRxDma(void *rxBuffer, unsigned rxDataSize, unsigned numElements) {

      // Size for Rx data DMA transfers
      DmaSize   rxDmaSize      = (rxDataSize==1)?DmaSize_8bit:DmaSize_16bit;
      uint32_t  spiPoprAddress = spi.spi+offsetof(SPI_Type, POPR);

      int32_t writeOffset = rxDataSize;
      if (rxBuffer==nullptr) {
         writeOffset = 0;
         rxBuffer = &discardRxBuffer;
      }

      /**
       * Structure to define the Receive DMA transfer
       *
       * Note: The transfer size used here is 8 or 16-bits only
       */
      DmaTcd rxTcd (
         {  /* Source */
            /* Address                  */ spiPoprAddress,            // Source is SPI.POPR data register
            /* Offset                   */ 0,                         // Source address doesn't change
            /* Size                     */ rxDmaSize,                 // Read from source address depends on data size
            /* Last address adjustment  */ 0,                         // Source address doesn't change
         },
         {  /* Destination */
            /* Address                  */ (uint32_t)(rxBuffer),      // Destination array
            /* Offset                   */ writeOffset,               // Destination address advances 1 element for each request
            /* Size                     */ rxDmaSize,                 // Write to destination address depends on data size
            /* Last address adjustment  */ 0,                         // Don't adjust destination address
         },
         /* Minor loop byte count       */ dmaNBytes(rxDataSize),     // Total transfer in one minor-loop
         /* Major loop count            */ dmaCiter(numElements),     // Transfer entire buffer

         {  // CSR
            /* Disable Req. on complete */ DmaStopOnComplete_Enabled, // Clear hardware request when major loop completed
            /* IRQ on major complete    */ DmaIntMajor_Enabled,       // Generate interrupt on completion of major-loop
         }
      );

      // Connect DMA channel to SPI Rx
      DmaMux0::configure(dmaReceiveChannel, Dma0Slot_SPI0_Rx, DmaMuxEnable_Continuous);

      // Configure the Rx transfer
      Dma0::configureTransfer(dmaReceiveChannel, rxTcd);

      return E_NO_ERROR;
   }

   /**
    * Set up for DMA operation
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T  Type of elements in rxBuffer (deduced)
    * @tparam N  Number of elements in rxBuffer (deduced)
    *            This becomes the number of elements to Tx and Rx
    *
    * @param rxBuffer Buffer for received data
    *
    * @note This method may be called before the SPI configuration has been set.
    *
    * @return E_NOERROR on success
    * @return E_NO_RESOURCE if failed to allocate required DMA channels
    */
   template<typename T, unsigned N>
   ErrorCode initialiseDma(const T (&rxBuffer)[N]) {

      static_assert((sizeof(T) == 1) || (sizeof(T) == 2) , "T must be of size 1 or 2 bytes");
      ErrorCode rc;
      do {
         rc = allocateDmaChannels();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseTxDma(N, false);
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseFinalTransfer();
         if (rc != E_NO_ERROR) {
            break;
         }
         rc = initialiseRxDma((void*)rxBuffer, sizeof(T), N);
         if (rc != E_NO_ERROR) {
            break;
         }
      } while(false);
      return rc;
   }

   /**
    * Set up for DMA operation
    * - Copies Tx data to internal buffer (with expansion)
    * - Allocates DMA channels
    * - Configure DMA Mux for Tx and Rx channels
    * - Configures DMA channels for Tx and Rx
    * No transfers are actually started
    *
    * @tparam T         Type for data (deduced)
    * @tparam N         Number of data items in transfer
    * @param dataIn     Data to send to SPI
    * @param rxBuffer   Buffer for received data
    *
    * @return E_NOERROR on success
    */
   template<typename T, unsigned N>
   ErrorCode initialiseTxRx(const T (&dataIn)[N], T (&rxBuffer)[N]) {

      // Set up transmit buffer
      loadTxData(dataIn);

      // Set up DMA
      return initialiseDma(rxBuffer);
   }

   /**
    * Start DMA transfers To/From SPI
    */
   void startTransfer() {

      // Clear SPI Status
      spi.getStatus();

      spi.configureInterrupts(
            SpiTxCompleteInterrupt_Enabled,
            SpiEndOfQueueInterrupt_Enabled,
            SpiTxFifoUnderflowInterrupt_Enabled,
            SpiRxFifoOverflowInterrupt_Enabled);

      spi.clearFifos(SpiClearFifo_Both);

      spi.configureFifoRequests(SpiTxFifoRequest_Dma, SpiRxFifoRequest_Dma);

      spi.enableTransfer();

      Dma0::enableMultipleErrorInterrupts((1<<dmaTransmitChannel)|(1<<dmaReceiveChannel), true);

      // Enable Rx hardware requests
      Dma0::enableRequests(dmaReceiveChannel);

      // Enable Tx hardware requests
      Dma0::enableRequests(dmaTransmitChannel);
   }

protected:
   static void cleanUp(DmaChannelNum &channel) {

      if (channel == DmaChannelNum_None) {
         return;
      }
      // Clear request and release DMA channel
      Dma0::enableRequests(channel, false);
      DmaMux0::disable(channel);
      Dma0::setCallback(channel, nullptr);
      Dma0::freeChannel(channel);
      channel = DmaChannelNum_None;
   }

public:
   void cleanUp() {
      cleanUp(dmaTransmitChannel);
      cleanUp(dmaReceiveChannel);
   }
};

#endif

#if $(/SPI/dmaSupport:false)

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info           Class describing Spi hardware
 */
template<class Info>
class SpiBase_T : public Spi, public Info {

public:

   static unsigned dmaComplete;
   static uint32_t dmaErrorCode;
   static bool     keepDmaConfiguration;

   /**
    * Class to handle SPI DMA operations
    * It will create the required buffer to format data for the DMA transfer.
    * This is necessary because of the really stupid SPI transfers that require 32-bit writes to include COMMAND+DATA
    * for each item transferred. Note that some later devices may not require this.
    * This means that to transfer a buffer of data (8/16 bit items) requires copying it to a RAM Buffer up to 4-times its size
    * and add in the command values for each entry.
    *
    * @tparam itemCount Maximum size of buffer that can be expanded (in items)
    */
   template<unsigned itemCount>
   class SpiDmaHandler_T : public SpiDmaHandlerBase<itemCount> {

   private:
      using Super = SpiDmaHandlerBase<itemCount>;

      /**
       * DMA complete callback
       *
       * Sets flag to indicate sequence complete.
       */
      static void dmaCallback(DmaChannelNum channel, uint32_t errorStatus) {

         Dma0::clearInterruptRequest(channel);
         Dma0::enableRequests(channel, false);
         if (dmaComplete>0) {
            dmaComplete--;
         }
         if (errorStatus&DMA_ES_VLD_MASK) {
            // Error callback
            dmaErrorCode = errorStatus;
            dmaComplete = 0;
         }
      }

      /**
       * SPI callback
       *
       * Used for debug timing checks.
       * LED toggles on each SPI event
       *
       * @param status Interrupt status value from SPI->SR
       */
      static void spiCallback(uint32_t status) {
         (void)status;
      }

   public:
      SpiDmaHandler_T(Spi &spi) : Super(spi) {
         spi.setCallback(spiCallback);
      }

      /**
       * Start transfer
       */
      void startTransfer() {

         dmaComplete = 2;

         // Set up DMA IRQ handlers
         Dma0::setCallback(Super::dmaTransmitChannel, dmaCallback);
         Dma0::setCallback(Super::dmaReceiveChannel,  dmaCallback);

         Dma0::enableNvicInterrupts(Super::dmaTransmitChannel, NvicPriority_Normal);
         Dma0::enableNvicInterrupts(Super::dmaReceiveChannel,  NvicPriority_Normal);
         Dma0::enableNvicErrorInterrupt(NvicPriority_MidHigh);
         Super::startTransfer();
      }

      bool isBusy() {
         if (errorCode != 0) {
            // Release resources on error
            Super::cleanUp();
         }
         if ((dmaComplete == 0) && !keepDmaConfiguration) {
            // Release DMA channels
            Super::cleanUp();
         }
         return dmaComplete != 0;
      }

      /**
       * If set:
       *    - The DMA configuration (including allocated DMA channels) set up by initialiseDma() are
       *      retained for re-use.
       *    - Resources must be manually released by calling cleanUp().
       *
       * If not set:
       *    - Allocated resources are released when the DMA transfer completes successfully
       *
       * @param keepConfiguration  true to keep configuration and resources
       */
      static void setKeepDmaConfiguration(bool keepConfiguration) {
         keepDmaConfiguration = keepConfiguration;
      }

   };

   /**
    * Creates a DMA buffer and associated code for DMA transfers to/from the SPI
    *
    * Examples use:
    * @code
    *    Spi0 spi;
    *
    *    // Configure SPI
    *
    *    constexpr unsigned NumDataItems = 10;
    *
    *    using DataSize = uint16_t; // Can be uint8_t or uint16_t
    *
    *    // Transmit data
    *    DataSize txBuffer[NumDataItems];
    *
    *    // Create DMA buffers etc.
    *    auto txBuffer = spi.createDmaHandler<NumDataItems>();
    *
    *    // Receive buffer
    *    DataSize rxBuffer[NumDataItems];
    *
    *    // Set up DMA transfer from internal buffer -> SPI -> rxBuffer
    *    txBuffer.initialiseDma(rxBuffer);
    *
    *    // Load data into SPI transmit buffer
    *    txBuffer.loadTxData(txBufferOriginal);
    *
    *    // Start transfer
    *    txBuffer.startTransfer();
    *
    *    // Wait for completion
    *    while (txBuffer.isBusy()) {
    *       __asm__("nop");
    *    }
    * @endcode
    *
    * @tparam itemCount Number of items in internal DMA buffer buffer
    *
    * @return Instance of SpiDmaHandler customised for buffer size
    */
   template<unsigned itemCount>
   SpiDmaHandler_T<itemCount> createDmaHandler() {
      return SpiDmaHandler_T<itemCount>(*this);
   }

};
template<class Info>
unsigned SpiBase_T<Info>::dmaComplete = false;

template<class Info>
bool SpiBase_T<Info>::keepDmaConfiguration = false;

template<class Info>
uint32_t SpiBase_T<Info>::dmaErrorCode = 0;
#endif

$(/SPI/declarations: // No declarations found)
/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM
#endif // $(/SPI/_BasicInfoGuard) // /FTM/_BasicInfoGuard

#endif /* INCLUDE_USBDM_SPI_H_ */

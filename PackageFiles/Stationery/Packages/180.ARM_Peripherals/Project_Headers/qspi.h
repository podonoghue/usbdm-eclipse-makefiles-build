/**alse,
 * @file     qspi.h (180.ARM_Peripherals/Project_Headers/qspi.h)
 * @brief    Quad Serial Peripheral Interface
 */

#ifndef HEADER_QSPI_H
#define HEADER_QSPI_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"
#include "cstdlib"
#include "memory"
#include "formatted_io.h"
#include "delay.h"

$(/QSPI/prototypes:// $/QSPI/prototypes not found)

namespace USBDM {

/**
 * @addtogroup QSPI_Group QSPI, Quad Serial Peripheral Interface
 * @brief Abstraction for Quad Serial Peripheral Interface
 * @{
 */
$(/QSPI/peripheral_h_definition:// $/QSPI/peripheral_h_definition not found)
#if $(/QSPI/_BasicInfoGuard:false) // /QSPI/_BasicInfoGuard

/**
 * Crossbar Switch Master Assignments - with System MPU
 * Not sure if this is the 'master' ID used by QSPI
 */
enum QspiMasterId {
   QspiMasterId_CoreCode = QSPI_BUFCR_MSTRID(0),  /**< ARM core code bus   */
   QspiMasterId_CoreBus  = QSPI_BUFCR_MSTRID(1),  /**< ARM core system bus */
   QspiMasterId_Dma      = QSPI_BUFCR_MSTRID(2),  /**< DMA                 */
   QspiMasterId_UsbFs    = QSPI_BUFCR_MSTRID(3),  /**< USB FS/LS OTG       */
   QspiMasterId_Sdhc     = QSPI_BUFCR_MSTRID(4),  /**< SDHC                */
   QspiMasterId_UsbHs    = QSPI_BUFCR_MSTRID(5),  /**< USB HS/FS/LS OTG    */
   QspiMasterId_None     = QSPI_BUFCR_MSTRID(14),
};

/**
 * Additional buffer options
 */
enum QspiBufferOption {
   QspiBufferOption_None         = 0,                      /**< None */
   QspiBufferOption_HighPriority = QSPI_BUF0CR_HP_EN(1),   /**< HighPriority - Buffer 0 only */
   QspiBufferOption_AllMaster    = QSPI_BUF3CR_ALLMST(1),  /**< AllMaster - Buffer 3 only */
};

/**
 * Enable/Disable control for QSPI
 * Note that this is separate from the clock enable etc.
 */
enum QspiModule {
   QspiModule_Enable  = QSPI_MCR_MDIS(0), /**< QSPI Module Enable */
   QspiModule_Disable = QSPI_MCR_MDIS(1), /**< QSPI Module Disable */
};

/**
 * QSPI serial clock configuration.  QSPI_MCR[SCLKCFG]
 */
enum QspiClockDivide {
   QspiClockDivide_By1  = QSPI_MCR_SCLKCFG(0),
   QspiClockDivide_By2  = QSPI_MCR_SCLKCFG(1),
   QspiClockDivide_By3  = QSPI_MCR_SCLKCFG(2),
   QspiClockDivide_By4  = QSPI_MCR_SCLKCFG(3),
   QspiClockDivide_By5  = QSPI_MCR_SCLKCFG(4),
   QspiClockDivide_By6  = QSPI_MCR_SCLKCFG(5),
   QspiClockDivide_By7  = QSPI_MCR_SCLKCFG(6),
   QspiClockDivide_By8  = QSPI_MCR_SCLKCFG(7),
   QspiClockDivide_By9  = QSPI_MCR_SCLKCFG(8),
   QspiClockDivide_By10 = QSPI_MCR_SCLKCFG(9),
   QspiClockDivide_By11 = QSPI_MCR_SCLKCFG(10),
   QspiClockDivide_By12 = QSPI_MCR_SCLKCFG(11),
   QspiClockDivide_By13 = QSPI_MCR_SCLKCFG(12),
   QspiClockDivide_By14 = QSPI_MCR_SCLKCFG(13),
   QspiClockDivide_By15 = QSPI_MCR_SCLKCFG(14),
   QspiClockDivide_By16 = QSPI_MCR_SCLKCFG(15),
};

#ifdef QSPI_MCR_ISD2FA
/**
 * Idle Signal Drive IOFA[2] Flash A.
 *
 * This bit determines the logic level the IOFA[2] output of the QuadSPI module is driven to in the inactive state.
 */
enum QspiIdleSignalDrive2A {
   QspiIdleSignalDrive2A_L = QSPI_MCR_ISD2FA(0), /**< IOFA[2] is driven to logic L */
   QspiIdleSignalDrive2A_H = QSPI_MCR_ISD2FA(1), /**< IOFA[2] is driven to logic H */
};

/**
 * Idle Signal Drive IOFA[3] Flash A.
 *
 * This bit determines the logic level the IOFA[3] output of the QuadSPI module is driven to in the inactive state.
 */
enum QspiIdleSignalDrive3A {
   QspiIdleSignalDrive3A_L = QSPI_MCR_ISD3FA(0), /**< IOFA[3] is driven to logic L */
   QspiIdleSignalDrive3A_H = QSPI_MCR_ISD3FA(1), /**< IOFA[3] is driven to logic H */
};

/**
 * Idle Signal Drive IOFB[2] Flash B.
 * This bit determines the logic level the IOFB[2] output of the QuadSPI module is driven to in the inactive state.
 */
enum QspiIdleSignalDrive2B {
   QspiIdleSignalDrive2B_L = QSPI_MCR_ISD2FB(0), /**< IOFB[2] is driven to logic L */
   QspiIdleSignalDrive2B_H = QSPI_MCR_ISD2FB(1), /**< IOFB[2] is driven to logic H */
};

/**
 * Idle Signal Drive IOFB[3] Flash B.
 *
 * This bit determines the logic level the IOFB[3] output of the QuadSPI module is driven to in the inactive state.
 */
enum QspiIdleSignalDrive3B {
   QspiIdleSignalDrive3B_L = QSPI_MCR_ISD3FB(0), /**< IOFB[3] is driven to logic L */
   QspiIdleSignalDrive3B_H = QSPI_MCR_ISD3FB(1), /**< IOFB[3] is driven to logic H */
};
#endif

/**
 * DDR mode enable
 */
enum QspiDdr {
   QspiDDR_Disable = QSPI_MCR_DDR_EN(0), /**< 2x and 4x clocks are disabled for SDR instructions only */
   QspiDDR_Enable  = QSPI_MCR_DDR_EN(1), /**< 2x and 4x clocks are enabled supports both SDR and DDR instruction. */
};

/**
 * DQS enable. This field is valid for both SDR and DDR mode.
 *
 * When enabled, the incoming data is sampled on both the edges of DQS input when
 * QSPI_MCR[DDR_EN] is set, else, on only one edge when QSPI_MCR[DDR_EN] is 0.
 * The QSPI_SMPR[DDR_SMP] values are ignored.
 */
enum QspiDqs {
   QspiDqs_Disable  = QSPI_MCR_DQS_EN(0), /**< DQS disabled */
   QspiDqs_Enable   = QSPI_MCR_DQS_EN(1), /**< DQS enabled  */
};

/**
 * DQS Latency Enable.
 *
 * This field is valid when latency is included in between read access from
 * flash memory in cases when QSPI_MCR[DQS_EN] is 1.
 */
enum QspiDqsLatency {
   QspiDqsLatency_Disable = QSPI_MCR_DQS_LAT_EN(0),/**< QspiDqsLatency_Disable */
   QspiDqsLatency_Enable  = QSPI_MCR_DQS_LAT_EN(0),/**< QspiDqsLatency_Enable */
};

/**
 * Defines the endianness of the QuadSPI module.
 */
enum QspiEndian {
   QspiEndian_64bit_BE = QSPI_MCR_END_CFG(0b00), /**< 64 bit Big-endian */
   QspiEndian_32bit_LE = QSPI_MCR_END_CFG(0b01), /**< 32 bit Little-endian */
   QspiEndian_32bit_BE = QSPI_MCR_END_CFG(0b10), /**< 32 bit Big-endian */
   QspiEndian_64bit_LE = QSPI_MCR_END_CFG(0b11), /**< 64 bit Little-endian */
};

/**
 * Points to a sequence in the Look-up table.
 *
 * This field defines bits [6:2] of the LUT index.
 * The bits [1:0] are always assumed to be 0.
 * A write to this field triggers a transaction on the serial flash interface.
 */
enum QspiSequenceIdentity {
   QspiSequenceIdentity_0  = QSPI_IPCR_SEQID(0),  /**< Sequence 0  */
   QspiSequenceIdentity_1  = QSPI_IPCR_SEQID(1),  /**< Sequence 1  */
   QspiSequenceIdentity_2  = QSPI_IPCR_SEQID(2),  /**< Sequence 2  */
   QspiSequenceIdentity_3  = QSPI_IPCR_SEQID(3),  /**< Sequence 3  */
   QspiSequenceIdentity_4  = QSPI_IPCR_SEQID(4),  /**< Sequence 4  */
   QspiSequenceIdentity_5  = QSPI_IPCR_SEQID(5),  /**< Sequence 5  */
   QspiSequenceIdentity_6  = QSPI_IPCR_SEQID(6),  /**< Sequence 6  */
   QspiSequenceIdentity_7  = QSPI_IPCR_SEQID(7),  /**< Sequence 7  */
   QspiSequenceIdentity_8  = QSPI_IPCR_SEQID(8),  /**< Sequence 8  */
   QspiSequenceIdentity_9  = QSPI_IPCR_SEQID(9),  /**< Sequence 9  */
   QspiSequenceIdentity_10 = QSPI_IPCR_SEQID(10), /**< Sequence 10 */
   QspiSequenceIdentity_11 = QSPI_IPCR_SEQID(11), /**< Sequence 11 */
   QspiSequenceIdentity_12 = QSPI_IPCR_SEQID(12), /**< Sequence 12 */
   QspiSequenceIdentity_13 = QSPI_IPCR_SEQID(13), /**< Sequence 13 */
   QspiSequenceIdentity_14 = QSPI_IPCR_SEQID(14), /**< Sequence 14 */
   QspiSequenceIdentity_15 = QSPI_IPCR_SEQID(15), /**< Sequence 15 */
};

/**
 * If enabled a transaction to two serial flash devices is triggered in parallel mode.
 */
#if QSPI_IPCR_PAR_EN_MASK != QSPI_BFGENCR_PAR_EN_MASK
#error "Combined masks don't align"
#endif
enum QspiParallelTransaction {
   QspiParallelTransaction_Disable = QSPI_IPCR_PAR_EN(0),/**< Parallel transfer disabled */
   QspiParallelTransaction_Enable  = QSPI_IPCR_PAR_EN(1),/**< Parallel transfer enabled */
};

/**
 * Serial flash data in hold time.
 *
 * This helps in meeting the Data In Hold time requirement of a flash.
 * This is valid only in DDR mode.
 *
 * @note This field should be set to 0x00 in SDR mode (QuadSPI_MCR[DDR_EN]=0).
 *       Refer to Data input hold requirement of Flash for details.
 */
enum QspiDataInHoldTime {
   QspiDataInHoldTime_InternalPosEdge  = QSPI_FLSHCR_TDH(0b00),  /**< Data aligned with the posedge of Internal reference clock of QuadSPI_ */
   QspiDataInHoldTime_2XClock          = QSPI_FLSHCR_TDH(0b01),  /**< Data aligned with 2x serial flash half clock_ */
   QspiDataInHoldTime_4XClock          = QSPI_FLSHCR_TDH(0b10),  /**< Data aligned with 4x serial flash half clock_ */
//      QspiDataInHoldTime_ = QSPI_FLSHCR_TDH(0b11),/**< _ */
};

/**
 * Serial flash CS hold time in terms of serial flash clock cycles.
 *
 * The actual delay between chip select and clock is defined as:
 * TCSH = 1 SCK clk if N= 0/1 else, N SCK clk if N>1, where N is the setting of TCSH
 */
enum QspiChipSelectHoldTime {
   QspiChipSelectHoldTime_1_sck  = QSPI_FLSHCR_TCSH( 0),  /**< 1  SCK clock cycles */
//   QspiChipSelectHoldTime_1_sck  = QSPI_FLSHCR_TCSH(1),  /**<  1 SCK clock cycles */
   QspiChipSelectHoldTime_2_sck  = QSPI_FLSHCR_TCSH(2),  /**<  2 SCK clock cycles */
   QspiChipSelectHoldTime_3_sck  = QSPI_FLSHCR_TCSH(3),  /**<  3 SCK clock cycles */
   QspiChipSelectHoldTime_4_sck  = QSPI_FLSHCR_TCSH(4),  /**<  4 SCK clock cycles */
   QspiChipSelectHoldTime_5_sck  = QSPI_FLSHCR_TCSH(5),  /**<  5 SCK clock cycles */
   QspiChipSelectHoldTime_6_sck  = QSPI_FLSHCR_TCSH(6),  /**<  6 SCK clock cycles */
   QspiChipSelectHoldTime_7_sck  = QSPI_FLSHCR_TCSH(7),  /**<  7 SCK clock cycles */
   QspiChipSelectHoldTime_8_sck  = QSPI_FLSHCR_TCSH(8),  /**<  8 SCK clock cycles */
   QspiChipSelectHoldTime_9_sck  = QSPI_FLSHCR_TCSH(9),  /**<  9 SCK clock cycles */
   QspiChipSelectHoldTime_10_sck = QSPI_FLSHCR_TCSH(10), /**< 10 SCK clock cycles */
   QspiChipSelectHoldTime_11_sck = QSPI_FLSHCR_TCSH(11), /**< 11 SCK clock cycles */
   QspiChipSelectHoldTime_12_sck = QSPI_FLSHCR_TCSH(12), /**< 12 SCK clock cycles */
   QspiChipSelectHoldTime_13_sck = QSPI_FLSHCR_TCSH(13), /**< 13 SCK clock cycles */
   QspiChipSelectHoldTime_14_sck = QSPI_FLSHCR_TCSH(14), /**< 14 SCK clock cycles */
   QspiChipSelectHoldTime_15_sck = QSPI_FLSHCR_TCSH(15), /**< 15 SCK clock cycles */
};

/**
 * Serial flash CS setup time in terms of serial flash clock cycles.
 *
 * - Any update to the TCSS register bits is visible on the flash interface only
 *   from the second transaction following the update.
 *
 * - The actual delay between chip select and clock is defined as:
 *   TCSS = 0.5 SCK clk if N= 0/1 else, N+0.5 SCK clk if N>1, where N is the setting of TCSS.
 */
enum QspiChipSelectSetupTime {
   QspiChipSelectSetupTime_0_5sck  = QSPI_FLSHCR_TCSS(0),  /**<  0.5 SCK clock cycles */
//   QspiChipSelectSetupTime_0_5sck  = QSPI_FLSHCR_TCSS(1),  /**<  0.5 SCK clock cycles */
   QspiChipSelectSetupTime_2_5sck  = QSPI_FLSHCR_TCSS(2),  /**<  2.5 SCK clock cycles */
   QspiChipSelectSetupTime_3_5sck  = QSPI_FLSHCR_TCSS(3),  /**<  3.5 SCK clock cycles */
   QspiChipSelectSetupTime_4_5sck  = QSPI_FLSHCR_TCSS(4),  /**<  4.5 SCK clock cycles */
   QspiChipSelectSetupTime_5_5sck  = QSPI_FLSHCR_TCSS(5),  /**<  5.5 SCK clock cycles */
   QspiChipSelectSetupTime_6_5sck  = QSPI_FLSHCR_TCSS(6),  /**<  6.5 SCK clock cycles */
   QspiChipSelectSetupTime_7_5sck  = QSPI_FLSHCR_TCSS(7),  /**<  7.5 SCK clock cycles */
   QspiChipSelectSetupTime_8_5sck  = QSPI_FLSHCR_TCSS(8),  /**<  8.5 SCK clock cycles */
   QspiChipSelectSetupTime_9_5sck  = QSPI_FLSHCR_TCSS(9),  /**<  9.5 SCK clock cycles */
   QspiChipSelectSetupTime_10_5sck = QSPI_FLSHCR_TCSS(10), /**< 10.5 SCK clock cycles */
   QspiChipSelectSetupTime_11_5sck = QSPI_FLSHCR_TCSS(11), /**< 11.5 SCK clock cycles */
   QspiChipSelectSetupTime_12_5sck = QSPI_FLSHCR_TCSS(12), /**< 12.5 SCK clock cycles */
   QspiChipSelectSetupTime_13_5sck = QSPI_FLSHCR_TCSS(13), /**< 13.5 SCK clock cycles */
   QspiChipSelectSetupTime_14_5sck = QSPI_FLSHCR_TCSS(14), /**< 14.5 SCK clock cycles */
   QspiChipSelectSetupTime_15_5sck = QSPI_FLSHCR_TCSS(15), /**< 15.5 SCK clock cycles */
};

/**
 * Clock source selection for the clock divider
 */
enum QspiClockSource {
   QspiClockSource_System     = QSPI_SOCCR_QSPISRC(0b000),  /**< Core/system clock */
   QspiClockSource_MCGFLL     = QSPI_SOCCR_QSPISRC(0b001),  /**< MCGFLL clock      */
   QspiClockSource_MCGPLL     = QSPI_SOCCR_QSPISRC(0b010),  /**< MCGPLL clock      */
   QspiClockSource_MCGPLLx2   = QSPI_SOCCR_QSPISRC(0b011),  /**< MCGPLL 2x clock   */
   QspiClockSource_IRC48M     = QSPI_SOCCR_QSPISRC(0b100),  /**< IRC48M clock      */
   QspiClockSource_OSCERCLK   = QSPI_SOCCR_QSPISRC(0b101),  /**< OSCERCLK clock    */
   QspiClockSource_MCGIRCLK   = QSPI_SOCCR_QSPISRC(0b110),  /**< MCGIRCLK clock    */
   QspiClockSource_USB1PFDCLK = QSPI_SOCCR_QSPISRC(0b111),  /**< USB1PFDCLK clock  */
};

/**
 * Octal data pins enable
 *
 * Allows the QSPI0B_DATAx pins to be used as an additional 4 QSPI0B data pins for a composite eight bit data bus
 */
enum QspiOctalDataPins {
   QspiOctalDataPins_Disabled = QSPI_SOCCR_OCTEN(0),  /**< QSPI0B_DATAx pins have normal use */
   QspiOctalDataPins_Enabled  = QSPI_SOCCR_OCTEN(1),  /**< QSPI0B_DATAx pins are assigned to QSPI Port A */
};

/**
 * Differential flash clock pins enable
 *
 * When enabled QSPI0B_SCLK pin serves as an inverse QSPI0A_SCLK, QSPI0B_SS1_B pin serves as an
 * inverse CK2 clock if CK2EN bit is set as well.
 */
enum QspiDiffClockEnable {
   QspiDiffClockEnable_Disabled = QSPI_SOCCR_DIFFCKEN(0),/**< Differential flash clock is disabled. */
   QspiDiffClockEnable_Enabled  = QSPI_SOCCR_DIFFCKEN(1),/**< Differential flash clock is enabled. */
};

/**
 * Flash CK2 clock pin enable
 *
 * When this bit is set QSPI0B_DQS pin serves as flash CK2 clock, QSPI0B_SS1_B pin serves as an
 * inverse CK2 clock if DIFFCKEN bit is set as well.
 * CK2 and inverse CK2 are only available in 144 pin packages
 */
enum QspiFlashClock2Pin {
   QspiFlashClock2Pin_Disabled = QSPI_SOCCR_CK2EN(0),/**< CK2 flash clock is disabled */
   QspiFlashClock2Pin_Enabled  = QSPI_SOCCR_CK2EN(1),/**< CK2 flash clock is enabled */
};


/**
 * Select inverted clock source for internal DQS generation
 */
enum QspiDqsClockPolarity {
   QspiDqsClockPolarity_NonInverted = QSPI_SOCCR_DQSINVSEL(0),/**< 1x internal reference clock */
   QspiDqsClockPolarity_Inverted    = QSPI_SOCCR_DQSINVSEL(1),/**< Inverted 1x internal reference clock */
};

/**
 * Select phase shift for internal DQS generation.
 *
 * These bits are always zero in SDR mode.
 */
enum QspiPhaseSelectDqs {
   QspiPhaseSelectDqs_None       = QSPI_SOCCR_DQSPHASEL(0b00),/**< No phase shift */
   QspiPhaseSelectDqs_45_Degree  = QSPI_SOCCR_DQSPHASEL(0b00),/**< 45 degree phase shift */
   QspiPhaseSelectDqs_90_Degree  = QSPI_SOCCR_DQSPHASEL(0b00),/**< 90 degree phase shift */
   QspiPhaseSelectDqs_135_Degree = QSPI_SOCCR_DQSPHASEL(0b00),/**< 135 degree phase shift */
};

/**
 * Selects how the internally generated DQS is routed:
 * - DQS will be sent to the DQS pad first and then looped back to QuadSPI.
 * - DQS is selected and looped back to QuadSPI, without going to DQS pad
 */
enum QspiLoopDqs {
   QspiLoopDqs_External    = QSPI_SOCCR_DQSPADLPEN(0)|QSPI_SOCCR_DQSLPEN(0), /**< Externally provided DQS ? */
   QspiLoopDqs_ViaPad      = QSPI_SOCCR_DQSPADLPEN(1)|QSPI_SOCCR_DQSLPEN(0), /**< Internally generated DQS looped via pad to QSPISpi */
   QspiLoopDqs_Internally  = QSPI_SOCCR_DQSPADLPEN(0)|QSPI_SOCCR_DQSLPEN(1), /**< Internally generated DQS looped directly to QSPISpi */
};

/**
 * DDR Sampling point
 *
 * Select the sampling point for incoming data when serial flash is executing a DDR instruction.
 */
enum QspiDdrSamplePoint {
   QspiDdrSamplePoint_0 = QSPI_SMPR_DDRSMP(0b000), /**< Sample point 0 */
   QspiDdrSamplePoint_1 = QSPI_SMPR_DDRSMP(0b001), /**< Sample point 1 */
   QspiDdrSamplePoint_2 = QSPI_SMPR_DDRSMP(0b010), /**< Sample point 2 */
   QspiDdrSamplePoint_3 = QSPI_SMPR_DDRSMP(0b011), /**< Sample point 3 */
   QspiDdrSamplePoint_4 = QSPI_SMPR_DDRSMP(0b100), /**< Sample point 4 */
   QspiDdrSamplePoint_5 = QSPI_SMPR_DDRSMP(0b101), /**< Sample point 5 */
   QspiDdrSamplePoint_6 = QSPI_SMPR_DDRSMP(0b110), /**< Sample point 6 */
   QspiDdrSamplePoint_7 = QSPI_SMPR_DDRSMP(0b111), /**< Sample point 7 */
};

/**
 * Full Speed Delay selection for SDR instructions.
 *
 * Select the delay with respect to the reference edge for the sample point valid for full speed commands.
 */
enum QspiSdrFullSpeedDelay {
   QspiSdrFullSpeedDelay_1_ClockCycle  = QSPI_SMPR_FSDLY(0), /**< One clock cycle delay */
   QspiSdrFullSpeedDelay_2_ClockCycles = QSPI_SMPR_FSDLY(1), /**< Two clock cycle delay */
};

/**
 *  Full Speed Phase selection for SDR instructions.
 *
 *  Select the edge of the sampling clock valid for full speed commands.
 */
enum QspiSdrFullSpeedPhase {
   QspiSdrFullSpeedPhase_NonInvertedCLock = QSPI_SMPR_FSPHS(0), /**< Select sampling at non-inverted clock */
   QspiSdrFullSpeedPhase_InvertedCLock    = QSPI_SMPR_FSPHS(1), /**< Select sampling at inverted clock.    */
};

/**
 * Half Speed Delay selection for SDR instructions.
 *
 * Only relevant when HSENA bit is set.
 * Select the delay with respect to the reference edge for the sample point valid for half speed commands.
 */
enum QspiHalfSpeedDelay {
   QspiHalfSpeedDelay_1_ClockCycle  = QSPI_SMPR_HSDLY(0), /**< One clock cycle delay */
   QspiHalfSpeedDelay_2_ClockCycles = QSPI_SMPR_HSDLY(1), /**< Two clock cycle delay */
};

/**
 * Half Speed Phase selection for SDR instructions.
 *
 * Only relevant when HSENA bit is set.
 * Select the delay with respect to the reference edge for the sample point valid for half speed commands.
 */
enum QspiHalfSpeedPhase {
   QspiHalfSpeedPhase_NonInvertedClock = QSPI_SMPR_HSPHS(0), /**< QspiHalfSpeedPhase_NonInvertedClock */
   QspiHalfSpeedPhase_InvertedClock    = QSPI_SMPR_HSPHS(1), /**< QspiHalfSpeedPhase_InvertedClock */
};

/**
 * Half Speed serial flash clock Enable
 *
 * This enables the divide by 2 of the clock to the external serial flash device
 * for all commands in SDR.
 *
 */
enum QspiHalfSpeedSerialClock {
   QspiHalfSpeedSerialClock_Enable  = QSPI_SMPR_HSENA(0), /**< QspiHalfSpeedSerialClock_Enable */
   QspiHalfSpeedSerialClock_Disable = QSPI_SMPR_HSENA(0), /**< QspiHalfSpeedSerialClock_Disable */
};

#if QSPI_RBCT_WMRK_MASK != QSPI_TBCT_WMRK_MASK
#error "Expected QSPI_RBCT_WMRK field == QSPI_TBCT_WMRK field"
#endif
/**
 * Buffer Watermark.
 *
 * For read buffer\n
 * This determines when the readout action of the RX Buffer is triggered.
 * When the number of valid entries in the RX Buffer is equal to or greater than this
 * value the QSPI_SR[RXWE] flag is asserted.
 *
 * For write buffer\n
 * This determines the watermark for the TX Buffer.
 * When the number of available space in TX Buffer is greater than this value, QSPI_SR[TXWA] is asserted.
 */
enum QspiBufferWaterMark {
   QspiBufferWaterMark_4_Bytes  = QSPI_RBCT_WMRK( 0),/**< 4  Bytes */
   QspiBufferWaterMark_8_Bytes  = QSPI_RBCT_WMRK( 1),/**< 8  Bytes */
   QspiBufferWaterMark_12_Bytes = QSPI_RBCT_WMRK( 2),/**< 12 Bytes */
   QspiBufferWaterMark_16_Bytes = QSPI_RBCT_WMRK( 3),/**< 16 Bytes */
   QspiBufferWaterMark_20_Bytes = QSPI_RBCT_WMRK( 4),/**< 20 Bytes */
   QspiBufferWaterMark_24_Bytes = QSPI_RBCT_WMRK( 5),/**< 24 Bytes */
   QspiBufferWaterMark_28_Bytes = QSPI_RBCT_WMRK( 6),/**< 28 Bytes */
   QspiBufferWaterMark_32_Bytes = QSPI_RBCT_WMRK( 7),/**< 32 Bytes */
   QspiBufferWaterMark_36_Bytes = QSPI_RBCT_WMRK( 8),/**< 36 Bytes */
   QspiBufferWaterMark_40_Bytes = QSPI_RBCT_WMRK( 9),/**< 40 Bytes */
   QspiBufferWaterMark_44_Bytes = QSPI_RBCT_WMRK(10),/**< 44 Bytes */
   QspiBufferWaterMark_48_Bytes = QSPI_RBCT_WMRK(11),/**< 48 Bytes */
   QspiBufferWaterMark_52_Bytes = QSPI_RBCT_WMRK(12),/**< 52 Bytes */
   QspiBufferWaterMark_56_Bytes = QSPI_RBCT_WMRK(13),/**< 56 Bytes */
   QspiBufferWaterMark_60_Bytes = QSPI_RBCT_WMRK(14),/**< 60 Bytes */
   QspiBufferWaterMark_64_Bytes = QSPI_RBCT_WMRK(15),/**< 64 Bytes */
};

/**
 * RX Buffer Readout.
 *
 * This field specifies the access scheme for the RX Buffer readout.
 *  - RX Buffer content is read using the AHB Bus registers QSPI_ARDB[0..15], or
 *  - RX Buffer content is read using the IP Bus registers QSPI_RBDR[0..15].
 */
enum QspiBufferReadoutVia {
   QspiBufferReadoutVia_AHB = QSPI_RBCT_RXBRD(0),/**< Read via QSPI_ARDB[0..15] */
   QspiBufferReadoutVia_IP  = QSPI_RBCT_RXBRD(1),/**< Read via QSPI_RBDR[0..15]  */
};


/**
 * Status masks for use with @ref QspiBase_T<Qspi0Info>::readStatusRegister()
 */
enum QspiStatusMask {

   /**
    * Data learning pattern sampling point.
    *
    * The sampling point found by the controller with the data learning pattern.
    * This is used for DDR only.
    * If the learning fails, this field will return garbage and DLPFF bit will be set.
    * In case of Data learning with DQS this field will return the reset value as sampling point match is not
    * found in case of DQS. */
   QspiStatusMask_DataLearningSample           = QSPI_SR_DLPSMP_MASK,

   /**
    * TX Buffer Full.
    * Asserted when no more data can be stored.
    */
   QspiStatusMask_TxBuffer_Full                = QSPI_SR_TXFULL_MASK,

   /** Asserted when TXFIFO fill via DMA is active i.e. DMA is requested or running */
   QspiStatusMask_TxDmaBusy                    = QSPI_SR_TXDMA_MASK,

   /**
    * TX Buffer watermark Available
    *
    * Asserted when the number of available spaces in TX buffer
    * is greater than or equal to the value give by transmit watermark
    */
   QspiStatusMask_TxAboveWatermark             = QSPI_SR_TXWA_MASK,

   /**
    * Tx Buffer Enough Data Available
    *
    * Asserted when TX Buffer contains enough data for any pop operation to take place.
    * There must be at least 128 bit data available in TX FIFO for any pop operation;
    * otherwise, QSPI_FR[TBUF] will be set.
    */
   QspiStatusMask_EnoughDataAvailable          = QSPI_SR_TXEDA_MASK,

   /**
    * RX Buffer DMA.
    *
    * Asserted when RX Buffer read out via DMA is active i.e DMA is requested or running.
    */
   QspiStatusMask_RxDmaBusy                    = QSPI_SR_RXDMA_MASK,

   /**
    * RX Buffer Full.
    *
    * Asserted when the RX Buffer is full, i.e. that QSPI_RBSR[RDBFL] field is equal to 32.
    */
   QspiStatusMask_RxBufferFull                 = QSPI_SR_RXFULL_MASK,

   /**
    * RX Buffer Watermark Exceeded.
    *
    * Asserted when the number of valid entries in the RX Buffer exceeds the
    * number given in the Receive watermark
    */
   QspiStatusMask_RxAboveWatermark             = QSPI_SR_RXWE_MASK,

   /**
    * AHB 3 Buffer Full.
    *
    * Asserted when AHB 3 buffer is full.
    */
   QspiStatusMask_AHB3_BufferFull              = QSPI_SR_AHB3FUL_MASK,

   /**
    * AHB 2 Buffer Full.
    *
    * Asserted when AHB 2 buffer is full.
    */
   QspiStatusMask_AHB2_BufferFull              = QSPI_SR_AHB2FUL_MASK,

   /**
    * AHB 1 Buffer Full.
    *
    * Asserted when AHB 1 buffer is full.
    */
   QspiStatusMask_AHB1_BufferFull              = QSPI_SR_AHB1FUL_MASK,

   /**
    * AHB 0 Buffer Full.
    *
    * Asserted when AHB 0 buffer is full.
    */
   QspiStatusMask_AHB0_BufferFull              = QSPI_SR_AHB0FUL_MASK,

   /**
    * AHB 3 Buffer Not Empty.
    *
    * Asserted when AHB 3 buffer contains data.
    */
   QspiStatusMask_AHB3_BufferNotEmpty          = QSPI_SR_AHB3NE_MASK,

   /**
    * AHB 2 Buffer Not Empty.
    *
    * Asserted when AHB 2 buffer contains data.
    */
   QspiStatusMask_AHB2_BufferNotEmpty          = QSPI_SR_AHB2NE_MASK,

   /**
    * AHB 1 Buffer Not Empty.
    *
    * Asserted when AHB 1 buffer contains data.
    */
   QspiStatusMask_AHB1_BufferNotEmpty          = QSPI_SR_AHB1NE_MASK,

   /**
    * AHB 0 Buffer Not Empty.
    *
    * Asserted when AHB 0 buffer contains data.
    */
   QspiStatusMask_AHB0_BufferNotEmpty          = QSPI_SR_AHB0NE_MASK,

   /**
    * AHB Access Transaction pending.
    *
    * Asserted when there is a pending request on the AHB interface.
    */
   QspiStatusMask_AHB_AccessTransactionPending = QSPI_SR_AHBTRN_MASK,

   /**
    * AHB Command priority Granted.
    *
    * Asserted when another module has been granted priority of AHB Commands against IP Commands.
    */
   QspiStatusMask_AHB_CommandPriorityGranted   = QSPI_SR_AHBGNT_MASK,

   /**
    * AHB Access.
    * Asserted when the transaction currently executed was initiated by AHB bus.
    */
   QspiStatusMask_AHB_Access                   = QSPI_SR_AHB_ACC_MASK,

   /**
    * IP Access.
    * Asserted when transaction currently executed was initiated by IP bus.
    */
   QspiStatusMask_IP_Access                    = QSPI_SR_IP_ACC_MASK,

   /**
    * Module Busy.
    * Asserted when module is currently busy handling a transaction to an external flash device.
    */
   QspiStatusMask_ModuleBusy                   = QSPI_SR_BUSY_MASK,
};

/**
 * Status flag masks for use with @ref QspiBase_T<Qspi0Info>::readFlags() and @ref QspiBase_T<Qspi0Info>::clearFlags()
 */
enum QspiFlag {
   /**
    * Data Learning Pattern Failure Flag.
    *
    * Set when DATA_LEARN instruction was encountered in a sequence but no sampling point was found
    * for the data learning pattern in case only 8 bit data learning is requested for non DQS mode.
    * The controller automatically starts sampling using the value in QSPI_SMPR[DDRSMP].
    * If more than 8 bits data learning are requested with QSPI_MCR[DQS_EN] set to 0, and the
    * sampling point found after first 8 bit match doesn't remain the same for the whole instruction
    * duration, this flag is set.
    * In case of Data learn with DQS this flag is set whenever the incoming data from flash on
    * DQS edges doesn't match the pattern in QSPI_DLPR.
    */
   QspiFlag_DataLearningPatternFailure = QSPI_FR_DLPFF_MASK,/**< QspiFlag_DataLearningPatternFailure */

   /**
    * TX Buffer Fill Flag.
    *
    * Before writing to the TX buffer, this bit should be cleared.
    * Then this bit has to be read back.
    * If the bit is set, the TX Buffer can take more data.
    * If the bit remains cleared, the TX buffer is full.
    */
   QspiFlag_TxBufferFillFlag_TxBufferFill = QSPI_FR_TBFF_MASK,           /**< QspiFlag_TxBufferFillFlag */

   /**
    * TX Buffer Underrun Flag.
    *
    * Set when the module tried to pull data although TX Buffer was empty or the buffer
    * contains less than 128 bits of data. The application must ensure that the buffer never goes empty
    * during a transaction except for the last data fetch.
    * The IP Command leading to the TX Buffer underrun is continued (data sent to the serial
    * flash device is all F in case of valid TX underrun. The application must clear the TX
    * Buffer in response to this event by writing a 1 to the QSPI_MCR[CLR_TXF] bit.
    */
   QspiFlag_TxBufferUnderrun = QSPI_FR_TBUF_MASK,                           /**< QspiFlag_ */

   /**
    * Illegal Instruction Error Flag
    *
    * Set when an illegal instruction is encountered by the controller in any of the sequences.
    */
   QspiFlag_IllegalInstructionError = QSPI_FR_ILLINE_MASK,                         /**< QspiFlag_ */

   /**
    * RX Buffer Overflow Flag.
    *
    * Set when not all the data read from the serial flash device could be pushed into the RX Buffer.
    * The IP Command leading to this condition is continued until the number of bytes according to the
    * QSPI_IPCR[IDATSZ] field has been read from the serial flash device.
    * The content of the RX Buffer is not changed.
    */
   QspiFlag_RxBufferOverflow = QSPI_FR_RBOF_MASK,                           /**< QspiFlag_ */

   /**
    * RX Buffer Drain Flag.
    *
    * Will be set if the QuadSPI_SR[RXWE] status bit is asserted.
    * Writing 1 into this bit triggers one of the following actions:
    * - If the RX Buffer has up to QuadSPI_RBCT[WMRK] valid entries then the flag is cleared.
    * - If the RX Buffer has more than QuadSPI_RBCT[WMRK] valid entries and the QuadSPI_RSER[RBDDE]
    *   bit is not set (flag driven mode) a RX Buffer POP event is triggered.
    * The flag remains set if the RX Buffer contains more than QuadSPI_RBCT[WMRK] valid entries
    * after the RX Buffer POP event is finished.
    * The flag is cleared if the RX Buffer contains less than or equal to QuadSPI_RBCT[WMRK]
    * valid entries after the RX Buffer POP event is finished.
    */
   QspiFlag_RxBufferDrain = QSPI_FR_RBDF_MASK,                           /**< QspiFlag_ */

   /**
    * AHB Sequence Error Flag.
    *
    * Set when the execution of an AHB Command is started with a WRITE or WRITE_DDR Command
    * in the sequence pointed to by the QSPI_BUFxCR register. (QSPI_BUFxCR implies any one
    * of QSPI_BUF0CR/QSPI_BUF1CR/QSPI_BUF2CR/QSPI_BUF3CR.)
    * Communication with the serial flash device is terminated before the execution of
    * WRITE/WRITE_DDR command by the QuadSPI module.
    * The AHB bus request which triggered this command is answered with an ERROR response.
    */
   QspiFlag_AhbSequenceErrorError = QSPI_FR_ABSEF_MASK,                          /**< QspiFlag_ */

   /**
    * AHB Illegal transaction error flag.
    *
    * Set whenever there is no response generated from QSPI to AHB bus in case of illegal transaction
    * and the watchdog timer expires.The timer value is taken as parameter.
    */
   QspiFlag_AhbIllegalTransactionError = QSPI_FR_AITEF_MASK,                          /**< QspiFlag_ */

   /**
    * AHB Illegal Burst Size Error Flag.
    *
    * Set whenever the total burst size (size x beat) of an AHB transaction is greater than the prefetch data size.
    * The prefetch data size is defined by QSPI_BUFxCR[ADATSZ] or data size mentioned in the sequence pointed to
    * by the SEQID field in case ADATSZ = 0.
    */
   QspiFlag_AhbIllegalBurstSizeError = QSPI_FR_AIBSEF_MASK,                         /**< QspiFlag_ */

   /**
    * AHB Buffer Overflow Flag.
    *
    * Set when the size of the AHB access exceeds the size of the AHB buffer.
    * This condition can occur only if the QSPI_BUFxCR[ADATSZ] field is programmed incorrectly.
    * The AHB Command leading to this condition is continued until the number of entries according
    * to the QSPI_BUFxCR[ADATSZ] field has been read from the serial flash device.
    * The content of the AHB Buffer is not changed.
    */
   QspiFlag_AhbBufferOverflowError = QSPI_FR_ABOF_MASK,                           /**< QspiFlag_ */

   /**
    * IP Command Usage Error Flag.
    *
    * Set when in parallel flash mode the execution of an IP Command is started with more than
    * one pad enabled and the sequence pointed to by the sequence ID contains a WRITE or a
    * WRITE_DDR command. Refer to Table 35-21 table for the related commands.
    * Communication with the serial flash device is terminated before the execution of
    * WRITE/WRITE_DDR command by the QuadSPI module.
    */
   QspiFlag_IpCommandUsageError = QSPI_FR_IUEF_MASK,                           /**< QspiFlag_ */

   /** IP Command Trigger during AHB Access Error Flag.
    *
    *  Set when the following condition occurs:
    *  - A write access occurs to the QSPI_IPCR[SEQID] field and the QSPI_SR[AHB_ACC] bit is set.
    *    Any command leading to the assertion of the IPAEF flag is ignored.
    */
   QspiFlag_IpCommandTriggerDuringAhbError = QSPI_FR_IPAEF_MASK,                          /**< QspiFlag_ */

   /**
    * IP Command Trigger could not be executed Error Flag.
    *
    * Set when the QSPI_SR[IP_ACC] bit is set (i.e. an IP triggered command is currently executing)
    *  and any of the following conditions occurs:
    *  - Write access to the QSPI_IPCR register. Any command leading to the assertion of the IPIEF flag is ignored
    *  - Write access to the QSPI_SFAR register.
    *  - Write access to the QSPI_RBCT register.
    */
   QspiFlag_IpCommandTriggerNotExecutedError = QSPI_FR_IPIEF_MASK,                          /**< QspiFlag_ */

   /**
    * IP Command Trigger during AHB Grant Error Flag.
    *
    * Set when the following condition occurs:
    * - A write access occurs to the QSPI_IPCR[SEQID] field and the QSPI_SR[AHBGNT] bit is set.
    *   Any command leading to the assertion of the IPGEF flag is ignored.
    */
   QspiFlag_IpCommandTriggerDuringAhbGrantError = QSPI_FR_IPGEF_MASK,                          /**< QspiFlag_ */

   /**
    * IP Command Transaction Finished Flag.
    *
    * Set when the QuadSPI module has finished a running IP Command.
    * If an error occurred the related error flags are valid, at the latest,
    * in the same clock cycle when the TFF flag is asserted.
    */
   QspiFlag_IpCommandTransactionFinished = QSPI_FR_TFF_MASK,                            /**< QspiFlag_ */
};

/**
 * Bit masks for Interrupt or DMA requests.
 * See @ref QspiBase_T<Qspi0Info>::enableInterruptOrDmaRequests() and @ref QspiBase_T<Qspi0Info>::disableInterruptOrDmaRequests()
 */
enum QspiRequest {

   /**
    * Data Learning Pattern Failure Interrupt enable.
    * Triggered by DLPFF flag in QSPI_FR register
    */
   QspiAction_DataLearningPatternFailureInterrupt  = QSPI_RSER_DLPFIE_MASK,

   /**
    * TX Buffer Fill Interrupt Enable
    */
   QspiAction_TxBufferFillInterrupt                = QSPI_RSER_TBFIE_MASK,

   /**
    * TX Buffer Underrun Interrupt Enable
    */
   QspiAction_TxBufferUnderrunInterrupt            = QSPI_RSER_TBUIE_MASK,

   /**
    * TX Buffer Fill DMA Enable
    */
   QspiAction_TxBufferFillDma                      = QSPI_RSER_TBFDE_MASK,

   /**
    * Illegal Instruction Error Interrupt Enable.
    * Triggered by ILLINE flag in QSPI_FR
    */
   QspiAction_IllegalInstructionErrorInterrupt     = QSPI_RSER_ILLINIE_MASK,

   /**
    * RX Buffer Drain DMA Enable: Enables generation of DMA requests for RX Buffer Drain.
    * When this bit is set DMA requests are generated as long as the QSPI_SR[RXWE] status bit is set.
    */
   QspiAction_RxBufferDrainDma                     = QSPI_RSER_RBDDE_MASK,

   /**
    * RX Buffer Overflow Interrupt Enable
    */
   QspiAction_RxBufferOverflowInterruptEnable      = QSPI_RSER_RBOIE_MASK,

   /**
    * RX Buffer Drain Interrupt Enable: Enables generation of IRQ requests for RX Buffer Drain.
    * When this bit is set the interrupt is asserted as long as the QuadSPI_SR[RBDF] flag is set.
    */
   QspiAction_RxBufferDrainInterrupt               = QSPI_RSER_RBDIE_MASK,

   /**
    * AHB Sequence Error Interrupt Enable.
    * Triggered by ABSEF flags of QSPI_FR
    */
   QspiAction_AhbSequenceErrorInterrupt            = QSPI_RSER_ABSEIE_MASK,

   /**
    * AHB Illegal transaction interrupt enable.
    */
   QspiAction_AhbIllegalTransactionInterrupt       = QSPI_RSER_AITIE_MASK,

   /**
    * AHB Illegal Burst Size Interrupt Enable
    */
   QspiAction_AhbIllegalBurstSizeInterrupt         = QSPI_RSER_AIBSIE_MASK,

   /**
    * AHB Buffer Overflow Interrupt Enable
    */
   QspiAction_AhbBufferOverflowInterrupt           = QSPI_RSER_ABOIE_MASK,

   /**
    * IP Command Usage Error Interrupt Enable
    */
   QspiAction_IpCommandUsageErrorInterrupt         = QSPI_RSER_IUEIE_MASK,

   /**
    * IP Command Trigger during AHB Access Error Interrupt Enable
    */
   QspiAction_IpCommandTrigger                     = QSPI_RSER_IPAEIE_MASK,

   /**
    * IP Command Trigger during IP Access Error Interrupt Enable
    */
   QspiAction_IpCommandTriggerDuringAhbAccessError = QSPI_RSER_IPIEIE_MASK,

   /**
    * IP Command Trigger during AHB Grant Error Interrupt Enable
    */
   QspiAction_IpCommandTriggerDuringIpAccessError  = QSPI_RSER_IPGEIE_MASK,

   /**
    * Transaction Finished Interrupt Enable
    */
   QspiAction_IpCommandTriggerDuringAhbGrantError  = QSPI_RSER_TFIE_MASK,
};

enum QspiClear {
   QspiClear_IpPointer         = QSPI_SPTRCLR_IPPTRC_MASK,
   QspiClear_AhbPointer        = QSPI_SPTRCLR_BFPTRC_MASK,
   QspiClear_IpAndAhbPointers  = QSPI_SPTRCLR_IPPTRC_MASK|QSPI_SPTRCLR_BFPTRC_MASK,
};


enum QspiLutPadInfo : unsigned {
   QspiLutPadInfo_1Pad  = QSPI_LUT_PAD(0b00),
   QspiLutPadInfo_2Pads = QSPI_LUT_PAD(0b01),
   QspiLutPadInfo_4Pads = QSPI_LUT_PAD(0b10),
   QspiLutPadInfo_8Pads = QSPI_LUT_PAD(0b11),
};

/**
 * Command encoding for instructions
 */
enum QspiInstruction {
   QspiInstruction_Stop                        = QSPI_LUT_INSTR( 0), /**< Stop */
   QspiInstruction_Command                     = QSPI_LUT_INSTR( 1), /**< Command */
   QspiInstruction_Address                     = QSPI_LUT_INSTR( 2), /**< Address */
   QspiInstruction_Dummy                       = QSPI_LUT_INSTR( 3), /**< Dummy */
   QspiInstruction_Mode8                       = QSPI_LUT_INSTR( 4), /**< Mode */
   QspiInstruction_Mode2                       = QSPI_LUT_INSTR( 5), /**< Mode2 */
   QspiInstruction_Mode4                       = QSPI_LUT_INSTR( 6), /**< Mode4 */
   QspiInstruction_Read                        = QSPI_LUT_INSTR( 7), /**< Read */
   QspiInstruction_Write                       = QSPI_LUT_INSTR( 8), /**< Write */
   QspiInstruction_JumpOnChipSelect            = QSPI_LUT_INSTR( 9), /**< Jump On Chip Select */
   QspiInstruction_Addr_DDR                    = QSPI_LUT_INSTR(10), /**< Addr DDR */
   QspiInstruction_Mode8_DDR                   = QSPI_LUT_INSTR(11), /**< Mode DDR */
   QspiInstruction_Mode2_DDR                   = QSPI_LUT_INSTR(12), /**< Mode2 DDR */
   QspiInstruction_Mode4_DDR                   = QSPI_LUT_INSTR(13), /**< Mode4 DDR */
   QspiInstruction_Read_DDR                    = QSPI_LUT_INSTR(14), /**< Read DDR */
   QspiInstruction_Write_DDR                   = QSPI_LUT_INSTR(15), /**< Write DDR */
   QspiInstruction_DataLearn                   = QSPI_LUT_INSTR(16), /**< Data Learn */
   QspiInstruction_Command_DDR                 = QSPI_LUT_INSTR(17), /**< Command DDR */
   QspiInstruction_ColumnAddress               = QSPI_LUT_INSTR(18), /**< Column Address */
   QspiInstruction_ColumnAddress_DDR           = QSPI_LUT_INSTR(19), /**< Column Address DDR */
};

/**
 * Indicates which FIFOs to clear
 */
enum QspiFifoClear {
   QspiFifoClear_Transmit        = QSPI_MCR_CLR_TXF_MASK,                       /**< Transmit FIFO */
   QspiFifoClear_Receive         = QSPI_MCR_CLR_RXF_MASK,                       /**< Receive FIFO */
   QspiFifoClear_BothTxAndRx     = QSPI_MCR_CLR_TXF_MASK|QSPI_MCR_CLR_RXF_MASK, /**< Both Transmit and Receive FIFOs */

};
union __attribute__((packed)) QspiLutInstruction {
   struct __attribute__((packed)) {
      uint8_t         operand;
      unsigned        pads : 2;
      unsigned        instruction : 6;
   } instruction;
   uint16_t value;

   /**
    * Construct Instruction in LUT format
    *
    * @param instruction      Instruction
    * @param qspiLutPadInfo   Select number of pads used
    * @param operand          Operand associated with instruction
    */
   constexpr QspiLutInstruction(QspiInstruction instruction, QspiLutPadInfo qspiLutPadInfo, unsigned operand) :
         value(instruction|qspiLutPadInfo|operand) {
      usbdm_assert(operand == (operand & QSPI_LUT_OPRND_MASK), "Illegal operand");
   }

   /**
    * Construct Instruction in LUT format
    *
    * @param instruction   Instruction
    * @param operand       Operand associated with instruction
    */
   constexpr QspiLutInstruction(QspiInstruction instruction, unsigned operand) :
         value(instruction|operand) {
      usbdm_assert(operand == (operand & QSPI_LUT_OPRND_MASK), "Illegal operand");
   }

   /**
    * Construct Instruction in LUT format
    *
    * @param instruction   Instruction
    */
   constexpr QspiLutInstruction(QspiInstruction instruction) :
         value(instruction) {
   }

   /**
    * Default constructor
    * Used for array fill.
    * (Stop instruction)
    */
   constexpr QspiLutInstruction() :
         value(QspiInstruction_Stop) {
   }
};

/// Type for Delay chain tap number selection for QSPI Port A DQS
using QspiDelayTabSelectA = uint32_t;

/// Type for Delay chain tap number selection for QSPI Port B DQS
using QspiDelayTabSelectB = uint32_t;

/**
 * Calculate Delay chain tap number QSPI Port A DQS
 *
 * @param tapSelect Tap selection
 *
 * @return Tap selection suitable for use with QSPI_SOCCR
 */
static constexpr QspiDelayTabSelectA qspiDelayTabSelect_A(unsigned tapSelect) {
   return QSPI_SOCCR_DLYTAPSELA(tapSelect);
}

/**
 * Calculate Delay chain tap number QSPI Port B DQS
 *
 * @param tapSelect Tap selection
 *
 * @return Tap selection suitable for use with QSPI_SOCCR
 */
static constexpr QspiDelayTabSelectA qspiDelayTabSelect_B(unsigned tapSelect) {
   return QSPI_SOCCR_DLYTAPSELB(tapSelect);
}

/**
 * Base class for QSPI interface
 */
class QspiBase {

private:
   /**
    * This class is not intended to be instantiated by copy
    */
   QspiBase(const QspiBase&) = delete;
   QspiBase(QspiBase&&) = delete;

protected:
   const HardwarePtr<QSPI_Type> qspi;                 //!< QSPI hardware instance

   /**
      * Get QSPI input clock frequency
      *
      * @return Frequency as a uint32_t in Hz
      *
      * @note This is the frequency of the clock used by QSPI internally not the external FLEXBUS/SDRAM clock on CLKOUT.
      */
   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

public:
#if defined(MCU_MK28F15) || defined (MCU_MK82F25615)
   /**
    * MK28F/MK82F
    *
    * [0x6700_0000-0x67FF_FFFF] QuadSPI0 Rx Buffer - All masters
    * [0x6800_0000-0x6FFF_FFFF] QuadSPI0 (External Memory) - All masters
    */
   static constexpr uint32_t QSPI0_AMBA_RXDATA_ADDRESS = 0x6700'0000;
   static constexpr uint32_t QSPI0_AMBA_BASE_ADDRESS   = 0x6800'0000;
   /**
    * Size of AHB Buffer
    */
   static constexpr unsigned AHB_BUFFER_SIZE = 512;

#endif
};

/**
 * Setting for BFGENCR
 */
union __attribute__((packed)) QspiGenericBufferConfiguration {

private:
   QspiGenericBufferConfiguration() = delete;

public:
   constexpr QspiGenericBufferConfiguration(const QspiGenericBufferConfiguration&) = default;
   constexpr QspiGenericBufferConfiguration(QspiGenericBufferConfiguration&&) = default;

   struct __attribute__((packed)) {
      const unsigned :12;
      const unsigned sequenceId : 4;
      const bool     parallelEnable:1;
      const unsigned :15;
   };

   const uint32_t value;
   constexpr QspiGenericBufferConfiguration(QspiSequenceIdentity qspiSequenceIdentity, bool parallelEnable = false) :
      value((qspiSequenceIdentity>>(QSPI_IPCR_SEQID_SHIFT-QSPI_BFGENCR_SEQID_SHIFT))|QSPI_BFGENCR_PAR_EN(parallelEnable)) {
   }

};

/**
 * Setting for BUFxCR
 */
union __attribute__((packed)) QspiBufferConfiguration {
   struct __attribute__((packed)) {
      const unsigned masterid : 4;
      const unsigned :4;
      const unsigned dataSize : 7;
      const unsigned :16;
      const bool     option:1;
   };
   const uint32_t value;

   /**
    * Configuration for buffer as general use
    *
    * @param qspiMasterId   Master ID
    * @param ahbDataSize    Size of buffer
    */
   constexpr QspiBufferConfiguration(QspiMasterId qspiMasterId, unsigned ahbDataSize) :
         value(QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId) {
      usbdm_assert((ahbDataSize <= QspiBase::AHB_BUFFER_SIZE) && ((ahbDataSize&0b111) == 0), "Illegal ahbDataSize");
   }

   /**
    * Configure for buffer with option (buffer 0 most likely)
    *
    * @param qspiMasterId     Master ID
    * @param ahbDataSize      Size of buffer
    * @param qspiBufferOption Applicable option dependent on buffer
    */
   constexpr QspiBufferConfiguration(QspiMasterId qspiMasterId, unsigned ahbDataSize, QspiBufferOption qspiBufferOption ) :
         value(QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId|qspiBufferOption) {
      usbdm_assert((ahbDataSize <= QspiBase::AHB_BUFFER_SIZE) && ((ahbDataSize&0b111) == 0), "Illegal ahbDataSize");
   }

   /**
    * Configure for buffer3 as All-master
    *
    * @param ahbDataSize   Size of buffer
    */
   constexpr QspiBufferConfiguration(unsigned ahbDataSize) :
         value(QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|QspiBufferOption_AllMaster) {
      usbdm_assert((ahbDataSize <= QspiBase::AHB_BUFFER_SIZE) && ((ahbDataSize&0b111) == 0), "Illegal ahbDataSize");
   }

   /**
    * Default constructor - disabled
    */
   constexpr QspiBufferConfiguration() :
         value(QSPI_BUFCR_MSTRID(15)) {
      // 15 is a 'safe' master
   }
};

/**
 * Setting for RBCT
 */
union __attribute__((packed)) QspiRxBufferConfiguration {

private:
   QspiRxBufferConfiguration() = delete;

public:
   constexpr QspiRxBufferConfiguration(const QspiRxBufferConfiguration&) = default;
   constexpr QspiRxBufferConfiguration(QspiRxBufferConfiguration&&) = default;

   struct __attribute__((packed)) {
      const unsigned watermark : 4;
      const unsigned :4;
      const bool     bufferReadOut:1;
      const unsigned :23;
   };
   const uint32_t value;

   /**
    * Configuration for Receive Buffer Control Register
    *
    * @param qspiBufferWaterMark   This determines the watermark for the Receive Buffer.
    *
    * @param qspiBufferReadoutVia  Receive Buffer Readout access
    */
   constexpr QspiRxBufferConfiguration(
         QspiBufferWaterMark   qspiBufferWaterMark,
         QspiBufferReadoutVia  qspiBufferReadoutVia
         ) :
      value(qspiBufferWaterMark|qspiBufferReadoutVia) {
   }
};

/**
 * Setting for TBCT
 */
union __attribute__((packed)) QspiTxBufferConfiguration {

private:
   QspiTxBufferConfiguration() = delete;

public:
   constexpr QspiTxBufferConfiguration(const QspiTxBufferConfiguration&) = default;
   constexpr QspiTxBufferConfiguration(QspiTxBufferConfiguration&&) = default;

   struct __attribute__((packed)) {
      const unsigned watermark : 4;
      const unsigned :28;
   };
   const uint32_t value;

   /**
    * Configuration for Receive Buffer Control Register
    *
    * @param qspiBufferWaterMark   This determines the watermark for the Receive Buffer.
    */
   constexpr QspiTxBufferConfiguration(
         QspiBufferWaterMark   qspiBufferWaterMark
         ) :
      value(qspiBufferWaterMark) {
   }
};

/**
 * Configuration settings for use with @ref QspiBase_T<Qspi0Info>::configure()
 */
struct QspiSettings {
   QspiClockSource                clockSource;
   uint32_t                       baudRate;
   QspiBufferConfiguration        bufferConfiguration[4];
   QspiGenericBufferConfiguration genericBufferConfiguration;
   QspiTxBufferConfiguration      qspiTxBufferConfiguration;
   QspiRxBufferConfiguration      qspiRxBufferConfiguration;
   uint32_t                       flashSizes[4];
};

#ifdef QSPI_MCR_ISD2FA
/**
 * Configuration settings for use with @ref QspiBase_T<Qspi0Info>::configureAdvanced()
 */
struct QspiAdvancedSettings {
   const uint32_t mcr;
   const uint32_t soccr;

   constexpr QspiAdvancedSettings(
         QspiDdr                 qspiDdr                = QspiDDR_Disable,
         QspiEndian              qspiEndian             = QspiEndian_64bit_LE,

         QspiFlashClock2Pin      qspiFlashClock2Pin     = QspiFlashClock2Pin_Disabled,
         QspiDiffClockEnable     qspiDiffClockEnable    = QspiDiffClockEnable_Disabled,
         QspiOctalDataPins       qspiOctalDataPins      = QspiOctalDataPins_Disabled,

         QspiIdleSignalDrive2A   qspiIdleSignalDrive2A  = QspiIdleSignalDrive2A_H,
         QspiIdleSignalDrive2B   qspiIdleSignalDrive2B  = QspiIdleSignalDrive2B_H,
         QspiIdleSignalDrive3A   qspiIdleSignalDrive3A  = QspiIdleSignalDrive3A_H,
         QspiIdleSignalDrive3B   qspiIdleSignalDrive3B  = QspiIdleSignalDrive3B_H ) :
      mcr(qspiDdr|qspiEndian|qspiIdleSignalDrive2A|qspiIdleSignalDrive2B|qspiIdleSignalDrive3A|qspiIdleSignalDrive3B),
      soccr(qspiFlashClock2Pin|qspiDiffClockEnable|qspiOctalDataPins) {
   }
};
#else // !QSPI_MCR_ISD2FA
/**
 * Configuration settings for use with @ref QspiBase_T<Qspi0Info>::configureAdvanced()
 */
struct QspiAdvancedSettings {
   const uint32_t mcr;
   const uint32_t soccr;

   constexpr QspiAdvancedSettings(
         QspiDdr                 qspiDdr                = QspiDDR_Disable,
         QspiEndian              qspiEndian             = QspiEndian_64bit_LE,

         QspiFlashClock2Pin      qspiFlashClock2Pin     = QspiFlashClock2Pin_Disabled,
         QspiDiffClockEnable     qspiDiffClockEnable    = QspiDiffClockEnable_Disabled,
         QspiOctalDataPins       qspiOctalDataPins      = QspiOctalDataPins_Disabled) :
      mcr(qspiDdr|qspiEndian),
      soccr(qspiFlashClock2Pin|qspiDiffClockEnable|qspiOctalDataPins) {
   }
};
#endif

/**
 * Configuration settings for use with @ref QspiBase_T<Qspi0Info>::configureDqs()
 */
struct QspiDqsSettings {
   const uint32_t mcr;
   const uint32_t soccr;

   constexpr QspiDqsSettings(
         QspiDqsLatency          qspiDQSLatency         = QspiDqsLatency_Disable,
         QspiLoopDqs             qspiLoopDqs            = QspiLoopDqs_External,
         QspiPhaseSelectDqs      qspiPhaseSelectDqs     = QspiPhaseSelectDqs_None,
         QspiDqsClockPolarity    qspiDqsClockPolarity   = QspiDqsClockPolarity_NonInverted,
         QspiDelayTabSelectA     qspiDelayTabSelectA    = qspiDelayTabSelect_A(0),
         QspiDelayTabSelectB     qspiDelayTabSelectB    = qspiDelayTabSelect_B(0)
      ) :
      mcr(QspiDqs_Enable|qspiDQSLatency),
      soccr(qspiLoopDqs|qspiPhaseSelectDqs|qspiDqsClockPolarity|qspiDelayTabSelectA|qspiDelayTabSelectB) {
      };
};

/**
 * @brief Template class representing an QSPI interface
 *
 * <b>Example</b>
 *
 * @code
 *  @endcode
 *
 * @tparam Info            Class describing QSPI hardware
 */
template<class Info>
class QspiBase_T : public QspiBase, public Info {

private:
   /**
    * This class is not intended to be instantiated by copy
    */
   QspiBase_T(const QspiBase_T&) = delete;
   QspiBase_T(QspiBase_T&&) = delete;

   // Dummy routine as no IRQs
   void disableNvicInterrupts();

public:
   /** Class to static check channel exists and is mapped to a pin */
   template<int pin> class CheckPinExistsAndIsMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (pin>=0) && (pin<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[pin].gpioBit != PinIndex::UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[pin].gpioBit >= 0);

      static_assert(Test1, "Illegal QSPI pin - Check Configure.usbdm for available pin");
      static_assert(Test2, "QSPI output is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "QSPI pin doesn't exist in this device/package - Check Configure.usbdm for available outputs pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Hardware instance pointer
    *
    * @return Pointer to QSPI hardware
    */
   static constexpr HardwarePtr<QSPI_Type> qspi = Info::baseAddress;

   /**
    * Construct QSPI interface
    */
   constexpr QspiBase_T() : QspiBase(Info::baseAddress) {
   }

   $(/QSPI/classInfo: // No class Info found)

   static uint32_t getClockFrequency(QspiClockSource qspiClockSource) {
      switch(qspiClockSource) {
         case QspiClockSource_System     : return SystemBusClock;
         case QspiClockSource_MCGFLL     : return SystemMcgFllClock;
         case QspiClockSource_MCGPLL     : return SystemMcgPllClock;
         case QspiClockSource_MCGPLLx2   : return 2*SystemMcgPllClock;
         case QspiClockSource_IRC48M     : return SimInfo::irc48mClock;
         case QspiClockSource_OSCERCLK   : return Osc0Info::getOscerClock();
         case QspiClockSource_MCGIRCLK   : return McgInfo::getMcgIrClock();
         case QspiClockSource_USB1PFDCLK : break;
      }
      usbdm_assert(false, "Not supported");
      return 0;
   }

   /**
    * Enable Module
    *
    * Assume configuration has been completed.
    */
   static void enableModule() {
      qspi->MCR = qspi->MCR & ~QSPI_MCR_MDIS_MASK;
   }

   /**
    * Disable Module
    */
   static void disableModule() {
      qspi->MCR = qspi->MCR | QSPI_MCR_MDIS_MASK;
   }

   /**
    * Enable with default settings.
    */
   static void defaultConfigure() {
      Info::enable();
   }

   /**
    * Software reset for serial flash domain and AHB domain
    *
    * Serial Flash domain and AHB domain flops are reset.
    * Does not reset configuration registers.
    *
    * @note The QSPI is left disabled.
    *
    * @note The software resets need the clock to be running to propagate to the design.
    *       The MCR[MDIS] should therefore be set to 0 when the software reset bits are asserted.
    *       Also, before they can be deasserted again (by setting MCR[SWRSTSD] to 0),
    *       it is recommended to set the MCR[MDIS] bit to 1.
    *       Once the software resets have been deasserted, the normal operation can be
    *       started by setting the MCR[MDIS] bit to 0.
    */
   static void softwareReset() {

      // Reset AHB and Serial flash domain FFs
      qspi->MCR = qspi->MCR | (QSPI_MCR_SWRSTSD_MASK|QSPI_MCR_SWRSTHD_MASK);

      // Enable QSPI
      enableModule();

      // Wait a while
      waitUS(10);

      // Disable QSPI
      disableModule();

      // Release reset of AHB and Serial flash domain FFs
      qspi->MCR = qspi->MCR & ~(QSPI_MCR_SWRSTSD_MASK|QSPI_MCR_SWRSTHD_MASK);
   }

   /**
    * Clear Transmit/Receive FIFOs
    *
    * @param qspiFifoClear Which FIFOs to clear
    */
   static void clearFifos(QspiFifoClear qspiFifoClear) {

      // These are self-clearing bits
      qspi->MCR = qspi->MCR | qspiFifoClear;
   }

   /**
    * Base configuration of QSPI module
    *
    * This should be done before @ref configureDqs() or @ref configureAdvanced() \n
    * Other main settings are set to default values.
    *
    * @param baudRate         Baud rate for communication
    * @param qspiClockSource  Clock source to use
    *
    * @note The module is left disabled
    */
   static void configure(
         uint32_t             baudRate,
         QspiClockSource      qspiClockSource
         ) {

      unsigned frequency = getClockFrequency(qspiClockSource);
      unsigned divider = ((frequency+baudRate-1)/baudRate);
      QspiClockDivide qspiClockDivide = (QspiClockDivide)QSPI_MCR_SCLKCFG(divider);
      usbdm_assert(qspiClockDivide == (divider<<QSPI_MCR_SCLKCFG_SHIFT), "Invalid divider calculated");

      // Enable clock and map pins if selected
      Info::enable();

      // Configure clock and default settings - Module is left disabled internally
      qspi->SOCCR = qspiClockSource;
#ifdef QSPI_MCR_ISD2FA
      qspi->MCR   = qspiClockDivide|QspiModule_Disable|QspiEndian_64bit_LE|
            QspiIdleSignalDrive2A_H|QspiIdleSignalDrive2B_H|QspiIdleSignalDrive3A_H|QspiIdleSignalDrive3B_H;
#else
      qspi->MCR   = qspiClockDivide|QspiModule_Disable|QspiEndian_64bit_LE;
#endif

      softwareReset();
   }

   /**
    * Enable and configure DQS (Data Strobe) settings
    *
    * This should be done after @ref configure()
    *
    * @param settings   Configuration settings to use
    */
   static void configureDqs(const QspiDqsSettings &settings) {

      uint32_t value;

      value = qspi->MCR & ~(QSPI_MCR_DQS_EN_MASK|QSPI_MCR_DQS_LAT_EN_MASK);

      qspi->MCR = value | settings.mcr;

      value = qspi->SOCCR & (QSPI_SOCCR_DQSPADLPEN_MASK|QSPI_SOCCR_DQSLPEN_MASK|QSPI_SOCCR_DQSPHASEL_MASK|
            QSPI_SOCCR_DQSINVSEL_MASK|QSPI_SOCCR_DLYTAPSELA_MASK|QSPI_SOCCR_DLYTAPSELB_MASK);

      qspi->SOCCR = value | settings.soccr;
   }

   /**
    * Enable and configure DQS (Data Strobe) settings
    *
    * This should be done after @ref configure()
    *
    * @param qspiDQSLatency           DQS latency enable
    * @param qspiLoopDqs              DQS pin path
    * @param qspiPhaseSelectDqs       Select phase shift for internal DQS generation
    * @param qspiDqsClockPolarity     Select clock source for internal DQS generation
    * @param qspiDelayTabSelectA      Delay chain tap number selection for QSPI Port A DQS
    * @param qspiDelayTabSelectB      Delay chain tap number selection for QSPI Port B DQS
    */
   static void configureDqs(
      QspiDqsLatency          qspiDQSLatency         = QspiDqsLatency_Disable,
      QspiLoopDqs             qspiLoopDqs            = QspiLoopDqs_External,
      QspiPhaseSelectDqs      qspiPhaseSelectDqs     = QspiPhaseSelectDqs_None,
      QspiDqsClockPolarity    qspiDqsClockPolarity   = QspiDqsClockPolarity_NonInverted,
      QspiDelayTabSelectA     qspiDelayTabSelectA    = qspiDelayTabSelect_A(0),
      QspiDelayTabSelectB     qspiDelayTabSelectB    = qspiDelayTabSelect_B(0)
   ) {

      uint32_t value;

      value = qspi->MCR & ~(QSPI_MCR_DQS_EN_MASK|QSPI_MCR_DQS_LAT_EN_MASK);

      qspi->MCR = value | (QspiDqs_Enable|qspiDQSLatency);

      value = qspi->SOCCR & (QSPI_SOCCR_DQSPADLPEN_MASK|QSPI_SOCCR_DQSLPEN_MASK|QSPI_SOCCR_DQSPHASEL_MASK|
            QSPI_SOCCR_DQSINVSEL_MASK|QSPI_SOCCR_DLYTAPSELA_MASK|QSPI_SOCCR_DLYTAPSELB_MASK);

      qspi->SOCCR = value | (qspiLoopDqs|qspiPhaseSelectDqs|qspiDqsClockPolarity|qspiDelayTabSelectA|qspiDelayTabSelectB);
   }

   /**
    * Advanced configuration of QSPI module
    *
    * This should be done after @ref configure()
    *
    * @param settings   Configuration settings to use
    */
   static void configureAdvanced(const QspiAdvancedSettings &settings) {

      uint32_t value;

      value = qspi->MCR & ~(QSPI_MCR_DQS_EN_MASK|QSPI_MCR_DQS_LAT_EN_MASK);

      qspi->MCR = value | (QspiDqs_Enable|settings.mcr);

      value = qspi->SOCCR & (QSPI_SOCCR_DQSPADLPEN_MASK|QSPI_SOCCR_DQSLPEN_MASK|QSPI_SOCCR_DQSPHASEL_MASK|
            QSPI_SOCCR_DQSINVSEL_MASK|QSPI_SOCCR_DLYTAPSELA_MASK|QSPI_SOCCR_DLYTAPSELB_MASK);

      qspi->SOCCR = value | settings.soccr;
   }

#ifdef QSPI_MCR_ISD2FA
   /**
    * Advanced configuration of QSPI module
    *
    * This should be done after @ref configure()
    *
    * @param qspiDdr                  DDR mode enable
    * @param qspiEndian               Endianness
    * @param qspiFlashClock2Pin       Flash CK2 clock pin enable
    * @param qspiDiffClockEnable      Differential flash clock pins enable
    * @param qspiOctalDataPins        Octal data pins enable
    * @param qspiIdleSignalDrive2A    Idle Signal Drive IOFA[2] Flash A.
    * @param qspiIdleSignalDrive2B    Idle Signal Drive IOFB[2] Flash B.
    * @param qspiIdleSignalDrive3A    Idle Signal Drive IOFB[3] Flash A.
    * @param qspiIdleSignalDrive3B    Idle Signal Drive IOFB[3] Flash B.
    */
   static void configureAdvanced (
         QspiDdr                 qspiDdr                = QspiDDR_Disable,
         QspiEndian              qspiEndian             = QspiEndian_64bit_LE,

         QspiFlashClock2Pin      qspiFlashClock2Pin     = QspiFlashClock2Pin_Disabled,
         QspiDiffClockEnable     qspiDiffClockEnable    = QspiDiffClockEnable_Disabled,
         QspiOctalDataPins       qspiOctalDataPins      = QspiOctalDataPins_Disabled,

         QspiIdleSignalDrive2A   qspiIdleSignalDrive2A  = QspiIdleSignalDrive2A_H,
         QspiIdleSignalDrive2B   qspiIdleSignalDrive2B  = QspiIdleSignalDrive2B_H,
         QspiIdleSignalDrive3A   qspiIdleSignalDrive3A  = QspiIdleSignalDrive3A_H,
         QspiIdleSignalDrive3B   qspiIdleSignalDrive3B  = QspiIdleSignalDrive3B_H ) {

      uint32_t value;

      value = qspi->MCR & ~(QSPI_MCR_DDR_EN_MASK|QSPI_MCR_END_CFG_MASK|
            QSPI_MCR_ISD2FA_MASK|QSPI_MCR_ISD2FB_MASK|QSPI_MCR_ISD3FA_MASK|QSPI_MCR_ISD3FB_MASK);

      qspi->MCR = value | (qspiDdr|qspiEndian|
            qspiIdleSignalDrive2A|qspiIdleSignalDrive2B|qspiIdleSignalDrive3A|qspiIdleSignalDrive3B);

      value = qspi->SOCCR & (~QSPI_SOCCR_CK2EN_MASK|QSPI_SOCCR_DIFFCKEN_MASK|QSPI_SOCCR_OCTEN_MASK);

      qspi->SOCCR = value | (qspiFlashClock2Pin|qspiDiffClockEnable|qspiOctalDataPins);
   }
#else
   /**
    * Advanced configuration of QSPI module
    *
    * This should be done after @ref configure()
    *
    * @param qspiDdr                  DDR mode enable
    * @param qspiEndian               Endianness
    * @param qspiFlashClock2Pin       Flash CK2 clock pin enable
    * @param qspiDiffClockEnable      Differential flash clock pins enable
    * @param qspiOctalDataPins        Octal data pins enable
    */
   static void configureAdvanced (
         QspiDdr                 qspiDdr                = QspiDDR_Disable,
         QspiEndian              qspiEndian             = QspiEndian_64bit_LE,

         QspiFlashClock2Pin      qspiFlashClock2Pin     = QspiFlashClock2Pin_Disabled,
         QspiDiffClockEnable     qspiDiffClockEnable    = QspiDiffClockEnable_Disabled,
         QspiOctalDataPins       qspiOctalDataPins      = QspiOctalDataPins_Disabled) {

      uint32_t value;

      value = qspi->MCR & ~(QSPI_MCR_DDR_EN_MASK|QSPI_MCR_END_CFG_MASK);

      qspi->MCR = value | (qspiDdr|qspiEndian);

      value = qspi->SOCCR & (~QSPI_SOCCR_CK2EN_MASK|QSPI_SOCCR_DIFFCKEN_MASK|QSPI_SOCCR_OCTEN_MASK);

      qspi->SOCCR = value | (qspiFlashClock2Pin|qspiDiffClockEnable|qspiOctalDataPins);
   }
#endif

   /**
    * Configure QSPI from settings object.
    *
    * This is a more capable alternative to @ref configure() \n
    * This may be all that is needed for simple configurations.
    *
    * @param qspiSettings  Configuration parameters
    */
   static void configure(const QspiSettings &qspiSettings) {

      // Base configuration
      configure(qspiSettings.baudRate, qspiSettings.clockSource);

      // Configure AHB buffers
      qspi->BUF0CR      = qspiSettings.bufferConfiguration[0].value;
      qspi->BUF1CR      = qspiSettings.bufferConfiguration[1].value;
      qspi->BUF2CR      = qspiSettings.bufferConfiguration[2].value;
      qspi->BUF3CR      = qspiSettings.bufferConfiguration[3].value;
      qspi->BFGENCR     = qspiSettings.genericBufferConfiguration.value;
      qspi->TBCT        = qspiSettings.qspiTxBufferConfiguration.value;
      qspi->RBCT        = qspiSettings.qspiRxBufferConfiguration.value;

      uint32_t flashTopAddress = QSPI0_AMBA_BASE_ADDRESS;
      flashTopAddress += qspiSettings.flashSizes[0];
      setSerialFlashA1TopAddress(flashTopAddress);
      flashTopAddress += qspiSettings.flashSizes[1];
      setSerialFlashA2TopAddress(flashTopAddress);
      flashTopAddress += qspiSettings.flashSizes[2];
      setSerialFlashB1TopAddress(flashTopAddress);
      flashTopAddress += qspiSettings.flashSizes[3];
      setSerialFlashB2TopAddress(flashTopAddress);
   }

   /**
    * Initiate IP command
    *
    * @param qspiSequenceIdentity   Index of sequence in LUT to execute
    * @param dataSize               IP data transfer size. Defines the data transfer size in bytes of the IP command.
    * @param parallel               True to enable transaction to two serial flash devices in parallel mode.
    *
    * @note Waits for Module idle before command
    * @note Does not wait for command completion
    */
   static void initiateIpCommand(
      QspiSequenceIdentity  qspiSequenceIdentity,
      uint16_t              dataSize = 0,
      bool                  parallel = false ) {

      usbdm_assert((dataSize == (dataSize&(QSPI_IPCR_IDATSZ_MASK>>QSPI_IPCR_IDATSZ_SHIFT))), "Illegal dataSize");

      while (readStatusRegister() & QspiStatusMask_ModuleBusy) {
      }
      clearSequencePointers(QspiClear_IpPointer);
      qspi->IPCR = qspiSequenceIdentity|QSPI_IPCR_PAR_EN(parallel)|QSPI_IPCR_IDATSZ(dataSize);
   }

   /**
    * Set Flash timing
    *
    * @param qspiDataInHoldTime        Serial flash data in hold time.
    * @param qspiChipSelectHoldTime    Serial flash CS hold time in terms of serial flash clock cycles.
    * @param qspiChipSelectSetupTime   Serial flash CS setup time in terms of serial flash clock cycles.
    */
   static void setFlashTiming(
         QspiDataInHoldTime      qspiDataInHoldTime,
         QspiChipSelectHoldTime  qspiChipSelectHoldTime,
         QspiChipSelectSetupTime qspiChipSelectSetupTime ) {

      qspi->FLSHCR = qspiDataInHoldTime|qspiChipSelectHoldTime|qspiChipSelectSetupTime;
   }

   /**
    * Configuration for any access to buffer 0.
    *
    * An access is routed to this buffer when the master port number of the incoming
    * AHB request matches masterId.
    * Any buffer "miss" leads to a serial flash transaction being triggered as per
    * the sequence pointed to the SEQID field.
    *
    * @param highPriority
    *    High Priority Enable.
    *    When set, the master associated with this buffer is assigned a priority higher
    *    than the rest of the masters. An access by a high priority master will suspend
    *    any ongoing prefetch by another AHB master and will be serviced on high priority.
    *
    * @param ahbDataSize
    *    AHB data transfer size. Must be a multiple of 8.
    *    Defines the data transfer size of an AHB triggered access to serial flash.
    *    When ADATSZ = 0, the data size mentioned the sequence pointed to by the SEQID field
    *    overrides this value.
    *    Software should ensure that this transfer size is not greater than the size of this buffer.
    *
    * @param qspiMasterId
    *    Master ID.
    *    The ID of the AHB master associated with BUFFER0.
    *    Any AHB access with this master port number is routed to this buffer.
    *    It must be ensured that the master IDs associated with all buffers must be different.
    */
   static void configureBuffer0(
         unsigned  ahbDataSize,
         QspiMasterId qspiMasterId,
         bool     highPriority = false) {

      usbdm_assert(ahbDataSize <= AHB_BUFFER_SIZE, "Illegal ahbDataSize");

      qspi->BUF0CR = (highPriority?QSPI_BUF0CR_HP_EN_MASK:0)| QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId;
   }

   /**
    * Configuration for any access to buffer 1.
    *
    * An access is routed to this buffer when the master port number of the incoming AHB request matches masterId.
    * Any buffer "miss" leads to a serial flash transaction being triggered as per
    * the sequence pointed to the SEQID field.
    *
    * @param ahbDataSize
    *    AHB data transfer size. Must be a multiple of 8.
    *    Defines the data transfer size of an AHB triggered access to serial flash.
    *    When ADATSZ = 0, the data size mentioned the sequence pointed to by the SEQID field
    *    overrides this value.
    *    Software should ensure that this transfer size is not greater than the size of this buffer.
    *
    * @param qspiMasterId
    *    Master ID.
    *    The ID of the AHB master associated with BUFFER0.
    *    Any AHB access with this master port number is routed to this buffer.
    *    It must be ensured that the master IDs associated with all buffers must be different.
    */
   static void configureBuffer1(
         unsigned  ahbDataSize,
         QspiMasterId qspiMasterId ) {

      usbdm_assert(ahbDataSize <= AHB_BUFFER_SIZE, "Illegal ahbDataSize");

      qspi->BUF0CR = QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId;
   }

   /**
    * Configuration for any access to buffer 2.
    *
    * An access is routed to this buffer when the master port number of the incoming AHB request matches masterId.
    * Any buffer "miss" leads to a serial flash transaction being triggered as per
    * the sequence pointed to the SEQID field.
    *
    * @param ahbDataSize
    *    AHB data transfer size. Must be a multiple of 8.
    *    Defines the data transfer size of an AHB triggered access to serial flash.
    *    When ADATSZ = 0, the data size mentioned the sequence pointed to by the SEQID field
    *    overrides this value.
    *    Software should ensure that this transfer size is not greater than the size of this buffer.
    *
    * @param qspiMasterId
    *    Master ID.
    *    The ID of the AHB master associated with BUFFER0.
    *    Any AHB access with this master port number is routed to this buffer.
    *    It must be ensured that the master IDs associated with all buffers must be different.
    */
   static void configureBuffer2(
         unsigned        ahbDataSize,
         QspiMasterId   qspiMasterId ) {

      usbdm_assert(ahbDataSize <= AHB_BUFFER_SIZE, "Illegal ahbDataSize");

      qspi->BUF2CR = QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId;
   }

   /**
    * Configuration for any access to buffer 3.
    *
    * An access is routed to this buffer when the master port number of the incoming AHB request matches masterId.
    * Any buffer "miss" leads to a serial flash transaction being triggered as per
    * the sequence pointed to the SEQID field.
    *
    * @param ahbDataSize
    *    AHB data transfer size. Must be a multiple of 8.
    *    Defines the data transfer size of an AHB triggered access to serial flash.
    *    When ADATSZ = 0, the data size mentioned the sequence pointed to by the SEQID field
    *    overrides this value.
    *    Software should ensure that this transfer size is not greater than the size of this buffer.
    *
    * @param qspiMasterId
    *    Master ID.
    *    The ID of the AHB master associated with BUFFER0.
    *    Any AHB access with this master port number is routed to this buffer.
    *    It must be ensured that the master IDs associated with all buffers must be different.
    */
   static void configureBuffer3(
         unsigned  ahbDataSize,
         QspiMasterId qspiMasterId ) {

      usbdm_assert(ahbDataSize <= AHB_BUFFER_SIZE, "Illegal ahbDataSize");

      qspi->BUF3CR = QSPI_BUFCR_ADATSZ(ahbDataSize>>3)|qspiMasterId;
   }

   /**
    * Configure all AHB accesses to use buffer 3.
    *
    * Buffer 3 acts as an all-master buffer.
    * Other buffers are disabled.
    *
    * @param ahbDataSize (defaults to all of buffer)
    *    AHB data transfer size. Must be a multiple of 8.
    *    Defines the data transfer size of an AHB triggered access to serial flash.
    *    When ADATSZ = 0, the data size mentioned the sequence pointed to by the SEQID field
    *    overrides this value.
    *    Software should ensure that this transfer size is not greater than the size of this buffer.
    *
    */
   static void configureSingleAhbBuffer(unsigned  ahbDataSize = AHB_BUFFER_SIZE) {

      usbdm_assert(ahbDataSize <= AHB_BUFFER_SIZE, "Illegal ahbDataSize");

      qspi->BUF0CR = QSPI_BUFCR_ADATSZ(0)|QSPI_BUFCR_MSTRID(14);
      qspi->BUF1CR = QSPI_BUFCR_ADATSZ(0)|QSPI_BUFCR_MSTRID(14);
      qspi->BUF2CR = QSPI_BUFCR_ADATSZ(0)|QSPI_BUFCR_MSTRID(14);
      qspi->BUF3CR = QSPI_BUF3CR_ALLMST_MASK|QSPI_BUFCR_ADATSZ(AHB_BUFFER_SIZE>>3);
   }

   /**
    * Set the generic configuration for any of buffer accesses.
    * Any buffer "miss" leads to the buffer being flushed and a serial flash
    * transaction being triggered as per the sequence pointed to by the SEQID
    * field. If the PAR_EN field is set, all the buffer accesses result in
    * parallel accesses to the flashes.
    *
    * @param qspiSequenceIdentity   Points to a sequence in the Look-up table.
    * @param parallelEnable         True to enable transaction to two serial flash devices in parallel mode.
    */
   static void configureGenericBuffer(
         QspiSequenceIdentity    qspiSequenceIdentity,
         bool                    parallelEnable = false ) {
      qspi->BFGENCR = (qspiSequenceIdentity>>(QSPI_IPCR_SEQID_SHIFT-QSPI_BFGENCR_SEQID_SHIFT))|QSPI_BFGENCR_PAR_EN(parallelEnable);
   }

   /**
    * This sets the top index of buffer 0, which defines its size.
    *
    * @note The 3 LSBs of this value must be zero.
    *       This ensures that the buffer is 64-bit aligned, as each buffer entry is 64 bits long.
    *
    * @param topIndex Top index value
    */
   static void setBuffer0TopIndex(uint32_t topIndex) {
      usbdm_assert(topIndex == (topIndex&QSPI_BUFIND_TPINDX_MASK), "Illegal top index");
      qspi->BUF0IND = topIndex;
   }

   /**
    * This sets the top index of buffer 1, which defines its size.
    *
    * @note The 3 LSBs of this value must be zero.
    *       This ensures that the buffer is 64-bit aligned, as each buffer entry is 64 bits long.
    *
    * @param topIndex Top index value
    */
   static void setBuffer1TopIndex(uint32_t topIndex) {
      usbdm_assert(topIndex == (topIndex&QSPI_BUFIND_TPINDX_MASK), "Illegal top index");
      qspi->BUF1IND = topIndex;
   }

   /**
    * This sets the top index of buffer 2, which defines its size.
    *
    * @note The 3 LSBs of this value must be zero.
    *       This ensures that the buffer is 64-bit aligned, as each buffer entry is 64 bits long.
    *
    * @param topIndex Top index value
    */
   static void setBuffer2TopIndex(uint32_t topIndex) {
      usbdm_assert(topIndex == (topIndex&QSPI_BUFIND_TPINDX_MASK), "Illegal top index");
      qspi->BUF2IND = topIndex;
   }

   /**
    * Set Serial Flash Address
    *
    * The module automatically translates this address on the memory map to the address on
    * the flash itself.
    * - In 24-bit mode, only bits 23-0 are sent to the flash.
    * - In 32-bit mode, bits 27-0 are used with bits 31-28 driven to 0 when QSPI_SFACR[CAS] is set to 0.
    *
    * Say, if QSPI_SFACR[CAS] is 3 then bits 26-3 are sent to flash as it page address in
    * case flash is operating in 24-bit mode. Total number of address bits request by flash as it
    * page and column address must not be more than 32 bit.
    *
    * Refer to Table 35-14 for the mapping between the access mode and the QSPI_SFAR content
    * and to Normal Mode for details about the command triggering and command execution.
    * The software should ensure that the serial flash address provided in the QSPI_SFAR
    * register lies in the valid flash address range as defined in Table 35-14.
    *
    * @param address  The address to set
    */
   static void setSerialFlashAddress(uint32_t address) {
      qspi->SFAR = address;
   }

   /**
    * Set Flash Address Configuration
    *
    *  This register contains the serial flash specific address requirements that must be
    *  configured according to the flash connected, for the controller to function properly. The
    *  module automatically translates the address QSPI_SFAR on the memory map or the
    *  incoming address on the AHB bus to the column address on the flash itself. Say, a flash
    *  needs 3 bits as its column address than only the lower 3 bits of QSPI_SFAR/AHB
    *  address are send to flash as its column address. The software should ensure that the serial
    *  flash address provided in the QSPI_SFAR register or the incoming AHB address lies in
    *  the valid flash address range.
    *
    * @param columnAddressSpace
    *    Column Address Space
    *    Defines the width of the column address.
    *    If the column address is say [2:0] of QSPI_SFAR/AHB address, then CAS must be 3.
    *    If there is no column address separation in any serial flash this value must be 0.
    *
    * @param isFLashWordAddressable
    *    Word Addressable
    *    Defines whether the serial flash is a byte addressable flash or a word addressable flash.
    *    According to this configuration the address is re-mapped to the flash interface.
    */
   static void setFlashAddressConfiguration(
         unsigned columnAddressSpace,
         bool     isFLashWordAddressable) {
      usbdm_assert(columnAddressSpace == (columnAddressSpace&QSPI_SFACR_CAS_MASK), "Illegal columnAddressSpace");
      qspi->SFACR = QSPI_SFACR_CAS(columnAddressSpace)|(isFLashWordAddressable?QSPI_SFACR_WA_MASK:0);
   }

   /**
    * Configure sampling points
    *
    * @param qspiSdrFullSpeedDelay     Full Speed Delay selection for SDR instructions
    * @param qspiSdrFullSpeedPhase     Full Speed Phase selection for SDR instructions
    * @param qspiDdrSamplePoint        DDR Sampling point
    * @param qspiHalfSpeedSerialClock  Half Speed serial flash clock Enable
    * @param qspiHalfSpeedDelay        Half Speed Delay selection for SDR instructions
    * @param qspiHalfSpeedPhase        Half Speed Phase selection for SDR instructions.
    */
   static void configureSampling(
         QspiSdrFullSpeedDelay      qspiSdrFullSpeedDelay,
         QspiSdrFullSpeedPhase      qspiSdrFullSpeedPhase,
         QspiDdrSamplePoint         qspiDdrSamplePoint       = QspiDdrSamplePoint_0,
         QspiHalfSpeedSerialClock   qspiHalfSpeedSerialClock = QspiHalfSpeedSerialClock_Disable,
         QspiHalfSpeedDelay         qspiHalfSpeedDelay       = QspiHalfSpeedDelay_1_ClockCycle,
         QspiHalfSpeedPhase         qspiHalfSpeedPhase       = QspiHalfSpeedPhase_NonInvertedClock
   ) {
      qspi->SMPR =
            qspiDdrSamplePoint|qspiSdrFullSpeedDelay|qspiSdrFullSpeedPhase|
            qspiHalfSpeedDelay|qspiHalfSpeedPhase|qspiHalfSpeedSerialClock;
   }

   /**
    * Get buffer Status
    *
    * @param readCounter
    *    Read Counter.
    *    Indicates how many entries of 4 bytes have been removed from the RX Buffer.
    *    For example, a value of 0x2 would indicate 8 bytes have been removed.
    *
    * @param fillLevel
    *    RX Buffer Fill Level.
    *    Indicates how many entries of 4 bytes are still available in the RX Buffer.
    *    For example, a value of 0x2 would indicate 8 bytes are available.
    */
   static void getRxBufferStatus(
         unsigned &readCounter,
         unsigned &fillLevel) {
      uint32_t rbsr = qspi->RBSR;
      readCounter = (rbsr>>QSPI_RBSR_RDCTR_SHIFT)&(QSPI_RBSR_RDCTR_MASK>>QSPI_RBSR_RDCTR_SHIFT);
      fillLevel   = (rbsr>>QSPI_RBSR_RDBFL_SHIFT)&(QSPI_RBSR_RDBFL_MASK>>QSPI_RBSR_RDBFL_SHIFT);
   }

   /**
    * Configure Receive Buffer Control Register
    *
    * @param qspiBufferWaterMark   This determines the watermark for the Receive Buffer.
    *
    * @param qspiBufferReadoutVia  Receive Buffer Readout access
    */
   static void configureRxBuffer(
         QspiBufferWaterMark   qspiBufferWaterMark,
         QspiBufferReadoutVia  qspiBufferReadoutVia
         ) {
      qspi->RBCT = qspiBufferWaterMark|qspiBufferReadoutVia;
   }

   /**
    *
    * @param transmitCounter
    *    Transmit Counter.
    *    This field indicates how many entries of 4 bytes have been written into the TX Buffer by host accesses.
    *    It is reset to 0 when a 1 is written to QSPI_MCR[CLR_TXF].
    *    It is incremented on each write access to the QSPI_TBDR register when another word has been
    *    pushed onto the TX Buffer. When it is not cleared the TRCTR field wraps around to 0.
    *
    * @param fillLevel
    *    TX Buffer Fill Level.
    *    The TRBFL field contains the number of entries of 4 bytes each available in the TX Buffer for the
    *    QuadSPI module to transmit to the serial flash device.
    */
   static void getTxBufferStatsus(
         unsigned &transmitCounter,
         unsigned &fillLevel) {
      uint32_t tbsr = qspi->TBSR;
      transmitCounter = (tbsr>>QSPI_TBSR_TRCTR_SHIFT)&(QSPI_TBSR_TRCTR_MASK>>QSPI_TBSR_TRCTR_SHIFT);
      fillLevel   = (tbsr>>QSPI_TBSR_TRBFL_SHIFT)&(QSPI_TBSR_TRBFL_MASK>>QSPI_TBSR_TRBFL_SHIFT);
   }

   /**
    * Write to the circular TX Buffer of depth 64 bytes.
    *
    * This buffer provides the data written into it as write data for the page
    * programming commands to the serial flash device.
    * A write transaction on the flash with data size of less than 32 bits will lead
    * to the removal of four data entry from the TX buffer.
    * The valid bits will be used and the rest of the bits will be discarded.
    *
    * Refer to Table 35-23 for the byte ordering scheme.
    *
    * @param data
    *     Write data.
    *     The data is written into the next available entry of the TX Buffer and the QPSI_TBSR[TRBFL]
    *     field is updated accordingly.
    */
   static void writeTransmitBuffer(uint32_t data) {
      qspi->TBDR = data;
   }

   /**
    * Return the last data written to the Transmit buffer
    *
    * @return  Last data written
    */
   static uint32_t readTransmitBuffer() {
      return qspi->TBDR;
   }

   /**
    * Configure Receive Buffer Control Register
    *
    * @param qspiBufferWaterMark  This determines the watermark for the Transmit Buffer.
    */
   static void configureTxBuffer(QspiBufferWaterMark qspiBufferWaterMark) {
      qspi->TBCT = qspiBufferWaterMark;
   }

   /**
    * Provides all available status information about SFM command execution and arbitration,
    * the RX Buffer, TX Buffer, and the AHB Buffer.
    *
    * @return bit mask indicating different conditions @ref QspiStatusMask for values
    */
   static uint32_t readStatusRegister() {
      return qspi->SR;
   }

   /**
    * Waits until QSPI is idle (StatusReqister.ModuleBusy = 0)
    */
   static void waitForIdle() {
      while (readStatusRegister() & QspiStatusMask_ModuleBusy) {
      }
   }

   /**
    * The QSPI_FR register provides all available flags about SFM command execution and
    * arbitration which may serve as source for the generation of interrupt service requests.
    * Note that the error flags in this register do not relate directly to the execution of the
    * transaction in the serial flash device itself but only to the behaviour and conditions visible
    * in the QuadSPI module.
    *
    * @return BIt mask made up of @ref QspiFlag flags
    */
   static uint32_t readFlags() {
      return qspi->FR;
   }

   /**
    * Clear flags in Flag register
    *
    * @param qspiFlag Bit mask of @ref QspiFlag flags to clear
    */
   static void clearFlags(uint32_t qspiFlag) {
      qspi->FR = qspiFlag;
   }

   /**
    * Enable DMA or Interrupt requests
    *
    * @param qspiRequest Mask for interrupt or DMA requests to enable.
    *        See @ref QspiRequest
    */
   static void enableInterruptOrDmaRequests(uint32_t qspiRequest) {
      qspi->RSER = qspi->RSER | qspiRequest;
   }

   /**
    * Disable DMA or Interrupt requests see
    *
    * @param qspiRequest Mask for interrupt or DMA requests to disable.
    *        See @ref QspiRequest
    */
   static void disableInterruptOrDmaRequests(uint32_t qspiRequest) {
      qspi->RSER = qspi->RSER & ~qspiRequest;
   }

   /**
    * Sequence Suspend Status
    *
    * The sequence suspend status provides information specific to any suspended sequence.
    * An AHB sequence may be suspended when a high priority AHB master makes an access
    * before the AHB sequence completes the data transfer requested.
    *
    * @param dataLeft
    *    Data left
    *    Provides information about the amount of data left to be read in the suspended sequence.
    *    Value in terms of 64 bits or 8 bytes
    *    Valid only when return value is true.
    *
    * @param bufferNumber
    *    Suspended Buffer
    *    Provides the suspended buffer number.
    *    Valid only when return value is true.
    *
    * @return Boolean indicating if a sequence is in suspended state.
    */
   static bool readSuspendStatus(unsigned &dataLeft, unsigned &bufferNumber) {
      if ((qspi->SPNDST&QSPI_SPNDST_SUSPND_MASK) == 0) {
         return false;
      }
      dataLeft     = (qspi->SPNDST>>QSPI_SPNDST_DATLFT_SHIFT)&(QSPI_SPNDST_SUSPND_MASK>>QSPI_SPNDST_SUSPND_SHIFT);
      bufferNumber = (qspi->SPNDST>>QSPI_SPNDST_SPDBUF_SHIFT)&(QSPI_SPNDST_SPDBUF_MASK>>QSPI_SPNDST_SPDBUF_SHIFT);
      return true;
   }

   /**
    * Clear IP and/or AHB buffer pointers
    *
    * @param qspiClear  Which buffer pointers to clear
    */
   static void clearSequencePointers(QspiClear qspiClear = QspiClear_IpAndAhbPointers) {

      // These bits are self clearing
      qspi->SPTRCLR = qspi->SPTRCLR | qspiClear;
   }

   /**
    * Set Serial Flash A1 Top Address
    *
    *    Sets the address mapping for the serial flash A1.
    *    The difference between QSPI_SFA1AD[TPADA1] and QSPI_AMBA_BASE
    *    defines the size of the memory map for serial flash A1.
    *
    * @param address
    *    Top address for Serial Flash A1.
    *    In effect, TPADxx is the first location of the next memory
    */
   static void setSerialFlashA1TopAddress(uint32_t address) {
      usbdm_assert(address == (address & QSPI_SFAD_TPAD_MASK), "Illegal address");
      qspi->SFA1AD = address;
   }

   /**
    * Set Serial Flash A2 Top Address
    *
    *    Sets the address mapping for the serial flash A2.
    *    The difference between QSPI_SFA2AD[TPADA2] and QSPI_SFA1AD[TPADA1]
    *    defines the size of the memory map for serial flash A2.
    *
    * @param address
    *    Top address for Serial Flash A2.
    *    In effect, TPxxAD is the first location of the next memory.
    */
   static void setSerialFlashA2TopAddress(uint32_t address) {
      usbdm_assert(address == (address & QSPI_SFAD_TPAD_MASK), "Illegal address");
      qspi->SFA2AD = address;
   }


   /**
    * Set Serial Flash B1 Top Address
    *    Sets the address mapping for the serial flash B1.
    *    The difference between QSPI_SFB1AD[TPADB1] and QSPI_SFA2AD[TPADA2]
    *    defines the size of the memory map for serial flash B1.
    *
    * @param address
    *    Top address for Serial Flash B1.
    *    In effect, TPxxAD is the first location of the next memory.
    */
   static void setSerialFlashB1TopAddress(uint32_t address) {
      usbdm_assert(address == (address & QSPI_SFAD_TPAD_MASK), "Illegal address");
      qspi->SFB1AD = address;
   }

   /**
    * Set Serial Flash B2 Top Address
    *    Sets the address mapping for the serial flash B2.
    *    The difference between QSPI_SFB2AD[TPADB2] and QSPI_SFB1AD[TPADB1]
    *    defines the size of the memory map for serial flash B2.
    *
    * @param address
    *    Top address for Serial Flash B2.
    *    In effect, TPxxAD is the first location of the next memory.
    */
   static void setSerialFlashB2TopAddress(uint32_t address) {
      usbdm_assert(address == (address & QSPI_SFAD_TPAD_MASK), "Illegal address");
      qspi->SFB2AD = address;
   }

   /**
    * Set Data Learning Pattern
    *
    * This value is used for data learning in DDR and DQS mode.
    * If programmer wants to do data learn for more than 32 bit than the same value
    * is repeated. Say if 64 bit data learning is requested by any flash and the
    * value set is aa55_3443 then the 64 bit value will be aa55_3443_aa55_3443.
    * If 8 bit data learning was enabled by programming in seq_operand fields of
    * DATA_LEARN instruction to 1, the bits [7:0] are used as data_learning pattern.
    *
    * @param pattern Data Learning Pattern Value
    */
   static void setDataLearningPattern(uint32_t pattern) {
      qspi->DLPR - pattern;
   }

   /**
    * Get Data Learning Pattern
    *
    * This value is used for data learning in DDR and DQS mode.
    * If programmer wants to do data learn for more than 32 bit than the same value
    * is repeated. Say if 64 bit data learning is requested by any flash and the
    * value set is aa55_3443 then the 64 bit value will be aa55_3443_aa55_3443.
    * If 8 bit data learning was enabled by programming in seq_operand fields of
    * DATA_LEARN instruction to 1, the bits [7:0] are used as data_learning pattern.
    *
    * @return Data Learning Pattern Value
    */
   static uint32_t getDataLearningPattern() {
      return qspi->DLPR;
   }

   /**
    * Read Receive Buffer Data
    *
    * @param index   Index into buffer
    * @return value  Value to write
    */
   static uint32_t readRxDataBuffer(unsigned index) {
      usbdm_assert(index<(sizeof(qspi->RBDR)/sizeof(qspi->RBDR[0])), "Index out of range");
      return qspi->RBDR[index];
   }

   /**
    * Unlock Look Up Table (LUT)
    */
   static void unlockLookUpTable() {
      qspi->LUTKEY = 0x5AF05AF0;
      qspi->LCKCR  = QSPI_LCKCR_UNLOCK_MASK;
   }

   /**
    * Lock Look Up Table (LUT)
    */
   static void lockLookUpTable() {
      qspi->LUTKEY = 0x5AF05AF0;
      qspi->LCKCR  = QSPI_LCKCR_LOCK_MASK;
   }

   /**
    * Write LUT entries
    *
    * @param qspiLutEntries  The LUT entries for entire table (may be truncated)
    */
   template<size_t N>
   static void writeLookUpTable(const QspiLutInstruction (&qspiLutEntries)[N][8]) {
      unlockLookUpTable();
      const QspiLutInstruction *tPtr = (QspiLutInstruction*)qspiLutEntries;
      for (unsigned index=0; index<8*N; index++) {
         qspi->LUT[index] = tPtr[index].value;
      }
      lockLookUpTable();
   }

   /**
    * Report contents of look up table
    *
    * @param io Where to write report to
    */
   static void reportLuts(FormattedIO &io) {

      static constexpr IntegerFormat format {
         Width_4,
         Padding_LeadingZeroes,
      };
      io.setFormat(format);

      static constexpr unsigned TOTAL_LUTS = sizeof(qspi->LUT)/sizeof(qspi->LUT[0]);
      static constexpr unsigned SEQ_COUNT = TOTAL_LUTS/8;

      unsigned index = 0;
      for (unsigned seq=0; seq<SEQ_COUNT; seq++) {
         io.write(seq).write(" {");
         for (unsigned t=0; t<8; t++) {
            uint16_t entry = qspi->LUT[index];
            if (entry != 0) {
               if (t>0) {
                  io.write(", ");
               }
               io.write(entry, Radix_16);
            }
            index++;
         }
         io.writeln("}");
      }
      io.flushOutput();
      io.resetIntegerFormat();
   }

   /**
    * Create an entry for the LUT : Stop execution; deassert CS
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Stop() {
      return QspiLutInstruction(QspiInstruction_Stop);
   }

   /**
    * Create an entry for the LUT :
    * Instruction to provide the serial flash with operand on the number of pads specified
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          8-bit command value
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Command(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Command, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with address cycles according to the operand on the number of pads specified.
    *
    * The actual address to be provided will be derived from:
    * - the incoming address in case of AHB initiated transactions
    * - the value of SFAR in case of IPS initiated transactions, if QSPI_SFACR[CAS] is set to 0,
    *   else the actual address will take CAS into consideration.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of address bits to be sent
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Addr(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Address, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with dummy cycles as per the operand.
    *
    * The PAD information defines the number of pads in input mode
    * (for example, one pad implies that pad 1 is not driven, rest are driven)
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of dummy clock cycles
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Dummy(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Dummy, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 8-bit operand on the number of pads specified.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          8-bit mode value
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode8(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode8, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 2-bit operand on the number of pads specified.
    *
    * @param qspiLutPadInfo   Number of pads (1,2 pads)
    * @param operand          2-bit mode value
    *
    * A 1 pad instruction will take 2 serial flash clock cycles on the flash interface.
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode2(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode2, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 4-bit operand on the number of pads specified.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4 pads)
    * @param operand          4-bit mode value
    *
    * A 1 pad instruction will take 4 serial flash clock cycles on the flash interface.
    * A 4 pad instruction will take 1 serial flash clock cycle on the flash interface.
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode4(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode4, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Read data from flash on the number of pads specified.
    *
    * The data size may be overwritten by writing to:
    * - the ADATSZ field of the QSPI_BUFxCR registers for AHB initiated transactions
    * - the IDATSZ field of IP Configuration Register (QuadSPI_IPCR) for IP initiated transactions.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Read data size in bytes (multiple of 8)
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Read(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Read, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Write data on number of pads specified.
    *
    * The data size may be overwritten by writing to:
    * - the IDATSZ field of IP Configuration Register (QuadSPI_IPCR) register
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Write data size in bytes
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Write(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Write, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Every time the chip select (CS) is deasserted, jump to the instruction pointed to by the operand.
    *
    * This instruction allows the programmer to specify the behaviour of the controller when a new read
    * transaction is initiated following a CS deassertion.
    *
    * @param operand    Instruction number
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_JumpOnCs(uint8_t operand) {
      return QspiLutInstruction(QspiInstruction_JumpOnChipSelect, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with address cycles according to the address bits operand
    * on the number of pads specified at each clock edge of serial flash clock.
    * The actual address to be provided will be derived from the incoming address
    * in case of AHB initiated transactions and the value of QSPI_SFAR in case of IPS
    * initiated transactions , if QSPI_SFACR[CAS] is set to 0, else
    * the actual address will take CAS into consideration.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of address bits to be sent
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Addr_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Addr_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 8-bit operand on the number of
    * pads specified at each clock edge of serial flash.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          8-bit mode value
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode8_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 2-bit operand on the number of
    * pads specified at each clock edge of serial flash.
    *
    * @param qspiLutPadInfo   Number of pads (1 pad)
    * @param operand          2-bit mode value
    *
    * For a 1 pad instruction will take 1 serial flash clock cycle on the flash interface.
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode2_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode2_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with 4-bit operand on the number of
    * pads specified at each clock edge of serial flash.
    *
    * @param qspiLutPadInfo   Number of pads (1,2 pads)
    * @param operand          4-bit mode value
    *
    * For a 1 pad instruction will take 2 serial flash clock cycles on the flash interface.
    * For a 4 pad instruction will take half a cycle on the serial flash interface.
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Mode4_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Mode4_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Read data from flash on the number of pads specified at each clock edge of serial flash.
    *
    * The data size may be overwritten by writing to:
    * - the ADATSZ field of the QSPI_BUFxCR registers for AHB initiated transactions
    * - the IDATSZ field of IP Configuration Register (QuadSPI_IPCR) for IP initiated transactions.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Read data size in bytes (multiple of 8)
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Read_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Read_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Write data on number of pads specified at each clock edge of serial flash.
    *
    * The data size may be overwritten by writing to:
    * - the IDATSZ field of IP Configuration Register (QuadSPI_IPCR) register
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Write data size in bytes
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Write_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Write_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Finds the correct sampling point in case of only DDR operations.
    *
    * When this instruction is encountered, the
    * QSPI_SMPR[DDRSMP] values are ignored and the controller
    * finds the correct sampling point on its own by data learning.
    * But this feature of sampling point is valid for only DDR modes.
    * If DQS mode is enabled, then data learn instruction just
    * matches the incoming data from flash and if it does not
    * matches the QSPI_DLPV then Flag in QSPI_FR[DLPFF] is set
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of data bytes to be used for learning
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_DataLearn(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_DataLearn, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with the operand with number of pads specified at each clock edge of the serial flash
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          8-bit command value
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_Command_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_Command_DDR, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with column address cycles according to the operand on the number of pads specified.
    *
    * The actual address to be provided to flash will depend on value of QSPI_SFACR[CAS].
    * For example, if QSPI_SFACR[CAS] is 3, then the address to flash will be [2:0] of incoming address in
    * case of AHB and the value of QSPI_SFAR in case of IP.
    * This will be appended with zero if QSPI_SFACR[CAS] is less than number of pads for a Flash.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of address bits to be sent
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_ColumnAddr(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_ColumnAddress, qspiLutPadInfo, operand);
   }

   /**
    * Create an entry for the LUT :
    * Provide the serial flash with column address cycles according to the operand on the number of pads specified
    * on each edge of the flash clock.
    *
    * The actual address to be provided to flash will depend on value of QSPI_SFACR[CAS].
    * For example, if QSPI_SFACR[CAS] is 3, then the address to flash will be [2:0] of incoming address in
    * case of AHB and the value of QSPI_SFAR in case of IP.
    * This will be appended with zero if QSPI_SFACR[CAS] is less than number of pads for a Flash.
    *
    * @param qspiLutPadInfo   Number of pads (1,2,4,8 pads)
    * @param operand          Number of address bits to be sent
    *
    * @return  Encoded instruction
    */
   static constexpr QspiLutInstruction lutEntry_ColumnAddr_DDR(QspiLutPadInfo qspiLutPadInfo, unsigned operand) {
      return QspiLutInstruction(QspiInstruction_ColumnAddress_DDR, qspiLutPadInfo, operand);
   }

};

$(/QSPI/declarations: // No declarations found)

#endif // /QSPI/_BasicInfoGuard
/**
 * End QSPI_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_QSPI_H */

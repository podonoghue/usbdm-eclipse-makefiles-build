/**
 * @file     smc.h (180.ARM_Peripherals/Project_Headers/smc.h)
 * @brief    System Management Controller
 */

#ifndef HEADER_SMC_H
#define HEADER_SMC_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "string.h"
#include "mcg.h"
#include "pin_mapping.h"
#include "fmc.h"

namespace USBDM {

/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
$(/SMC/peripheral_h_definition:// $/SMC/peripheral_h_definition not found)

#if $(/SMC/_BasicInfoGuard) // /SMC/_BasicInfoGuard
/**
 *  Sleep on exit from Interrupt Service Routine (ISR)\n
 *  This option controls whether the processor re-enters sleep mode when exiting the\n
 *  handler for the interrupt that awakened it.
 */
enum SmcSleepOnExit {
   SmcSleepOnExit_Disabled = 0,                       //!< Processor does not re-enter SLEEP/DEEPSLEEP mode on completion of interrupt.
   SmcSleepOnExit_Enabled  = SCB_SCR_SLEEPONEXIT_Msk, //!< Processor re-enters SLEEP/DEEPSLEEP mode on completion of interrupt.
};

/**
 * @brief Template class representing the System Mode Controller (SMC)
 *
 * Partially based on Freescale Application note AN4503\n
 * Support for Kinetis Low Power operation.
 *
 * @image html KinetisPowerModes.png
 */
class SmcBase : public SmcInfo {

protected:
	   /** Hardware instance pointer */
	   static constexpr HardwarePtr<SMC_Type> smc = baseAddress;

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the currently configured STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.\n
    * The stop mode to enter may be set by setStopMode().
    * Other options that affect stop mode may be set by setStopOptions().
    *
    * @note This function is loaded in RAM as stop may power down flash
    */
__attribute__((section(".ram_functions")))
__attribute__((long_call))
__attribute__((noinline))
   static void _enterStopMode() {
      // Set deep sleep
      SCB->SCR = SCB->SCR | SCB_SCR_SLEEPDEEP_Msk;
      (void)SCB->SCR;
      __DSB();
      __WFI();
      __ISB();
   }

public:

   /**
    * Get name from SMC status e.g. RUN, VLPR, HSRUN
    *
    * @param status
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName(SmcStatus status) {
#ifdef SMC_PMPROT_AHSRUN
      if (status == SmcStatus_HSRUN) {
         return "HSRUN";
      }
#endif
      if (status == SmcStatus_RUN) {
         return "RUN";
      }
      if (status == SmcStatus_VLPR) {
         return "VLPR";
      }
      return "Impossible while running!";
   }

   /**
    * Get name for current SMC status  e.g. RUN, VLPR, HSRUN
    *
    * @return Pointer to static string
    */
   static const char *getSmcStatusName() {
      return getSmcStatusName(getStatus());
   }

   /**
    * Basic enable of SMC\n
    * Includes configuring all pins
    */
   static __attribute__((always_inline)) void enable() {
      // No clock or pins
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param[in] smcStopMode Stop mode to set.  This will become the default STOP mode.
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(SmcStopMode smcStopMode) {
      setStopMode(smcStopMode);

      return enterStopMode();
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with the current STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode() {
      /*
       * Actions required before entry to STOP modes
       */
$(/SMC/preEnterStopMode: // /SMC/preEnterStopMode not found)
      _enterStopMode();
      /*
       * Actions required after exit from STOP modes
       */
$(/SMC/postExitStopMode: // /SMC/postExitStopMode not found)
      return (smc->PMCTRL & SMC_PMCTRL_STOPA_MASK)?E_INTERRUPTED:E_NO_ERROR;
   }

   /**
    * Enter Stop Mode (STOP, VLPS, LLSx, VLLSx)  with given STOP settings
    * (ARM core DEEPSLEEP mode)
    *
    * The processor will stop execution and enter the given STOP mode.\n
    * Peripherals affected will depend on the stop mode selected.
    *
    * @param smcInit    Settings to apply before entering STOP mode
    *
    * @return E_NO_ERROR    Processor entered STOP
    * @return E_INTERRUPTED Processor failed to enter STOP mode due to interrupt
    */
   static ErrorCode enterStopMode(Init smcInit) {
      smcInit.setOptions();
      return enterStopMode();
   }

   /**
    * Enter Wait Mode (WAIT, VLPW)\n
    * (ARM core SLEEP mode)
    *
    * The processor will stop execution and enter WAIT/VLPW mode.\n
    * This function can be used to enter normal WAIT mode or VLPW mode
    * depending upon current run mode.\n
    * In wait mode the core clock is disabled (no code executing),
    * but bus clocks are enabled (peripheral modules are operational).
    *
    * Possible power mode transitions:
    * - RUN  -> WAIT
    * - VLPR -> VLPW
    *
    * WAIT mode is exited using any enabled interrupt or RESET.
    *
    * For Kinetis K:
    * If in VLPW mode, the statue of the SMC_PMCTRL[LPWUI] bit
    * determines if the processor exits to VLPR or RUN mode.\n
    * Use setExitVeryLowPowerOnInterrupt() to modify this action.
    *
    * For Kinetis L:
    * LPWUI does not exist.\n
    * Exits with an interrupt from VLPW will always be back to VLPR.\n
    * Exits from an interrupt from WAIT will always be back to RUN.
    *
    * @note Some modules include a programmable option to disable them in wait mode.\n
    * If those modules are programmed to disable in wait mode, they will not be able to
    * generate interrupts to wake the core.
    */
   static void enterWaitMode() {
      SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPDEEP_Msk;
      // Make sure write completes
      (void)(SCB->SCR);
      __asm volatile( "dsb" ::: "memory" );
      __asm volatile( "wfi" );
      __asm volatile( "isb" );
   }

   /**
    * Set Sleep-on-exit action
    *
    * If enabled, when the processor completes the execution of all exception handlers it
    * returns to Thread mode and immediately enters WAIT/STOP mode (ARM core SLEEP/DEEPSLEEP mode).\n
    * Use this mechanism in applications that only require the processor to run when
    * an exception occurs.
    *
    * @param[in] smcSleepOnExit Determines action on completion of all exception handlers
    */
   static void setSleepOnExit(SmcSleepOnExit smcSleepOnExit=SmcSleepOnExit_Enabled) {
      if (smcSleepOnExit) {
         SCB->SCR = SCB->SCR | SCB_SCR_SLEEPONEXIT_Msk;
      }
      else {
         SCB->SCR = SCB->SCR & ~SCB_SCR_SLEEPONEXIT_Msk;
      }
      // Make sure write completes
      (void)(SCB->SCR);
   }
$(/SMC/enterRunMode:    #error "/SMC/enterRunMode not found" )   
$(/SMC/enterPowerMode:  #error "/SMC/enterPowerMode not found" )   
$(/SMC/DefaultInitValue: // /SMC/DefaultInitValue not found)
$(/SMC/InitMethod: // /SMC/InitMethod not found)
};

$(/SMC/declarations: // No declarations found)
#endif // /SMC/_BasicInfoGuard
/**
 * End SMC_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_SMC_H */

/**
 * @file     tpm.h (180.ARM_Peripherals/Project_Headers/tpm.h)
 * @brief    Flexitimer Timer Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 *      Author: podonoghue
 */
#ifndef HEADER_TPM_H
#define HEADER_TPM_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <cmath>
#include "pin_mapping.h"

/*
 * Default port information
 */
namespace USBDM {

/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 *  Control mode of operation of shared timer counter
 */
enum TpmMode {
   //! Up counter: Used for left-aligned PWM, input capture and output compare modes
   TpmMode_LeftAlign   = TPM_SC_CPWMS(0),
   //! Up-down counter: Used for centre-aligned PWM
   TpmMode_CentreAlign = TPM_SC_CPWMS(1),
   //! Dummy value: Used for quadrature decoder
   TpmMode_Quadrature  = 0,
};

/**
 * Controls basic operation of PWM/Input capture/Output compare
 */
enum TpmChMode {
   TpmChMode_Disabled                = TPM_CnSC_MS(0)|TPM_CnSC_ELS(0), //!< Channel disabled
   TpmChMode_InputCaptureRisingEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(1), //!< Capture rising edge
   TpmChMode_InputCaptureFallingEdge = TPM_CnSC_MS(0)|TPM_CnSC_ELS(2), //!< Capture falling edge
   TpmChMode_InputCaptureEitherEdge  = TPM_CnSC_MS(0)|TPM_CnSC_ELS(3), //!< Capture both rising and falling edges
   TpmChMode_OutputCompare           = TPM_CnSC_MS(1),                 //!< Output compare operation without pin action
   TpmChMode_OutputCompareToggle     = TPM_CnSC_MS(1)|TPM_CnSC_ELS(1), //!< Toggle pin on output compare
   TpmChMode_OutputCompareClear      = TPM_CnSC_MS(1)|TPM_CnSC_ELS(2), //!< Clear pin on output compare
   TpmChMode_OutputCompareSet        = TPM_CnSC_MS(1)|TPM_CnSC_ELS(3), //!< Set pin on output compare
   TpmChMode_PwmHighTruePulses       = TPM_CnSC_MS(2)|TPM_CnSC_ELS(2), //!< PWM with high-true pulses
   TpmChMode_PwmLowTruePulses        = TPM_CnSC_MS(2)|TPM_CnSC_ELS(1), //!< PWM with low-true pulses
};

/**
 * Control alignment of PWM function
 */
enum TpmClockSource {
   TpmClockSource_Disabled    = TPM_SC_CMOD(0),  //!< Timer is disabled
   TpmClockSource_Internal    = TPM_SC_CMOD(1),  //!< Internal clock (usually determined by SIM->TPMCLKSRC clock )
   TpmClockSource_External    = TPM_SC_CMOD(2),  //!< External clock provided to TPM_CLKINx pin
   TpmClockSource_Reserved    = TPM_SC_CMOD(3),  //!< Reserved
};

/**
 * Control Prescaler for TPM clock
 */
enum TpmPrescale {
   TpmPrescale_1   = TPM_SC_PS(0),  //!< Divide by 1
   TpmPrescale_2   = TPM_SC_PS(1),  //!< Divide by 2
   TpmPrescale_4   = TPM_SC_PS(2),  //!< Divide by 4
   TpmPrescale_8   = TPM_SC_PS(3),  //!< Divide by 8
   TpmPrescale_16  = TPM_SC_PS(4),  //!< Divide by 16
   TpmPrescale_32  = TPM_SC_PS(5),  //!< Divide by 32
   TpmPrescale_64  = TPM_SC_PS(6),  //!< Divide by 64
   TpmPrescale_128 = TPM_SC_PS(7),  //!< Divide by 128
};

/*
 * Enabled Timer interrupt or DMA
 */
enum TpmChannelAction {
   TpmChannelAction_None   = TPM_CnSC_CHIE(0), //!< No action on event
   TpmChannelAction_Irq    = TPM_CnSC_CHIE(1), //!< Interrupt on event
#ifdef TPM_CnSC_DMA
   TpmChannelAction_Dma    = TPM_CnSC_CHIE(1)|TPM_CnSC_DMA(1), //!< DMA on event
#endif
};


/**
 * Type definition for timer overflow interrupt call back
 */
typedef void (*TpmCallbackFunction)();
/**
 * Type definition for channel interrupt call back
 *
 * @param[in] status Flags indicating interrupt source channel(s)
 */
typedef void (*TpmChannelCallbackFunction)(uint8_t status);

/**
 * Provides shared methods.
 */
class TpmBase {

private:
   TpmBase(const TpmBase&) = delete;
   TpmBase(TpmBase&&) = delete;

protected:
   // Constructor
   constexpr TpmBase(uint32_t baseAddress) : tmr(baseAddress) {};
   ~TpmBase() = default;

   /** Allow access owning TPM */
   const HardwarePtr<TPM_Type> tmr;

   /**
    * Limit index to permitted pin index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @tparam Inf    Associated info table
    * @param index   Index to limit
    *
    * @return Index limited to permitted range
    */
   template <class Inf>
   static inline constexpr int limitIndex(int index) {
      if (index<0) {
         return 0;
      }
      if (index>(Inf::numSignals-1)) {
         return Inf::numSignals-1;
      }
      return index;
   }

   /** Class to static check channel exists and is mapped to a pin */
   template<class Info, int channel> class CheckChannelExistsAndMapped {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != UNMAPPED_PCR);
      // Non-existent function and catch-all. (should be INVALID_PCR)
      static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[channel].gpioBit >= 0);

      static_assert(Test1, "Illegal FTM channel - Check Configure.usbdm for available inputs");
      static_assert(Test2, "FTM input is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Test3, "FTM channel doesn't exist in this device/package - Check Configure.usbdm for available input pins");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check channel is mapped to a pin - Ignores non-existence etc. */
   template<class Info, int channel> class CheckChannelIsMappedToPinOnly {

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Function is not currently mapped to a pin
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != UNMAPPED_PCR);

      static_assert(Test2, "FTM channel is not mapped to a pin - Modify Configure.usbdm");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /** Class to static check channel exists - it does not check that it is mapped to a pin */
   template<class Info, int channel> class CheckChannel {
      // Tests are chained so only a single assertion can fail so as to reduce noise

      // Out of bounds value for function index
      static constexpr bool Test1 = (channel>=0) && (channel<(Info::numSignals));
      // Non-existent function
      static constexpr bool Test2 = !Test1 || (Info::info[channel].gpioBit != INVALID_PCR);

      static_assert(Test1, "Illegal FTM channel - Check Configure.usbdm for available channels");
      static_assert(Test2, "FTM channel doesn't exist in this device/package - Check Configure.usbdm for available channels");

   public:
      /** Dummy function to allow convenient in-line checking */
      static constexpr void check() {}
   };

   /**
    * Callback to catch unhandled interrupt
    *
    * @param mask Mask identifying channel
    */
   static void unhandledChannelCallback(uint8_t mask) {
      (void)mask;
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Get Timer input frequency.
    *
    * @return Clock frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual() const = 0;

public:
   /**
    * Structure for FTM channel.
    */
   struct TpmChannelRegs {
      __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
      __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
   };

   /**
    * Set timer mode
    *
    * @param[in] tpmMode        Mode of operation
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setMode(TpmMode tpmMode) const {
      // Disable timer to allow change
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;

      // Set new mode
      tmr->SC = (sc&~TPM_SC_CPWMS_MASK)|tpmMode;
   }

   /**
    * Stop timer counter.
    * This simply disables the counter clock source. \n
    * To restart use setClockSource() or configure();
    *
    * @note This function will affect all channels of the timer.
    */
   void stopCounter() const {
      //if (isEnabled()) {
      tmr->SC = (tmr->SC&~TPM_SC_CMOD_MASK);
      //}
   }

   /**
    * Set timer clock source
    *
    * @param[in] tpmClockSource Clock source for timer
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setClockSource(TpmClockSource tpmClockSource=TpmClockSource_Internal) const {
      // Calculate new SC value
      uint32_t sc = (tmr->SC&~TPM_SC_CMOD_MASK)|tpmClockSource;
      // Disable timer to change clock (can't switch directly between clock sources)
      tmr->SC = 0;
      // Make sure write has completed (disabled)
      (void)tmr->SC;
      // Write new value
      tmr->SC = sc;
   }

   /**
    *  Set timer prescaler
    *
    * @param[in] tpmPrescale    Clock prescaler. Used to divide counter clock source before use
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   void setPrescaler(TpmPrescale tpmPrescale=TpmPrescale_128) const {
      // Disable timer to allow change
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      // Make sure write completes
      (void)tmr->SC;
      // Write new value
      tmr->SC = (sc&~TPM_SC_PS_MASK)|tpmPrescale;
   }
   /**
    * Set maximum value of timer counter.
    *
    * @param[in] endValue Modulo value in ticks (<65535), 0 = 65536.
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    */
   void setCounterMaximumValue(uint16_t endValue, bool suspend=false) const {
      uint32_t sc;
      if (suspend) {
         // Disable timer so register changes are immediate
         sc = tmr->SC;
         tmr->SC = 0;
         (void)tmr->SC;
      }
      tmr->MOD = endValue;
      if (suspend) {
         tmr->SC = sc;
      }
   }

   /**
    * Get maximum value of timer counter.
    *
    * @return Counter modulo value in ticks (<65535), 0 = 65536.
    */
   uint16_t getCounterMaximumValue() const {
      return tmr->MOD;
   }

   /**
    * Set period.
    *
    * @param[in] period   Period in ticks (<65535)
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @return E_NO_ERROR       Success
    * @return E_TOO_LARGE      Requested period is too large
    *
    * @note Prescaler is not affected.
    * @note Assumes prescale has been set to an appropriate value.
    * @note Only rudimentary range checking.
    * @note This function will affect all channels of the timer.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    */
   ErrorCode setPeriodInTicks(uint32_t period, bool suspend=false) const {

      // Check if CPWMS is set (affects period)
      bool centreAlign = (tmr->SC&TPM_SC_CPWMS_MASK);

      if (centreAlign) {
         // Centre-aligned period is 2*MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation

         // Halve with rounding
         period = (period+1)/2;
         if (period > 0x7FFFUL) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      else {
         // Left-aligned period is MOD+1 value
         period = period-1;
         if (period > 0xFFFF) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      uint32_t sc;
      if (suspend) {
         sc = tmr->SC;
         tmr->SC = 0;
      }
      // Change modulo
      tmr->MOD = period;

      if (suspend) {
         // Restart timer
         tmr->SC = sc;
      }
      // OK period
      return E_NO_ERROR;
   }

   /**
    * Calculate FTM timing parameters to achieve a given period
    *
    * @param period           Period in seconds
    * @param pPrescalerValue  Calculated prescaler value (for SC register)
    * @param pPeriodInTicks   Calculated period in ticks.
    *
    * @return E_NO_ERROR   Success.
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    */
   ErrorCode calculateTimingParameters(float period, unsigned &pPrescalerValue, unsigned &pPeriodInTicks) const {
      float inputClock = getInputClockFrequencyVirtual();
      unsigned prescaleFactor=1;
      unsigned prescalerValue=0;

      // Maximum period value in ticks
      uint32_t maxPeriodInTicks = 65536;

      // Check if CPWMS is set (affects period calculation)
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         // Centre-aligned period is ~double the MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation so
         // period in ticks is limited to 2*0x7FFF
         maxPeriodInTicks = 65534;
      }
      while (prescalerValue<=7) {
         float    clock = inputClock/prescaleFactor;
         uint32_t periodInTicks   = round(period*clock);
         if (periodInTicks <= 10) {
            usbdm_assert(false, "Interval is too short");
            // Too short a period for minimum resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (periodInTicks <= maxPeriodInTicks) {
            pPrescalerValue = prescalerValue;
            pPeriodInTicks  = periodInTicks;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      usbdm_assert(false, "Interval is too long");
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period
    *
    * @param[in] period   Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note The counter modulo value (MOD) is modified to obtain the requested period
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   ErrorCode setPeriod(float period) const {

      unsigned prescalerValue = 0;
      unsigned periodInTicks = 0;
      ErrorCode rc = calculateTimingParameters(period, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;
      setPeriodInTicks(periodInTicks, false);

      // Restart counter
      tmr->CNT   = 0;

      tmr->SC = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Set maximum interval for input-capture or output compare.
    * Input Capture and Output Compare will be able to operate over
    * at least this period without overflow.
    *
    * @param[in] interval Interval in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note FTM counter is configured for free-running mode i.e. 0-65535
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   ErrorCode setMaximumInterval(float interval) const {

      unsigned prescalerValue;
      unsigned periodInTicks;
      ErrorCode rc = calculateTimingParameters(interval, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;

      // Configure for free-running mode
      // This is the usual value for IC or OC set-up
      tmr->MOD = 0;

      // Restart counter
      tmr->CNT   = 0;

      tmr->SC = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   float getTickFrequencyAsFloat() const {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return static_cast<float>(getInputClockFrequencyVirtual())/prescaleFactor;
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   uint32_t getTickFrequencyAsInt() const {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return getInputClockFrequencyVirtual()/prescaleFactor;
   }

   /**
    * Set approximate frequency of timer tick
    *
    * @param[in] frequency Frequency as a float
    * @param[in] tolerance Tolerance in percent
    *
    * @return E_NO_ERROR       Success
    * @return E_ILLEGAL_PARAM  Failed to find suitable pre-scaler values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note This function will affect all channels of the timer.
    */
   ErrorCode setTickFrequency(float frequency, float tolerance) const {
      float inputClockFrequency = getInputClockFrequencyVirtual();

      int prescaleFactor=1;
      int prescalerValue=0;
      while (prescalerValue<=7) {
         float tickFrequency = inputClockFrequency/prescaleFactor;

         if ((100*std::abs((tickFrequency/frequency)-1)) < tolerance) {
            // Clear SC so immediate effect on prescale change
            uint32_t sc = tmr->SC&~TPM_SC_PS_MASK;
            tmr->SC = 0;
            (void)tmr->SC;
            tmr->SC     = sc|TPM_SC_PS(prescalerValue);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the Timer minimum resolution
    */
   uint32_t convertMicrosecondsToTicks(int time) const {

      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < 10) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
    * @note Will set error code if calculated value is less the minimum resolution
    */
   uint32_t convertSecondsToTicks(float seconds) const {

      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = rintf(seconds*tickRate);
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < 10) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   uint32_t convertTicksToMicroseconds(int timeInTicks) const {

      // Calculate period
      uint64_t rv = (static_cast<uint64_t>(timeInTicks)*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   uint32_t convertTicksToMilliseconds(int timeInTicks) const {

      // Calculate period
      uint64_t rv = (static_cast<uint64_t>(timeInTicks)*1000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in seconds
    */
   float convertTicksToSeconds(int timeInTicks) const {
      return static_cast<float>(timeInTicks)/getTickFrequencyAsFloat();
   }

   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   uint16_t getTime() const {
      return tmr->CNT;
   }

   /**
    * Reset counter to initial value
    */
   void resetTime() const {
      // Note: writing ANY value loads CNT from CNTIN
      tmr->CNT = 0;
   }

   /**
    * Get timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   unsigned getInterruptFlags() const {
      return tmr->STATUS;
   }

   /**
    * Clear selected timer event flags
    *
    * @param channelMask Mask indicating which channel flags to clear
    *                    There is one bit for each channel
    *
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   void clearSelectedInterruptFlags(uint32_t channelMask) const {
      (void)tmr->STATUS;
      tmr->STATUS = ~channelMask;
   }

   /**
    * Get and clear timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
    * @note Flags will not be cleared if the channel is configured for DMA
    */
   unsigned getAndClearInterruptFlags() const {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = tmr->STATUS;
      tmr->STATUS = ~status;
      return status;
   }

   /**
    * Enable/disable Timer Overflow interrupts
    */
   void enableTimerOverflowInterrupts() const {
      tmr->SC |= TPM_SC_TOIE_MASK;
   }

   /**
    * Disable Timer Overflow interrupts
    */
   void disableTimerOverflowInterrupts() const {
      tmr->SC &= ~TPM_SC_TOIE_MASK;
   }

   /**
    * Set PWM duty cycle.
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(float dutyCycle, int channel) const {
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*tmr->MOD)/100.0f);
      }
      else {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*(tmr->MOD+1))/100.0f);
      }
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(int dutyCycle, int channel) const {
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*tmr->MOD)/100;
      }
      else {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*(tmr->MOD+1))/100;
      }
   }

   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   ErrorCode setHighTimeInTicks(uint32_t highTime, int channel) const {

      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1)/2;
      }
#ifdef DEBUG_BUILD
      if (highTime > tmr->MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      tmr->CONTROLS[channel].CnV  = highTime;
      return E_NO_ERROR;
   }
};

class TpmChannel : public TpmBase {

private:
   TpmChannel(const TpmChannel&) = delete;
   TpmChannel(TpmChannel&&) = delete;

protected:
   // Empty constructor
   constexpr TpmChannel(uint32_t baseAddress, unsigned channelNum) :
   TpmBase(baseAddress),
   channelRegs((uint32_t)(tmr->CONTROLS+channelNum)),
   CHANNEL(channelNum),
   CHANNEL_MASK(1<<channelNum) {
   }
   ~TpmChannel() = default;

public:
   /** Allow access to FTM channel registers */
   const HardwarePtr<TpmBase::TpmChannelRegs> channelRegs;

   /** Timer channel number */
   const unsigned CHANNEL;

   /** Mask for Timer channel */
   const uint32_t CHANNEL_MASK;

   /**
    * Configure channel.
    * Doesn't affect shared settings of owning Timer
    *
    * @param[in] tpmChMode         Mode of operation for channel
    * @param[in] tpmChannelAction  Whether to enable the interrupt or DMA function on this channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   void configure(
         TpmChMode         tpmChMode,
         TpmChannelAction  tpmChannelAction = TpmChannelAction_None) const {

      tmr->CONTROLS[CHANNEL].CnSC = tpmChMode|tpmChannelAction;
   }

   /**
    * Disables timer channel (sets mode to TpmChMode_Disabled)
    */
   void disable() const {
      setMode(TpmChMode_Disabled);
   }

   /**
    * Get channel mode.
    *
    * @return Current mode of operation for the channel
    */
   TpmChMode getMode() const {
      return (TpmChMode)(tmr->CONTROLS[CHANNEL].CnSC &
            (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
   }

   /**
    * Set channel mode
    *
    * @param[in] tpmChMode      Mode of operation for channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   void setMode(TpmChMode tpmChMode) const {
      tmr->CONTROLS[CHANNEL].CnSC =
            (tmr->CONTROLS[CHANNEL].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|
            tpmChMode;
   }

   /**
    * Set channel action on event.
    *
    * @param[in] tpmChannelAction      Action to take on channel event (DMA or Interrupt)
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   void setAction(TpmChannelAction tpmChannelAction) const {
      tmr->CONTROLS[CHANNEL].CnSC =
            (tmr->CONTROLS[CHANNEL].CnSC & ~(FTM_CnSC_CHIE_MASK|FTM_CnSC_DMA_MASK))|
            tpmChannelAction;
   }

   /**
    * Set PWM high time in ticks.
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   ErrorCode setHighTimeInTicks(uint32_t highTime) const {
      return TpmBase::setHighTimeInTicks(highTime, CHANNEL);
   }

   /**
    * Set PWM high time in seconds.
    * Higher precision float version
    *
    * @param[in] highTime   PWM high time in seconds
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   ErrorCode setHighTime(float highTime) const {
      return TpmBase::setHighTimeInTicks(convertSecondsToTicks(highTime), CHANNEL);
   }
   /**
    * Set PWM duty cycle.
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(int dutyCycle) const {
      TpmBase::setDutyCycle(dutyCycle, CHANNEL);
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   void setDutyCycle(float dutyCycle) const {
      TpmBase::setDutyCycle(dutyCycle, CHANNEL);
   }

   /**
    * Set Timer event time.
    *
    * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   void setDeltaEventTime(uint16_t offset) {
      tmr->CONTROLS[CHANNEL].CnV += offset;
   }

   /**
    * Set Timer event time relative to current timer count value.
    *
    * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   void setRelativeEventTime(uint16_t offset) const {
      tmr->CONTROLS[CHANNEL].CnV = tmr->CNT + offset;
   }

   /**
    * Set Absolute Timer event time.
    *
    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
    *
    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
    */
   void setEventTime(uint16_t eventTime) const {
      tmr->CONTROLS[CHANNEL].CnV = eventTime;
   }

   /**
    * Get Absolute Timer event time.
    *
    * @return Absolute time of last event in ticks i.e. value from timer event register
    */
   uint16_t getEventTime() const {
      return tmr->CONTROLS[CHANNEL].CnV;
   }

   /**
    * Get Timer interrupt/event flag.
    *
    * @return true  Indicates an event has occurred on a channel
    * @return false Indicates no event has occurred on a channel since last polled
    */
   bool getInterruptFlag() const {
      return (tmr->STATUS&CHANNEL_MASK) != 0;
   }

   /**
    * Get and Clear Timer channel interrupt flag.
    *
    * @return true  Indicates an event has occurred on a channel
    * @return false Indicates no event has occurred on a channel since last polled
    *
    * @note Only flags captured in the return value are cleared
    */
   bool getAndClearInterruptFlag() const {
      // Note - requires read and write zero to clear flags
      // so only flags captured in status are cleared
      bool status = (tmr->STATUS&CHANNEL_MASK) != 0;
      tmr->STATUS = ~CHANNEL_MASK;
      return status;
   }

   /**
    * Clear interrupt flag on channel.
    */
   void clearInterruptFlag() const {
      // Note - requires read and write zero to clear flag
      tmr->CONTROLS[CHANNEL].CnSC &= ~FTM_CnSC_CHF_MASK;
   }

};

/**
 * Base class representing a TPM.
 *
 *
 * @tparam Info  Class describing TPM hardware instance
 */
template<class Info>
class TpmBase_T : public TpmBase {

private:
   /**
    * This class is not intended to be instantiated
    */
   TpmBase_T(const TpmBase_T&) = delete;
   TpmBase_T(TpmBase_T&&) = delete;

public:

   // Empty constructor
   constexpr TpmBase_T() : TpmBase(Info::baseAddress) {}
   virtual ~TpmBase_T() = default;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TPM_Type> tmr = Info::baseAddress;

   /** Get reference to TPM hardware as struct */
   static constexpr HardwarePtr<TPM_Type> tpm = Info::baseAddress;

   /** @return Base address of SPI hardware as uint32_t */
   static constexpr uint32_t tpmBase() { return Info::baseAddress; }
   /** @return Base address of TPM.SC register as uint32_t */
   static constexpr uint32_t tpmSC() { return tpmBase() + offsetof(TPM_Type, SC); }
   /** @return Base address of TPM.CNT register as uint32_t */
   static constexpr uint32_t tpmCNT() { return tpmBase() + offsetof(TPM_Type, CNT); }
   /** @return Base address of TPM.MOD register as uint32_t */
   static constexpr uint32_t tpmMOD() { return tpmBase() + offsetof(TPM_Type, MOD); }
   /** @return Base address of TPM.CONTROL[n] struct as uint32_t */
   static constexpr uint32_t tpmCONTROL(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS[index]); }
   /** @return Base address of TPM.CONTROL[n].CnSC struct as uint32_t */
   static constexpr uint32_t tpmCnSC(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS[index])+0; }
   /** @return Base address of TPM.CONTROL[n].CnV struct as uint32_t */
   static constexpr uint32_t tpmCnV(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS[index])+sizeof(uint32_t); }

private:
   /** Callback function for TOI ISR */
   static TpmCallbackFunction sToiCallback;

   /** Callback function for Channel Fault */
   static TpmCallbackFunction sFaultCallback;

   /** Callback function for Channel ISR */
   static TpmChannelCallbackFunction sChannelCallback;


protected:
   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual() const override {
      return Info::getInputClockFrequency();
   }

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      if ((tmr->SC&(TPM_SC_TOF_MASK|TPM_SC_TOIE_MASK)) == (TPM_SC_TOF_MASK|TPM_SC_TOIE_MASK)) {
         // Clear TOI flag (w1c)
         tmr->SC |= TPM_SC_TOF_MASK;
         sToiCallback();
      }
      // Get status for channels
      uint32_t status = tmr->STATUS;
      if (status) {
         // Clear flags for channel events being handled (w1c register if read)
         tmr->STATUS = status;
         sChannelCallback(status);
      }
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match TpmChannelCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Tpm0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Tpm0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint8_t), T &object>
   static TpmChannelCallbackFunction wrapCallback() {
      static TpmChannelCallbackFunction fn = [](uint8_t status) {
         (object.*callback)(status);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    int y;
    *
    *    // Member function used as callback
    *    // This function must match TpmChannelCallbackFunction
    *    void callback(uint8_t status) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * AClass aClass;
    * ...
    * // Wrap member function
    * auto fn = Tpm0::wrapCallback<AClass, &AClass::callback>(aClass);
    * // Use as callback
    * Tpm0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint8_t)>
   static TpmChannelCallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      static TpmChannelCallbackFunction fn = [](uint8_t status) {
         (obj.*callback)(status);
      };
      return fn;
   }

   /**
    * Set channel Callback function\n
    * Note that one callback is shared by all channels of the timer
    *
    * @param[in] callback Callback function to execute on channel interrupt.\n
    *                     Use nullptr to remove callback.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note One channel event callback is shared by all channels of the timer.
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode setChannelCallback(TpmChannelCallbackFunction callback) {
      static_assert(Info::irqLevel>=0, "TPM not configured for interrupts - Modify Configure.usbdm");
      if (callback == nullptr) {
         sChannelCallback = unhandledChannelCallback;
         return E_NO_ERROR;
      }
#ifdef DEBUG_BUILD
      // Callback is shared across all channels. Check if callback already assigned
      if ((sChannelCallback != unhandledChannelCallback) &&
            (sChannelCallback != nullptr) &&
            (sChannelCallback != callback)) {
         return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      }
#endif
      sChannelCallback = callback;
      return E_NO_ERROR;
   }
   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the timer
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static void setTimerOverflowCallback(TpmCallbackFunction theCallback) {
      static_assert(Info::irqLevel>=0, "TPM not configured for interrupts - Modify Configure.usbdmF");
      if (theCallback == nullptr) {
         sToiCallback = unhandledCallback;
         return;
      }
      sToiCallback = theCallback;
   }

public:
   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }

   /**
    * Enables clock to peripheral and configures all pins if
    * mapPinsOnEnable setting is true
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }

      // Enable clock to peripheral interface
      Info::enableClock();
      __DMB();
   }

   /**
    * Disables peripheral including clocks
    */
   static void disable() {
      // Disable (clock source disabled)
      tmr->SC = 0;

      // Disable clock to peripheral interface
      Info::disableClock();
      __DMB();
   }

   /**
    * Configure with settings from Configure.usbdmProject.
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Disable so immediate effect
      tmr->SC = 0;
      (void)tmr->SC;
      // Common registers
      tmr->CNT     = 0;
      tmr->MOD     = Info::modulo;
      tmr->SC      = Info::sc;

      enableNvicInterrupts(Info::irqLevel);
   }

   /**
    * Enables clock to peripheral and configures all pins.
    * Configures main operating settings for timer.
    *
    * @param[in] tpmMode        Mode of operation.
    * @param[in] tpmClockSource Clock source for timer.
    * @param[in] tpmPrescale    Clock prescaler. Used to divide input clock.
    */
   static void configure(
         TpmMode        tpmMode,
         TpmClockSource tpmClockSource = TpmClockSource_Internal,
         TpmPrescale    tpmPrescale    = TpmPrescale_128) {

      enable();

      // Disable so immediate effect
      tmr->SC = 0;
      (void)tmr->SC;
      tmr->SC  = tpmMode|tpmClockSource|tpmPrescale;
   }

   /**
    * Set timer mode
    *
    * @param[in] tpmMode        Mode of operation
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setMode(TpmMode tpmMode) {
      // Disable timer to allow change
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;

      // Set new mode
      tmr->SC = (sc&~TPM_SC_CPWMS_MASK)|tpmMode;
   }

   /**
    * Stop timer counter.
    * This simply disables the counter clock source. \n
    * To restart use setClockSource() or configure();
    *
    * @note This function will affect all channels of the timer.
    */
   static void stopCounter() {
      //if (isEnabled()) {
      tmr->SC = (tmr->SC&~TPM_SC_CMOD_MASK);
      //}
   }

   /**
    * Set timer clock source
    *
    * @param[in] tpmClockSource Clock source for timer
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setClockSource(TpmClockSource tpmClockSource=TpmClockSource_Internal) {
      // Calculate new SC value
      uint32_t sc = (tmr->SC&~TPM_SC_CMOD_MASK)|tpmClockSource;
      // Disable timer to change clock (can't switch directly between clock sources)
      tmr->SC = 0;
      // Make sure write has completed (disabled)
      (void)tmr->SC;
      // Write new value
      tmr->SC = sc;
   }

   /**
    *  Set timer prescaler
    *
    * @param[in] tpmPrescale    Clock prescaler. Used to divide counter clock source before use
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    */
   static void setPrescaler(TpmPrescale tpmPrescale=TpmPrescale_128) {
      // Disable timer to allow change
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      // Make sure write completes
      (void)tmr->SC;
      // Write new value
      tmr->SC = (sc&~TPM_SC_PS_MASK)|tpmPrescale;
   }

   /**
    * Set maximum value of timer counter.
    *
    * @param[in] endValue Modulo value in ticks (<65535), 0 = 65536.
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @note This function will affect all channels of the timer.
    * @note The timer will be disabled while making changes.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    */
   static void setCounterMaximumValue(uint16_t endValue, bool suspend=false) {
      uint32_t sc;
      if (suspend) {
         // Disable timer so register changes are immediate
         sc = tmr->SC;
         tmr->SC = 0;
         (void)tmr->SC;
      }
      tmr->MOD = endValue;
      if (suspend) {
         tmr->SC = sc;
      }
   }

   /**
    * Get maximum value of timer counter.
    *
    * @return Counter modulo value in ticks (<65535), 0 = 65536.
    */
   static uint16_t getCounterMaximumValue() {
      return tmr->MOD;
   }

   /**
    * Set period.
    *
    * @param[in] period   Period in ticks (<65535)
    * @param[in] suspend  Whether to suspend timer during change.
    *
    * @return E_NO_ERROR       Success
    * @return E_TOO_LARGE      Requested period is too large
    *
    * @note Prescaler is not affected.
    * @note Assumes prescale has been set to an appropriate value.
    * @note Only rudimentary range checking.
    * @note This function will affect all channels of the timer.
    * @note This value is write-buffered and updated by MOD synchronisation
    *       unless suspend is true.
    */
   static ErrorCode setPeriodInTicks(uint32_t period, bool suspend=false) {

      // Check if CPWMS is set (affects period)
      bool centreAlign = (tmr->SC&TPM_SC_CPWMS_MASK);

      if (centreAlign) {
         // Centre-aligned period is 2*MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation

         // Halve with rounding
         period = (period+1)/2;
         if (period > 0x7FFFUL) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      else {
         // Left-aligned period is MOD+1 value
         period = period-1;
         if (period > 0xFFFF) {
            // Attempt to set too long a period
            usbdm_assert(false, "Interval is too long");
            return setErrorCode(E_TOO_LARGE);
         }
      }
      uint32_t sc;
      if (suspend) {
         sc = tmr->SC;
         tmr->SC = 0;
      }
      // Change modulo
      tmr->MOD = period;

      if (suspend) {
         // Restart timer
         tmr->SC = sc;
      }
      // OK period
      return E_NO_ERROR;
   }

   /**
    * Calculate FTM timing parameters to achieve a given period
    *
    * @param period           Period in seconds
    * @param pPrescalerValue  Calculated prescaler value (for SC register)
    * @param pPeriodInTicks   Calculated period in ticks.
    *
    * @return E_NO_ERROR   Success.
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    */
   static ErrorCode calculateTimingParameters(float period, unsigned &pPrescalerValue, unsigned &pPeriodInTicks) {
      float inputClock = Info::getInputClockFrequency();
      unsigned prescaleFactor=1;
      unsigned prescalerValue=0;

      // Maximum period value in ticks
      uint32_t maxPeriodInTicks = 65536;

      // Check if CPWMS is set (affects period calculation)
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         // Centre-aligned period is ~double the MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation so
         // period in ticks is limited to 2*0x7FFF
         maxPeriodInTicks = 65534;
      }
      while (prescalerValue<=7) {
         float    clock = inputClock/prescaleFactor;
         uint32_t periodInTicks   = round(period*clock);
         if (periodInTicks < Info::minimumResolution) {
            usbdm_assert(false, "Interval is too short");
            // Too short a period for minimum resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (periodInTicks <= maxPeriodInTicks) {
            pPrescalerValue = prescalerValue;
            pPeriodInTicks  = periodInTicks;
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      usbdm_assert(false, "Interval is too long");
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set period
    *
    * @param[in] period   Period in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note The counter modulo value (MOD) is modified to obtain the requested period
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static ErrorCode setPeriod(float period) {

      unsigned prescalerValue;
      unsigned periodInTicks;
      ErrorCode rc = calculateTimingParameters(period, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;
      setPeriodInTicks(periodInTicks, false);

      // Restart counter
      tmr->CNT   = 0;

      tmr->SC = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Set maximum interval for input-capture or output compare.
    * Input Capture and Output Compare will be able to operate over
    * at least this period without overflow.
    *
    * @param[in] interval Interval in seconds as a float
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
    * @return E_TOO_LARGE  Requested period is too large.
    *
    * @note This function will affect all channels of the timer.
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note FTM counter is configured for free-running mode i.e. 0-65535
    * @note The Timer is stopped while being modified.
    * @note The Timer counter is restarted from zero
    */
   static ErrorCode setMaximumInterval(float interval) {

      unsigned prescalerValue;
      unsigned periodInTicks;
      ErrorCode rc = calculateTimingParameters(interval, prescalerValue, periodInTicks);

      if (rc != E_NO_ERROR) {
         return rc;
      }
      // Disable timer to change prescaler and period
      uint32_t sc = tmr->SC;
      tmr->SC = 0;
      (void)tmr->SC;

      // Configure for free-running mode
      // This is the usual value for IC or OC set-up
      tmr->MOD = 0;

      // Restart counter
      tmr->CNT   = 0;

      tmr->SC = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);

      return E_NO_ERROR;
   }

   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   static float getTickFrequencyAsFloat() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return static_cast<float>(Info::getInputClockFrequency())/prescaleFactor;
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getTickFrequencyAsInt() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);

      return Info::getInputClockFrequency()/prescaleFactor;
   }

   /**
    * Set approximate frequency of timer tick
    *
    * @param[in] frequency Frequency as a float
    * @param[in] tolerance Tolerance in percent
    *
    * @return E_NO_ERROR       Success
    * @return E_ILLEGAL_PARAM  Failed to find suitable pre-scaler values
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    * @note This function will affect all channels of the timer.
    */
   static ErrorCode setTickFrequency(float frequency, float tolerance) {
      float inputClockFrequency = Info::getInputClockFrequency();

      int prescaleFactor=1;
      int prescalerValue=0;
      while (prescalerValue<=7) {
         float tickFrequency = inputClockFrequency/prescaleFactor;

         if ((100*std::abs((tickFrequency/frequency)-1)) < tolerance) {
            // Clear SC so immediate effect on prescale change
            uint32_t sc = tmr->SC&~TPM_SC_PS_MASK;
            tmr->SC = 0;
            (void)tmr->SC;
            tmr->SC     = sc|TPM_SC_PS(prescalerValue);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Convert time in microseconds to time in ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    * @note Will set error code if calculated value is less the Timer minimum resolution
    */
   static uint32_t convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = getTickFrequencyAsInt();
      uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
    * @note Will set error code if calculated value is less the minimum resolution
    */
   static uint32_t convertSecondsToTicks(float seconds) {

      // Calculate period
      float    tickRate = getTickFrequencyAsFloat();
      uint64_t rv       = rintf(seconds*tickRate);
      usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv < Info::minimumInterval) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
      return rv;
   }

   /**
    * Convert time in ticks to time in microseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMicroseconds(int timeInTicks) {

      // Calculate period
      uint64_t rv = (static_cast<uint64_t>(timeInTicks)*1000000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in milliseconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in milliseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMilliseconds(int timeInTicks) {

      // Calculate period
      uint64_t rv = (static_cast<uint64_t>(timeInTicks)*1000)/getTickFrequencyAsInt();
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time in ticks
    *
    * @return Time in seconds
    */
   static float convertTicksToSeconds(int timeInTicks) {
      return static_cast<float>(timeInTicks)/getTickFrequencyAsFloat();
   }

   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   static uint16_t getTime() {
      return tmr->CNT;
   }

   /**
    * Reset counter to initial value
    */
   static void resetTime() {
      // Note: writing ANY value loads CNT from CNTIN
      tmr->CNT = 0;
   }

   /**
    * Get timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    */
   static unsigned getInterruptFlags() {
      return tmr->STATUS;
   }

   /**
    * Clear selected timer event flags
    *
    * @param channelMask Mask indicating which channel flags to clear
    *                    There is one bit for each channel
   *
   * @note Flags will not be cleared if the channel is configured for DMA
    */
   static void clearSelectedInterruptFlags(uint32_t channelMask) {
      (void)tmr->STATUS;
      tmr->STATUS = ~channelMask;
   }

   /**
    * Get and clear timer event flags
    *
    * @return Flags indicating if an event has occurred on a channel
    *         There is one bit for each channel
    *
    * @note Only flags captured in the return value are cleared
   * @note Flags will not be cleared if the channel is configured for DMA
    */
   static unsigned getAndClearInterruptFlags() {
      // Note requires read and write zero to clear flags
      // so only flags captured in status are cleared
      unsigned status = tmr->STATUS;
      tmr->STATUS = ~status;
      return status;
   }

   /**
    * Enable/disable Timer Overflow interrupts
    */
   static void enableTimerOverflowInterrupts() {
      tmr->SC |= TPM_SC_TOIE_MASK;
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static void disableTimerOverflowInterrupts() {
      tmr->SC &= ~TPM_SC_TOIE_MASK;
   }


   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event in ticks i.e. value from timer event register
    */
   static uint16_t getEventTime(int channel) {
      return tmr->CONTROLS[channel].CnV;
   }

   /**
    * Set Timer event time
    *
    * This value is write-buffered and updated by Cnv synchronisation.
    *
    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   static void setEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV = eventTime;
   }

   /**
    * Set Timer event time relative to current event time
    *
    * @param[in] eventTime  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static void setDeltaEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV += eventTime;
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] eventTime  Event time in ticks relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    *
    * @note This value is write-buffered and updated by CnV synchronisation.
    */
   static void setRelativeEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV = tmr->CNT + eventTime;
   }

   /**
    * Set PWM duty cycle.
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(float dutyCycle, int channel) {
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*tmr->MOD)/100.0f);
      }
      else {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*(tmr->MOD+1))/100.0f);
      }
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static void setDutyCycle(int dutyCycle, int channel) {
      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*tmr->MOD)/100;
      }
      else {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*(tmr->MOD+1))/100;
      }
   }

   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    *
    * @note The actual CnV register update may be delayed by the register synchronisation mechanism
    */
   static ErrorCode setHighTime(uint32_t highTime, int channel) {

      if (tmr->SC&TPM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1)/2;
      }
#ifdef DEBUG_BUILD
      if (highTime > tmr->MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      tmr->CONTROLS[channel].CnV  = highTime;
      return E_NO_ERROR;
   }

   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update may be delayed by the TPM register synchronisation mechanism
    */
   static ErrorCode setHighTime(float highTime, int channel) {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }



   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

public:
   /**
    * Template class representing a timer channel
    *
    * Example
    * @code
    * // Instantiate the timer and channel being used (for TPM0 & channel 6)
    * using Tmr      = USBDM::Tpm0;
    * using Tmr0_ch6 = Tmr::Channel<6>;
    *
    * // Enable and initialise timer with initial alignment
    * Tmr::configure(TpmMode_LeftAlign);
    *
    * // Change timer period (in ticks) (affects ALL channels of timer)
    * Tmr::setPeriod(500);
    *
    * // Configure channel as PWM
    * Tmr0_ch6::configure(TpmChMode_PwmHighTruePulses);
    *
    * // Change duty cycle (in percent)
    * Tmr0_ch6.setDutyCycle(45);
    * @endcode
    *
    * @tparam channel TPM timer channel
    */
   template <int channel>
   class Channel {

   private:
      TpmBase::CheckChannel<Info, channel> check;

   public:
      /** Allow access to PCR of associated pin */
      using Pcr = PcrTable_T<Info, limitIndex<Info>(channel)>;

      /** Allow access owning TPM */
      using Tpm = TpmBase_T<Info>;

      /** @return Base address of TPM.CONTROL struct as uint32_t */
      static constexpr uint32_t tpmCONTROL() { return tpmBase() + offsetof(TPM_Type, CONTROLS[channel]); }
      /** @return Address of TPM.CONTROL.CnSC as uint32_t */
      static constexpr uint32_t tpmCnSC() { return tpmBase() + offsetof(TPM_Type, CONTROLS[channel])+0; }
      /** @return Address of TPM.CONTROL.CnV as uint32_t */
      static constexpr uint32_t tpmCnV() { return tpmBase() + offsetof(TPM_Type, CONTROLS[channel])+sizeof(uint32_t); }

      /**
       * Structure for TPM channel.
       */
      struct TpmChannelRegs {
         __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
         __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
      };

      /**
       * Allows access to TPM channel registers.
       *
       * @return Reference to the TPM channel registers
       */
      static __attribute__((always_inline)) volatile TpmChannelRegs &channelRegs() {
         return *reinterpret_cast<TpmChannelRegs *>(&Tpm::tmr->CONTROLS[CHANNEL]);
      }

      /** Timer channel number */
      static constexpr unsigned CHANNEL      = channel;

      /** Mask for Timer channel */
      static constexpr uint32_t CHANNEL_MASK = 1<<channel;

      /**
       * Configure channel and sets mode.
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void defaultConfigure() {

         Tpm::tmr->CONTROLS[channel].CnSC = TpmChMode_PwmHighTruePulses|TpmChannelAction_None;
      }

      /**
       * Configure channel.
       * Doesn't affect shared settings of owning Timer
       *
       * @param[in] tpmChMode         Mode of operation for channel
       * @param[in] tpmChannelAction  Whether to enable the interrupt or DMA function on this channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void configure(
            TpmChMode         tpmChMode,
            TpmChannelAction  tpmChannelAction = TpmChannelAction_None) {

         Tpm::tmr->CONTROLS[channel].CnSC = tpmChMode|tpmChannelAction;
      }

      /**
       * Disables timer channel (sets mode to TpmChMode_Disabled)
       */
      void disable() {
         setMode(TpmChMode_Disabled);
      }

      /**
       * Get channel mode.
       *
       * @return Current mode of operation for the channel
       */
      static TpmChMode getMode() {
         return static_cast<TpmChMode>(Tpm::tmr->CONTROLS[channel].CnSC &
               (TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK));
      }

      /**
       * Set channel mode
       *
       * @param[in] tpmChMode      Mode of operation for channel
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void setMode(TpmChMode tpmChMode) {
         Tpm::tmr->CONTROLS[channel].CnSC =
               (Tpm::tmr->CONTROLS[channel].CnSC & ~(TPM_CnSC_MS_MASK|TPM_CnSC_ELS_MASK))|tpmChMode;
      }

      /**
       * Set channel action on event.
       *
       * @param[in] tpmChannelAction      Action to take on channel event (DMA or Interrupt)
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void setAction(TpmChannelAction tpmChannelAction) {
#ifdef TPM_CnSC_DMA
         Tpm::tmr->CONTROLS[channel].CnSC =
               (Tpm::tmr->CONTROLS[channel].CnSC & ~(TPM_CnSC_CHIE_MASK|TPM_CnSC_DMA_MASK))|
               tpmChannelAction;
#else
         Tpm::tmr->CONTROLS[channel].CnSC =
               (Tpm::tmr->CONTROLS[channel].CnSC & ~TPM_CnSC_CHIE_MASK)|tpmChannelAction;
#endif
      }

      /**
       * Set PWM high time in ticks.
       * Assumes value is less than period
       *
       * @param[in] highTime   PWM high time in ticks
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static ErrorCode setHighTimeInTicks(uint32_t highTime) {
         return Tpm::setHighTime(highTime, channel);
      }

      /**
       * Set PWM high time in seconds.
       * Higher precision float version
       *
       * @param[in] highTime   PWM high time in seconds
       *
       * @return E_NO_ERROR on success
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static ErrorCode setHighTime(float highTime) {
         return Tpm::setHighTime(highTime, channel);
      }
      /**
       * Set PWM duty cycle.
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static void setDutyCycle(int dutyCycle) {
         Tpm::setDutyCycle(dutyCycle, channel);
      }

      /**
       * Set PWM duty cycle
       *
       * @param[in] dutyCycle  Duty-cycle as percentage
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static void setDutyCycle(float dutyCycle) {
         Tpm::setDutyCycle(dutyCycle, channel);
      }

      /**
       * Set Timer event time.
       *
       * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static void setDeltaEventTime(uint16_t offset) {
         Tpm::setDeltaEventTime(offset, channel);
      }

      /**
       * Set Timer event time relative to current timer count value.
       *
       * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static void setRelativeEventTime(uint16_t offset) {
         Tpm::setRelativeEventTime(offset, channel);
      }

      /**
       * Set Absolute Timer event time.
       *
       * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
       *
       * @note The actual CnV register update will be delayed by the register synchronisation mechanism
       */
      static void setEventTime(uint16_t eventTime) {
         Tpm::setEventTime(eventTime, channel);
      }

      /**
       * Get Absolute Timer event time.
       *
       * @return Absolute time of last event in ticks i.e. value from timer event register
       */
      static uint16_t getEventTime() {
         return Tpm::getEventTime(channel);
      }

      /**
       * Get Timer interrupt/event flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       */
      static bool getInterruptFlag() {
         return (Tpm::tmr->STATUS&CHANNEL_MASK) != 0;
      }

      /**
       * Get and Clear Timer channel interrupt flag.
       *
       * @return true  Indicates an event has occurred on a channel
       * @return false Indicates no event has occurred on a channel since last polled
       *
       * @note Only flags captured in the return value are cleared
       */
      static bool getAndClearInterruptFlag() {
         // Note - requires read and write zero to clear flags
         // so only flags captured in status are cleared
         bool status = (Tpm::tmr->STATUS&CHANNEL_MASK) != 0;
         Tpm::tmr->STATUS = CHANNEL_MASK;
         return status;
      }

      /**
       * Clear interrupt flag on channel.
       */
      static void clearInterruptFlag() {
         // Note - requires one to clear flag
         Tpm::tmr->STATUS = CHANNEL_MASK;
      }




      /*******************************
       *  PIN Functions
       *******************************/
      /**
       * Set callback for Pin IRQ.
       *
       * @param[in] callback The function to call on Pin interrupt.\n
       *                     nullptr to indicate none
       *
       * @note There is a single callback function for all pins on the related port.
       */
      static __attribute__((always_inline)) void setPinCallback(PinCallbackFunction callback) {
         TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();
         static_assert(Pcr::HANDLER_INSTALLED, "Gpio associated with FTM channel not configured for PIN interrupts - Modify Configure.usbdm");
         Pcr::setPinCallback(callback);
      }

#if defined(PORT_PCR_ODE_MASK) and defined (PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC |= (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }
#elif defined(PORT_PCR_ODE_ASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue) {

      TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC |= (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode);
   }
#elif defined(PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC |= (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinSlewRate);
   }
#else
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue) {

      TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC |= (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif

      Pcr::setPCR(pinDriveStrength);
   }
#endif

      /**
       * @brief
       * Set subset of Pin Control Register Attributes associated with input direction \n
       * Mux value is set appropriately for the pin function being used. Other attributes are cleared.\n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
       * @param[in] pinAction        One of PinAction_None, etc
       * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive
       *
       *  @note see also configureDigitalFilter(), enableDigitalFilter(), disableDigitalFilter()
       */
      static void setInput(
            PinPull           pinPull           = Pcr::defaultPcrValue,
            PinAction         pinAction         = Pcr::defaultPcrValue,
            PinFilter         pinFilter         = Pcr::defaultPcrValue) {

         TpmBase::CheckChannelIsMappedToPinOnly<Info, channel>::check();
//         TpmBase::CheckChannelExistsAndMapped<Info, channel>::check(); // More noisy errors

#ifdef TPM_SC_PWMEN0_SHIFT
         // Disable output pin in TPM
         tpm->SC &= ~(1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif

         Pcr::setInput(pinPull,pinAction,pinFilter);
      }

   };

};

template<class Info> TpmCallbackFunction         TpmBase_T<Info>::sToiCallback     = TpmBase_T<Info>::unhandledCallback;
template<class Info> TpmChannelCallbackFunction  TpmBase_T<Info>::sChannelCallback = TpmBase_T<Info>::unhandledChannelCallback;

#ifdef USBDM_TPM0_IS_DEFINED
/**
 * Class representing TPM0.
 */
using Tpm0 = TpmBase_T<Tpm0Info>;
#endif

#ifdef USBDM_TPM1_IS_DEFINED
/**
 * Class representing TPM1.
 */
using Tpm1 = TpmBase_T<Tpm1Info>;
#endif

#ifdef USBDM_TPM2_IS_DEFINED
/**
 * Class representing TPM2
 */
using Tpm2 = TpmBase_T<Tpm2Info>;
#endif

#ifdef USBDM_TPM3_IS_DEFINED
/**
 * Class representing TPM3
 */
using Tpm3 = TpmBase_T<Tpm3Info>;
#endif

#ifdef TPM_QDCTRL_QUADEN_MASK
/**
 *  Quadrature Decoder Mode\n
 *  Selects the encoding mode used in the Quadrature Decoder mode.
 */
enum TpmQuadratureMode {
   TpmQuadratureMode_Phase_AB_Mode        = TPM_QDCTRL_QUADMODE(0),   //!< Phase A and phase B encoding mode.
   TpmQuadratureMode_Count_Direction_Mode = TPM_QDCTRL_QUADMODE(1),   //!< Count and direction encoding mode.
};

/**
 * Template class representing a TPM configured as a Quadrature decoder
 *
 * @tparam info      Information class for TPM
 *
 * @code
 *  using TpmQuadDecoder = TpmQuadDecoder_T<Tpm0Info>;
 *
 *  // Enable decoder
 *  TpmQuadDecoder::configure();
 *
 *  // Set pin filters
 *  TpmQuadDecoder::enableFilter(15);
 *
 *  // Reset position to zero
 *  // Movement will be +/- relative to this initial position
 *  TpmQuadDecoder::resetPosition();
 *
 *  for(;;) {
 *     console.write("Position =").writeln(QuadDecoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class TpmQuadDecoder_T {

private:
   TpmQuadDecoder_T(const TpmQuadDecoder_T&) = delete;
   TpmQuadDecoder_T(TpmQuadDecoder_T&&) = delete;

   TpmBase::CheckChannel<typename Info::InfoQUAD, 0> checkQ0;
   TpmBase::CheckChannel<typename Info::InfoQUAD, 1> checkQ1;

public:
   // Default constructor
   constexpr TpmQuadDecoder_T() {};

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TPM_Type>tmr = Info::baseAddress;

   /** Allow more convenient access associated Tpm */
   using Tpm = TpmBase_T<Info>;

   /** Allow access to PCR of associated phase-A pin */
   using Pcr0 = PcrTable_T<typename Info::InfoQUAD, 0>;

   /** Allow access to PCR of associated phase-B pin */
   using Pcr1 = PcrTable_T<typename Info::InfoQUAD, 1>;

   /**
    * Set Pin Control Register (PCR) values for PHA and PHB inputs.
    * This will map the pin to the Quadrature function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = Pcr0::defaultPcrValue,
         PinAction         pinAction         = Pcr0::defaultPcrValue,
         PinFilter         pinFilter         = Pcr0::defaultPcrValue) {

      Pcr0::setPCR(pinPull|pinAction|pinFilter);
      Pcr1::setPCR(pinPull|pinAction|pinFilter);
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the TPM
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setTimerOverflowCallback(TpmCallbackFunction theCallback) {
      Tpm::setTimerOverflowCallback(theCallback);
   }

   /**
    * Enable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void enableTimerOverflowInterrupts() {
      Tpm::enableTimerOverflowInterrupts();
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void disableTimerOverflowInterrupts() {
      Tpm::disableTimerOverflowInterrupts();
   }

   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    *
    * @param[in]  nvicPriority  Interrupt priority
    *
    * @note Any pending interrupts are cleared before enabling.
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(Info::irqNums[0]);
   }

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void configureAllPins() {
      // Configure pins
      Info::InfoQUAD::initPCRs();
   }

   /**
    * Enables clock to peripheral and configures all pins if
    * mapPinsOnEnable setting is true
    */
   static void enable() {
      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }
      // Enable clock to peripheral interface
      Info::enableClock();
      __DMB();
   }

   /**
    * Disables peripheral including clocks
    */
   static void disable() {
      // Disable TPM (clock source disabled)
      tmr->QDCTRL = 0;

      // Disable clock to peripheral interface
      Info::disableClock();
      __DMB();
   }

   /**
    * Basic configuration of Quadrature decoder.
    * Includes configuring all pins if
    * mapPinsOnEnable setting is true
    *
    * @param tpmPrescale       Prescale value applied to the output of the quadrature decode before the counter.
    * @param tpmQuadratureMode Selects the encoding mode used to decode the input changes.
    */
   static void configure(
         TpmPrescale       tpmPrescale       = TpmPrescale_1,
         TpmQuadratureMode tpmQuadratureMode = TpmQuadratureMode_Phase_AB_Mode
   ) {
      // Assertions placed here so only checked if TpmQuadDecoder actually used
      static_assert(Info::InfoQUAD::info[0].gpioBit >= 0, "TpmQuadDecoder_T PHA is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Info::InfoQUAD::info[1].gpioBit >= 0, "TpmQuadDecoder_T PHB is not mapped to a pin - Modify Configure.usbdm");

      enable();

      // Disable so immediate effect
      tmr->SC = 0;
      (void)tmr->SC;
      tmr->SC = TpmMode_Quadrature|TpmClockSource_Disabled|tpmPrescale;

      tmr->QDCTRL =
            TPM_QDCTRL_QUADEN_MASK|      // Enable Quadrature decoder
            tpmQuadratureMode;           // Quadrature mode
      tmr->CONF   = TPM_CONF_DBGMODE(3);
   }

   /**
    * Reset position to zero
    */
   static void resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      tmr->CNT = 0;
   }

   /**
    * Get Quadrature decoder position
    *
    * @return Signed number representing position relative to reference location
    *
    * @note This can be viewed as a signed number +/- relative to the initial position.
    * @note This can be viewed as an unsigned number counting up from 0
    *       with overflow at 0xFFFF and underflow at 0.
    */
   static int16_t getPosition() {
      return (int16_t)(tmr->CNT);
   }

   /**
    * Get Quadrature decoder overflow direction.
    * This would be used in the overflow callback.
    *
    * @return Timer overflow direction. true => increasing, false => decreasing.
    *
    * @note Overflow occurs at MOD -> CNTIN, Underflow occurs at CNTIN -> MOD.
    */
   static bool getOverflowDirection() {
      return (bool)(tmr->QDCTRL & FTM_QDCTRL_TOFDIR_MASK);
   }
};
#endif // defined(TPM_QDCTRL_QUADEN_MASK)


#ifdef USBDM_TPM0_INFOQUAD_IS_DEFINED
/**
 * Class representing TPM0 as Quadrature decoder
 * Not all TPMs support this mode
 */
using TpmQuadDecoder0 = TpmQuadDecoder_T<Tpm0Info>;
#endif

#ifdef USBDM_TPM1_INFOQUAD_IS_DEFINED
/**
 * Class representing TPM1 as Quadrature decoder
 */
using TpmQuadDecoder1 = TpmQuadDecoder_T<Tpm1Info>;
#endif

#ifdef USBDM_TPM2_INFOQUAD_IS_DEFINED
/**
 * Class representing TPM2 as Quadrature decoder
 */
using TpmQuadDecoder2 = TpmQuadDecoder_T<Tpm2Info>;
#endif

#ifdef USBDM_TPM3_INFOQUAD_IS_DEFINED
/**
 * Class representing TPM3 as Quadrature decoder
 */
using TpmQuadDecoder3 = TpmQuadDecoder_T<Tpm3Info>;
#endif

#ifdef USBDM_TPM4_INFOQUAD_IS_DEFINED
/**
 * Class representing TPM4 as Quadrature decoder
 */
using TpmQuadDecoder4 = TpmQuadDecoder_T<Tpm4Info>;
#endif

/**
 * End TPM_Group
 * @}
 */

} // End namespace USBDM

#endif /* HEADER_TPM_H */


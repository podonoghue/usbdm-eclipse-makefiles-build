/**
 * @file     tpm.h (180.ARM_Peripherals/Project_Headers/tpm.h)
 * @brief    Flexitimer Timer Module
 */

#ifndef HEADER_TPM_H
#define HEADER_TPM_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <cmath>
#include "pin_mapping.h"
#include "gpio.h"

#if $(/TPM/_BasicInfoGuard) // /TPM/_BasicInfoGuard

/*
 * Default port information
 */
namespace USBDM {

$(/TPM/peripheral_h_definition:// $/TPM/peripheral_h_definition not found)
/**
 * Calculate a TPM channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  TPM channel number calculated from channel+offset
 */
constexpr TpmChannelNum inline operator+(TpmChannelNum pitChannelNum, unsigned offset) {
   return TpmChannelNum(unsigned(pitChannelNum) + offset);
}

/**
 * Calculate a TPM channel number using an offset from an existing number
 *
 * @param pitChannelNum Base channel to use
 * @param offset  Offset from base channel
 *
 * @return  TPM channel number calculated from channel+offset
 */
constexpr TpmChannelNum inline operator+(TpmChannelNum pitChannelNum, int offset) {
   return TpmChannelNum(unsigned(pitChannelNum) + unsigned(offset));
}

/**
 * @addtogroup TPM_Group TPM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 * Provides shared methods.
 */
class TpmBase {

private:
   TpmBase(const TpmBase&) = delete;
   TpmBase(TpmBase&&) = delete;

public:
#if $(/PCR/_present:false) // /PCR/_present
   CreatePeripheralPinChecker("TPM");
#endif

protected:
   // Constructor
   constexpr TpmBase(uint32_t baseAddress) : tpm(baseAddress) {};
   ~TpmBase() = default;

   /** Allow access owning TPM */
   const HardwarePtr<TPM_Type> tpm;

   /**
    * Limit index to permitted pin index range
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @tparam Inf    Associated info table
    * @param index   Index to limit
    *
    * @return Index limited to permitted range
    */
   template <class Inf>
   static inline constexpr int limitIndex(int index) {
      if (index<0) {
         return 0;
      }
      if (index>(Inf::numSignals-1)) {
         return Inf::numSignals-1;
      }
      return index;
   }

   /**
    * Callback to catch unhandled interrupt
    */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   /**
    * Get Timer input frequency.
    *
    * @param tpmClockSource
    *
    * @return Clock frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual(TpmClockSource tpmClockSource) const = 0;

public:
   /**
    * Structure for TPM channel.
    */
   struct TpmChannelRegs {
      __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
      __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
   };

/*
 *   // Member functions (mirrored)
 */
$(/TPM/non_static_functions:  // /TPM/non_static_functions not found)
};

class TpmChannel : public TpmBase {

private:
   TpmChannel(const TpmChannel&) = delete;
   TpmChannel(TpmChannel&&) = delete;

protected:
   // Empty constructor
   constexpr TpmChannel(uint32_t baseAddress, TpmChannelNum channelNum) :
   TpmBase(baseAddress),
   channelRegs((uint32_t)(tpm->CONTROLS+channelNum)),
   CHANNEL(channelNum),
   CHANNEL_MASK(1<<channelNum) {
   }
   ~TpmChannel() = default;

public:
   /** Allow access to TPM channel registers */
   const HardwarePtr<TpmBase::TpmChannelRegs> channelRegs;

   /** Timer channel number */
   const TpmChannelNum CHANNEL;

   /** Mask for Timer channel */
   const uint32_t CHANNEL_MASK;

$(/TPM_CHANNEL/non_static_functions:  // /TPM_CHANNEL/non_static_functions not found)
};

/**
 * Base class representing a TPM.
 *
 *
 * @tparam Info  Class describing TPM hardware instance
 */
template<class Info>
class TpmBase_T : public TpmBase, public Info {

private:
   /**
    * This class is not intended to be instantiated
    */
   TpmBase_T(const TpmBase_T&) = delete;
   TpmBase_T(TpmBase_T&&) = delete;

public:
   // Make visible
   using Info::configure;

   // Empty constructor
   constexpr TpmBase_T() : TpmBase(Info::baseAddress) {}
   virtual ~TpmBase_T() = default;

   /** Maximum counter value in ticks */
   static constexpr Ticks MaximumPeriodInTicks = Ticks(TPM_MOD_MOD_MASK);

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TPM_Type> tpm = Info::baseAddress;

   /** @return Base address of TPM hardware as uint32_t */
   static constexpr uint32_t tpmBase() { return Info::baseAddress; }
   /** @return Base address of TPM.SC register as uint32_t */
   static constexpr uint32_t tpmSC() { return tpmBase() + offsetof(TPM_Type, SC); }
   /** @return Base address of TPM.CNT register as uint32_t */
   static constexpr uint32_t tpmCNT() { return tpmBase() + offsetof(TPM_Type, CNT); }
   /** @return Base address of TPM.MOD register as uint32_t */
   static constexpr uint32_t tpmMOD() { return tpmBase() + offsetof(TPM_Type, MOD); }
   /** @return Base address of TPM.CONTROL[n] struct as uint32_t */
   static constexpr uint32_t tpmCONTROL(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS) + index*sizeof(TPM_Type::CONTROLS[0]); }
   /** @return Base address of TPM.CONTROL[n].CnSC struct as uint32_t */
   static constexpr uint32_t tpmCnSC(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS) + index*sizeof(TPM_Type::CONTROLS[0])+0; }
   /** @return Base address of TPM.CONTROL[n].CnV struct as uint32_t */
   static constexpr uint32_t tpmCnV(int index) { return tpmBase() + offsetof(TPM_Type, CONTROLS) + index*sizeof(TPM_Type::CONTROLS[0])+sizeof(uint32_t); }

private:
   /** Number of channels mapped to a channel event vector */
   static constexpr unsigned ChannelVectorRatio = Info::NumChannels/Info::NumChannelVectors;

protected:
   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   virtual float getInputClockFrequencyVirtual(TpmClockSource tpmClockSource) const override {
      return Info::getInputClockFrequency(tpmClockSource);
   }

public:

$(/TPM/classInfo: // No class Info found)
$(/TPM/InitMethod:// /TPM/InitMethod not found)
$(/TPM/ChannelInitMethod: // /TPM/ChannelInitMethod not found)
$(/TPM/FaultInitMethod: // /TPM/FaultInitMethod not found)

/*
 *   // Static functions (mirrored)
 */
$(/TPM/static_functions:  // /TPM/static_functions not found)

public:
   /**
    * Template class representing a timer channel
    *
    * Example
    * @code
    * // Instantiate the timer and channel being used (for TPM0 & channel 6)
    * using Tmr      = USBDM::Tpm0;
    * using Tmr0_ch6 = Tmr::Channel<6>;
    *
    * // Enable and initialise timer with initial alignment
    * Tmr::configure(TpmMode_LeftAlign);
    *
    * // Change timer period (in ticks) (affects ALL channels of timer)
    * Tmr::setPeriod(500);
    *
    * // Configure channel as PWM
    * Tmr0_ch6::configure(TpmChannelMode_PwmHighTruePulses);
    *
    * // Change duty cycle (in percent)
    * Tmr0_ch6.setDutyCycle(45);
    * @endcode
    *
    * @tparam channel TPM timer channel
    */
   template <int channel>
   class Channel :
#if $(/PCR/_present:false) // /PCR/_present
   public PcrTable_T<Info, limitIndex<Info>(channel)>,
#endif
   public TpmChannel, public Info {

   private:
#if $(/PCR/_present:false) // /PCR/_present
      TpmBase::CheckPinExistsAndIsMapped<Info, channel> check;
#endif

      /**
       * This class is not intended to be instantiated
       */
      Channel(const Channel&) = delete;
      Channel(Channel&&) = delete;

   public:
//      typedef typename Info::ChannelInit ChannelInit;

      constexpr Channel() : TpmChannel(Info::baseAddress, (TpmChannelNum)channel) {}
      virtual ~Channel() = default;

   protected:
      /**
       * Get frequency of timer tick
       *
       * @return Timer frequency in Hz
       */
      virtual float getInputClockFrequencyVirtual(TpmClockSource tpmClockSource) const override {
         return Info::getInputClockFrequency(tpmClockSource);
      }

   public:
#if $(/PCR/_present:false) // /PCR/_present
      // GPIO associated with this channel
      template<Polarity polarity>
      using Gpio = GpioTable_T<Info, limitIndex<Info>(channel), polarity>; // Inactive is high

      /** Allow access to PCR of associated pin */
      using Pcr = PcrTable_T<Info, limitIndex<Info>(channel)>;
#endif

      /** Allow access owning TPM */
      using OwningTpm = TpmBase_T<Info>;

      /** Allow access to TPM hardware */
      static constexpr HardwarePtr<TPM_Type> tpm = Info::baseAddress;

      /** @return Base address of TPM.CONTROL struct as uint32_t */
      static constexpr uint32_t tpmCONTROL() { return tpmBase() + offsetof(TPM_Type, CONTROLS[channel]); }

      /** @return Address of TPM.CONTROL.CnSC as uint32_t */
      static constexpr uint32_t tpmCnSC() { return tpmCONTROL()+0; }

      /** @return Address of TPM.CONTROL.CnV as uint32_t */
      static constexpr uint32_t tpmCnV() { return tpmCONTROL()+sizeof(uint32_t); }

      /**
       * Structure for TPM channel.
       */
      struct TpmChannelRegs {
         __IO uint32_t  CnSC; /**< 000C: Channel  Status and Control */
         __IO uint32_t  CnV;  /**< 0010: Channel  Value              */
      };

      /**
       * Allows access to TPM channel registers.
       *
       * @return Reference to the TPM channel registers
       */
      static __attribute__((always_inline)) volatile TpmChannelRegs &channelRegs() {
         return *reinterpret_cast<TpmChannelRegs *>(&OwningTpm::tpm->CONTROLS[CHANNEL]);
      }

      /** Timer channel number */
      static constexpr TpmChannelNum CHANNEL      = (TpmChannelNum)channel;

      /** Mask for Timer channel */
      static constexpr uint32_t CHANNEL_MASK = 1<<channel;

      /**
       * Configure channel and sets mode.
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       */
      static void defaultConfigure() {
         Info::configure(OwningTpm::DefaultChannelInitValues[channel]);
      }

      /**
       * Configure channel from Init data
       *
       * @note This method has the side-effect of clearing the register update synchronisation i.e.
       *       pending CnV register updates are discarded.
       *
       * @param channelInit (channel number is ignored)
       */
      static void configure(const typename Info::ChannelInit channelInit) {
         Info::configure(TpmChannelNum(channel), channelInit);
      }
      
$(/TPM_CHANNEL/static_functions:  // /TPM_CHANNEL/static_functions not found)
#if false // /TPM/_CommonInfoIrqGuard
   /**
    * Set channel event callback function
    *
    * @param[in] callback Callback function to execute on channel event interrupt.
    *                     Use nullptr to remove callback.
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note Channel callbacks may be shared by multiple channels of the timer.\n
    *       It is necessary to identify the originating channel in the callback
    */
   static ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      if constexpr (Info::IndividualCallbacks) {
         return OwningTpm::setChannelCallback(channel, callback);
      }
      else {
         return OwningTpm::setChannelCallback(callback);
      }
   }
#endif // /TPM/_CommonInfoIrqGuard
#if $(/PCR/_present:false) // /PCR/_present
   /*******************************
    *  PIN Functions
    *******************************/
   /**
    * Set callback for Pin IRQ.
    *
    * @param[in] callback The function to call on Pin interrupt.
    *                     nullptr to indicate none
    *
    * @note There is a single callback function for all pins on the related port.
    */
   static __attribute__((always_inline)) void setPinCallback(PinCallbackFunction callback) {
      TpmBase::CheckPinExistsAndIsMapped<Info, channel>::check();
      static_assert(Pcr::HANDLER_INSTALLED, "Gpio associated with TPM channel not configured for PIN interrupts - Modify Configure.usbdm");
      Pcr::setPinCallback(callback);
   }

#if defined(PORT_PCR_ODE_MASK) and defined (PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      TpmBase::CheckPinExistsAndIsMapped<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC = tpm->SC | (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
   }
#elif defined(PORT_PCR_ODE_ASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinDriveMode      pinDriveMode      = Pcr::defaultPcrValue) {

      TpmBase::CheckPinExistsAndIsMappedIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC = tpm->SC | (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinDriveMode);
   }
#elif defined(PORT_PCR_SRE_MASK)
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue,
         PinSlewRate       pinSlewRate       = Pcr::defaultPcrValue) {

      TpmBase::CheckPinExistsAndIsMapped<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC = tpm->SC | (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif
      Pcr::setPCR(pinDriveStrength|pinSlewRate);
   }
#else
   /**
    * @brief
    * Set subset of Pin Control Register Attributes associated with output direction \n
    * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
    * Assumes clock to the port has already been enabled
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = Pcr::defaultPcrValue) {

      TpmBase::CheckPinExistsAndIsMappedIsMappedToPinOnly<Info, channel>::check();

#ifdef TPM_SC_PWMEN0_SHIFT
      // Enable output pin in TPM
      tpm->SC = tpm->SC | (1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif

      Pcr::setPCR(pinDriveStrength);
   }
#endif

      /**
       * @brief
       * Set subset of Pin Control Register Attributes associated with input direction \n
       * Mux value is set appropriately for the pin function being used. Other attributes are cleared.\n
       * The clock to the port will be enabled before changing the PCR.
       *
       * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
       * @param[in] pinAction        One of PinAction_None, etc
       * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive
       *
       *  @note see also configureDigitalFilter(), enableDigitalFilter(), disableDigitalFilter()
       */
      static void setInput(
            PinPull           pinPull           = Pcr::defaultPcrValue,
            PinAction         pinAction         = Pcr::defaultPcrValue,
            PinFilter         pinFilter         = Pcr::defaultPcrValue) {

         TpmBase::CheckPinExistsAndIsMapped<Info, channel>::check();
//         TpmBase::CheckPinExistsAndIsMappedExistsAndMapped<Info, channel>::check(); // More noisy errors

#ifdef TPM_SC_PWMEN0_SHIFT
         // Disable output pin in TPM
         tpm->SC = tpm->SC & ~(1<<(channel+TPM_SC_PWMEN0_SHIFT));
#endif

         Pcr::setInput(pinPull,pinAction,pinFilter);
      }
#endif

   };

};

#ifdef TPM_QDCTRL_QUADEN_MASK

/**
 * Template class representing a TPM configured as a Quadrature decoder
 *
 * @tparam info      Information class for TPM
 *
 * @code
 *  using TpmQuadDecoder = TpmQuadDecoder_T<Tpm0Info>;
 *
 *  // Enable decoder
 *  TpmQuadDecoder::configure();
 *
 *  // Set pin filters
 *  TpmQuadDecoder::enableFilter(15);
 *
 *  // Reset position to zero
 *  // Movement will be +/- relative to this initial position
 *  TpmQuadDecoder::resetPosition();
 *
 *  for(;;) {
 *     console.write("Position =").writeln(QuadDecoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class TpmQuadDecoder_T : public Info {

private:
   TpmQuadDecoder_T(const TpmQuadDecoder_T&) = delete;
   TpmQuadDecoder_T(TpmQuadDecoder_T&&) = delete;

   TpmBase::CheckPinExistsAndIsMapped<Info, 0> checkQ0;
   TpmBase::CheckPinExistsAndIsMapped<Info, 1> checkQ1;

public:
   // Default constructor
   TpmQuadDecoder_T() = default;

   // Make visible
   using Info::configure;

   /** Hardware instance pointer */
   static constexpr HardwarePtr<TPM_Type> tpm = Info::baseAddress;

   /** Allow more convenient access associated Tpm */
   using OwningTpm = TpmBase_T<Info>;

   /** Allow access to PCR of associated phase-A pin */
   using Pcr0 = PcrTable_T<Info, 0>;

   /** Allow access to PCR of associated phase-B pin */
   using Pcr1 = PcrTable_T<Info, 1>;

   /**
    * Set Pin Control Register (PCR) values for PHA and PHB inputs.
    * This will map the pin to the Quadrature function (mux value) \n
    * The clock to the port will be enabled before changing the PCR
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = Pcr0::defaultPcrValue,
         PinAction         pinAction         = Pcr0::defaultPcrValue,
         PinFilter         pinFilter         = Pcr0::defaultPcrValue) {

      Pcr0::setPCR(pinPull|pinAction|pinFilter);
      Pcr1::setPCR(pinPull|pinAction|pinFilter);
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the TPM
    *
    * @param[in] theCallback Callback function to execute when timer overflows. \n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setTimerOverflowCallback(typename Info::CallbackFunction theCallback) {
      OwningTpm::setTimerOverflowCallback(theCallback);
   }

   /**
    * Enable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void enableTimerOverflowInterrupts() {
      OwningTpm::enableTimerOverflowInterrupts();
   }

   /**
    * Disable Timer Overflow interrupts
    */
   static __attribute__((always_inline)) void disableTimerOverflowInterrupts() {
      OwningTpm::disableTimerOverflowInterrupts();
   }

$(/TPM/QuadInitMethod:// /TPM/InitMethod not found)

   /**
    * Basic configuration of Quadrature decoder.
    * Includes configuring all pins if
    * mapPinsOnEnable setting is true
    *
    * @param tpmPrescale       Prescale value applied to the output of the quadrature decode before the counter.
    * @param tpmQuadratureMode Selects the encoding mode used to decode the input changes.
    */
   static void configure(
         TpmPrescale       tpmPrescale       = TpmPrescale_DivBy1,
         TpmQuadratureMode tpmQuadratureMode = TpmQuadratureMode_Phase_AB_Mode
         ) {
      // Assertions placed here so only checked if TpmQuadDecoder actually used
      static_assert(Info::info[0].pinIndex >= PinIndex::MIN_PIN_INDEX, "TpmQuadDecoder PHA is not mapped to a pin - Modify Configure.usbdm");
      static_assert(Info::info[1].pinIndex >= PinIndex::MIN_PIN_INDEX, "TpmQuadDecoder PHB is not mapped to a pin - Modify Configure.usbdm");

      Info::enable();

      // Disable so immediate effect
      tpm->SC = 0;
      (void)tpm->SC;
      tpm->SC = TpmClockSource_Disabled|tpmPrescale;

      tpm->QDCTRL =
            TPM_QDCTRL_QUADEN_MASK|      // Enable Quadrature decoder
            tpmQuadratureMode;           // Quadrature mode
      tpm->CONF   = TPM_CONF_DBGMODE(3);
   }

   /**
    * Reset position to zero
    */
   static void resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      tpm->CNT = 0;
   }

   /**
    * Get Quadrature decoder position
    *
    * @return Signed number representing position relative to reference location
    *
    * @note This can be viewed as a signed number +/- relative to the initial position.
    * @note This can be viewed as an unsigned number counting up from 0
    *       with overflow at 0xFFFF and underflow at 0.
    */
   static int16_t getPosition() {
      return (int16_t)(tpm->CNT);
   }

   /**
    * Get Quadrature decoder overflow direction.
    * This would be used in the overflow callback.
    *
    * @return Timer overflow direction. true => increasing, false => decreasing.
    *
    * @note Overflow occurs at MOD -> CNTIN, Underflow occurs at CNTIN -> MOD.
    */
   static bool getOverflowDirection() {
      return (bool)(tpm->QDCTRL & TPM_QDCTRL_TOFDIR_MASK);
   }
};
#endif // defined(TPM_QDCTRL_QUADEN_MASK)

$(/TPM/declarations: // No TPM declarations found)
/**
 * End TPM_Group
 * @}
 */

} // End namespace USBDM

#endif // /TPM/_BasicInfoGuard

#endif /* HEADER_TPM_H */


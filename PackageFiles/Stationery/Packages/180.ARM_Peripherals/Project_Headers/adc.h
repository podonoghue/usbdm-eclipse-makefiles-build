/**
 * @file     adc.h (180.ARM_Peripherals/Project_Headers/adc.h)
 * @brief    ADC routines
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_ADC_H
#define HEADER_ADC_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cstddef>
#include "pin_mapping.h"
#include "gpio.h"

#if $(/ADC/enablePeripheralSupport) // /ADC/enablePeripheralSupport

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */

/**
 * Provides:
 * - Common unhandledCallback for all ADCs.
 * - Shared constants
 *
 * This class is not intended to be instantiated directly.
 */
class Adc {

public:

   /// Pointer to hardware instance
   const HardwarePtr<ADC_Type> adc;

private:
   Adc(const Adc&) = delete;
   Adc(Adc&&) = delete;

protected:

   // Channel number used for PGA
   static constexpr uint32_t PGA_CHANNEL = 2;

   /**
    * Limit channel to permitted range.
    * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
    *
    * @param channel   Channel number to limit
    *
    * @return Index limited to permitted range
    */
   template<class Info>
   static inline constexpr int limitIndex(int channel) {
      if (channel<0) {
         return 0;
      }
      if (channel>(Info::numSignals-1)) {
         return Info::numSignals-1;
      }
      return channel;
   }

   /** Class to static check channel exists and is mapped to an input pin */
   CreatePeripheralPinChecker("ADC");

   /**
    * Constructor
    *
    * @param adcBaseAddress Base address of ADC hardware
    */
   constexpr  Adc(uint32_t adcBaseAddress) : adc(adcBaseAddress) {
   }

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value. This includes channel, differential mode and interrupts enable.
    */
   void startConversion(const int sc1Value) const {
      // Trigger conversion
      adc->SC1[0] = sc1Value;
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value including the ADC channel to use and differential mode
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue(uint32_t sc1Value) const {

      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];

      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }

      return getConversionResult();
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value including the ADC channel to use and differential mode
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used affects all future conversion on all channels on the ADC
    */
   int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) const {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   };

public:

$(/ADC/methods:// /ADC/methods not found)
   /**
    * Set resolution
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @note This affects all channels on the ADC
    */
   void setResolution(AdcResolution adcResolution) const {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
   }

   /**
    * Set averaging mode
    *
    * @param[in] adcAveraging Mode for averaging e.g. AdcAveraging_4 etc
    *
    * @note This affects all channels on the ADC
    */
   void setAveraging(AdcAveraging adcAveraging) const {
      adc->SC3 = (adc->SC3&~(ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK))|adcAveraging;
   }

   /**
    * Set ADC  (and PGA if present) voltage reference
    *
    * @param adcRefSel Reference to select
    *
    * @note The PGA requires use of AdcRefSel_VrefOut (~1.2V)
    */
   void setReference(AdcRefSel adcRefSel=AdcRefSel_Default) {
      adc->SC2 = (adc->SC2&~ADC_SC2_REFSEL_MASK)|adcRefSel;
   }

   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] low          Lower threshold
    * @param[in] high         Higher threshold (if needed)
    */
   void enableComparison(AdcCompare adcCompare, int low=INT_MIN, int high=INT_MAX) const {

      usbdm_assert (low<=high, "ADC Low level > high level");

      // Juggle CV1, CV2 values to satisfy comparison rules
      switch (adcCompare) {
         case AdcCompare_Disabled:
            break;
         case AdcCompare_LessThan:
         case AdcCompare_GreaterThanOrEqual:
            adc->CV1 = low;
            break;
         case AdcCompare_OutsideRangeExclusive:
         case AdcCompare_InsideRangeInclusive:
            adc->CV1 = low;
            adc->CV2 = high;
            break;
         case AdcCompare_InsideRangeExclusive:
         case AdcCompare_OutsideRangeInclusive:
            adc->CV1 = high;
            adc->CV2 = low;
            break;
      }
      // Set comparison fields
      adc->SC2 = adc->SC2 | (adc->SC2&~(ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1)))|
            (adcCompare&(ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1)));
   }

   /**
    * Enable/disable continuous conversion mode.
    *
    * @param[in] adcContinuous  Controls continuous conversion mode.
    */
   void enableContinuousConversions(AdcContinuous adcContinuous = AdcContinuous_Enabled) const {
      if (adcContinuous) {
         adc->SC3 = adc->SC3 | ADC_SC3_ADCO_MASK;
      }
      else {
         adc->SC3 = adc->SC3 & ~ADC_SC3_ADCO_MASK;
      }
   }

   /**
    * Gets result of last software initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getConversionResult() const {

      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);

#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[0] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         return static_cast<int16_t>(value);
      }
#endif

      return value;
   };

   /**
    * Gets result of hardware initiated conversion
    *
    * @param pretrigger Pretrigger to use (identifies which SC1 register to access)
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getHardwareConversionResult(AdcPretrigger preTrigger) const {

      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[preTrigger]);

#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[preTrigger] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         return static_cast<int16_t>(value);
      }
#endif

      return value;
   };

   /**
    * Check if ADC is current doing a conversion
    *
    * @return true   => ADC is busy doing a conversion
    * @return false  => ADC is idle
    */
   bool isBusy() const {
      return adc->SC2&ADC_SC2_ADACT_MASK;
   }

#if defined(ADC_PGA_PGAEN_MASK)
#if defined(ADC_PGA_PGACHPb_MASK)
      /**
       * Configure Programmable Gain Amplifier.
       * Only affects the single channel associated with the PGA.
       *
       * @param adcPgaMode Mode to operate in (or disabled)
       * @param adcPgaGain Gain
       * @param adcPgaChop PGA chopping control
       *
       * @note Chopping should only be used in conjunction with even-numbered averaging
       *       since the chopping is applied between consecutive conversions.
       */
      void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_1, AdcPgaChop adcPgaChop=AdcPgaChop_Enabled) const {
         adc->PGA = adcPgaMode|adcPgaGain|adcPgaChop;
      }

      /**
       * Measure PGA offset
       * The PGA should be configured for intended use before doing this.
       *
       * @note  If chopping is enabled, then the returned value represents the residual offset after
       *        chopping and can be applied to correct later conversions done with chopping enabled.
       *        If chopping is disabled, then the return value is the entire offset and may be
       *        applied to correct conversions with chopping disabled.
       *
       * @note To apply offset correction subtract <b>[(pga_offset_measurement*(Gain+1))/(64+1)]</b> from
       *       the ADC result, where Gain is the PGA gain during actual ADC operation.
       *
       * @return Offset measurement. (pga_offset * (64+1))
       */
      int measurePgaOffset() const {
         adc->PGA = adc->PGA | ADC_PGA_PGAOFSM_MASK;
         int offset = readAnalogue(PGA_CHANNEL);
         adc->PGA = adc->PGA & ~ADC_PGA_PGAOFSM_MASK;
         return offset;
      }
#else
      /**
       * Configure Programmable Gain Amplifier.
       * Only affects the single channel associated with the PGA.
       *
       * @param adcPgaMode Mode to operate in (or disabled)
       * @param adcPgaGain Gain
       */
      void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_x1) const {
         adc->PGA = adcPgaMode|adcPgaGain;
      }
#endif
#endif

};

/**
 * Class representing a minimal ADC channel
 *
 * This class is not intended to be instantiated directly.
 */
class AdcChannel : public Adc {

private:
   AdcChannel() = delete;
   AdcChannel(const AdcChannel&) = delete;
   AdcChannel(AdcChannel&&) = delete;

protected:
   /// ADC channel (including ADC_SC1_DIFF_MASK mask)
   const uint32_t sc1Value;

   /**
    * Constructor
    *
    * @param adcAddress  ADC address
    * @param channel     ADC channel to use
    */
   constexpr AdcChannel(uint32_t adcAddress, uint8_t channel) : Adc(adcAddress), sc1Value(channel) {}

public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue() const {
      return Adc::readAnalogue(sc1Value);
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used here affects all future conversion on all channels on the ADC
    */
   int readAnalogue(AdcResolution adcResolution) const {
      return Adc::readAnalogue(sc1Value, adcResolution);
   };

   /**
    * Enables hardware trigger mode of operation and configures a channel.
    *
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
    * @param[in] adcInterrupt    Whether to generate an interrupt when each conversion completes
    */
   void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcInterrupt=AdcAction_None) const {
      Adc::enableHardwareConversion(adcInterrupt|sc1Value, adcPretrigger);
   }

#if defined(ADC_SC2_DMAEN)
   /**
    * Enables hardware trigger mode of operation and configures a channel.
    *
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
    * @param[in] adcInterrupt    Whether to generate an interrupt when each conversion completes
    * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
    */
   void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcInterrupt, AdcDma adcDma) const {
      Adc::enableHardwareConversion(adcInterrupt|sc1Value, adcPretrigger, adcDma);
   }
#endif

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] adcInterrupt   Determines if an interrupt is generated when conversions are complete
    */
   void startConversion(AdcAction adcInterrupt=AdcAction_None) const {
      Adc::startConversion(sc1Value|adcInterrupt);
   };

}; // class AdcChannel

/**
 * Template class representing an ADC.
 * This class is not intended to be instantiated.
 *
 * Example
 * @code
 *  // Access to ADC0
 *  using Adc0 = AdcBase_T<Adc0Info>;
 *
 *  // Initialise ADC
 *  Adc0::setMode(AdcResolution_16bit_se);
 *  @endcode
 *
 * @tparam info Table of information describing ADC
 */
template<class Info>
class AdcBase_T : public Adc, public Info {

private:
   AdcBase_T(const AdcBase_T&) = delete;
   AdcBase_T(AdcBase_T&&) = delete;


protected:
$(/ADC/protectedMethods: // No /ADC/protectedMethods found)

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<ADC_Type> adc = Info::baseAddress;

   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return Info::adc(); }

   /** @return Base address of SPI hardware as uint32_t */
   static constexpr uint32_t adcBase() { return Info::baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }

   using Info::configure;

$(/ADC/classInfo: // No class Info found)
public:
#if $(/ADC/irqHandlingMethod:false) // /ADC/irqHandlingMethod
   constexpr AdcBase_T() : Adc(Info::baseAddress) {};

   /** Allow convenient access to associate AdcInfo */
   using AdcInfo = Info;

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note Only usable with static objects.
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback(uint32_t result, int channel) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function to create handler
    * auto fn = Adc0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Adc0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t result, int channel), T &object>
   static constexpr typename Info::CallbackFunction wrapCallback() {
      typename Info::CallbackFunction fn = [](uint32_t result, int channel) {
         (object.*callback)(result, channel);
      };
      return fn;
   }

   /**
    * Wrapper to allow the use of a class member as a callback function
    * @note There is a considerable space and time overhead to using this method
    *
    * @tparam T         Type of the object containing the callback member function
    * @tparam callback  Member function pointer
    * @tparam object    Object containing the member function
    *
    * @return  Pointer to a function suitable for the use as a callback
    *
    * @code
    * class AClass {
    * public:
    *    // Member function used as callback
    *    // This function must match CallbackFunction
    *    void callback(uint32_t result, int channel) {
    *       ...;
    *    }
    * };
    * ...
    * // Instance of class containing callback member function
    * static AClass aClass;
    * ...
    * // Wrap member function to create handler
    * auto fn = Adc0::wrapCallback<AClass, &AClass::callback, aClass>();
    * // Use as callback
    * Adc0::setCallback(fn);
    * @endcode
    */
   template<class T, void(T::*callback)(uint32_t result, int channel)>
   static typename Info::CallbackFunction wrapCallback(T &object) {
      static T &obj = object;
      typename Info::CallbackFunction fn = [](uint32_t result, int channel) {
         (obj.*callback)(result, channel);
      };
      return fn;
   }
#endif


$(/ADC/publicMethods: // No /ADC/publicMethods found)
$(/ADC/InitMethod: // /ADC/InitMethod not found)
   /**
    * Check if ADC is current doing a conversion
    *
    * @return true   => ADC is busy doing a conversion
    * @return false  => ADC is idle
    */
   static bool isBusy() {
      return adc->SC2&ADC_SC2_ADACT_MASK;
   }

   /**
    * Set conversion mode
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @note This affects all channels on the ADC
    */
   static void setResolution(AdcResolution adcResolution) {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
   }

   /**
    * Set clock source
    *
    * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
    * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
    *
    * @note This affects all channels on the ADC.\n
    * The resulting ADC clock rate should be restricted to the following ranges:\n
    *  [2..12MHz] for 16-bit conversion modes  \n
    *  [1..18MHz] for other conversion modes
    */
   static void setClockSource(AdcClockSource adcClockSource, AdcClockDivider adcClockDivider=AdcClockDivider_Div1) {
      adc->CFG1 = (adc->CFG1&~(ADC_CFG1_ADIV_MASK|ADC_CFG1_ADICLK_MASK))|adcClockSource|adcClockDivider;
   }

   /**
    * Enable ADC internal asynchronous clock source
    *
    * @note It is not necessary to enable the internal clock to use it as an ADC clock source.\n
    *       If the internal clock is selected, it will be automatically enabled when an ADC conversion is initiated.\n
    *       However, enabling it beforehand will reduce the latency of the 1st conversion in a sequence.
    */
   static void enableAsynchronousClock() {
      adc->CFG2 = adc->CFG2 | ADC_CFG2_ADACKEN_MASK;
   }

   /**
    * Disable ADC internal asynchronous clock source
    */
   static void disableAsynchronousClock() {
      adc->CFG2 = adc->CFG2 & ~ADC_CFG2_ADACKEN_MASK;
   }

   /**
    * Set averaging mode
    *
    * @param[in] adcAveraging Mode for averaging e.g. AdcAveraging_4 etc
    *
    * @note This affects all channels on the ADC
    */
   static void setAveraging(AdcAveraging adcAveraging) {
      adc->SC3 = (adc->SC3&~(ADC_SC3_AVGE_MASK|ADC_SC3_AVGS_MASK))|adcAveraging;
   }

   /**
    * Set ADC  (and PGA if present) voltage reference
    *
    * @param adcRefSel Reference to select
    */
   static void setReference(AdcRefSel adcRefSel=AdcRefSel_Default) {
      adc->SC2 = (adc->SC2&~ADC_SC2_REFSEL_MASK)|adcRefSel;
   }

   /**
    * ADC calibrate.
    * Calibrates the ADC before first use.
    *
    * @note Set up the ADC clock and resolution before calibration
    *
    * @return E_NO_ERROR       Calibration successful
    * @return E_CALIBRATE_FAIL Failed calibration
    */
   static ErrorCode calibrate() {
      return Info::calibrate(adc);
   }

   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] low          Lower threshold
    * @param[in] high         Higher threshold (if needed)
    */
   static void enableComparison(AdcCompare adcCompare, int low=INT_MIN, int high=INT_MAX) {
#ifdef DEBUG_BUILD
      usbdm_assert (low<=high, "ADC Low level > high level");
#endif
      // Juggle CV1, CV2 values to satisfy comparison rules
      switch (adcCompare) {
         case AdcCompare_Disabled:
            break;
         case AdcCompare_LessThan:
         case AdcCompare_GreaterThanOrEqual:
            adc->CV1 = low;
            break;
         case AdcCompare_OutsideRangeExclusive:
         case AdcCompare_InsideRangeInclusive:
            adc->CV1 = low;
            adc->CV2 = high;
            break;
         case AdcCompare_InsideRangeExclusive:
         case AdcCompare_OutsideRangeInclusive:
            adc->CV1 = high;
            adc->CV2 = low;
            break;
      }
      // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
      static constexpr uint32_t mask = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1);

      // Set comparison fields
      adc->SC2 = adc->SC2 | (adc->SC2&~mask)|(adcCompare&mask);
   }

   /**
    * Enable/disable continuous conversion mode.
    *
    * @param[in] adcContinuous  Controls continuous conversion mode.
    */
   static void enableContinuousConversions(AdcContinuous adcContinuous) {
      if (adcContinuous) {
         adc->SC3 = adc->SC3 | ADC_SC3_ADCO_MASK;
      }
      else {
         adc->SC3 = adc->SC3 & ~ADC_SC3_ADCO_MASK;
      }
   }

#ifdef ADC_SC2_DMAEN_MASK
   /**
    * Enable/disable DMA.
    *
    * @param[in] adcDma  Controls DMA operation.
    */
   static void enableDma(AdcDma adcDma = AdcDma_Enabled) {
      // Set up DMA
      if (adcDma) {
         adc->SC2 = adc->SC2 | ADC_SC2_DMAEN_MASK;
      }
      else {
         adc->SC2 = adc->SC2 & ~ADC_SC2_DMAEN_MASK;
      }
   }
#endif

protected:
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
    */
   static void enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) {
      // Set hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1);
      // Configure channel for hardware trigger input
      adc->SC1[adcPretrigger] = sc1Value;
   }

#ifdef ADC_SC2_DMAEN
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
    *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
    * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
    */
   static void enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger, AdcDma adcDma) {
      // Set hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1)|adcDma;
      // Configure channel for hardware trigger input
      adc->SC1[adcPretrigger] = sc1Value;
   }
#endif

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode and interrupts enable.
    */
   static void startConversion(const int sc1Value) {
      // Trigger conversion
      adc->SC1[0] = sc1Value;
   };

public:
   /**
    * Gets result of last software initiated conversion
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
    *           For single-ended conversions this will be zero extended\n
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended channels.
    * @note This will also clear the conversion flag if set
    */
   static int getConversionResult() {

      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);

#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[0] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         return static_cast<int16_t>(value);
      }
#endif
      return value;
   };

   /**
    * Gets result of hardware initiated conversion
    *
    * @param pretrigger Pretrigger to use (identifies which SC1 register to access)
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended channels.
    * @note This will also clear the conversion flag if set
    */
   static int getHardwareConversionResult(AdcPretrigger pretrigger) {

      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[pretrigger]);

#if defined(ADC_SC1_DIFF_MASK)
      if (adc->SC1[pretrigger] & ADC_SC1_DIFF_MASK) {
         // Differential conversion - convert to signed
         return static_cast<int16_t>(value);
      }
#endif
      return value;
   };

protected:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value including the ADC channel to use and whether differential mode
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
    *           For single-ended conversions this will be zero extended\n
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   static int readAnalogue(const int sc1Value) {
      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];

      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }

      return getConversionResult();
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value including the ADC channel to use and whether differential mode
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
    *           For single-ended conversions this will be zero extended\n
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used here affects all further conversion on all channels on the ADC
    *
    */
   static int readAnalogue(const int sc1Value, AdcResolution adcResolution) {
      adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   }

public:
#if defined(ADC_PGA_PGAEN_MASK)
#if defined(ADC_PGA_PGACHPb_MASK)
      /**
       * Configure Programmable Gain Amplifier.
       * Only affects the single channel associated with the PGA.
       *
       * @param adcPgaMode Mode to operate in (or disabled)
       * @param adcPgaGain Gain
       * @param adcPgaChop PGA chopping control
       */
      static void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_1, AdcPgaChop adcPgaChop=AdcPgaChop_Enabled) {
         adc->PGA = adcPgaMode|adcPgaGain|adcPgaChop;
      }

      /**
       * Measure PGA offset
       * The PGA should be configured for intended use before doing this.
       *
       * @note  If chopping is enabled, then the returned value represents the residual offset after
       *        chopping and can be applied to correct later conversions done with chopping enabled.
       *        If chopping is disabled, then the return value is the entire offset and may be
       *        applied to correct conversions with chopping disabled.
       *
       * @note To apply offset correction subtract <b>[(pga_offset_measurement*(Gain+1))/(64+1)]</b> from
       *       the ADC result, where Gain is the PGA gain during actual ADC operation.
       *
       * @return Offset measurement. (pga_offset * (64+1))
       */
      static int measurePgaOffset() {
         adc->PGA = adc->PGA | ADC_PGA_PGAOFSM_MASK;
         int offset = readAnalogue(PGA_CHANNEL);
         adc->PGA = adc->PGA & ~ADC_PGA_PGAOFSM_MASK;
         return offset;
      }
#else
      /**
       * Configure Programmable Gain Amplifier.
       * Only affects the single channel associated with the PGA.
       *
       * @param adcPgaMode Mode to operate in (or disabled)
       * @param adcPgaGain Gain
       */
      static void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_x1) {
         adc->PGA = adcPgaMode|adcPgaGain;
      }
#endif
#endif

   /**
    * Template class representing an ADC channel.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::Channel<6>;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class ChannelCommon : public AdcChannel {
   private:
      /**
       * This class is not intended to be instantiated
       */
      ChannelCommon(const ChannelCommon&) = delete;
      ChannelCommon(ChannelCommon&&) = delete;

   public:
      constexpr ChannelCommon() : AdcChannel(AdcInfo::baseAddress, channel) {}

      /** The ADC that owns this channel */
      using OwningAdc = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=channel;

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param[in] adcInterrupt   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcAction adcInterrupt=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcInterrupt == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(channel|adcInterrupt);
      };

      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       */
      static int readAnalogue() {
         return AdcBase_T::readAnalogue(channel);
      };
      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       * @note The resolution used here affects all further conversion on all channels on the ADC
       */
      static int readAnalogue(AdcResolution adcResolution) {
         return AdcBase_T::readAnalogue(channel, adcResolution);
      };

      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcInterrupt    Whether to generate an interrupt when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcInterrupt=AdcAction_None) {
         AdcBase_T::enableHardwareConversion(channel|adcInterrupt, adcPretrigger);
      }

#ifdef ADC_SC2_DMAEN
      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcInterrupt    Whether to generate an interrupt when each conversion completes
       * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcInterrupt, AdcDma adcDma) {
         AdcBase_T::enableHardwareConversion(channel|adcInterrupt, adcPretrigger, adcDma);
      }
#endif
   };

   template<AdcChannelNum channel>
   class Channel : public ChannelCommon<channel>  {
   private:
      /**
       * This class is not intended to be instantiated
       */
      Channel(const Channel&) = delete;
      Channel(Channel&&) = delete;

      CheckPinExistsAndIsMapped<Info, channel&ADC_SC1_ADCH_MASK> check;

   public:
      /** The PCR associated with this channel (Not all channels have an associated PCR!) */
      using Pcr = PcrTable_T<Info, limitIndex<Info>(channel)>;

      /** GPIO pin associated with this channel (Not all channels have an associated GPIO!) */
      template<Polarity polarity=ActiveHigh>
      class GpioPin : public GpioTable_T<Info, channel, polarity> {
         static_assert((Info::info[channel].portAddress != 0),
               "ADC channel does not have corresponding GPIO pin");
      };

      /**
       * Configure the pin associated with this ADC channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to ADC
         Pcr::setPCR();
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (Info::info[channel].portAddress != 0) {
            Pcr::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaChannel : public ChannelCommon<2> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaChannel(const PgaChannel&) = delete;
      PgaChannel(PgaChannel&&) = delete;

   public:
      constexpr PgaChannel(){}
   };
#endif

   /**
    * Template class representing an ADC channel using B MUX setting
    *
    * Example
    * @code
    * // Instantiate the ADC and the differential channel (for ADC_DM0, ADC_DP0)
    * using Adc0 = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::DiffChannel<0>;
    *
    * // Set ADC resolution
    * Adc0.setMode(AdcResolution_11bit_diff );
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch0.readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class ChannelB : public ChannelCommon<AdcChannelNum(channel)> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      ChannelB(const ChannelB&) = delete;
      ChannelB(ChannelB&&) = delete;

      CheckPinExistsAndIsMapped<typename Info::InfoBChannels, channel&ADC_SC1_ADCH_MASK> checkPos;

   public:
      constexpr ChannelB() : ChannelCommon<AdcChannelNum(channel)>() {}

      /** PCR associated with plus channel */
      using PcrB = PcrTable_T<typename Info::InfoBChannels, limitIndex<typename Info::InfoBChannels>(channel)>;

      /** The ADC that owns this channel */
      using OwningAdc = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=channel;

      /**
       * Configure the pins associated with this ADC channel.
       * The pins are in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pins to ADC
         PcrB::setPCR(Info::InfoBChannels::info[channel].pcrValue);
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (AdcInfo::InfoBChannels::info[channel].portAddress != 0) {
            PcrB::disablePin();
         }
      }
   };

#ifdef ADC_SC1_DIFF_MASK
   /**
    * Template class representing an ADC differential channel
    *
    * Example
    * @code
    * // Instantiate the ADC and the differential channel (for ADC_DM0, ADC_DP0)
    * using Adc0 = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::DiffChannel<0>;
    *
    * // Set ADC resolution
    * Adc0.setMode(AdcResolution_11bit_diff );
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch0.readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class DiffChannel : public ChannelCommon<AdcChannelNum(channel|ADC_SC1_DIFF_MASK)> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      DiffChannel(const DiffChannel&) = delete;
      DiffChannel(DiffChannel&&) = delete;

      CheckPinExistsAndIsMapped<typename Info::InfoDP, channel&ADC_SC1_ADCH_MASK> checkPos;
      CheckPinExistsAndIsMapped<typename Info::InfoDM, channel&ADC_SC1_ADCH_MASK> checkNeg;

   public:
      constexpr DiffChannel() : ChannelCommon<AdcChannelNum(channel|ADC_SC1_DIFF_MASK)>() {}

      /** PCR associated with plus channel */
      using PcrP = PcrTable_T<typename Info::InfoDP, limitIndex<typename Info::InfoDP>(channel)>;

      /** PCR associated with minus channel */
      using PcrM = PcrTable_T<typename Info::InfoDM, limitIndex<typename Info::InfoDM>(channel)>;

      /** The ADC that owns this channel */
      using OwningAdc = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=channel;

      /**
       * Configure the pins associated with this ADC channel.
       * The pins are in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pins to ADC
         PcrP::setPCR(Info::InfoDP::info[channel].pcrValue);
         PcrM::setPCR(Info::InfoDM::info[channel].pcrValue);
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (AdcInfo::InfoDP::info[channel].portAddress != 0) {
            PcrP::disablePin();
            PcrM::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaDiffChannel : public DiffChannel<2> {

   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaDiffChannel(const PgaDiffChannel&) = delete;
      PgaDiffChannel(PgaDiffChannel&&) = delete;

   public:
      constexpr PgaDiffChannel(){}
   };
#endif

#endif

};

$(/ADC/declarations:// #error "No declarations found")
/**
 * End ADC_Group
 * @}
 */

} // End namespace USBDM

#endif // /ADC/enablePeripheralSupport

#endif /* HEADER_ADC_H */


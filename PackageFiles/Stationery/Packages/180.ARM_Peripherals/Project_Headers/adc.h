/**
 * @file     adc.h (180.ARM_Peripherals/Project_Headers/adc.h)
 * @brief    ADC routines
 */

#ifndef HEADER_ADC_H
#define HEADER_ADC_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cstddef>
#include "pin_mapping.h"
#include "gpio.h"

#if $(/ADC/_BasicInfoGuard) // /ADC/_BasicInfoGuard

namespace USBDM {
// Forward declaration
enum AdcChannelNum : uint8_t;
}

$(/ADC/prototypes:// $/ADC/prototypes not found)
namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
$(/ADC/peripheral_h_definition:// $/ADC/peripheral_h_definition not found)

/**
 * Class representing a minimal ADC channel
 *
 * This class is not intended to be instantiated directly.
 */
class AdcChannel : public AdcBasicInfo {

private:
   AdcChannel() = delete;
   AdcChannel(const AdcChannel&) = delete;
   AdcChannel(AdcChannel&&) = delete;

protected:
   /// ADC channel (including ADC_SC1_DIFF_MASK mask)
   const uint32_t sc1Value;

   /**
    * Constructor
    *
    * @param adcAddress  ADC address
    * @param channel     ADC channel to use
    */
   constexpr AdcChannel(uint32_t adcAddress, uint8_t channel) : AdcBasicInfo((volatile ADC_Type *)adcAddress), sc1Value(channel) {}

public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue() const {
      return AdcBasicInfo::readAnalogue(sc1Value);
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used here affects all future conversion on all channels on the ADC
    */
   int readAnalogue(AdcResolution adcResolution) const {
      return AdcBasicInfo::readAnalogue(sc1Value, adcResolution);
   };

   /**
    * Enables hardware trigger mode of operation and configures a channel.
    *
    * @param[in] adcPretrigger Hardware pre-trigger to use for this channel.\n
    *                          This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
    * @param[in] adcAction     Whether to generate an interrupt when each conversion completes
    */
   void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction=AdcAction_None) const {
      AdcBasicInfo::enableHardwareConversion(adcAction|sc1Value, adcPretrigger);
   }

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
    */
   void startConversion(AdcAction adcAction=AdcAction_None) const {
      AdcBasicInfo::startConversion(sc1Value|adcAction);
   };

}; // class AdcChannel

/**
 * Template class representing an ADC.
 * This class is not intended to be instantiated.
 *
 * Example
 * @code
 *  // Access to ADC0
 *  using Adc0 = AdcBase_T<Adc0Info>;
 *
 *  // Initialise ADC
 *  Adc0::setMode(AdcResolution_16bit_se);
 *  @endcode
 *
 * @tparam info Table of information describing ADC
 */
template<class Info>
class AdcBase_T : public Info {

private:
   using Info::mapChannelNumToPhysicalChannelNum;

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<ADC_Type> adc = Info::baseAddress;

   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return Info::adc(); }

   /** @return Base address of SPI hardware as uint32_t */
   static constexpr uint32_t adcBase() { return Info::baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }

   using Info::configure;

public:

   AdcBase_T() = default;

   /**
    * Template class representing an ADC channel.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::Channel<6>;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class ChannelCommon : public AdcChannel {
   private:
      /**
       * This class is not intended to be instantiated
       */
      ChannelCommon(const ChannelCommon&) = delete;
      ChannelCommon(ChannelCommon&&) = delete;

   public:
      constexpr ChannelCommon() : AdcChannel(AdcInfo::baseAddress, channel) {}

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr AdcChannelNum CHANNEL=channel;

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction);
      };

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param adcResolution      New Resolution to use (persistent)
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcResolution adcResolution, AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcResolution);
      };

      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       */
      static int readAnalogue() {
         return AdcBase_T::readAnalogue(mapChannelNumToPhysicalChannelNum(channel));
      };
      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       * @note The resolution used here affects all further conversion on all channels on the ADC
       */
      static int readAnalogue(AdcResolution adcResolution) {
         return AdcBase_T::readAnalogue(mapChannelNumToPhysicalChannelNum(channel), adcResolution);
      };

      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction=AdcAction_None) {
         AdcBase_T::enableHardwareConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcPretrigger);
      }

#ifdef ADC_SC2_DMAEN
      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
       */
      static void enableHardwareConversion(AdcPretrigger adcPretrigger, AdcAction adcAction, AdcDma adcDma) {
         AdcBase_T::enableHardwareConversion(mapChannelNumToPhysicalChannelNum(channel)|adcAction, adcPretrigger, adcDma);
      }
#endif
   };

   template<AdcChannelNum channel>
   class Channel : public ChannelCommon<channel>  {
   private:
      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, channel> check{};
#if $(/ADC0/adc_sc1_diff_present:false) // adc_sc1_diff_present
      static_assert(((channel<AdcChannelNum_DiffFirst)||(channel>AdcChannelNum_DiffLast)), "Illegal channel number");
#endif
   public:
      /** The PCR associated with this channel (Not all channels have an associated PCR!) */
      using Pcr = PcrTable_T<Info, AdcBasicInfo::limitIndex<Info>(channel)>;

      /** GPIO pin associated with this channel (Not all channels have an associated GPIO!) */
      template<Polarity polarity=ActiveHigh>
      class GpioPin : public GpioTable_T<Info, channel, polarity> {
         static_assert((Info::info[channel].pinIndex >= PinIndex::MIN_PIN_INDEX),
               "ADC channel does not have corresponding GPIO pin");
      };

      /**
       * Configure the pin associated with this ADC channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to ADC
         Pcr::setPCR();
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (Info::info[channel].pinIndex >= PinIndex::MIN_PIN_INDEX) {
            Pcr::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaChannel : public ChannelCommon<AdcChannelNum_Diff2> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaChannel(const PgaChannel&) = delete;
      PgaChannel(PgaChannel&&) = delete;

   public:
      constexpr PgaChannel(){}
   };
#endif

#ifdef ADC_SC1_DIFF_MASK
   /**
    * Template class representing an ADC differential channel
    *
    * Example
    * @code
    * // Instantiate the ADC and the differential channel (for ADC_DM0, ADC_DP0)
    * using Adc0 = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::DiffChannel<AdcChannelNum_Diff1>;
    *
    * // Set ADC resolution
    * Adc0.setMode(AdcResolution_11bit_diff );
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch0.readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class DiffChannel : public ChannelCommon<channel> {

      static_assert((channel>=AdcChannelNum_DiffFirst)&&(channel<=AdcChannelNum_DiffLast), "Illegal differential channel number");

   private:
      /**
       * This class is not intended to be instantiated
       */
      DiffChannel(const DiffChannel&) = delete;
      DiffChannel(DiffChannel&&) = delete;

      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, channel>   checkPos{};
      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, channel+8> checkNeg{};

   public:
      constexpr DiffChannel() : ChannelCommon<AdcChannelNum(channel)>() {}

      /** PCR associated with plus channel */
      using PcrP = PcrTable_T<Info, channel>;

      /** PCR associated with minus channel */
      using PcrM = PcrTable_T<Info, channel>;

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=channel;

      /**
       * Configure the pins associated with this ADC channel.
       * The pins are in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pins to ADC
         PcrP::setPCR(Info::info[channel].pcrValue);
         PcrM::setPCR(Info::info[channel].pcrValue);
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (AdcInfo::InfoDP::info[0x1f&mapChannelNumToPhysicalChannelNum(channel)].portAddress != 0) {
            PcrP::disablePin();
            PcrM::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaDiffChannel : public DiffChannel<AdcChannelNum_Diff2> {

   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaDiffChannel(const PgaDiffChannel&) = delete;
      PgaDiffChannel(PgaDiffChannel&&) = delete;

   public:
      constexpr PgaDiffChannel(){}
   };
#endif

#endif

};

$(/ADC/declarations:// #error "No declarations found")
/**
 * End ADC_Group
 * @}
 */

} // End namespace USBDM

#endif // /ADC/_BasicInfoGuard

#endif /* HEADER_ADC_H */


/**
 * @file     lpit.h (180.ARM_Peripherals/Project_Headers/lpit-MK.h)
 *
 * @brief    Programmable Interrupt Timer interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef INCLUDE_USBDM_LPIT_H_
#define INCLUDE_USBDM_LPIT_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "system.h"
#include "hardware.h"

namespace USBDM {

enum DmaChannelNum : unsigned;

/**
 * @addtogroup LPIT_Group LPIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
/**
 * Type definition for LPIT interrupt call back
 */
typedef void (*LpitCallbackFunction)(void);

/**
 * Control LPIT operation in debug mode (suspended for debugging)
 */
enum LpitDebugMode {
   LpitDebugMode_Run  = LPIT_MCR_DBG_EN(1),  //!< LPIT continues to run in debug mode
   LpitDebugMode_Stop = LPIT_MCR_DBG_EN(0),  //!< LPIT stops in debug mode
};

/**
 * Control LPIT operation in WAIT and SLEEP modes
 */
enum LpitDozeMode {
   LpitDozeMode_Run  = LPIT_MCR_DOZE_EN(1),  //!< LPIT operates in WAIT and SLEEP modes
   LpitDozeMode_Stop = LPIT_MCR_DOZE_EN(0),  //!< LPIT stops in WAIT and SLEEP modes
};

/**
 * Enable the LPIT interrupts
 */
enum LpitChannelIrq {
   LpitChannelIrq_Disabled  = false,  //!< LPIT channel interrupt disabled
   LpitChannelIrq_Enabled   = true,   //!< LPIT channel interrupt disabled
};

/**
 * Channel numbers.
 */
enum LpitChannelNum : unsigned {
   LpitChannelNum_0,      //!< Channel  0
   LpitChannelNum_1,      //!< Channel  1
   LpitChannelNum_2,      //!< Channel  2
   LpitChannelNum_3,      //!< Channel  3

   LpitChannelNum_None = (1<<7),  //!< Used to indicate failed channel allocation
};

/**
 * Calculate a LPIT channel number using an offset from an existing number
 *
 * @param channel Base slot to use
 * @param offset  Offset from base channel
 *
 * @return  LPIT channel number calculated from slot+offset
 */
constexpr LpitChannelNum inline operator+(LpitChannelNum channel, unsigned offset) {
   return (LpitChannelNum)((unsigned)channel + offset);
}

/**
 * Calculate a LPIT channel number using an offset from an existing number
 *
 * @param channel Base slot to use
 * @param offset  Offset from base channel
 *
 * @return  LPIT channel number calculated from slot+offset
 */
constexpr LpitChannelNum inline operator+(LpitChannelNum channel, int offset) {
   return channel + (unsigned)offset;
}


/**
 * @brief Class representing a Programmable Interrupt  Timer
 *
 * <b>Example</b>
 * @code
 *
 * @endcode
 */
template<class Info>
class LpitBase_T {

private:
   /**
    * This class is not intended to be instantiated
    */
   LpitBase_T() = delete;
   LpitBase_T(const LpitBase_T&) = delete;
   LpitBase_T(LpitBase_T&&) = delete;

   /** Bit-mask of allocated channels */
   static uint32_t allocatedChannels;

protected:
   /** Default TCTRL value for timer channel */
   static constexpr uint32_t LPIT_TCTRL_DEFAULT_VALUE = (LPIT_MCR_M_CEN_MASK);

   /** Callback functions for ISRs */
   static LpitCallbackFunction sCallbacks[Info::NumChannels];

   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /**
    * Allocate LPIT channel.
    *
    * @return LpitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static LpitChannelNum allocateChannel() {
      unsigned channelNum = __builtin_ffs(allocatedChannels);
      if ((channelNum == 0)||(--channelNum>=Info::NumChannels)) {
         setErrorCode(E_NO_RESOURCE);
         return LpitChannelNum_None;
      }
      allocatedChannels &= ~(1<<channelNum);
      return (LpitChannelNum) channelNum;
   }

   /**
    * Allocate LPIT channel associated with DMA channel.
    * This is a channel that may be used to throttle the associated DMA channel.
    *
    * @param dmaChannelNum DMA channel being used.
    *
    * @return LpitChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static LpitChannelNum allocateDmaAssociatedChannel(DmaChannelNum dmaChannelNum) {
      const uint32_t channelMask = (1<<dmaChannelNum);
      usbdm_assert(dmaChannelNum<Info::NumChannels, "No LPIT channel associated with DMA channel");
      usbdm_assert((allocatedChannels & channelMask) != 0, "LPIT channel already allocated");
      if ((allocatedChannels & channelMask) == 0) {
         setErrorCode(E_NO_RESOURCE);
         return LpitChannelNum_None;
      }
      allocatedChannels &= ~channelMask;
      return (LpitChannelNum) dmaChannelNum;
   }

   /**
    * Free LPIT channel.
    *
    * @param lpitChannelNum Channel to release
    */
   static void freeChannel(LpitChannelNum lpitChannelNum) {
      const uint32_t channelMask = (1<<lpitChannelNum);
      usbdm_assert(lpitChannelNum<Info::NumChannels, "Illegal LPIT channel");
      usbdm_assert((allocatedChannels & channelMask) == 0, "Freeing unallocated LPIT channel");
      allocatedChannels |= channelMask;
   }

   /**
    * Enable channel interrupts
    *
    * @param[in]  channel Channel being modified
    */
   static void enableInterrupts(LpitChannelNum channel) {
      lpit->MIER |= (1<<channel);
   }

   /**
    * Disable channel interrupts
    *
    * @param[in]  channel Channel being modified
    */
   static void disableInterrupts(LpitChannelNum channel) {
      lpit->MIER &= ~(1<<channel);
   }

   /**
    * Set interrupt callback
    *
    *  @param[in]  channel   Channel to configure
    *  @param[in]  callback  Callback function to be executed on interrupt.\n
    *                        Use nullptr to remove callback.
    */
   static void setCallback(LpitChannelNum channel, LpitCallbackFunction callback) {
      static_assert(Info::irqHandlerInstalled, "LPIT not configure for interrupts");
      if (callback == nullptr) {
         callback = unhandledCallback;
      }
      sCallbacks[channel] = callback;
   }

protected:
   /** Pointer to hardware */
   static constexpr HardwarePtr<LPIT_Type> lpit = Info::baseAddress;

public:
   /**
    * Basic enable of LPIT
    */
   static void enable() {
      // Enable clock
      Info::enableClock();
      __DMB();
   }

   /**
    *  Enable the LPIT with default settings.
    *  All channels are enabled with default settings.
    */
   static void defaultConfigure() {
      enable();

      // Enable timer
      lpit->MCR = Info::mcr;
      for (unsigned i=0; i<Info::irqCount; i++) {
         configureChannelInTicks(i, Info::lpit_ldval);
         disableNvicInterrupts((LpitChannelNum)i);
      }
   }

   /**
    *  Enables and configures the LPIT.
    *  This also clears all channels and channel reservations.
    *
    *  @param[in]  lpitDebugMode  Determines whether the LPIT halts when suspended during debug
    *  @param[in]  lpitDozeMode   Determines whether the LPIT halts when processor is in wait or sleep modes
    */
   static void configure(LpitDozeMode lpitDozeMode, LpitDebugMode lpitDebugMode=LpitDebugMode_Stop) {
      enable();
      lpit->MCR = lpitDebugMode|lpitDozeMode|LPIT_MCR_M_CEN_MASK;
      disableChannels((1<<Lpit0Info::NumChannels)-1);
      allocatedChannels = -1;
   }

   /**
    *   Disable the LPIT (all channels)
    */
   static void disable() {
      lpit->MCR = 0;
      Info::disableClock();
   }

   /**
    * Enable interrupts in NVIC
    *
    * @param[in]  channel       Channel being modified
    */
   static void enableNvicInterrupts(LpitChannelNum channel) {
      static const IRQn_Type irqNums[] = {
            Info::irqNums[0], Info::irqNums[1], Info::irqNums[2], Info::irqNums[3],
      };
      usbdm_assert(channel<Info::irqCount,"Illegal LPIT channel");
      NVIC_EnableIRQ(irqNums[channel]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  channel       Channel being modified
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(LpitChannelNum channel, uint32_t nvicPriority) {
      static const IRQn_Type irqNums[] = {
            Info::irqNums[0], Info::irqNums[1], Info::irqNums[2], Info::irqNums[3],
      };
      usbdm_assert(channel<Info::irqCount,"Illegal LPIT channel");
      enableNvicInterrupt(irqNums[channel], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    *
    * @param[in]  channel       Channel being modified
    */
   static void disableNvicInterrupts(LpitChannelNum channel) {
      static const IRQn_Type irqNums[] = {
            Info::irqNums[0], Info::irqNums[1], Info::irqNums[2], Info::irqNums[3],
      };
      usbdm_assert(channel<Info::irqCount,"Illegal LPIT channel");
      NVIC_DisableIRQ(irqNums[channel]);
   }
   
   /**
    *  Enable the LPIT channel
    *
    *  @param[in]  channel   Channel to enable
    */
   static void enableChannel(const LpitChannelNum channel) {
      lpit->SETTEN = (1<<channel);
   }

   /**
    *   Disable the LPIT channel
    *
    *   @param[in]  channel Channel to disable
    */
   static void disableChannel(LpitChannelNum channel) {
      lpit->CLRTEN = (1<<channel);
   }

   /**
    *  Enable multiple LPIT channels
    *
    *  @param[in]  mask   Mask indicating channels to enable
    */
   static void enableChannels(uint32_t mask) {
      lpit->SETTEN = mask;
   }

   /**
    *   Disable multiple LPIT channels
    *
    *  @param[in]  mask   Mask indicating channels to disable
    */
   static void disableChannels(uint32_t mask) {
      lpit->CLRTEN = mask;
   }

   /**
    *  Configure the LPIT channel
    *
    *  @param[in]  channel           Channel to configure
    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
    *  @param[in]  lpitChannelIrq    Whether to enable interrupts
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannelInTicks(
         LpitChannelNum     channel,
         uint32_t           tickInterval,
         LpitChannelIrq     lpitChannelIrq=LpitChannelIrq_Disabled) {

      usbdm_assert(tickInterval>0, "Interval too short");

      lpit->TMR[channel].TCTRL = 0;
      lpit->TMR[channel].TVAL  = tickInterval-1;
      lpit->MSR                = (1<<channel);
      lpit->MIER              |= (lpitChannelIrq<<channel);
      lpit->TMR[channel].TCTRL = LPIT_TCTRL_T_EN_MASK;
   }

   /**
    *  Configure the LPIT channel
    *
    *  @param[in]  channel           Channel to configure
    *  @param[in]  intervalInSeconds Interval in seconds
    *  @param[in]  lpitChannelIrq     Whether to enable interrupts
    *
    *  @note The timer channel is disabled before configuring so that period changes have
    *        immediate effect.
    */
   static void configureChannel(
         LpitChannelNum     channel,
         float              intervalInSeconds,
         LpitChannelIrq     lpitChannelIrq=LpitChannelIrq_Disabled) {

      configureChannelInTicks(channel, convertSecondsToTicks(intervalInSeconds), lpitChannelIrq);
   }

   /**
    * Convert time in ticks to time in seconds
    *
    * @param[in] timeInTicks Time interval in ticks
    *
    * @return Time interval in seconds
    */
   static float convertTicksToSeconds(uint32_t timeInTicks) {
      return ((float)timeInTicks)/Info::getClockFrequency();
   }

   /**
    * Converts time in seconds to time in ticks
    *
    * @param[in] seconds Time interval in seconds
    *
    * @return Time interval in ticks
    *
    * @note Will set error code if calculated value is unsuitable
    */
   static uint32_t convertSecondsToTicks(float seconds) {
      float intervalInTicks = rintf(seconds*Info::getClockFrequency());
      usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      usbdm_assert(intervalInTicks > 0, "Interval is too short");
      if (intervalInTicks > 0xFFFFFFFFUL) {
         setErrorCode(E_TOO_LARGE);
      }
      if (intervalInTicks <= 0) {
         setErrorCode(E_TOO_SMALL);
      }
      return (uint32_t)intervalInTicks;
   }

   /**
    * Set period in seconds
    *
    * @param[in]  channel Channel being modified
    * @param[in]  interval Interval in ticks
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriodInTicks(LpitChannelNum channel, uint32_t interval) {
      lpit->TMR[channel].TVAL = interval-1;
   }

   /**
    * Set period in seconds
    *
    * @param[in]  channel Channel being modified
    * @param[in]  interval Interval in seconds
    *
    * @note If the timer is currently enabled this value will be loaded on the next expiration.
    *       To have immediate effect it is necessary to use configureChannel().
    */
   static void setPeriod(LpitChannelNum channel, float interval) {
      setPeriodInTicks(channel, rintf(interval*Info::getClockFrequency()));
   }

   /**
    *  Use a LPIT channel to implement a busy-wait delay
    *
    *  @param[in]  channel   Channel to use
    *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delayInTicks(LpitChannelNum channel, uint32_t interval) {
      configureChannelInTicks(channel, interval);
      while ((lpit->MSR&(1<<channel)) == 0) {
         __NOP();
      }
      disableChannel(channel);
   }

   /**
    *  Use a LPIT channel to implement a busy-wait delay
    *
    *  @param[in]  channel   Channel to use
    *  @param[in]  interval  Interval to wait as a float
    *
    *  @note Function doesn't return until interval has expired
    */
   static void delay(LpitChannelNum channel, float interval) {
      configureChannel(channel, interval);
      while ((lpit->MSR&(1<<channel)) == 0) {
         __NOP();
      }
      disableChannel(channel);
   }

   /**
    * Class representing a LPIT channel
    *
    * @tparam channel Timer channel number
    */
   template <int channel>
   class Channel {

   public:
      /** Timer channel number */
      static constexpr LpitChannelNum CHANNEL      = (LpitChannelNum)channel;
      static constexpr uint32_t       CHANNEL_MASK = 1<<CHANNEL;

      /**
       * Set interrupt callback
       *
       * @param[in]  callbackFunction  Function to call from stub ISR
       */
      static void setCallback(LpitCallbackFunction callbackFunction) {
         LpitBase_T<Info>::setCallback(CHANNEL, callbackFunction);
      }

      /** LPIT interrupt handler - Calls LPIT callback */
      static void irqHandler() {
         // Clear interrupt flag
         lpit->MSR = CHANNEL_MASK;
         sCallbacks[channel]();
      }

      /**
       *  Configure the LPIT channel
       *
       *  @param[in]  interval          Interval in timer ticks (usually bus clock)
       *  @param[in]  lpitChannelIrq     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void __attribute__((always_inline)) configureInTicks(
            uint32_t          interval,
            LpitChannelIrq     lpitChannelIrq=LpitChannelIrq_Disabled) {

         LpitBase_T<Info>::configureChannelInTicks(CHANNEL, interval, lpitChannelIrq);
      }

      /**
       *  Configure the LPIT channel
       *
       *  @param[in]  interval          Interval in seconds
       *  @param[in]  lpitChannelIrq     Whether to enable interrupts
       *
       *  @note The timer channel is disabled before configuring so that period changes
       *        have immediate effect.
       */
      static void __attribute__((always_inline)) configure(
            float             interval,
            LpitChannelIrq     lpitChannelIrq=LpitChannelIrq_Disabled) {

         LpitBase_T<Info>::configureChannel(CHANNEL, interval, lpitChannelIrq);
      }

      /**
       * Set period in seconds
       *
       * @param[in]  interval Interval in seconds
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void __attribute__((always_inline)) setPeriod(float interval) {
         LpitBase_T<Info>::setPeriod(CHANNEL, interval);
      }

      /**
       * Set period in ticks
       *
       * @param[in]  interval Interval in ticks
       *
       * @note If the timer is currently enabled this value will be loaded on the next expiration.
       *       To have immediate effect it is necessary to use configure().
       */
      static void __attribute__((always_inline)) setPeriodInTicks(uint32_t interval) {
         LpitBase_T<Info>::setPeriodInTicks(CHANNEL, interval);
      }

      /**
       *   Enable the LPIT channel
       */
      static void __attribute__((always_inline)) enable() {
         LpitBase_T<Info>::enableChannel(CHANNEL);
      }

      /**
       *   Disable the LPIT channel
       */
      static void __attribute__((always_inline)) disable() {
         LpitBase_T<Info>::disableChannel(CHANNEL);
      }

      /**
       * Enable/disable channel interrupts.
       *
       * @param[in]  enable  True => enable, False => disable
       *
       * @note It is also necessary to modify NVIC using enableNvicInterrupts().
       */
      static void __attribute__((always_inline)) enableInterrupts(bool enable=true) {
         LpitBase_T<Info>::enableInterrupts(CHANNEL);
      }

      /**
       * Enable and set priority of interrupts in NVIC
       * Any pending NVIC interrupts are first cleared.
       *
       * @param[in]  nvicPriority  Interrupt priority
       */
      static void enableNvicInterrupts(NvicPriority nvicPriority) {
         return LpitBase_T<Info>::enableNvicInterrupts(CHANNEL, nvicPriority);
      }

      /**
       * Enable interrupts in NVIC
       */
      static void enableNvicInterrupts() {
         return LpitBase_T<Info>::enableNvicInterrupts(CHANNEL);
      }

      /**
       * Disable interrupts in NVIC
       */
      static void disableNvicInterrupts() {
         return LpitBase_T<Info>::disableNvicInterrupts(CHANNEL);
      }

      /**
       *  Use a LPIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
       *
       *  @note Function doesn't return until interval has expired
       */
      static void __attribute__((always_inline)) delayInTicks(uint32_t interval) {
         LpitBase_T<Info>::delayInTicks(CHANNEL, interval);
      }

      /**
       *  Use a LPIT channel to implement a busy-wait delay
       *
       *  @param[in]  interval  Interval to wait as a float
       *
       *  @note Function doesn't return until interval has expired
       */
      static void __attribute__((always_inline)) delay(float interval) {
         LpitBase_T<Info>::delay(CHANNEL, interval);
      }
   };
};

/** Bit-mask of allocated channels */
template<class Info> uint32_t LpitBase_T<Info>::allocatedChannels = -1;

/**
 * Callback table for programmatically set handlers
 */
template<class Info>
LpitCallbackFunction LpitBase_T<Info>::sCallbacks[] = {
      LpitBase_T<Info>::unhandledCallback,
      LpitBase_T<Info>::unhandledCallback,
      LpitBase_T<Info>::unhandledCallback,
      LpitBase_T<Info>::unhandledCallback,
};

#if defined(USBDM_LPIT0_IS_DEFINED)
/**
 * @brief class representing the LPIT
 */
using Lpit0 = LpitBase_T<Lpit0Info>;

/**
 * @brief Class representing a LPIT channel
 *
 * @tparam channel Channel number
 */
template <int channel>
using LpitChannel = Lpit0::Channel<channel>;
$(/LPITO/Declarations:   // No declarations Found)
#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_LPIT_H_ */

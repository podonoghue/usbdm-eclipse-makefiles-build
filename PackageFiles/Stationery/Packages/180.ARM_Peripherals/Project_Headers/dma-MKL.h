/**
 * @file    dma.h  (180.ARM_Peripherals/Project_Headers/dma-MKL.h)
 * @brief   Direct Memory Controller
 *
 * @version  V4.12.1.210
 * @date     30 September 2017
 */

#ifndef INCLUDE_USBDM_DMA_H_
#define INCLUDE_USBDM_DMA_H_

#include "pin_mapping.h"

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
namespace USBDM {

#if $(/DMA/_BasicInfoGuard) // /DMA/_BasicInfoGuard

/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Support for DMA operations
 * @{
 */
$(/DMA/peripheral_h_definition:// $/PIT/peripheral_h_definition not found)
$(/DMAMUX/peripheral_h_definition:// $/PIT/peripheral_h_definition not found)

/**
 * Controls operation of DMA-MUX channel.
 */
enum DmamuxEnable {
   DmamuxEnable_Disabled   = DMAMUX_CHCFG_ENBL(0),                      //!< DMA channel is disabled
   DmamuxEnable_Continuous = DMAMUX_CHCFG_ENBL(1)|DMAMUX_CHCFG_TRIG(0), //!< DMA channel is enabled continuously
   DmamuxEnable_Triggered  = DMAMUX_CHCFG_ENBL(1)|DMAMUX_CHCFG_TRIG(1), //!< DMA channel is enabled and triggered by PIT channel
};

/**
 * Get size of destination object for DMA.
 *
 * @param[in] obj Object to obtain DMA size value for
 *
 * @return one of the DmaDestinationSize_xxx values
 */
template <class T>
static constexpr DmaDestinationSize dmaDestinationSize(const T &obj) {
   static_assert(((sizeof(obj)==1)||(sizeof(obj)==2)||(sizeof(obj)==4)), "Illegal DMA transfer size");
   return
      (sizeof(obj)==1) ?DmaDestinationSize_8Bit:
      (sizeof(obj)==2) ?DmaDestinationSize_16Bit:
      /*          ==4 */DmaDestinationSize_32Bit;
}

/**
 * Get size of source object for DMA.
 *
 * @param[in] obj Object to obtain DMA size value for
 *
 * @return one of the DmaSourceSize_xxx values
 */
template <class T>
static constexpr DmaSourceSize dmaSourceSize(const T &obj) {
   static_assert(((sizeof(obj)==1)||(sizeof(obj)==2)||(sizeof(obj)==4)), "Illegal DMA transfer size");
   return
      (sizeof(obj)==1) ?DmaSourceSize_8Bit:
      (sizeof(obj)==2) ?DmaSourceSize_16Bit:
      /*          ==4 */DmaSourceSize_32Bit;
}

/**
 * Class representing a DMA controller.
 *
 * @tparam Info Information describing DMA controller
 */
template<class Info>
class Dma_T : public Info {

   using MuxInfo = Dmamux0Info;

protected:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<DMA_Type> dmac = Info::baseAddress;

   /** Bit-mask of allocated channels */
   static uint32_t allocatedChannels;

   /** Callback to catch unhandled interrupt */
   static void noHandlerCallback(DmaChannelNum) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /// Number of DMA channels implemented
   using Info::NumChannels;

   /// Number of DMA vectors implemented
   using Info::NumVectors;

   /// Number of DMA channels with periodic feature
   using Info::NumPeriodicChannels;

   /// Configuration method
   using Info::configure;

   /**
    * Enable and configure shared DMA settings.
    * This also clears all DMA channels.
    */
   static void configure() {
      // Enable clock to DMAC
      Info::enableClock();

      // Clear call-backs and TCDs
      for (unsigned channel=0; channel<Dma0Info::NumChannels; channel++) {
         dmac->DMA[channel].DSR_BCR = DMA_DSR_BCR_DONE_MASK;
         Info::sCallbacks[channel] = Dma0Info::unhandledCallback;
      }
      // Reset record of allocated channels
      allocatedChannels = -1;
   }

   /**
    * Allocate DMA channel.
    *
    * @return DmaChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number     - Number of allocated channel
    */
   static DmaChannelNum allocateChannel() {
      CriticalSection cs;
      unsigned channelNum = __builtin_ffs(allocatedChannels);
      if ((channelNum == 0)||(--channelNum>=NumChannels)) {
         setErrorCode(E_NO_RESOURCE);
         return DmaChannelNum_None;
      }
      allocatedChannels &= ~(1<<channelNum);
      return (DmaChannelNum) channelNum;
   }

   /**
    * Allocate Periodic DMA channel.
    * This is a channel that may be throttled by an associated PIT channel.
    *
    * @return Error DmaChannelNum_None - No suitable channel available.  Error code set.
    * @return Channel number           - Number of allocated channel
    */
   static DmaChannelNum allocatePeriodicChannel() {
      CriticalSection cs;
      unsigned channelNum = __builtin_ffs(allocatedChannels);
      if ((channelNum == 0)||(--channelNum>=NumChannels)||(channelNum>=NumPeriodicChannels)) {
         setErrorCode(E_NO_RESOURCE);
         return DmaChannelNum_None;
      }
      allocatedChannels &= ~(1<<channelNum);
      return (DmaChannelNum) channelNum;
   }

   /**
    * Free DMA channel.
    *
    * @param dmaChannelNum DMA channel to release
    */
   static void freeChannel(DmaChannelNum dmaChannelNum) {
      const uint32_t channelMask = (1<<dmaChannelNum);
      usbdm_assert(dmaChannelNum<NumChannels,              "Illegal DMA channel");
      usbdm_assert((allocatedChannels & channelMask) == 0, "Freeing unallocated DMA channel");

      CriticalSection cs;
      allocatedChannels |= channelMask;
   }

   /**
    * Waits until the channel indicates the transaction has completed.
    *
    * @param[in] dmaChannelNum DMA channel number
    *
    * @return Status from completed transfer
    */
   static uint8_t waitUntilComplete(DmaChannelNum dmaChannelNum) {
      uint8_t status;
      do {
         status = dmac->DMA[dmaChannelNum].DSR;
      } while ((status & DMA_DSR_DONE_MASK) == 0);

      // Clear channel
      dmac->DMA[dmaChannelNum].DSR = DMA_DSR_DONE_MASK;

      // Return captured status
      return status;
   }

   /**
    * Clear interrupt request flag for a channel.
    * This also clears the request information and pending IRQ in NVIC.
    *
    * @param[in]  dmaChannelNum Channel being modified
    */
   static void __attribute__((always_inline)) clearInterruptRequest(DmaChannelNum dmaChannelNum) {
      dmac->DMA[dmaChannelNum].DSR_BCR = DMA_DSR_BCR_DONE_MASK;
      dmac->DMA[dmaChannelNum].DCR     = DMA_DCR_START(0)|DMA_DCR_ERQ(0);

      const IRQn_Type irqNum = Dma0Info::irqNums[0] + (dmaChannelNum&(Dma0Info::NumChannels-1));
      NVIC_ClearPendingIRQ(irqNum);
   }

};

   /** Bit-mask of allocated DMA channels */
   template<class Info>
   uint32_t Dma_T<Info>::allocatedChannels = 0;

$(/DMA/declarations: // No declaractions found)
$(/DMAMUX/declarations: // No declaractions found)

/**
 * End DMA_Group
 * @}
 */
#endif
} // End namespace USBDM

#endif /* INCLUDE_USBDM_DMA_H_ */

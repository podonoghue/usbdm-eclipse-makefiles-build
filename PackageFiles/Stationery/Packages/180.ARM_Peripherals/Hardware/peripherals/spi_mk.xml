<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- spi_mk.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Serial Peripheral Interface">

   <xi:include href="_default_instance.xml"/>

   <template><![CDATA[
      \t//! Pin number in Info table for SCK if mapped to a pin
      \tstatic constexpr int sckPin  = 0;

      \t//! Pin number in Info table for SIN if mapped to a pin
      \tstatic constexpr int sinPin  = 1;

      \t//! Pin number in Info table for SOUT if mapped to a pin
      \tstatic constexpr int soutPin  = 2;\n\n
   ]]></template>

   <xi:include href="_mapPinsOption_on.xml"/>

   <choiceOption key="spi_ctar_sel"
      hidden="true"
      enumType="uint8_t"
      enumStem="SpiCtarSelect"
      valueFormat="%s"
      description="CTAR Selection"
      toolTip="Selects between available CTAR registers">
      <choice value="0" name="CTAR 0" enum="0" isDefault="true" />
      <choice value="1" name="CTAR 1" enum="1" />
   </choiceOption>

   <constant key="NumCtars" value="2" type="Integer"/>

   <for keys="c" dim="NumCtars">

      <stringOption name="CTAR %(c)" key="CtarNum%(c)" constant="true" derived="true" value="----- %(c) -----"/>

      <intOption key="speed[%(c)]"
         description="Speed of interface"
         toolTip="Speed of transmission"
         typeName="const Hertz &amp;"
         valueFormat="%s_Hz"
         value="10_MHz" units="Hz"
         min="0" max="10000000" />

      <choiceOption key="spi_ctar_mode[%(c)]"
         enumStem="SpiMode"
         valueFormat="SPI_CTAR_CPOL(%s),SPI_CTAR_CPHA(%s)"
         description="Mode"
         toolTip="Communication mode\n
                  0: Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.\n
                  1: Active-high clock (idles low), Data changes on leading edge of SCK and is captured on the following edge.\n
                  2: Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.\n
                  3: Active-low clock (idles high), Data changes on leading edge of SCK and is captured on the following edge.
                  ">
         <choice value="0,0" name="Mode 0: CPOL=0, CPHA=0" enum="0" isDefault="true" />
         <choice value="0,1" name="Mode 1: CPOL=0, CPHA=1" enum="1" />
         <choice value="1,0" name="Mode 2: CPOL=1, CPHA=0" enum="2" />
         <choice value="1,1" name="Mode 3: CPOL=1, CPHA=1" enum="3" />
      </choiceOption>

      <choiceOption key="spi_ctar_fmsz[%(c)]"
         enumStem="SpiFrameSize"
         description="SPI Frame sizes"
         toolTip="Transfers are from 4 to 16 bits in size" >
         <choice value="4-1"  name="4 bits/transfer"                 enum="4_bits"  />
         <choice value="5-1"  name="5 bits/transfer"                 enum="5_bits"  />
         <choice value="6-1"  name="6 bits/transfer"                 enum="6_bits"  />
         <choice value="7-1"  name="7 bits/transfer"                 enum="7_bits"  />
         <choice value="8-1"  name="8 bits/transfer"                 enum="8_bits"  isDefault="true" />
         <choice value="9-1"  name="9 bits/transfer"                 enum="9_bits"  />
         <choice value="10-1" name="10 bits/transfer"                enum="10_bits" />
         <choice value="11-1" name="11 bits/transfer"                enum="11_bits" />
         <choice value="12-1" name="12 bits/transfer"                enum="12_bits" />
         <choice value="13-1" name="13 bits/transfer"                enum="13_bits" />
         <choice value="14-1" name="14 bits/transfer"                enum="14_bits" />
         <choice value="15-1" name="15 bits/transfer"                enum="15_bits" />
         <choice value="16-1" name="16 bits/transfer"                enum="16_bits" />
      </choiceOption>

      <binaryOption key="spi_ctar_lsbfe[%(c)]"
         enumStem="SpiBitOrder"
         description="Transmission order"
         toolTip="Transmission order">
         <choice value="0" name="MSB sent first" enum="MsbFirst" />
         <choice value="1" name="LSB sent first" enum="LsbFirst" />
      </binaryOption>

   </for>

   <stringOption name="" key="CtarNumX" derived="true" constant="true" value="----------------"/>

   <choiceOption key="spi_rser_txfifo"
      hidden="true"
      enumStem="SpiTxFifoRequest"
      valueFormat="SPI_RSER_TFFF_RE(%s),SPI_RSER_TFFF_DIRS(%s)"
      description="Transmit FIFO Fill Request interrupt/DMA enable"
      toolTip="Enable DMA or interrupts requests on Transmit FIFO space" >
      <choice value="0,0" name="No requests" enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Interrupt"   enum="Interrupt" />
      <choice value="1,1" name="DMA"         enum="Dma"       />
   </choiceOption>

   <choiceOption key="spi_rser_rxfifo"
      hidden="true"
      enumStem="SpiRxFifoRequest"
      valueFormat="SPI_RSER_RFDF_RE(%s),SPI_RSER_RFDF_DIRS(%s)"
      description="Receive FIFO Drain Request interrupt/DMA enable"
      toolTip="Enable DMA or interrupts requests on Receive FIFO data" >
      <choice value="0,0" name="No requests" enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Interrupt"   enum="Interrupt" />
      <choice value="1,1" name="DMA"         enum="Dma"       />
   </choiceOption>

   <binaryOption key="spi_rser_tfuf_re"
      hidden="true"
      enumStem="SpiTxFifoUnderflowInterrupt"
      description="TxFIFO Underflow interrupts"
      toolTip="Controls Transmit FIFO Underflow interrupts (on TFUF flag)">
      <choice value="0" name="No requests"             enum="Disabled" />
      <choice value="1" name="Interrupt on underflow"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_rfof_re"
      hidden="true"
      enumStem="SpiRxFifoOverflowInterrupt"
      description="RxFIFO Overflow interrupts"
      toolTip="Receive FIFO Overflow interrupts (on RFOF flag)">
      <choice value="0" name="No requests"            enum="Disabled" />
      <choice value="1" name="Interrupt on overflow"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_tcf_re"
      hidden="true"
      enumStem="SpiTxCompleteInterrupt"
      description="Tx complete interrupts"
      toolTip="Transmit complete interrupts (TCF Flag)">
      <choice value="0" name="No requests"             enum="Disabled" />
      <choice value="1" name="Interrupt on completion" enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_eoqf_re"
      hidden="true"
      enumStem="SpiEndOfQueueInterrupt"
      description="EOQ interrupts"
      toolTip="End of Queue interrupts (EOQF flag)">
      <choice value="0" name="No requests"               enum="Disabled" />
      <choice value="1" name="Interrupt on end of queue" enum="Enabled"  />
   </binaryOption>

   <choiceOption key="spi_pushr_pcs"
      hidden="true"
      enumStem="SpiPeripheralSelect"
      description="Peripheral Chip Select"
      toolTip="Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction\n
               Note: more than one PCS may be asserted (allows external decoder)" >
      <choice value="0"          name="PCSx not asserted" enum="None"  isDefault="true" />
      <choice value="1&lt;&lt;0" name="Assert PCS 0"      enum="0" />
      <choice value="1&lt;&lt;1" name="Assert PCS 1"      enum="1" />
      <choice value="1&lt;&lt;2" name="Assert PCS 2"      enum="2" />
      <choice value="1&lt;&lt;3" name="Assert PCS 3"      enum="3" />
      <choice value="1&lt;&lt;4" name="Assert PCS 4"      enum="4" />
      <choice value="1&lt;&lt;5" name="Assert PCS 5"      enum="5" />
      <choice value="1&lt;&lt;6" name="Assert PCS 6"      enum="6" />
      <choice value="1&lt;&lt;7" name="Assert PCS 7"      enum="7" />
   </choiceOption>

   <binaryOption key="spi_pushr_cont"
      hidden="true"
      enumStem="SpiSelectMode"
      description="Assert PCS between transfers"
      toolTip="Select whether Peripheral Select is returned to idle between transfers">
      <choice value="0" name="Idle between transactions"     enum="Idle"       />
      <choice value="1" name="Asserted between transactions" enum="Continuous" />
   </binaryOption>

   <!--binaryOption key="spi_pushr_eoq"
      hidden="true"
      enumStem="SpiEndOfQueue"
      description="Mark data value as End of Queue"
      toolTip="Indicates the associated data value is End of Queue, the Transmit and
               Receive operations will be disabled after this item completes transmission">
      <choice value="0" name="Not end of queue data item" enum="Disable"  />
      <choice value="1" name="End of Queue data item"     enum="Enable"   />
   </binaryOption-->

   <!--binaryOption key="spi_pushr_ctcnt"
      hidden="true"
      enumStem="SpiClearCounter"
      description="Mark data value to clear transmit count"
      toolTip="The transmit counter will be cleared before transmission of the associated data">
      <choice value="0" name="Transmission counter is not cleared" enum="Disable"  />
      <choice value="1" name="Transmission counter is cleared"     enum="Enable"   />
   </binaryOption-->

   <choiceOption key="PeripheralSelectMode"
      hidden="true"
      enumStem="SpiPeripheralSelectMode"
      enumType="uint8_t"
      valueFormat="(%s)"
      description="Controls PCS between transfers/transactions"
      toolTip="Select whether Peripheral Select is returned to idle between transfers or transactions">
      <choice value="0" name="Idle between each transfer"                enum="Transfer"    />
      <choice value="1" name="Idle between each transaction"             enum="Transaction" />
      <choice value="2" name="Asserted until another device is selected" enum="Continuous"  />
   </choiceOption>

      <choiceOption key="spi_mcr_pcsis"
         hidden="true"
         enumStem="SpiPeripheralSelectPolarity"
         description="Peripheral Chip Select Polarity"
         toolTip="Mask to select the polarity of Peripheral Chip Select Lines (PCSx)" >
         <choice value="0"          name="All PCSx active-high" enum="All_ActiveHigh"  isDefault="true" />
         <choice value="1&lt;&lt;0" name="PCS 0 Active-low"     enum="Pcs0_ActiveLow" />
         <choice value="1&lt;&lt;1" name="PCS 1 Active-low"     enum="Pcs1_ActiveLow" />
         <choice value="1&lt;&lt;2" name="PCS 2 Active-low"     enum="Pcs2_ActiveLow" />
         <choice value="1&lt;&lt;3" name="PCS 3 Active-low"     enum="Pcs3_ActiveLow" />
         <choice value="1&lt;&lt;4" name="PCS 4 Active-low"     enum="Pcs4_ActiveLow" />
         <choice value="1&lt;&lt;5" name="PCS 5 Active-low"     enum="Pcs5_ActiveLow" />
         <choice value="1&lt;&lt;6" name="PCS 6 Active-low"     enum="Pcs6_ActiveLow" />
         <choice value="1&lt;&lt;7" name="PCS 7 Active-low"     enum="Pcs7_ActiveLow" />
      </choiceOption>

   <choiceOption key="spi_mcr_clr_fifox"
      hidden="true"
      valueFormat="SPI_MCR_CLR_TXF(%s),SPI_MCR_CLR_RXF(%s)"
      enumStem="SpiClearFifo"
      description="Clear selected FIFOs"
      toolTip="Selectively clear transmit or receive FIFOs" >
      <choice value="0,0"  name="FIFOs not affected"       enum="None" />
      <choice value="0,1"  name="Clear Rx FIFO"            enum="Rx" />
      <choice value="1,0"  name="Clear Tx FIFO"            enum="Tx" />
      <choice value="1,1"  name="Clear Rx &amp; Tx FIFOs"  enum="Both" />
   </choiceOption>

   <choiceOption key="spi_mcr_dis_fifox"
      hidden="true"
      valueFormat="SPI_MCR_DIS_TXF(%s),SPI_MCR_DIS_RXF(%s)"
      enumStem="SpiEnableFifo"
      description="Enable selected FIFOs"
      toolTip="Selectively enable transmit or receive FIFOs" >
      <choice value="0,0"  name="Rx and Tx FIFOs enabled"    enum="Both" isDefault="true" />
      <choice value="0,1"  name="Enable Rx FIFO"             enum="Rx"   />
      <choice value="1,0"  name="Enable Tx FIFO"             enum="Tx"   />
      <choice value="1,1"  name="Disable Rx &amp; Tx FIFOs"  enum="None" />
   </choiceOption>

   <binaryOption key="spi_mcr_mstr"
      hidden="true"
      enumStem="SpiMasterSlave"
      description="Master or Slave operation"
      toolTip="Whether to operate as Master or Slave device">
      <choice value="0" name="Operate as Master" enum="Slave"   />
      <choice value="1" name="Operate as Slave"  enum="Master"  />
   </binaryOption>

   <choiceOption key="spi_mcr_mtfe"
      valueFormat="SPI_MCR_MTFE(%s),SPI_MCR_SMPL_PT(%s)"
      enumStem="SpiModifiedTiming"
      description="Modified Timing Format"
      toolTip="Controls when the module master samples serial-in,\n
               This field is only valid when CPHA bit 0." >
      <choice value="0,0"  name="Normal Timing"                         enum="Normal"  />
      <choice value="1,0"  name="No delay from SCK edge to SIN sample"  enum="0_Clocks" />
      <choice value="1,1"  name="1 clock  from SCK edge to SIN sample"  enum="1_Clocks" />
      <choice value="1,2"  name="2 clocks from SCK edge to SIN sample"  enum="2_Clocks" />
   </choiceOption>

   <binaryOption key="spi_mcr_pcsse" condition="spi_mcr_pcsse_present"
      enumStem="SpiPcsMode"
      description="PCS5/PCSS* pin mode"
      toolTip="Select use of PCS5/PCSS as PCS5 or PCS strobe*\n
               The strobe may be used to enable decoding of the remaining\n
               PCSx pins to multiple devices" >
      <choice value="0" name="PCS5/PCSS normal operation (PCS5)"        enum="PCS5"        />
      <choice value="1" name="PCSS/PCSS is used as a strobe for PCSx"   enum="PCSx_Strobe" />
   </binaryOption>

   <binaryOption key="spi_mcr_rooe"
      enumStem="SpiRxOverflowHandling"
      description="Handling of Rx Overflow Data"
      toolTip="Discard incoming data or overwite previous data on RxFIFO overflow ">
      <choice value="0" name="Ignore incoming"      enum="Ignore"    />
      <choice value="1" name="Overwrite existing"   enum="Overwrite" />
   </binaryOption>

   <binaryOption key="spi_mcr_doze"
      enumStem="SpiDoze"
      description="Enables Doze mode (when processor is waiting?)"
      toolTip="Enables Doze mode (when processor is waiting?)">
      <choice value="0" name="Ignore doze"      enum="Disabled" />
      <choice value="1" name="Suspend in doze"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="spi_mcr_frz"
      enumStem="SpiFreeze"
      description="Controls SPI operation while in debug mode"
      toolTip="Enable transfers to be stopped on the next frame boundary when the device enters Debug mode.">
      <choice value="0" name="Continue in debug"  enum="Disabled" />
      <choice value="1" name="Suspend in debug"   enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="spi_mcr_cont_scke"
      enumStem="SpiContinuousClock"
      description="Continuous SCK Enable"
      toolTip="Whether the Serial Communication Clock (SCK) runs continuously">
      <choice value="0" name="Clock during transfers only" enum="Disable" />
      <choice value="1" name="Continuous clock "           enum="Enable"  />
   </binaryOption>

<if condition="!/SPI/SpiBasicInfo_generated" >
   <constant key="/SPI/SpiBasicInfo_generated" type="Boolean" value="true" />

<!--   ========== BasicInfo class - start =============================== -->

   <template namespace="usbdm" ><![CDATA[
      class SpiBasicInfo {
      \t
      public:
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t *
      \t * @param status Interrupt status value from SPI->SR
      \t */
      \ttypedef void (*CallbackFunction)(uint32_t status);
      \t\n
   ]]></template>


<!--   ========== SPI SerialInit class =============================== -->

   <template key="/SPI/serial_init_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of a CTAR in $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_class)
      \t * // Options available vary with device - See $(_class)::DefaultInitValue for example
      \t * static const $(_class)::SerialInit serialInit {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *
      \t *    SpiCtarSelect_1,        // CTAR 1 initialisation
      \t *    1_MHz ,                 // Speed of interface
      \t *    SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *    SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *    SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_class)::configure(serialInit); // TODO
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      $(/SPI/serial_init_description)
      \tclass SerialInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr SerialInit(const SerialInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr SerialInit() = default;
      \t\n
   ]]></template>

<!--   Member variables -->

   <initialValueTemplate namespace="usbdm"
      variables="
         spi_ctar_sel"
   ><![CDATA[
      \t   ///  CTAR Selection
      \t   SpiCtarSelect ctarNum = SpiCtarSelect_0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="
         spi_ctar_mode[],
         spi_ctar_fmsz[],
         spi_ctar_lsbfe[]"
   ><![CDATA[
      \t   ///  Clock and Transfer Attributes Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="
         speed[]"
   ><![CDATA[
      \t   ///  Module Configuration Register
      \t   Hertz speed = 0_Hz;\n\n
   ]]></initialValueTemplate>

<!--    SerialInit Constructors -->

   <for keys="r" values="
         spi_ctar_mode[];
         spi_ctar_fmsz[];
         spi_ctar_lsbfe[]">
      <constructorTemplate namespace="usbdm" variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm" variables="speed[]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %comments
      \t    */
      \t   template <typename... Types>
      \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
      \t
      \t      speed = %paramExpression;
      \t   }
      \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" variables="spi_ctar_sel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %comments
      \t    */
      \t   template <typename... Types>
      \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
      \t
      \t      ctarNum = %paramExpression;
      \t   }
      \t\n
   ]]></constructorTemplate>

<!--   ========== SerialInit class - end =============================== -->

   <template namespace="usbdm" ><![CDATA[
      \t};\n
   ]]></template>

<!--   ========== SPI Init class =============================== -->

   <template key="/SPI/config_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of shared settings for $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_class)
      \t * // Options available vary with device - See $(_class)::DefaultConfigValue for example
      \t * static const $(_class)::Config spiConfig {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *
      \t *    SpiModifiedTiming_Disable ,    // Modified Timing Format - Disabled
      \t *    SpiDoze_Disabled ,             // Enables Doze mode (when processor is waiting?) - Ignore Doze
      \t *    SpiFreeze_Disabled ,           // Controls SPI operation while in debug mode - Continue in debug
      \t *    SpiRxOverflowHandling_Ignore , // Handling of Rx Overflow Data - Ignore incoming
      \t *    SpiContinuousClock_Disable,    // Continuous SCK Enable - Clock during transfers only
      \t *    SpiPeripheralSelect_3,         // Make PCS3 active-low (similar lines may be repeated)
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_class)::configure(spiConfig);
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      $(/SPI/config_description)
      \tclass Config {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Config(const Config &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Config() = default;
      \t\n
   ]]></template>

<!--   Member variables -->

   <setTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="
         spi_mcr_mtfe,
         spi_mcr_pcsse,
         spi_mcr_doze,
         spi_mcr_frz,
         spi_mcr_rooe,
         spi_mcr_cont_scke"
   ><![CDATA[
      \t   ///  Module Configuration Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="
         spi_ctar_sel,
         spi_pushr_pcs,
         PeripheralSelectMode"
   ><![CDATA[
      \t   ///  PUSHR values
      \t   uint32_t pushr      = 0;
      \t   uint32_t pushrFinal = 0;
      \t\n
   ]]></initialValueTemplate>

<!--  Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      this->%enumParam0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <for keys="r" values="
         spi_mcr_mtfe;
         spi_mcr_pcsse;
         spi_mcr_doze;
         spi_mcr_frz;
         spi_mcr_rooe;
         spi_mcr_cont_scke">
      <setTemplate namespace="usbdm" variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Config(%params, Types... rest) : Config(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></setTemplate>
   </for>

   <setTemplate namespace="usbdm" variables="spi_mcr_pcsis"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for Active-low PCSx
      \t    * By default PCSx signals are active-high i.e. they idle low between transfers/transactions
      \t    * This constructor changes the given PCSx to active-low i.e. PCSx will idle high
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %params Active-low PCS signal
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      mcr |= %paramExpression;
      \t   }
      \t\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm" variables="spi_pushr_pcs"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial Peripheral selection
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %params PCS signal to assert during transfers
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      pushr      |= %paramExpression;
      \t      pushrFinal |= %paramExpression;
      \t   }
      \t\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm" variables="spi_ctar_sel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial CTAR selection
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %params CTAR to use during transfers
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      pushr      = (pushr      & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(%paramExpression);
      \t      pushrFinal = (pushrFinal & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(%paramExpression);
      \t   }
      \t\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm" variables="PeripheralSelectMode"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial Peripheral selection timing
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %params PCS timing
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      pushr      |= (%paramExpression>=1)?SPI_PUSHR_CONT_MASK:0;
      \t      pushrFinal |= (%paramExpression>=2)?SPI_PUSHR_CONT_MASK:0;
      \t   }
      \t\n
   ]]></setTemplate>

<!--   ========== Config class - end =============================== -->

   <template namespace="usbdm" ><![CDATA[
      \t};\n
   ]]></template>

<!--   ========== Config class - start =============================== -->

   <template key="/SPI/init_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_class)
      \t *
      \t * This class has multiple constructors that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example1:
      \t * @code
      \t * // Shared init values
      \t * static constexpr Config SharedConfigValue = {
      \t *    SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
      \t *    SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
      \t *    SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
      \t *    SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
      \t *    SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
      \t *
      \t *    SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
      \t * };
      \t *
      \t * static constexpr SerialInit SerialInitValue0 = {
      \t *       SpiCtarSelect_0,        // CTAR 0 initialisation
      \t *       10_MHz ,                // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *
      \t *       // Optional base value to start with (must be last parameter)
      \t *       Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * static constexpr SerialInit SerialInitValue1 = {
      \t *       SpiCtarSelect_1,        // CTAR 1 initialisation
      \t *       1_MHz ,                 // Speed of interface
      \t *       SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
      \t *
      \t *       // Optional base value to start with (must be last parameter)
      \t *       Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * // Initialisation values for $(_class)
      \t * static const $(_class)::Init spiInit {
      \t *    SharedConfigValue,
      \t *    SerialInitValue0,
      \t *    SerialInitValue1
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_class)::configure(spiInit);
      \t * @endcode
      \t *
      \t * Example2:
      \t * @code
      \t * // Initialisation values for $(_class)
      \t * // Options available vary with device - See $(_class)::DefaultInitValue for example
      \t * static const $(_class)::Init spiInit {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *    {
      \t *       // Shared configuration
      \t *       SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
      \t *       SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
      \t *       SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
      \t *       SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
      \t *       SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
      \t *
      \t *       SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
      \t *    },
      \t *    {
      \t *       // CTAR 0 initialisation
      \t *       10_MHz ,                // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *    },
      \t *    {
      \t *       // CTAR 1 initialisation - May be ommited
      \t *       1_MHz ,                 // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *    },
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_class)::configure(spiInit);
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      $(/SPI/init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--   Config Member variables -->

   <template namespace="usbdm"
    ><![CDATA[
      \t   ///  Used to construct CTARx values
      \t   SerialInit ctars[2];
      \t
      \t   /// Common configuration
      \t   Config config;
      \t\n
   ]]></template>

<!--    Config Constructors -->

   <template namespace="usbdm"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for CTAR0, CTAR1 values
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param config  Shared configuration values
      \t    * @param ctar0   Configuration values for CTAR0
      \t    * @param ctar1   Configuration values for CTAR0
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(const Config &config, const SerialInit &ctar0, const SerialInit &ctar1, Types... rest) : Init(rest...) {
      \t
      \t      this->config     = config;
      \t      ctars[0]         = ctar0;
      \t      ctars[0].ctarNum = SpiCtarSelect_0;
      \t      ctars[1]         = ctar1;
      \t      ctars[1].ctarNum = SpiCtarSelect_1;
      \t   }
      \t\n
   ]]></template>

   <template namespace="usbdm"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for CTAR0, CTAR1 values
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param config  Shared configuration values
      \t    * @param ctar    Configuration values for all CTARs
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(const Config &config, const SerialInit &ctar, Types... rest) : Init(rest...) {
      \t
      \t      this->config     = config;
      \t      ctars[0]         = ctar;
      \t      ctars[0].ctarNum = SpiCtarSelect_0;
      \t      ctars[1]         = ctar;
      \t      ctars[1].ctarNum = SpiCtarSelect_1;
      \t   }
      \t\n
   ]]></template>

<!--  Init Configure methods -->

   <template discardRepeats="true" key="/SPI/InitMethod" namespace="all" ><![CDATA[
      /* Template /SPI/InitMethod - start */
      \t
      \t/**
      \t * Configure SPI from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const typename SpiBasicInfo::Init &init) {
      \t/*
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled
      \t      setCallback(init.callbackFunction);
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t*/
      \t   enable();
      \t
      \t   spi->MCR =
      \t         init.config.mcr |
      \t         SpiClearFifo_Both|         // Clear FIFOs
      \t         SPI_MCR_HALT(1)|           // Halt transfers initially
      \t         SPI_MCR_MSTR(1);           // Master mode
      \t
      \t   const uint32_t spiFrequency = getSpiInputClockFrequency();
      \t
      \t   // CTAR 0
      \t   spi->CTAR[0] = init.ctars[0].ctar|calculateCtarTiming(spiFrequency, init.ctars[0].speed);
      \t
      \t   // CTAR 1
      \t   spi->CTAR[1] = init.ctars[1].ctar|calculateCtarTiming(spiFrequency, init.ctars[1].speed);
      \t
      \t   // PUSHR values for intermediate and last transfer in transaction
      \t   pushrMask      = init.config.pushr;
      \t   pushrMaskFinal = init.config.pushrFinal;
      \t}
      \t\n
   ]]></template>

<!--   ========== Init class - end =============================== -->

   <template namespace="usbdm" ><![CDATA[
      \t};\n
   ]]></template>

<!--   ========== SPI BasicInfo class - end =============================== -->

   <template namespace="usbdm" ><![CDATA[
      };\n\n
   ]]></template>

</if>
<!--   ========== SPI BasicInfo class - end =============================== -->

<!--    Default Initialisation values -->

   <template><![CDATA[
      \t/**
      \t * Default initialisation value for $(_class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::SerialInit DefaultSerialInitValue[] = {\n
      ]]></template>

   <for keys="c" dim="NumCtars">

      <initialValueTemplate
         separator=","
         terminator=","
         variables="
            speed[%(c)],
            spi_ctar_mode[%(c)],
            spi_ctar_fmsz[%(c)],
            spi_ctar_lsbfe[%(c)]
            "
      ><![CDATA[
         \t{
         \t   SpiCtarSelect_%(c),
         %initExpression\n\t},\n
      ]]></initialValueTemplate>

   </for>

   <template><![CDATA[
      \t};
      \t\n
      ]]></template>

   <initialValueTemplate
      separator=","
      terminator=","
      variables="
         spi_mcr_mtfe,
         spi_mcr_pcsse,
         spi_mcr_doze,
         spi_mcr_frz,
         spi_mcr_rooe,
         spi_mcr_cont_scke
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::Config DefaultConfigValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <template><![CDATA[
      \t/**
      \t * Default initialisation value for $(_class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::Init DefaultInitValue = {
      \t   DefaultConfigValue,\n
   ]]></template>
   <for keys="c" dim="NumCtars">
      <template><![CDATA[
         \t   DefaultSerialInitValue[%(c)],\n
      ]]></template>
   </for>
   <template><![CDATA[
      \t};\n\n
   ]]></template>

<!--    Files -->

   <projectActionList id = "spi_files" >
      <copy source="Project_Headers/spi-MK.h"            target="Project_Headers/spi.h"             overwrite="true"  derived="true" />
      <copy source="Sources/spi-MK.cpp"                  target="Sources/spi.cpp"                   overwrite="true"  derived="true" />
      <copy source="Snippets/spi-example.cpp"            target="Snippets/spi-example.cpp"          overwrite="true"  derived="true" />
      <copy source="Snippets/spi-N-config-example.cpp"   target="Snippets/spi-N-config-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/spi-2-config-example.cpp"   target="Snippets/spi-2-config-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/spi-flash-example.cpp"      target="Snippets/spi-flash-example.cpp"    overwrite="true"  derived="true" />
      <copy source="Snippets/at45db041e.h"               target="Snippets/at45db041e.h"             overwrite="true"  derived="true" />

   </projectActionList>

   <template key="/SPI/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_name) interface
   \t * <b>Example</b>
   \t * @code
   \t * USBDM::Spi *spi = new USBDM::$(_class);
   \t *
   \t * uint8_t txData[] = {1,2,3};
   \t * uint8_t rxData[10];
   \t * spi->txRxBytes(sizeof(txData), txData, rxData);
   \t * @endcode
   \t */
   \tclass $(_class) : public $(_base_class)Base_T<$(_class)Info> {
   \tpublic:
   \t
   $(/$(_name)/InputMapping:   // No user mappings found)
   \t   $(_class)() : SpiBase_T<$(_class)Info>() {}
   \t   $(_class)(const typename SpiBasicInfo::Init &init) : SpiBase_T<$(_class)Info>(init) {}
   \t\n
   ]]></template>
   <template key="/SPI/declarations" namespace="all"  codeGenCondition="irqHandlingMethod" ><![CDATA[
   \t   /**
   \t    * Creates a DMA buffer and associated code for DMA transfers to/from the SPI
   \t    *
   \t    * Examples use:
   \t    * @code
   \t    *    $(_class) spi;
   \t    *
   \t    *    // Configure SPI
   \t    *
   \t    *    constexpr unsigned NumDataItems = 10;
   \t    *
   \t    *    using DataSize = uint16_t; // Can be uint8_t or uint16_t
   \t    *
   \t    *    // Transmit data
   \t    *    DataSize txBuffer[NumDataItems];
   \t    *
   \t    *    // Create DMA buffers etc.
   \t    *    auto txBuffer = spi.createDmaHandler<NumDataItems>();
   \t    *
   \t    *    // Receive buffer
   \t    *    DataSize rxBuffer[NumDataItems];
   \t    *
   \t    *    // Set up DMA transfer from internal buffer -> SPI -> rxBuffer
   \t    *    txBuffer.initialiseDma(rxBuffer);
   \t    *
   \t    *    // Load data into SPI transmit buffer
   \t    *    txBuffer.loadTxData(txBufferOriginal);
   \t    *
   \t    *    // Start transfer
   \t    *    txBuffer.startTransfer();
   \t    *
   \t    *    // Wait for completion
   \t    *    while (txBuffer.isBusy()) {
   \t    *       __asm__("nop");
   \t    *    }
   \t    * @endcode
   \t    *
   \t    * @tparam itemCount Number of items in internal DMA buffer buffer
   \t    *
   \t    * @return Instance of SpiDmaHandler customised for buffer size
   \t    */
   \t   template<unsigned itemCount>
   \t   SpiDmaHandler_T<itemCount> createDmaHandler() {
   \t      return SpiDmaHandler_T<itemCount>(*this);
   \t   }
   \t\n
   ]]></template>
   <template key="/SPI/declarations" namespace="all"  codeGenCondition="!irqHandlingMethod" ><![CDATA[
   \t   /**
   \t    * Dummy routine for error check
   \t    *
   \t    * @tparam itemCount Number of items in internal DMA buffer buffer
   \t    *
   \t    * @return Instance of SpiDmaHandler customised for buffer size
   \t    */
   \t   template<unsigned itemCount>
   \t   void createDmaHandler() {
   \t      constexpr bool $(_class)IrqAvailable = false&&itemCount;
   \t      static_assert($(_class)IrqAvailable, "$(_class) not configured for interrupts");
   \t   }
   \t\n
   ]]></template>
   <template key="/SPI/declarations" namespace="all" ><![CDATA[
   \t};
   \t\n
   ]]></template>

   <setTemplate variables="spi_mcr_cont_scke" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      /* Template /SPI/methods - start */
      \t
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \t void setContinousClock(%enumClass %enumParam) {
      \t   %defaultFieldExpression
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="spi_mcr_mstr" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \t void setMasterSlave(%enumClass %enumParam) {
      \t   %defaultFieldExpression
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="spi_mcr_pcsis" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t *
      \t * The mask would be created by ORing together the <b>active-low</b> PCS selection values
      \t * Examples:
      \t * @code
      \t *    // Set PCS0 and PCS3 active-low and all others active-high
      \t *    setPcsIdleLevels(SpiPeripheralSelectPolarity_Pcs0_ActiveLow|SpiPeripheralSelectPolarity_Pcs3_ActiveLow)
      \t *
      \t *    // Set all PCSx to active high (the most common situation)
      \t *    setPcsIdleLevels(SpiPeripheralSelectPolarity_All_ActiveHigh)
      \t * @endcode
      \t */
      \t void setPcsPolarity(%enumClass %enumParam) {
      \t   %defaultFieldExpression
      \t}\n\n
   ]]></setTemplate>

   <xi:include href="_irqOption.xml"/>

   <xi:include href="_clockOption.xml"/>

   <template key="/SPI/handlerSlot"><![CDATA[
      \t{nullptr}, // $(_name)\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.SpiValidate">
   </validate>

   <template><![CDATA[
      \t/**
      \t * Get SPI input clock frequency
      \t *
      \t * @return Frequency in Hz
      \t */
      \tstatic uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <signals/>
</peripheralPage>

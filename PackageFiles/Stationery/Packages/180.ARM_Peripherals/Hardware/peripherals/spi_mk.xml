<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- spi_mk.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Serial Peripheral Interface" >

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <equation key="no_initvectors"             value="true"      />
   <equation key="suppressIrqHandler"         value="" />
   <equation key="irq_parameters"             value="ErrorCode errorcode"  />
   <equation key="irq_dummy_parameters"       value="ErrorCode"            />
   <equation key="irq_call_parameters"        value="E_NO_ERROR"           />
   <equation key="generateDefault"            value="false"         />
   <equation key="configureInStartupDefault"  value="false"         />
   <xi:include href="enablePeripheral.xml"    />

   <!-- _____________ Class Declaration __________________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_Baseclass)BasicInfo"' />

   <template><![CDATA[
      \t//! Pin number in Info table for SCK if mapped to a pin
      \tstatic constexpr int sckPin  = 0;

      \t//! Pin number in Info table for SIN if mapped to a pin
      \tstatic constexpr int sinPin  = 1;

      \t//! Pin number in Info table for SOUT if mapped to a pin
      \tstatic constexpr int soutPin  = 2;\n\n
   ]]></template>

<!-- Clocking -->

   <!--  Default clock is Bus Clock -->
   <constant key="ClockSource" value='"SystemBusClock"' condition="!ClockSource" />

   <title description="Clocking" />
   <binaryOption key="/$(_BASENAME)/baudSupport"
      enabledBy="$(_BasicInfoGuard)"
      modify="true"
      description="Enable specifying speed in Hertz"
      toolTip="If not selected, the communication speed must be specified using the\n
               prescale values (SPPR and SPP) in initialisation structures" >
      <choice value="false" name="Prescale values must be used" isDefault="true" />
      <choice value="true"  name="Speed may be specified in Hertz" />
   </binaryOption>

   <if condition='=ClockSource=="SystemBusClock"'>
      <choiceOption key="spiClockConfig" condition="/MCG/_present"
         enabledBy="$(_BasicInfoGuard)"
         target="spiInputClock"
         description="Clock configuration"
         toolTip="Selects the clock configuration used for calculations involving the bus clock" >
         <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
         <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
         <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
         <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
      </choiceOption>

      <choiceOption key="spiClockConfig" condition="/ICS/_present"
         enabledBy="$(_BasicInfoGuard)"
         target="spiInputClock"
         description="Clock configuration"
         toolTip="Selects the clock configuration used for calculations involving the bus clock" >
         <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
         <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
         <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
         <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
      </choiceOption>
   </if>
   <if condition='=ClockSource=="SystemCoreClock"'>
      <choiceOption key="spiClockConfig" condition="/MCG/_present"
         enabledBy="$(_BasicInfoGuard)"
         target="spiInputClock"
         description="Clock configuration"
         toolTip="Selects the clock configuration used for calculations involving the bus clock" >
         <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_core_clock[0]"  isDefault="true" />
         <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_core_clock[1]"  />
         <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_core_clock[2]"  />
         <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_core_clock[3]"  />
      </choiceOption>

      <choiceOption key="spiClockConfig" condition="/ICS/_present"
         enabledBy="$(_BasicInfoGuard)"
         target="spiInputClock"
         description="Clock configuration"
         toolTip="Selects the clock configuration used for calculations involving the bus clock" >
         <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_core_clock[0]"  isDefault="true" />
         <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_core_clock[1]"  />
         <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_core_clock[2]"  />
         <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_core_clock[3]"  />
      </choiceOption>
   </if>

   <intOption key="spiInputClock"
      enabledBy="$(_BasicInfoGuard)"
      locked="true"
      derived="true"
      description="SPI input clock"
      toolTip="The frequency shown is based on the selected clock configuration.\n
               This frequency is used as the basis for calculations on this page."
      units="Hz"
      />

   <!-- DMA/Interrupt Request Select and Enable Register (RSER) register -->
   <choiceOption key="spi_rser_txfifo"
      hidden="true"
      typeName="SpiTxFifoRequest"
      valueFormat="SPI_RSER_TFFF_RE(%s),SPI_RSER_TFFF_DIRS(%s)"
      description="Transmit FIFO Fill Request interrupt/DMA enable"
      toolTip="Enable DMA or interrupts requests on Transmit FIFO space" >
      <choice value="0,0" name="No requests" enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Interrupt"   enum="Interrupt" />
      <choice value="1,1" name="DMA"         enum="Dma"       />
   </choiceOption>

   <choiceOption key="spi_rser_rxfifo"
      hidden="true"
      typeName="SpiRxFifoRequest"
      valueFormat="SPI_RSER_RFDF_RE(%s),SPI_RSER_RFDF_DIRS(%s)"
      description="Receive FIFO Drain Request interrupt/DMA enable"
      toolTip="Enable DMA or interrupts requests on Receive FIFO data" >
      <choice value="0,0" name="No requests" enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Interrupt"   enum="Interrupt" />
      <choice value="1,1" name="DMA"         enum="Dma"       />
   </choiceOption>

   <binaryOption key="spi_rser_tfuf_re"
      hidden="true"
      typeName="SpiTxFifoUnderflowInterrupt"
      description="TxFIFO Underflow interrupts"
      toolTip="Controls Transmit FIFO Underflow interrupts (on TFUF flag)" >
      <choice value="0" name="No requests"             enum="Disabled" />
      <choice value="1" name="Interrupt on underflow"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_rfof_re"
      hidden="true"
      typeName="SpiRxFifoOverflowInterrupt"
      description="RxFIFO Overflow interrupts"
      toolTip="Receive FIFO Overflow interrupts (on RFOF flag)" >
      <choice value="0" name="No requests"            enum="Disabled" />
      <choice value="1" name="Interrupt on overflow"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_tcf_re"
      hidden="true"
      typeName="SpiTxCompleteInterrupt"
      description="Tx complete interrupts"
      toolTip="Transmit complete interrupts (TCF Flag)" >
      <choice value="0" name="No requests"             enum="Disabled" />
      <choice value="1" name="Interrupt on completion" enum="Enabled"  />
   </binaryOption>

   <binaryOption key="spi_rser_eoqf_re"
      hidden="true"
      typeName="SpiEndOfQueueInterrupt"
      description="EOQ interrupts"
      toolTip="End of Queue interrupts (EOQF flag)" >
      <choice value="0" name="No requests"               enum="Disabled" />
      <choice value="1" name="Interrupt on end of queue" enum="Enabled"  />
   </binaryOption>


<!-- Common Options -->

   <title description="Common Options" toolTip="Options applied to whole peripheral" />

   <binaryOption key="/$(_STRUCTNAME)/dmaSupport"
      enabledBy="$(_BasicInfoIrqGuard)"
      modify="true"
      description="Enable use of DMA"
      toolTip="This creates some structes to support DMA transfers using the SPI (EXPERIMENTAL)" >
      <choice value="false" name="Not supported" isDefault="true" />
      <choice value="true"  name="Supported" />
   </binaryOption>

   <choiceOption key="spi_mcr_pcsis_enum" condition="spi_mcr_pcsis_present"
      hidden="true"
      derived="true"
      valueFormat="SPI_MCR_PCSIS(%s)"
      typeName="SpiPcsActiveLow"
      baseType="uint32_t"
      description="Polarity for PCS signals"
      toolTip="Mask to select the polarity of Peripheral Chip Select Lines (PCSx)\n
               Selected PCS signals will be active-low i.e. PCS will go low when accessing the peripheral" >
      <choiceExpansion name="PCS%(c) is active-low" value="1U&lt;&lt;%(c)" enum="Pcs%(c)" keys="c" dim="6" />
      <choice          name="All PCSx active-high" value="0"  enum="None" />
      <choice          name="All PCSx active-low"  value="-1" enum="All" />
   </choiceOption>

   <bitmaskOption key="spi_mcr_pcsis" condition="spi_mcr_pcsis_present"
      derivedFrom="spi_mcr_pcsis_enum"
      bitmask="0x0"
      bitList='@SignalList("^SPI\d_(PCS\d)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
      value="0"
      bitDescription='@"PCS%i is active-low"'
   />

   <binaryOption key="spi_mcr_pcsse" condition="spi_mcr_pcsse_present||/SPI1/spi_mcr_pcsse_present||/SPI2/spi_mcr_pcsse_present"
      typeName="SpiPcsMode"
      description="PCS_5/PCSS* pin mode"
      toolTip="Select use of PCS_5/PCSS as PCS_5 or PCS strobe*\n
               The strobe may be used to enable 1-of-N decoding of the \n
               remaining PCSx pins to multiple devices" >
      <choice value="0" name="Pin is used as PCS_5"             enum="PCS5"        />
      <choice value="1" name="Pin is used as a strobe for PCSx" enum="PCSx_Strobe" />
   </binaryOption>

<!--
   <stringOption
      hidden="true"
      derived="true"
      description="Polarity for PCS signals"
      valueFormat="%s"
      key="spi_mcr_pcsis"
      value="(SpiPcsPolarity)0"
      />

   <choiceOption key="spi_mcr_pcsis"
      typeName="SpiPcsPolarity"
      description="Peripheral Chip Select Polarity"
      toolTip="Mask to select the polarity of Peripheral Chip Select Lines (PCSx)" >
      <choice value="0"          name="All PCSx active-high" enum="All_ActiveHigh"  isDefault="true" />
      <choice value="1&lt;&lt;0" name="PCS 0 Active-low"     enum="0_ActiveLow" />
      <choice value="1&lt;&lt;1" name="PCS 1 Active-low"     enum="1_ActiveLow" />
      <choice value="1&lt;&lt;2" name="PCS 2 Active-low"     enum="2_ActiveLow" />
      <choice value="1&lt;&lt;3" name="PCS 3 Active-low"     enum="3_ActiveLow" />
      <choice value="1&lt;&lt;4" name="PCS 4 Active-low"     enum="4_ActiveLow" />
      <choice value="1&lt;&lt;5" name="PCS 5 Active-low"     enum="5_ActiveLow" />
      <choice value="1&lt;&lt;6" name="PCS 6 Active-low"     enum="6_ActiveLow" />
      <choice value="1&lt;&lt;7" name="PCS 7 Active-low"     enum="7_ActiveLow" />
   </choiceOption>
-->

   <choiceOption key="spi_mcr_clr_fifox"
      hidden="true"
      valueFormat="SPI_MCR_CLR_TXF(%s),SPI_MCR_CLR_RXF(%s)"
      typeName="SpiClearFifo"
      description="Clear selected FIFOs"
      toolTip="Selectively clear transmit or receive FIFOs" >
      <choice value="0,0"  name="FIFOs not affected"       enum="None" />
      <choice value="0,1"  name="Clear Rx FIFO"            enum="Rx" />
      <choice value="1,0"  name="Clear Tx FIFO"            enum="Tx" />
      <choice value="1,1"  name="Clear Rx &amp; Tx FIFOs"  enum="Both" />
   </choiceOption>

   <choiceOption key="spi_mcr_dis_fifox"
      hidden="true"
      valueFormat="SPI_MCR_DIS_TXF(%s),SPI_MCR_DIS_RXF(%s)"
      typeName="SpiEnableFifo"
      description="Enable selected FIFOs"
      toolTip="Selectively enable transmit or receive FIFOs" >
      <choice value="0,0"  name="Rx and Tx FIFOs enabled"    enum="Both" isDefault="true" />
      <choice value="0,1"  name="Enable Rx FIFO"             enum="Rx"   />
      <choice value="1,0"  name="Enable Tx FIFO"             enum="Tx"   />
      <choice value="1,1"  name="Disable Rx &amp; Tx FIFOs"  enum="None" />
   </choiceOption>

   <binaryOption key="spi_mcr_mstr"
      hidden="true"
      typeName="SpiMasterSlave"
      description="Master or Slave operation"
      toolTip="Whether to operate as Master or Slave device" >
      <choice value="0" name="Operate as Master" enum="Slave"   />
      <choice value="1" name="Operate as Slave"  enum="Master"  />
   </binaryOption>

   <choiceOption key="spi_mcr_mtfe"
      valueFormat="SPI_MCR_MTFE(%s),SPI_MCR_SMPL_PT(%s)"
      typeName="SpiModifiedTiming"
      description="Modified Timing Format"
      toolTip="Controls when the module master samples serial-in,\n
               This field is only valid when CPHA bit 0." >
      <choice value="0,0"  name="Normal Timing"                         enum="Normal"  />
      <choice value="1,0"  name="No delay from SCK edge to SIN sample"  enum="0_Clocks" />
      <choice value="1,1"  name="1 clock  from SCK edge to SIN sample"  enum="1_Clocks" />
      <choice value="1,2"  name="2 clocks from SCK edge to SIN sample"  enum="2_Clocks" />
   </choiceOption>

   <binaryOption key="spi_mcr_rooe"
      typeName="SpiRxOverflowHandling"
      description="Handling of Rx Overflow Data"
      toolTip="Discard incoming data or overwite previous data on RxFIFO overflow " >
      <choice value="0" name="Ignore incoming"      enum="Ignore"    />
      <choice value="1" name="Overwrite existing"   enum="Overwrite" />
   </binaryOption>

   <binaryOption key="spi_mcr_doze"
      typeName="SpiDoze"
      description="Enables Doze mode (when processor is waiting?)"
      toolTip="Enables Doze mode (when processor is waiting?)" >
      <choice value="0" name="Ignore doze"      enum="Disabled" />
      <choice value="1" name="Suspend in doze"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="spi_mcr_frz"
      typeName="SpiFreeze"
      description="Controls SPI operation while in debug mode"
      toolTip="Enable transfers to be stopped on the next frame boundary when the device enters Debug mode." >
      <choice value="0" name="Continue in debug"  enum="Disabled" />
      <choice value="1" name="Suspend in debug"   enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="spi_mcr_cont_scke"
      typeName="SpiContinuousClock"
      description="Continuous SCK Enable"
      toolTip="Whether the Serial Communication Clock (SCK) runs continuously" >
      <choice value="0" name="Clock during transfers only" enum="Disable" />
      <choice value="1" name="Continuous clock "           enum="Enable"  />
   </binaryOption>

   <for keys="c" dim="=spi_ctar_dim" >

      <title description="CTAR %(c)" toolTip="Clock and Transfer Attributes #%(c)" />

      <intOption key="speed[%(c)]"
         description="Speed of interface"
         toolTip="Speed of transmission"
         valueFormat="%s"
         units="Hz"
         value="10_MHz"
         min="0" max="10000000" />

      <choiceOption key="spi_ctar_mode[%(c)]"
         typeName="SpiMode"
         valueFormat="SPI_CTAR_CPOL(%s),SPI_CTAR_CPHA(%s)"
         description="Mode"
         toolTip="Communication mode\n
                  0: Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.\n
                  1: Active-high clock (idles low), Data changes on leading edge of SCK and is captured on the following edge.\n
                  2: Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.\n
                  3: Active-low clock (idles high), Data changes on leading edge of SCK and is captured on the following edge.
                  " >
         <choice value="0,0" name="Mode 0: CPOL=0, CPHA=0" enum="0" isDefault="true" />
         <choice value="0,1" name="Mode 1: CPOL=0, CPHA=1" enum="1" />
         <choice value="1,0" name="Mode 2: CPOL=1, CPHA=0" enum="2" />
         <choice value="1,1" name="Mode 3: CPOL=1, CPHA=1" enum="3" />
      </choiceOption>

      <choiceOption key="spi_ctar_fmsz[%(c)]"
         typeName="SpiFrameSize"
         description="SPI Frame sizes"
         toolTip="Transfers are from 4 to 16 bits in size" >
         <choice value="4-1"  name="4 bits/transfer"                 enum="4_bits"  />
         <choice value="5-1"  name="5 bits/transfer"                 enum="5_bits"  />
         <choice value="6-1"  name="6 bits/transfer"                 enum="6_bits"  />
         <choice value="7-1"  name="7 bits/transfer"                 enum="7_bits"  />
         <choice value="8-1"  name="8 bits/transfer"                 enum="8_bits"  isDefault="true" />
         <choice value="9-1"  name="9 bits/transfer"                 enum="9_bits"  />
         <choice value="10-1" name="10 bits/transfer"                enum="10_bits" />
         <choice value="11-1" name="11 bits/transfer"                enum="11_bits" />
         <choice value="12-1" name="12 bits/transfer"                enum="12_bits" />
         <choice value="13-1" name="13 bits/transfer"                enum="13_bits" />
         <choice value="14-1" name="14 bits/transfer"                enum="14_bits" />
         <choice value="15-1" name="15 bits/transfer"                enum="15_bits" />
         <choice value="16-1" name="16 bits/transfer"                enum="16_bits" />
      </choiceOption>

      <binaryOption key="spi_ctar_lsbfe[%(c)]"
         typeName="SpiBitOrder"
         description="Transmission order"
         toolTip="Transmission order" >
         <choice value="0" name="MSB sent first" enum="MsbFirst" />
         <choice value="1" name="LSB sent first" enum="LsbFirst" />
      </binaryOption>

   </for>

   <title description="Initial device options"
      toolTip="Device and CTAR choice after default configuration\n
               These options can be changed by selectConfiguration(...)"
      />

   <choiceOption key="spi_ctar_sel"
      baseType="uint8_t"
      typeName="SpiCtarSelect"
      valueFormat="%s"
      description="CTAR Selection"
      toolTip="Selects between available CTAR registers" >
      <choice value="0" name="CTAR 0" enum="0" isDefault="true" />
      <choice value="1" name="CTAR 1" enum="1" />
   </choiceOption>

   <choiceOption key="PeripheralSelectMode"
      typeName="SpiPeripheralSelectMode"
      baseType="uint8_t"
      valueFormat="(%s)"
      description="Controls PCS between transfers/transactions"
      toolTip="Select whether Peripheral Select is returned to idle between transfers or transactions" >
      <choice value="0" name="Negated between each transfer"             enum="Transfer"    />
      <choice value="1" name="Negated between each transaction"          enum="Transaction" />
      <choice value="2" name="Asserted until another device is selected" enum="Continuous"  />
   </choiceOption>

   <binaryOption key="spi_pushr_cont"
      hidden="true"
      typeName="SpiSelectMode"
      description="Assert PCS between transfers"
      toolTip="Select whether Peripheral Select is returned to idle between transfers" >
      <choice value="0" name="Idle between transactions"     enum="Idle"       />
      <choice value="1" name="Asserted between transactions" enum="Continuous" />
   </binaryOption>

   <choiceOption key="spi_pushr_pcs_enum"
      hidden="true"
      derived="true"
      valueFormat="SPI_PUSHR_PCS(%s)"
      typeName="SpiPeripheralSelect"
      baseType="uint32_t"
      description="Peripheral Chip Select"
      toolTip="Mask to select which Peripheral Chip Select Line (PCS) to assert during transaction\n
               Note: more than one PCS may be asserted (allows use of an external decoder)" >
      <choiceExpansion name="Assert PCS%(c) during transaction" value="1U&lt;&lt;%(c)" enum="Pcs%(c)" keys="c" dim="6" />
      <choice          name="PCSx not asserted" value="0"  enum="None" />
   </choiceOption>

   <bitmaskOption key="spi_pushr_pcs" condition="spi_pushr_pcs_present"
      derivedFrom="spi_pushr_pcs_enum"
      bitmask="0x0"
      bitList='@SignalList("^SPI\d_(PCS\d)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
      value="0"
      bitDescription='@"Assert PCS%i during transaction"'
   />

   <!--binaryOption key="spi_pushr_eoq"
      hidden="true"
      typeName="SpiEndOfQueue"
      description="Mark data value as End of Queue"
      toolTip="Indicates the associated data value is End of Queue, the Transmit and
               Receive operations will be disabled after this item completes transmission" >
      <choice value="0" name="Not end of queue data item" enum="Disable"  />
      <choice value="1" name="End of Queue data item"     enum="Enable"   />
   </binaryOption-->

   <!--binaryOption key="spi_pushr_ctcnt"
      hidden="true"
      typeName="SpiClearCounter"
      description="Mark data value to clear transmit count"
      toolTip="The transmit counter will be cleared before transmission of the associated data" >
      <choice value="0" name="Transmission counter is not cleared" enum="Disable"  />
      <choice value="1" name="Transmission counter is cleared"     enum="Enable"   />
   </binaryOption-->

<if condition="!/SPI/SpiBasicInfo_generated" >
   <constant key="/SPI/SpiBasicInfo_generated" type="Boolean" value="true" />

<!--   ========== SPI SerialInit class =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of a CTAR in $(_Class)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_Class)
      \t * // Options available vary with device - See $(_Class)::DefaultInitValue for example
      \t * static const $(_Class)::SerialInit serialInit {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *
      \t *    SpiCtarSelect_1,        // CTAR 1 initialisation
      \t *    1_MHz ,                 // Speed of interface
      \t *    SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *    SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *    SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_Class)::configure(serialInit);
      \t * @endcode
      \t */
      \tclass SerialInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr SerialInit(const SerialInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr SerialInit() = default;
      \t\n
   ]]></template>

<!--   Member variables -->

   <variableTemplate where="basicInfo"
      variables="
         spi_ctar_sel"
   ><![CDATA[
      \t   ///  CTAR Selection
      \t   SpiCtarSelect ctarNum = SpiCtarSelect_0;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo"
      variables="
         spi_ctar_mode[],
         spi_ctar_fmsz[],
         spi_ctar_lsbfe[]"
   ><![CDATA[
      \t   ///  Clock and Transfer Attributes Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo"
      variables="
         speed[]"
   ><![CDATA[
      \t   ///  Module Configuration Register
      \t   Hertz speed = 0_Hz;\n\n
   ]]></variableTemplate>

<!--    SerialInit Constructors -->

   <for keys="r" values="
         spi_ctar_mode[];
         spi_ctar_fmsz[];
         spi_ctar_lsbfe[]" >
      <variableTemplate where="basicInfo" variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" variables="speed[]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
      \t
      \t      speed = %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" variables="spi_ctar_sel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr SerialInit(%params, Types... rest) : SerialInit(rest...) {
      \t
      \t      ctarNum = %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

<!--   ========== SerialInit class - end =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t}; // class SerialInit\n
   ]]></template>

<!--   ========== SPI Init class =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of shared settings for $(_Class)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_Class)
      \t * // Options available vary with device - See $(_Class)::DefaultConfigValue for example
      \t * static const $(_Class)::Config spiConfig {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *
      \t *    // Common setting that are seldom changed
      \t *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
      \t *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
      \t *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
      \t *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
      \t *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
      \t *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
      \t *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
      \t *
      \t *    // The following are initial settings that would commonly be changed by selectConfiguration()
      \t *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
      \t *    SpiCtarSelect_1,                        // CTAR to use
      \t *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * @endcode
      \t */
      \tclass Config {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Config(const Config &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Config() = default;
      \t\n
   ]]></template>

<!--   Member variables -->

   <variableTemplate where="basicInfo" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo"
      variables="
         spi_mcr_mtfe,
         spi_mcr_pcsse,
         spi_mcr_doze,
         spi_mcr_frz,
         spi_mcr_rooe,
         spi_mcr_cont_scke"
   ><![CDATA[
      \t   ///  Module Configuration Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo"
      variables="
         spi_ctar_sel,
         spi_pushr_pcs,
         PeripheralSelectMode"
   ><![CDATA[
      \t   ///  PUSHR values
      \t   uint32_t pushr      = 0;
      \t   uint32_t pushrFinal = 0;
      \t\n
   ]]></variableTemplate>

<!--  Constructors -->

   <variableTemplate where="basicInfo" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r" values="
         spi_mcr_mtfe;
         spi_mcr_pcsse;
         spi_mcr_doze;
         spi_mcr_frz;
         spi_mcr_rooe;
         spi_mcr_cont_scke" >
      <variableTemplate where="basicInfo" variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Config(%params, Types... rest) : Config(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" variables="spi_mcr_pcsis"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for Active-low PCSx
      \t    * By default PCSx signals are active-high i.e. they are high to indicate a transfers/transactions
      \t    * This constructor changes the given PCSx to active-low i.e. PCSx will go low for transfer
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramName0 PCS signal to be made Active-low
      \t    *                         SpiPcsActiveLow_None clears all selections
      \t    *                         SpiPcsActiveLow_PCSn values are cumulative
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      if (%paramExpression == SpiPcsActiveLow_None) {
      \t         %registerName &= ~%mask;
      \t      }
      \t      else {
      \t         %registerName |= %paramName;
      \t      }
      \t   }
      \t\n
   ]]></variableTemplate>

   <!-- variableTemplate where="basicInfo" variables="spi_pushr_pcs"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial Peripheral selection
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramExpression PCS signal to assert during transfers
      \t    *                SpiPeripheralSelect_None clears all selections
      \t    *                SpiPeripheralSelect_XXXX values are cumulative
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      if (%paramExpression == SpiPeripheralSelect_None) {
      \t         pushr      &= ~%mask;
      \t         pushrFinal &= ~%mask;
      \t      }
      \t      else {
      \t         pushr      |= %paramExpression;
      \t         pushrFinal |= %paramExpression;
      \t      }
      \t   }
      \t\n
   ]]></variableTemplate -->

   <variableTemplate where="basicInfo" variables="spi_pushr_pcs"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial Peripheral selection
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramName PCS signal to assert during transfers
      \t    *                SpiPeripheralSelect_None clears all selections
      \t    *                SpiPeripheralSelect_XXXX values are cumulative
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      if (%paramName == SpiPeripheralSelect_None) {
      \t         pushr      &= ~%mask;
      \t         pushrFinal &= ~%mask;
      \t      }
      \t      else {
      \t         pushr      |= %paramName;
      \t         pushrFinal |= %paramName;
      \t      }
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" variables="spi_ctar_sel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial CTAR selection
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramExpression CTAR to use during transfers
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      pushr      = (pushr      & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(%paramExpression);
      \t      pushrFinal = (pushrFinal & ~SPI_PUSHR_CTAS_MASK)|SPI_PUSHR_CTAS(%paramExpression);
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" variables="PeripheralSelectMode"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for initial Peripheral selection timing
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramExpression PCS timing
      \t    */
      \t   template <typename... Types>
      \t   constexpr Config(%params, Types... rest) : Config(rest...) {
      \t
      \t      pushr      |= (%paramExpression>=1)?SPI_PUSHR_CONT_MASK:0;
      \t      pushrFinal |= (%paramExpression>=2)?SPI_PUSHR_CONT_MASK:0;
      \t   }
      \t\n
   ]]></variableTemplate>

<!--   ========== Config class - end =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t}; // class Config\n
   ]]></template>

<!--   ========== Config class - start =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Class)
      \t *
      \t * This class has multiple constructors that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example1:
      \t * This example breaks the initialisation into several constants which may allow re-use
      \t * @code
      \t * // Shared init values
      \t * static constexpr Config SharedConfigValue = {
      \t *    // Common setting that are seldom changed
      \t *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
      \t *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
      \t *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
      \t *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
      \t *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
      \t *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
      \t *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
      \t *
      \t *    // The following are initial settings that would commonly be changed by selectConfiguration()
      \t *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
      \t *    SpiCtarSelect_1,                        // CTAR to use
      \t *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
      \t * };
      \t *
      \t * static constexpr SerialInit SerialInitValue0 = {
      \t *       SpiCtarSelect_0,        // CTAR 0 initialisation
      \t *       10_MHz ,                // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *
      \t *       // Optional base value to start with (must be last parameter)
      \t *       Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * static constexpr SerialInit SerialInitValue1 = {
      \t *       SpiCtarSelect_1,        // CTAR 1 initialisation
      \t *       1_MHz ,                 // Speed of interface
      \t *       SpiMode_o ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_LsbFirst,   // Transmission order - LSB sent first
      \t *
      \t *       // Optional base value to start with (must be last parameter)
      \t *       Spi1::DefaultSerialInitValue,
      \t * };
      \t *
      \t * // Initialisation values for $(_Class)
      \t * static const $(_Class)::Init spiInit {
      \t *    SharedConfigValue,
      \t *    SerialInitValue0,
      \t *    SerialInitValue1
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_Class)::configure(spiInit);
      \t * @endcode
      \t *
      \t * Example2:
      \t * This example shows an all-in-one intialisation
      \t * @code
      \t * // Initialisation values for $(_Class)
      \t * // Options available vary with device - See $(_Class)::DefaultInitValue for example
      \t * static const $(_Class)::Init spiInit {
      \t *
      \t *    // Omitted parameters are take to be zero unless a base value is given
      \t *    {
      \t *    // Common setting that are seldom changed
      \t *    SpiModifiedTiming_Normal ,                   // Modified Timing Format - Normal Timing
      \t *    SpiPcsMode_PCS5 ,                            // PCS5/PCSS* pin mode - PCS5/PCSS normal operation (PCS5)
      \t *    SpiDoze_Enabled ,                            // Enables Doze mode (when processor is waiting?) - Suspend in doze
      \t *    SpiFreeze_Enabled ,                          // Controls SPI operation while in debug mode - Suspend in debug
      \t *    SpiRxOverflowHandling_Overwrite ,            // Handling of Rx Overflow Data - Overwrite existing
      \t *    SpiContinuousClock_Disable,                  // Continuous SCK Enable - Clock during transfers only
      \t *    SpiPcsPolarity_3_ActiveLow,                  // Polarity for PCS signals (similar lines may be repeated)
      \t *
      \t *    // The following are initial settings that would commonly be changed by selectConfiguration()
      \t *    SpiPeripheralSelect_Ptc4 ,              // Peripheral to select
      \t *    SpiCtarSelect_1,                        // CTAR to use
      \t *    SpiPeripheralSelectMode_Transaction     // Peripheral select mode
      \t *    },
      \t *    {
      \t *       // CTAR 0 initialisation
      \t *       10_MHz ,                // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *    },
      \t *    {
      \t *       // CTAR 1 initialisation - May be ommited
      \t *       1_MHz ,                 // Speed of interface
      \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
      \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
      \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
      \t *    },
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise SPI from values specified above
      \t * $(_Class)::configure(spiInit);
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--   Config Member variables -->

   <template where="basicInfo"
    ><![CDATA[
      \t   ///  Used to construct CTARx values
      \t   SerialInit ctars[2];
      \t
      \t   /// Common configuration
      \t   Config config;
      \t\n
   ]]></template>

<!--    Config Constructors -->

   <template where="basicInfo"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for CTAR0, CTAR1 values
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param config  Shared configuration values
      \t    * @param ctar0   Configuration values for CTAR0
      \t    * @param ctar1   Configuration values for CTAR0
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(const Config &config, const SerialInit &ctar0, const SerialInit &ctar1, Types... rest) : Init(rest...) {
      \t
      \t      this->config     = config;
      \t      ctars[0]         = ctar0;
      \t      ctars[0].ctarNum = SpiCtarSelect_0;
      \t      ctars[1]         = ctar1;
      \t      ctars[1].ctarNum = SpiCtarSelect_1;
      \t   }
      \t\n
   ]]></template>

   <template where="basicInfo"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for CTAR0, CTAR1 values
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param config  Shared configuration values
      \t    * @param ctar    Configuration values for all CTARs
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(const Config &config, const SerialInit &ctar, Types... rest) : Init(rest...) {
      \t
      \t      this->config     = config;
      \t      ctars[0]         = ctar;
      \t      ctars[0].ctarNum = SpiCtarSelect_0;
      \t      ctars[1]         = ctar;
      \t      ctars[1].ctarNum = SpiCtarSelect_1;
      \t   }
      \t\n
   ]]></template>

<!--  Init Configure methods -->

   <template discardRepeats="true" key="/SPI/InitMethod" ><![CDATA[
      /* Template /SPI/InitMethod - start */
      \t
      \t/**
      \t * Configure SPI from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const typename SpiBasicInfo::Init &init) {
      \t/*
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled
      \t      setCallback(init.callbackFunction);
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t*/
      \t   enable();
      \t
      \t   spi->MCR =
      \t         init.config.mcr |
      \t         SpiClearFifo_Both|         // Clear FIFOs
      \t         SPI_MCR_HALT(1)|           // Halt transfers initially
      \t         SPI_MCR_MSTR(1);           // Master mode
      \t
      \t   const uint32_t spiFrequency = getSpiInputClockFrequency();
      \t
      \t   // CTAR 0
      \t   spi->CTAR[0] = init.ctars[0].ctar|calculateCtarTiming(spiFrequency, init.ctars[0].speed);
      \t
      \t   // CTAR 1
      \t   spi->CTAR[1] = init.ctars[1].ctar|calculateCtarTiming(spiFrequency, init.ctars[1].speed);
      \t
      \t   // PUSHR values for intermediate and last transfer in transaction
      \t   pushrMask      = init.config.pushr;
      \t   pushrMaskFinal = init.config.pushrFinal;
      \t}
      \t\n
   ]]></template>

<!--   ========== Init class - end =============================== -->

   <template where="basicInfo" ><![CDATA[
      \t}; // class Init
      \t\n
   ]]></template>

</if>

<!--    Default Initialisation values -->

   <template><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::SerialInit DefaultSerialInitValue[] = {\n
   ]]></template>
   <for keys="c" dim="=spi_ctar_dim" >
      <variableTemplate
         separator=","
         terminator=","
         padToComments="35"
         variables="
            speed[%(c)],
            spi_ctar_mode[%(c)],
            spi_ctar_fmsz[%(c)],
            spi_ctar_lsbfe[%(c)]
            "
      ><![CDATA[
         \t{
         \t   SpiCtarSelect_%(c),
         %initExpression\n\t},\n
      ]]></variableTemplate>
   </for>
   <template><![CDATA[
      \t};
      \t\n
      ]]></template>

   <variableTemplate
      separator=","
      terminator=","
      padToComments="35"
      variables="
         spi_mcr_mtfe,
         spi_mcr_pcsse,
         spi_mcr_doze,
         spi_mcr_frz,
         spi_mcr_rooe,
         spi_mcr_cont_scke,
         spi_ctar_sel,
         PeripheralSelectMode
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::Config DefaultConfigValue = {%initNonZeroValues
      \t\n
   ]]></variableTemplate>
   <for keys="pcs" dim="6" >
      <template codeGenCondition="(spi_mcr_pcsis&amp;(1&lt;&lt;%(pcs)))!=0"><![CDATA[
         \t   SpiPcsActiveLow_Pcs%(pcs),     // (spi_mcr_pcsis.b%(pcs)) PCS%(pcs) is active-low\n
      ]]></template>
   </for>
   <for keys="pcs" dim="6" >
      <template codeGenCondition="(spi_pushr_pcs&amp;(1&lt;&lt;%(pcs)))!=0"><![CDATA[
         \t   SpiPeripheralSelect_Pcs%(pcs), // (spi_pushr_pcs.b%(pcs)) PCS%(pcs) is asserted during transfer\n
      ]]></template>
   </for>
   <template>
   <![CDATA[
      \t};\n\n
   ]]>
   </template>

   <template><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr SpiBasicInfo::Init DefaultInitValue = {
      \t   DefaultConfigValue,\n
   ]]></template>
   <for keys="c" dim="=spi_ctar_dim" >
      <template><![CDATA[
         \t   DefaultSerialInitValue[%(c)],\n
      ]]></template>
   </for>
   <template><![CDATA[
      \t};\n\n
   ]]></template>

   <template key="/SPI/declarations"  ><![CDATA[
   // $(_NAME) mappings
   $(/$(_NAME)/InputMapping:   // No user mappings found for $(_NAME))
   \t/**
   \t * Class representing $(_NAME) interface
   \t *
   \t * <b>Example</b>
   \t * @code
   \t * // Initialisation values for Spi
   \t * static const $(_Class)::Init spiInit {
   \t *
   \t *    {
   \t *       // Shared configuration
   \t *       SpiModifiedTiming_Normal ,        // Modified Timing Format - Normal Timing
   \t *       SpiDoze_Enabled ,                 // Enables Doze mode (when processor is waiting?) - Suspend in Doze
   \t *       SpiFreeze_Enabled ,               // Controls SPI operation while in debug mode - Suspend in debug
   \t *       SpiRxOverflowHandling_Overwrite , // Handling of Rx Overflow Data - Overwrite existing
   \t *       SpiContinuousClock_Enable,        // Continuous SCK Enable - Continuous clock
   \t *
   \t *       SpiPeripheralSelect_0,            // PCS0 is Active-low (others are active-high)
   \t *    },
   \t *    {
   \t *       // CTAR 0 initialisation
   \t *       10_MHz ,                // Speed of interface
   \t *       SpiMode_0 ,             // Mode - Mode 0: CPOL=0, CPHA=0
   \t *       SpiFrameSize_8_bits ,   // SPI Frame sizes - 8 bits/transfer
   \t *       SpiBitOrder_MsbFirst,   // Transmission order - MSB sent first
   \t *    },
   \t * };
   \t *
   \t * Spi0 spi(spiInit);
   \t * ...
   \t *
   \t * uint8_t txData[] = {1,2,3};
   \t * uint8_t rxData[10];
   \t *
   \t * spi.txRxBytes(sizeof(txData), txData, rxData);
   \t * ...
   \t * @endcode
   \t */
   \tusing $(_Class) = $(_Baseclass)Base_T<$(_Info)>;
   \t\n
   ]]></template>

   <variableTemplate variables="spi_mcr_cont_scke" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      /* Template /SPI/methods - start */
      \t
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \t void setContinousClock(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></variableTemplate>

   <variableTemplate variables="spi_mcr_mstr" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \t void setMasterSlave(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></variableTemplate>

   <variableTemplate variables="spi_mcr_pcsis" key="/SPI/methods" discardRepeats="true"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t *
      \t * The mask would be created by ORing together the <b>active-low</b> PCS selection values
      \t * Examples:
      \t * @code
      \t *    // Set PCS0 and PCS3 active-low and all others active-high
      \t *    setPcsIdleLevels(SpiPcsPolarity_Pcs0_ActiveLow|SpiPcsPolarity_Pcs3_ActiveLow)
      \t *
      \t *    // Set all PCSx to active high (the most common situation)
      \t *    setPcsIdleLevels(SpiPcsPolarity_All_ActiveHigh)
      \t * @endcode
      \t */
      \t void setPcsPolarity(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></variableTemplate>

   <template key="/SPI/handlerSlot" ><![CDATA[
      \t{nullptr}, // $(_NAME)\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" immediateVariables="ClockSource" ><![CDATA[
      \t/**
      \t * Get SPI input clock frequency
      \t *
      \t * @return Frequency in Hz
      \t */
      \tstatic uint32_t getClockFrequency() {
      \t   return $(ClockSource);
      \t}\n\n
   ]]></template>


   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <!-- _____________ Common __________________ -->
   <projectActionList id = "spi_files" >
      <copy source="Project_Headers/spi-MK.h"            target="Project_Headers/spi.h"             overwrite="true"  derived="true" />
      <copy source="Sources/spi-MK.cpp"                  target="Sources/spi.cpp"                   overwrite="true"  derived="true" />
      <copy source="Snippets/spi-example.cpp"            target="Snippets/spi-example.cpp"          overwrite="true"  derived="true" />
      <copy source="Snippets/spi-N-config-example.cpp"   target="Snippets/spi-N-config-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/spi-2-config-example.cpp"   target="Snippets/spi-2-config-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/spi-flash-example.cpp"      target="Snippets/spi-flash-example.cpp"    overwrite="true"  derived="true" />
      <copy source="Snippets/at45db041e.h"               target="Snippets/at45db041e.h"             overwrite="true"  derived="true" />
   </projectActionList>

   <!-- _____________ Startup __________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- _____________ SIM configuration __________________ -->
   <category name="Advanced" description="SIM configuration">
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!-- _____________ Signal mapping __________________ -->
   <signals enabledBy="enablePeripheralSupport" />

</peripheralPage>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- cmp_base.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <constant key="disable_peripheral" value='"cmp->CR1 = CMP_CR1_EN(0);"' type="String" />

   <!-- ____ Class Declaration ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <!-- ____ Instance control ________ -->
   <constant key="_can_create_instance" value="true" type="Boolean" />

   <equation key="suppressIrqHandler"         value="" />
   <equation key="irq_parameters"             value="const CmpStatus &amp;status"  />
   <equation key="irq_dummy_parameters"       value="const CmpStatus &amp;"  />
   <equation key="irq_call"                   value="cmpStatus"      />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <variable key="cmp_holder"                   type="String" expression='"Comparitor"' />
   <!-- constant key="window_input" value='"PDB"'   description="External Window input" / -->
   <!--  constant key="trigger"      value='"LPTMR"'      description="External Trigger input" / -->

   <stringOption key="window_input" 
      enabledBy="cmp_mode==(6,7,8)"
      hidden="true"
      derived="true"
      description="External Window input"
      value="PDB"
   />   

   <stringOption key="sample_input" 
      enabledBy="cmp_mode==(2,4)"
      hidden="true"
      derived="true"
      description="External Window input"
      value="PDB"
   />   

   <stringOption key="trigger"  condition="cmp_cr1_trigm_present"
      hidden="true"
      derived="true"
      enabledBy="cmp_cr1_trigm"
      description="External Trigger input"
      value="LPTMR"
   />   

   <aliasOption key="cmp_mode" locked="false" />
   
   <graphic key="cmp_config_graphics"
      var="cmp_holder"
      description="Comparator Configuration"
      toolTip="Opens a dialogue to configure the comparator" >
      
      <graphicBox       x="10" y="10" params="0,0, x1000, y400, x" >
         <graphicItem id="Mode of operation"  var="cmp_mode"  type="variableBox" params="250, 25,  240, large"                          />

         <!-- DAC -->         
         <graphicItem type="polygon"     id="DAC,x+10,y+25" var="cmp_daccr_vosel"     params="120:240, y+40,i, y+40, +40:-20,i, +40:-20,o, -80:-40" />
         <graphicItem type="node"                           var="cmp_daccr_dacen"     params="180,280"              />
         <graphicItem type="variableBox" id="Reference"     var="cmp_daccr_vrsel"     params="120,360,  180, small, on-60"    />
         <graphicItem type="connector"                                                params="DAC,0, Input +,0, x"            />
         <graphicItem type="connector"                                                params="DAC,0, Input -,0, x"            />
         <graphicItem type="connector"                                                params="Reference,0, DAC,0, y,x"        />

         <!-- CMP -->
         <graphicItem type="variableBox" id="Input +"       var="cmp_muxcr_psel"      params="130, 105,  250, large, is100, oe"    />
         <graphicItem type="variableBox" id="Input -"       var="cmp_muxcr_msel"      params="130, 205,  250, large, is100, oe"    />
                            
         <graphicItem type="connector"                                                params="Input +,0, CMP,0, (x-30),y,x"            />
         <graphicItem type="connector"                                                params="Input -,0, CMP,1, (x-30),y,x"            />
         <graphicItem type="polygon"     id="CMP,x+20,y+30,NOVALUE"  var="cmp_cr1_en" params="300:115, y+20,i, y+40,i, y+20, +20:-10,i, +30:-15,i, +30:-15,o" />

         <!-- Inversion -->
         <graphicItem type="connector"                                                params="CMP,0, Polarity,0"     />
         <graphicItem type="variableBox" id="Polarity"      var="cmp_cr1_inv"         params="460, 155,  90, large"    />
                                                            
         <!-- Window -->
         <graphicItem type="connector"                                                params="Polarity,0,      Window,0"     />
         <graphicItem type="variableBox" id="Window"        var="cmp_cr1_we"          params="580, 155,  90, large, iw,is-30, is+30,oe"    />
                                                            
         <graphicItem type="connector"                                                  params="Window,0, Filter,0, x,y"     />
         <graphicItem type="variableBox" id="Filter"        var="cmp_cr0_filter_cnt"    params="730, 155,  150, large, iw,is+50,oe"    />
         <graphicItem type="variableBox" id="fi,NONAME,"    var="cmp_fpr_filt_interval" params="730, 185,  150, small, is+50"    />
                                                            
         <graphicItem type="connector"                                                params="Filter,0, Action,0" />
         <graphicItem type="variableBox" id="Action"        var="cmp_scr_interrupt"   params="885, 155,  100, large, oe, os"      />
         <graphicItem type="connector"                                                params="Action,0, IRQ,0"            />
         <graphicItem type="node"        id="IRQ,x+40,y+17" var="cmp_scr_interrupt"   params="1000, 155"                  />

         <graphicItem type="connector"                      var="cmp_scr_dmaen"       params="Action,1, Dma,0"               />
         <graphicItem type="variableBox" id="Dma"           var="cmp_scr_dmaen"       params="885,  250,  100, large, in" />
         <graphicItem type="connector"                                                params="Dma,0, DMA,0"               />
         <graphicItem type="node"        id="DMA,x+40,y+17" var="cmp_scr_dmaen"       params="1000, 250"                  />

         <graphicItem type="variableBox" id="Hysteresis"    var="cmp_cr0_hystctr"     params="400, 235,  140, small, on"    />
         <graphicItem type="variableBox" id="Speed"         var="cmp_cr1_pmode"       params="400, 255,  140, small"        />
         <graphicItem type="connector"                                                params="Hysteresis,0, CMP,3, x,y"     />
         
         <if  condition="cmp_cr1_trigm_present" >
            <graphicItem type="variableBox" id="Trigger In.0"      var="trigger"         params="320, 450,  140, small, on"             />
            <graphicItem type="connector"                                                params="Trigger In.0,0, Trigger In,0, x,y"       />
            <graphicItem type="node"        id="Trigger In,NONAME" var="trigger"         params="320, 400, is, on"                      />
            <graphicItem type="connector"                                                params="Trigger In,0, Trigger,0, (y+20),x,y"     />
   
            <graphicItem type="variableBox" id="Trigger"       var="cmp_cr1_trigm"       params="320, 360,  140, small,on,is"            />
            <graphicItem type="connector"                      var="trigger"             params="Trigger,0, DAC,1, y-30,d,x,y"            />
            <graphicItem type="connector"                      var="trigger"             params="Trigger,0, CMP,2"                      />
         </if>
         

         <graphicItem type="connector"                                                params="Window,0, COS,1, x+10,d,y"     />
         <graphicItem type="connector"                                                params="Filter,0, COS,2, x+10,d,y"     />
         <graphicItem type="mux"         id="COS"            var="cmp_cr1_output"     params="860, 70, 0, normal"       />
         <graphicItem type="connector"                                                params="COS,0, COUT,0"     />
         <graphicItem type="node"        id="COUT,x+40,y+17" var="cmp_cr1_output"     params="1000, 70"                />


         <graphicItem type="variableBox" id="Clock Prescaler" var="cmp_fpr_filt_per"  params="600, 270,  120, large, iw"    />
         <graphicItem type="variableBox" id="fp,NONAME,"      var="cmp_filterPeriod"  params="600, 300,  120, small"    />
         
         <graphicItem type="connector"                                                  params="Clock Prescaler,0, Filter Clock,0, x+20,y,x"     />
         <graphicItem type="mux"         id="Filter Clock,x-30,y+70"  var="cmp_cr1_se"  params="740, 280, 0"       />
         <graphicItem type="connector"                                                  params="Filter Clock,0, fi,0, x,y"     />

         <graphicItem type="variableBox" id="Clock Config"   var="cmpClockConfig"     params="600, 450, 300, small" />
         <graphicItem type="variableBox" id="Input Clock.0"  var="input_clock"        params="600, 470, 300, small, on-100" />
         <graphicItem type="connector"                                                params="Input Clock.0,0, Input Clock,0, x,y"     />
         <graphicItem type="node"        id="Input Clock,NONAME" var="input_clock"    params="500, 400, is, on"                />
         <graphicItem type="connector"                                                params="Input Clock,0, Clock Prescaler,0, y,d,x"     />
         <graphicItem type="connector"                                                params="Input Clock,0, Window,1, (y+30),x,y"     />
         
         <graphicItem type="variableBox" id="Window In.0"        var="window_input"   params="830, 450,  120, small, on"    />
         <graphicItem type="variableBox" id="Sample In.0"        var="sample_input"   params="830, 470,  120, small, on"    />
         <graphicItem type="connector"                           var="window_input"   params="Window In.0,0, Window In,0, x,y"     />
         <graphicItem type="connector"                           var="sample_input"   params="Sample In.0,0, Window In,0, x,y"     />
         <graphicItem type="node"        id="Window In,NONAME"   var="window_input"   params="800, 400, is, on"                />
         <graphicItem type="connector"                           var="sample_input"   params="Window In,0, Filter Clock,1, y-40,x-100,y,d,x"     />
         <graphicItem type="connector"                           var="window_input"   params="Window In,0, Window,2,       y-40,x-100,(y+40),x"     />
         
      </graphicBox>
      
   </graphic>

   <!-- Interrupts and DMA -->
   <choiceOption key="cmp_scr_interrupt" condition="cmp_scr_ier_present || cmp_scr_ief_present"
      enabledBy="irqHandlingMethod&amp;&amp;(cmp_cr1_en)"
      typeName="CmpEvent"
      baseType="uint8_t"
      valueFormat="CMP_SCR_IER(%s),CMP_SCR_IEF(%s)"
      description="Action on transition"
      toolTip="Enables interrupt request on comparator transition">
      <choice value="0,0" name="Disabled"     enum="Disabled"  />
      <choice value="1,1" name="Rising edge"  enum="OnRising"  />
      <choice value="1,0" name="Falling edge" enum="OnFalling" />
      <choice value="1,0" name="Either edge"  enum="OnEither"  />
   </choiceOption>

   <binaryOption key="cmp_scr_dmaen" condition="cmp_scr_dmaen_present"
      enabledBy="cmp_scr_interrupt>0"
      typeName="CmpDma"
      baseType="uint8_t"
      description="DMA Enable Control"
      toolTip="Enables the DMA transfer triggered from the CMP module (If DMA supported by device)\n
               When this field is set, a DMA request is asserted when CFR or CFF is set">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  />
   </binaryOption>

   <!--  Clocking -->
   <title description="Clocking" />

   <choiceOption key="cmpClockConfig"
      target="input_clock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for ticks and time calculations" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="input_clock"
      enabledBy="cmp_mode==(3,5,6,7,8)"
      locked="true"
      derived="true"
      units="Hz"
      description="Frequency of CMP input Clock" />

   <!--  Configuration -->
   <title description="Configuration" />

   <choiceOption key="cmp_cr0_hystctr" condition="cmp_cr0_hystctr_present"
      enabledBy="cmp_cr1_en"
      typeName="CmpHysteresis"
      baseType="uint8_t"
      description="Comparator hard block hysteresis control"
      toolTip="Defines the programmable hysteresis level.\n
               The hysteresis values associated with each level are device specific">
      <choice value="0" name="Level 0" enum="Level_0" />
      <choice value="1" name="Level 1" enum="Level_1" />
      <choice value="2" name="Level 2" enum="Level_2" />
      <choice value="3" name="Level 3" enum="Level_3" />
   </choiceOption>

   <!-- ____ CR1 ________ -->

   <binaryOption key="cmp_cr1_pmode" condition="cmp_cr1_pmode_present"
      enabledBy="cmp_cr1_en"
      typeName="CmpPower"
      baseType="uint8_t"
      description="Power Mode Select"
      toolTip="Selects trade-off between speed and power consumption">
      <choice value="0" name="Low-Speed"  enum="LowSpeed"  />
      <choice value="1" name="High-Speed" enum="HighSpeed" />
   </binaryOption>

   <binaryOption key="cmp_cr1_inv" condition="cmp_cr1_inv_present"
      enabledBy="cmp_cr1_en"
      typeName="CmpPolarity"
      baseType="uint8_t"
      description="Comparator Invert"
      toolTip="Allows selection of the polarity of the analog comparator function">
      <choice value="0" name="Not inverted" enum="Normal"   />
      <choice value="1" name="Inverted"     enum="Inverted" />
   </binaryOption>

   <binaryOption key="cmp_cr1_trigm" condition="cmp_cr1_trigm_present"
      enabledBy="cmp_cr1_en"
      typeName="CmpTrigger"
      baseType="uint8_t"
      description="Trigger Mode Enable"
      toolTip="CMP and DAC are configured to CMP Trigger mode.  \n
              CMP Trigger mode depends on an external timer resource to periodically enable \n
              Upon setting TRIGM, the CMP and DAC are placed in a standby state until an \n
              external timer resource trigger is received.">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  />
   </binaryOption>

   <choiceOption key="cmp_cr1_output" condition="cmp_cr1_ope_present || cmp_cr1_cos_present"
      enabledBy="cmp_cr1_en"
      typeName="CmpOutput"
      baseType="uint8_t"
      valueFormat="CMP_CR1_OPE(%s),CMP_CR1_COS(%s)"
      description="Comparator output pin source"
      toolTip="Selects whether the output pin is driven by the filtered or unfiltered comparator output">
      <choice value="0,0" name="Disabled" enum="Disabled"/>
      <choice value="1,1" name="Direct (unfiltered)"  enum="Direct"   />
      <choice value="1,0" name="Filtered"             enum="Filtered" />
   </choiceOption>

   <choiceOption key="cmp_muxcr_psel"
      enabledBy="cmp_cr1_en"
      valueFormat="CMP_MUXCR_PSEL(%s)"
      typeName="CmpInputPlus"
      baseType="uint8_t"
      description="Plus Input Mux Control"
      toolTip="Determines which input is selected for the plus input of the comparator" >
      <choiceExpansion value="%(i)"  enum="%(i)"
                       name='@SignalDescriptionFromIndex(%(i),"^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
                       keys="i" dim="8" />
   </choiceOption>

   <choiceOption key="cmp_muxcr_msel"
      enabledBy="cmp_cr1_en"
      valueFormat="CMP_MUXCR_MSEL(%s)"
      typeName="CmpInputMinus"
      baseType="uint8_t"
      description="Minus Input Mux Control"
      toolTip="Determines which input is selected for the minus input of the comparator" >
      <choiceExpansion value="%(i)"  enum="%(i)"
                       name='@SignalDescriptionFromIndex(%(i),"^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
                       keys="i" dim="8" />
   </choiceOption>

   <!--  choiceOption key="cmp_muxcr_plus"
      hidden="true"
      valueFormat="CMP_MUXCR_PSEL(%s)"
      typeName="CmpInputPlus"
      baseType="uint8_t"
      description="Plus Input Mux Control"
      toolTip="Determines which input is selected for the plus input of the comparator" >
      <choiceExpansion value="%(i)" name='CMP_IN%(i) as positive input' enum="%(i)" keys="i" dim="8" />
   </choiceOption>

   <choiceOption key="cmp_muxcr_minus"
      hidden="true"
      valueFormat="CMP_MUXCR_MSEL(%s)"
      typeName="CmpInputMinus"
      baseType="uint8_t"
      description="Minus Input Mux Control"
      toolTip="Determines which input is selected for the minus input of the comparator" >
      <choiceExpansion value="%(i)" name='CMP_IN%(i) as negative input' enum="%(i)" keys="i" dim="8" />
   </choiceOption -->

   <!-- DAC Configuration -->
   <title description="Internal DAC Configuration" />

   <binaryOption key="cmp_daccr_dacen" condition="cmp_daccr_dacen_present"
      enabledBy="enablePeripheralSupport"
      typeName="CmpDacEnable"
      baseType="uint8_t"
      description="DAC Enable"
      toolTip="Enables the internal DAC">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="cmp_daccr_vrsel" condition="cmp_daccr_vrsel_present"
      enabledBy="cmp_daccr_dacen"
      typeName="CmpDacrefSel"
      baseType="uint8_t"
      description="DAC Reference Voltage Select"
      toolTip="Supply Voltage Reference Source Select">
      <choice value="0" name="Vin1 (Vref_OUT)"  enum="VrefOut" />
      <choice value="1" name="Vin2 (Vdd)"       enum="Vdd"     isDefault="true"/>
   </binaryOption>

   <intOption key="cmp_daccr_vosel" condition="cmp_daccr_vosel_present"
      enabledBy="cmp_daccr_dacen"
      typeName="CmpDacLevel"
      baseType="int8_t"
      description="DAC level"
      toolTip="Specifies the output level of the internal DAC"
      value="31" min="0" max="63"/>

   <!--  Filtering and Sampling -->
   <title description="Filtering and Sampling" />

   <binaryOption key="secondsSupport"
      enabledBy="enablePeripheralSupport"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point is necessary to support specifing CMP filter times in seconds in runtime code.\n
               If not needed, the overhead can be avoided by disabling this option">
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <choiceOption key="cmp_mode"
      enabledBy="enablePeripheralSupport"
      target="cmp_cr1_en;cmp_cr1_we;cmp_cr1_se;cmp_cr0_filter_cnt;cmp_fpr_filt_per"
      valueFormat="%s"
      baseType="uint8_t"
      typeName="CmpFilterMode"
      description="Comparator Filtering Mode"
      toolTip="Comparitor mode of operation">
      <!--                                                                                            cr1_en; cr1_we; cr1_se;cr0_filter_cnt;fpr_filt_per  -->
      <choice value="0" name="1    Disabled"                         enum="Disabled"             ref="false ; false ; false ;     0       ;     0      "  
         toolTip="Comparator is non-functional and consumes no power.\n
                  CMPO is 0 in this mode." />
                  
      <choice value="1" name="2a/b Continuous"                       enum="Continuous"           ref="true  ; false ; false ;     0       ;     0      "    
         toolTip="Mode 2 - Continuous mode\n
                  Both window control and filter blocks are completely bypassed.  \n
                  COUTA,COUT are the output of the comparator, with optional inversion, but without sampling or filtering. \n
                  SCR[COUT] is updated continuously.  \n
                  The path from comparator input pins is operating in combinational unclocked mode." />
                  
      <choice value="2" name="3a   Externally sampled, Non-Filtered" enum="External_NonFiltered" ref="true  ; false ; true  ;     1       ;     0      "    
         toolTip="Mode 3a - Externally clocked Sampling, Non-Filtered\n
                  Window control is bypassed. The filter block operates as a simple Sample and Hold \n
                  COUTA is the output of the comparator, with optional inversion, but without sampling or filtering. \n
                  COUT is COUTA after sampling.  \n
                  The external window/sample input is used to clock the Sample and Hold" />
               
      <choice value="3" name="3b   Internally sampled, Non-Filtered" enum="Internal_NonFiltered" ref="true  ; false ; false ;     1       ;     1      "    
         toolTip="Mode 3a/b - Internally clock Sampling, Non-Filtered mode\n
                  Window control is bypassed. The filter block operates as a simple Sample and Hold \n
                  COUTA is the output of the comparator, with optional inversion, but without sampling or filtering. \n
                  COUT is COUTA after sampling.  \n
                  FILT_PER acts as a prescaler for the bus clock driving the Sample and Hold" />
               
      <choice value="4" name="4a   Externally sampled, Filtered"     enum="External_Filtered"    ref="true  ; false ; true  ;      2      ;     0      "    
         toolTip="Mode 4a/b - Externally clocked Samping, Filtered mode\n
                  Window control is bypassed. The filter is enabled (FILTER_CNT>1). \n
                  COUTA is the output of the comparator, with optional inversion, but without sampling or filtering. \n
                  COUT is COUTA after filtering.  \n
                  The external window/sample input is used to clock the Filter.\n
                  FILTER_CNT determines the filter sample count (width)" />
               
      <choice value="5" name="4b   Internally sampled, Filtered"     enum="Internal_Filtered"    ref="true  ; false ; false ;      2      ;     1      "    
         toolTip="Mode 4a/b - Internally clocked Sampling, Filtered\n
                  Window control is bypassed. The filter is enabled (FILTER_CNT>1). \n
                  COUTA is the output of the comparator, with optional inversion, but without sampling or filtering. \n
                  COUT is COUTA after filtering.  \n
                  FILT_PER acts as a prescaler for the bus clock driving the Filter\n
                  FILTER_CNT determines the filter sample count (width)" />
               
      <choice value="6" name="5a/b Windowed"                         enum="Windowed"             ref="true  ; true  ; false ;     0       ;     0      "    
         toolTip="Mode 5a/b - Windowed mode\n
                  The comparator output is qualified by an external window signal. \n
                  COUTA is the windowed output of the comparator, with optional inversion. \n
                  When enabled by the window, the comparator output is clocked by the bus clock and held otherwise. \n
                  This introduces up to 1 clock delay. " />
               
      <choice value="7" name="6    Windowed, Re-sampled"             enum="Windowed_Resampled"   ref="true  ; true  ; false ;     1       ;     1      "    
         toolTip="Mode 6 - Windowed/Resampled mode\n
                  The comparator output is qualified by an external window signal and then resampled. \n
                  COUTA is the windowed output of the comparator, with optional inversion. \n
                  COUT is COUTA after sampling  \n
                  When enabled by the window, the comparator output is clocked by the bus clock and then resampled at a \n
                  rate determined by the bus clock*FILT_PER to generate COUT. " />
               
      <choice value="8" name="7    Windowed, Filtered"               enum="Windowed_Filtered"    ref="true  ; true  ; false ;     2       ;     1      "    
         toolTip=" Mode 7 - Windowed/Filtered mode\n
                  The comparator output is qualified by an external window signal and then filtered. \n
                  COUTA is the windowed output of the comparator, with optional inversion. \n
                  COUT is COUTA after filtering.  \n
                  When enabled by the window, the comparator output is clocked by the bus clock and then filtered at a \n
                  sample rate determined by the FILT_PER to generate COUT.\n
                  FILTER_CNT determines the filter sample count (width)" />
   </choiceOption>

   <binaryOption key="cmp_cr1_en"
      enabledBy="cmp_mode>0"
      typeName="CmpEnable"
      baseType="uint8_t"
      description="Comparator Enable"
      toolTip="Enable comparator"
      disabledValue="false"
      locked="true"
      derived="true">
      <choice value="0" name="Comparator is disabled" enum="Disabled"  />
      <choice value="1" name="Comparator is enabled"  enum="Enabled"   isDefault="true" />
   </binaryOption>

   <binaryOption key="cmp_cr1_we"
      enabledBy="cmp_cr1_en"
      typeName="CmpWindowEnable"
      baseType="uint8_t"
      description="Windowing Enable"
      toolTip="Enable the use of an external signal to qualify the comparator output (before filtering).\n
               The comparator output is held when the external signal is inactive and\n
               clocked directly by the bus clock when enabled.\n
               Usually a PDB output is available for this purpose."
      disabledValue="false"
      locked="true"
      derived="true">
      <choice value="0" name="Bypassed" enum="Bypassed" />
      <choice value="1" name="Enabled"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="cmp_cr1_se"
      enabledBy="cmp_mode==(2,3,4,5,7,8)"
      typeName="CmpSampleEnable"
      baseType="uint8_t"
      description="Sample Enable"
      toolTip="Select between the divided bus clock and an external clock for the filter block"
      disabledValue="false"
      locked="true"
      derived="true">
      <choice value="0" name="Internal clock" enum="Internal"  />
      <choice value="1" name="External clock" enum="External" isDefault="true" />
   </binaryOption>

   <!-- ____ FPR ________ -->

   <intOption key="cmp_fpr_filt_per"
      enabledBy="cmp_mode==(3,5,7,8)"
      description="Filter Sample Period in ticks"
      toolTip="Specifies the sampling period, in clock cycles, of the comparator output filter \n
               This has no effect if SE=1. In that case, the external SAMPLE signal is used to \n
               determine the sampling period."
      units="ticks"
      baseType="uint8_t"
      disabledValue="0"
      unlockedBy="cmp_mode==(3,5,7,8)"
      value="1" min="(cmp_mode==(0,1,2,4,6))?0:1" max="255"/>

   <floatOption key="cmp_filterPeriod"
      enabledBy="cmp_fpr_filt_per>0"
      ref="(1.0*cmp_fpr_filt_per)/input_clock#input_clock"
      units="s"
      valueFormat="%s"
      description="Filter Sample Period in seconds"
      toolTip="The calculated sampling period of the comparator output filter \n
               This has no effect if SE=1. In that case, the external SAMPLE signal is used to \n
               determine the sampling period."
      derived="true"
      locked="true"
      value="1k" min="0" />

   <choiceOption key="cmp_cr0_filter_cnt"
      unlockedBy="cmp_mode==(4,5,8)"
      enabledBy="cmp_cr1_en"
      valueFormat="CMP_CR0_FILTER_CNT(%s)"
      typeName="CmpFilterSamples"
      baseType="uint8_t"
      description="Filter Sample Count"
      toolTip="Represents the number of consecutive samples that must agree prior \n
               to the comparator output filter accepting a new output state">
      <choice value="0" name="Bypassed"             enum="Bypassed"       enabledBy="cmp_mode==(0,1,6)" />
      <choice value="1" name="Simple sampling"      enum="SimpleSampling" enabledBy="cmp_mode==(2,3,7)" />
      <choice value="2" name="2 samples must agree" enum="2"              enabledBy="cmp_mode==(4,5,8)" />
      <choice value="3" name="3 samples must agree" enum="3"              enabledBy="cmp_mode==(4,5,8)" />
      <choice value="4" name="4 samples must agree" enum="4"              enabledBy="cmp_mode==(4,5,8)" />
      <choice value="5" name="5 samples must agree" enum="5"              enabledBy="cmp_mode==(4,5,8)" />
      <choice value="6" name="6 samples must agree" enum="6"              enabledBy="cmp_mode==(4,5,8)" />
      <choice value="7" name="7 samples must agree" enum="7"              enabledBy="cmp_mode==(4,5,8)" />
   </choiceOption>

   <!-- intOption key="cmp_cr0_filter_cnt"
      unlockedBy="(cmp_mode==4)||(cmp_mode==5)||(cmp_mode==8)"
      enabledBy="((cmp_mode>=2)&amp;&amp;(cmp_mode&lt;=5))||(cmp_mode&gt;=7)"
      disabledValue="0"
      description="Filter Sample Count"
      typeName="CmpFilterSamples"
      baseType="uint8_t"
      toolTip="Represents the number of consecutive samples that must agree prior \n
               to the comparator output filter accepting a new output state"
      value="2" min="1" max="7"/ -->

   <floatOption key="cmp_fpr_filt_interval"
      enabledBy="cmp_mode==(2,3,4,5,7,8)"
      ref="cmp_filterPeriod*cmp_cr0_filter_cnt"
      valueFormat="%s_seconds"
      description="Filter Sample Interval in seconds"
      toolTip="The calculated interval of the comparator output filter (sample period*number of samples)."
      derived="true"
      locked="true"
      units="s" />

   <choiceOption key="cmp_cr1_mode"
      hidden="true"
      typeName="CmpMode"
      baseType="uint8_t"
      valueFormat="CMP_CR1_SE(%s),CMP_CR1_WE(%s)"
      description="Operating mode"
      toolTip="Selects operation in sampling or windowed mode">
      <choice value="0,0" name="Direct"         enum="Direct"   />
      <choice value="1,0" name="Sampling mode"  enum="Sampling" />
      <choice value="0,1" name="Windowing mode" enum="Windowed" />
   </choiceOption>

   <choiceOption key="cmp_scr_edge" condition="cmp_scr_cfr_present&amp;&amp;cmp_scr_cff_present"
      valueFormat="CMP_SCR_CFR(%s),CMP_SCR_CFF(%s)"
      hidden="true"
      derived="true"
      typeName="CmpEventId"
      baseType="uint8_t"
      toolTip="Indicates edge detected"
      description="Edge detection flag" >
      <choice value="0,0" name="None"         enum="None" />
      <choice value="1,0" name="Rising Edge"  enum="RisingEdge" />
      <choice value="0,1" name="Falling Edge" enum="FallingEdge" />
      <choice value="1,1" name="Both Edges"   enum="BothEdges" />
   </choiceOption>

   <intOption key="cmp_scr_cout" condition="cmp_scr_cout_present"
      enabledBy="enablePeripheralSupport"
      derived="true"
      hidden="true"
      typeName="uint8_t"
      description="Analog Comparator Output"
      toolTip="Returns the current value of the Analog Comparator output,"
   />

<!-- ====================================================================================================== -->
<!--     START BasicInfo Class      -->
<!-- ====================================================================================================== -->

   <!-- BasicInfo Instance pointer and Constructors  -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Pointer to $(_BASENAME) hardware instance
      \tvolatile $(_Type) * const $(_basename);
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Constructor
      \t *
      \t * @param $(_basename) $(_BASENAME) hardware instance
      \t */
      \tconstexpr $(_BasicInfo)(volatile $(_Type) * $(_basename)) : $(_basename)($(_basename)) {
      \t}
      \t\n
   ]]></template>

   <!-- Shared clock selection -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Get input clock frequency
      \t * (Shared by all peripherals)
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic inline uint32_t getInputClockFrequency() {
      \t   return SystemBusClock;
      \t}
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/** Class to static check output is mapped to a pin - Assumes existence */
      \ttemplate<int cmpOutput, typename Info> class CheckOutputIsMapped {
      \t
      \t   // Check mapping - no need to check existence
      \t   static constexpr bool Test1 = (Info::info[cmpOutput].pinIndex != PinIndex::UNMAPPED_PCR);
      \t
      \t   static_assert(Test1, "CMP output is not mapped to a pin - Modify Configure.usbdm");
      \t
      \tpublic:
      \t   /** Dummy function to allow convenient in-line checking */
      \t   static constexpr void check() {}
      \t};
      \t
      \t/** Class to static check cmpInput exists and is mapped to a pin */
      \ttemplate<int cmpInput, typename Info> class CheckPinExistsAndIsMapped {
      \t   // Tests are chained so only a single assertion can fail so as to reduce noise
      \t
      \t   // Out of bounds value for function index
      \t   static constexpr bool Test1 = (cmpInput>=0) && (cmpInput<(Info::numSignals));
      \t   // Function is not currently mapped to a pin
      \t   static constexpr bool Test2 = !Test1 || (Info::info[cmpInput].gpioBit != PinIndex::UNMAPPED_PCR);
      \t   // Non-existent function and catch-all. (should be INVALID_PCR)
      \t   static constexpr bool Test3 = !Test1 || !Test2 || (Info::info[cmpInput].gpioBit >= PinIndex::MIN_PIN_INDEX);
      \t
      \t   static_assert(Test1, "Illegal CMP Input - Check Configure.usbdm for available inputs");
      \t   static_assert(Test2, "CMP input is not mapped to a pin - Modify Configure.usbdm");
      \t   static_assert(Test3, "CMP input doesn't exist in this device/package - Check Configure.usbdm for available input pins");
      \t
      \tpublic:
      \t   /** Dummy function to allow convenient in-line checking */
      \t   static constexpr void check() {}
      \t};
      \t
      \t//! Pin number in Info table for comparator output if mapped to a pin
      \tstatic constexpr int outputPin  = 8;
      \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}
      \t
      \t/**
      \t * Converts time in ticks to time in seconds
      \t *
      \t * @param[in] ticks Time interval in ticks
      \t *
      \t * @return Time in ticks
      \t */
      \tstatic Seconds convertTicksToSeconds(const Ticks &ticks) {
      \t
      \t   return (float)ticks/getClockFrequency();
      \t}
      \t
      \t/**
      \t * Converts time in seconds to time in ticks
      \t *
      \t * @param[in] seconds Time interval in seconds
      \t *
      \t * @return Time in ticks
      \t */
      \tstatic Ticks convertSecondsToTicks(const Seconds &seconds) {
      \t
      \t   uint32_t res = roundf((float)seconds*getClockFrequency());
      \t   if (res >= 256) {
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   return Ticks(res);
      \t}
      \t\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     START BasicInfo/Info duplicated methods -->
<!-- ====================================================================================================== -->

<for
   keys="   static    : const    : where     : guard                                      "
   values=" ''        : 'const ' : basicInfo : $(_BasicInfoGuard)                         ;
            'static ' : ''       : info      : $(_InfoGuard)                              "  >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field           : set   : get   : clear : genCode                 : name"
        values="

         cmp_cr0_filter_cnt       : true  : true  : false : enableGettersAndSetters : FilterCount;
         cmp_cr0_hystctr      : true  : true  : false : enableGettersAndSetters : Hysteresis;

         cmp_cr1_se           : true  : true  : false : enableGettersAndSetters : SamppleEnable;
         cmp_cr1_we           : true  : true  : false : enableGettersAndSetters : WindowingEnable;
         cmp_cr1_trigm        : true  : true  : false : enableGettersAndSetters : TriggerMode;
         cmp_cr1_pmode        : true  : true  : false : enableGettersAndSetters : Power;
         cmp_cr1_inv          : true  : true  : false : enableGettersAndSetters : Invert;
         cmp_cr1_cos          : true  : true  : false : enableGettersAndSetters : OutputSelect;
         cmp_cr1_ope          : true  : true  : false : enableGettersAndSetters : OutputEnable;

         cmp_cr1_en           : true  : true  : false : enableGettersAndSetters : Enable;

         cmp_fpr_filt_per     : true  : true  : false : enableGettersAndSetters : FiltPeriod;

         cmp_scr_dmaen        : true  : true  : false : enableGettersAndSetters : DmaEnable;
         cmp_scr_edge         : false : true  : w1cIm : true                    : Edge;
         cmp_scr_cout         : false : true  : false : true                    : OutputState;
         cmp_scr_interrupt    : true  : true  : false : true                    : InterruptFlag;

         cmp_daccr_dacen      : true  : true  : false : enableGettersAndSetters : DacEnable;
         cmp_daccr_vrsel      : true  : true  : false : enableGettersAndSetters : DacReferenceSelect;
         cmp_daccr_vosel      : true  : true  : false : true                    : DacLevel;

         cmp_muxcr_psel       : true  : true  : false : enableGettersAndSetters : PlusSelect;
         cmp_muxcr_msel       : true  : true  : false : enableGettersAndSetters : MinusSelect" >
      <variableTemplate location="%(where)" condition="%(set)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition="%(get)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Get %description
         \t * (%variables)
         \t *
         \t * @return %tooltip
         \t */
         \t%(static)%returnType get%(name)() %(const){
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="(%variables)"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void clear%(name)(%params) %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1cIm"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void clear%(name)() %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template location="%(where)" codeGenCondition="%(guard)" >
   <![CDATA[
      \t/**
      \t * Set Continuous input - Mode 2a/b.
      \t * Assumes basic configuration done
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
      \t */
      \t%(static)void setInputContinous() %(const){
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(0);
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpMode_Direct;
      \t   cmp->FPR = 0;
      \t}
      \t
      \t/**
      \t * Set Sampled, Non-Filtered input - Modes 3a/3b.
      \t *
      \t * Assumes basic configuration done
      \t * The TRGMUX is used as the CmpSampleEnable_External source.
      \t *
      \t *                                                          CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 3a   Sampled, Non-Filtered, external     1      0      1      1              X     COUTA combinational, COUT sampled by external clk pin
      \t * 3b   Sampled, Non-Filtered, internal     1      0      0      1             >=1    COUTA combinational, COUT sampled by busclk/PFR
      \t *
      \t * @param[in] CmpSampleEnable          Filter clock source
      \t * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
      \t *                                     Only applicable if CmpSampleEnable=CmpSampleEnable_Internal
      \t */
      \t%(static)void setInputSampled(
      \t      CmpSampleEnable  CmpSampleEnable,
      \t      int              cmpFilterSamplePeriod=1
      \t      ) %(const){
      \t   usbdm_assert((CmpSampleEnable == CmpSampleEnable_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(1);
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable|CmpWindowEnable_Bypassed;
      \t   cmp->FPR = cmpFilterSamplePeriod;
      \t}
      \t
      \t/**
      \t * Set Sampled, Filtered input - Modes 4a/4b.
      \t *
      \t * Assumes basic configuration done
      \t * The TRGMUX is used as the CmpSampleEnable_External source.
      \t *
      \t *                                                          CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 4a   Sampled, Filtered, external         1      0      1     >=2             X     COUTA combinational, COUT filtered by external clk pin
      \t * 4b   Sampled, Filtered, internal         1      0      0     >=2            >=1    COUTA combinational, COUT filtered by busclk/PFR
      \t *
      \t * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2)
      \t * @param[in] cmpSampleEnable          Filter clock source
      \t * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255). \n
      \t *                                     Only applicable if CmpSampleEnable_Internal
      \t */
      \t%(static)void setInputFiltered(
      \t      CmpFilterSamples      cmpFilterSamples,
      \t      CmpSampleEnable       cmpSampleEnable=CmpSampleEnable_Internal,
      \t      uint8_t               cmpFilterSamplePeriod=1
      \t      ) %(const){
      \t   usbdm_assert((cmpSampleEnable == CmpSampleEnable_External) || (cmpFilterSamplePeriod>=1), "Illegal parameters");
      \t   usbdm_assert((cmpFilterSamples>1) , "Illegal parameter combination");
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|cmpSampleEnable|CmpWindowEnable_Bypassed;
      \t   cmp->FPR = cmpFilterSamplePeriod;
      \t}
      \t
      \t/**
      \t * Set Windowed input - Modes 5a/5b.
      \t *
      \t * Assumes basic configuration done
      \t * The TRGMUX is used as the Window source.
      \t *
      \t *                                                          CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 5a/b Windowed                            1      1      0      0              0     COUT == COUTA clocked by bus clock when Window=1
      \t */
      \t%(static)void setInputWindowed() %(const){
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|0;
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      \t   cmp->FPR = 0;
      \t}
      \t
      \t/**
      \t * Set Windowed, Re-sampled input - mode 6.
      \t * Assumes basic configuration done.
      \t *                                                          CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 6    Windowed, Re-sampled                1      1      0      1             >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
      \t *
      \t * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
      \t */
      \t%(static)void setInputWindowedResampled(
      \t      int  cmpFilterSamplePeriod=1
      \t      ) %(const){
      \t   usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|CMP_CR0_FILTER_CNT(1);
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      \t   cmp->FPR = cmpFilterSamplePeriod;
      \t}
      \t
      \t/**
      \t * Set Windowed, Filtered input - mode 7.
      \t * Assumes basic configuration done.
      \t *
      \t *                                                          CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 7    Windowed, Filtered                  1      1      0     >=2            >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
      \t *
      \t * @param[in] cmpFilterSamples         Number samples that must agree before COUT changes (>=2).
      \t * @param[in] cmpFilterSamplePeriod    Period of internal sample filter (1..255).
      \t */
      \t%(static)void setInputWindowedFiltered(
      \t      CmpFilterSamples     cmpFilterSamples,
      \t      int                  cmpFilterSamplePeriod=1
      \t      ) %(const){
      \t   usbdm_assert(cmpFilterSamplePeriod>=1, "Illegal parameters");
      \t   cmp->CR0 = (cmp->CR0&~CMP_CR0_FILTER_CNT_MASK)|cmpFilterSamples;
      \t   cmp->CR1 = (cmp->CR1&~(CMP_CR1_SE_MASK|CMP_CR1_WE_MASK))|CmpSampleEnable_Internal|CmpWindowEnable_Enabled;
      \t   cmp->FPR = cmpFilterSamplePeriod;
      \t}
      \t\n
   ]]>
   </template>

   <template location="%(where)" codeGenCondition="%(guard)" >
   <![CDATA[
      \t/** Maximum DAC value corresponding to Vref) */
      \tstatic constexpr CmpDacLevel MAXIMUM_DAC_VALUE = CmpDacLevel(CMP_DACCR_VOSEL_MASK);
      \t
      \t/**
      \t * Enable and configure DAC
      \t *
      \t * @param[in]  level        DAC level to select (0...MAXIMUM_DAC_VALUE) => (Vref/MAXIMUM_DAC_VALUE...Vref)
      \t * @param[in]  cmpDacSource Reference source select
      \t */
      \t%(static)void configureDac(
      \t      uint8_t       level,
      \t      CmpDacrefSel  cmpDacSource) %(const){
      \t   cmp->DACCR = CMP_DACCR_DACEN_MASK|cmpDacSource|CMP_DACCR_VOSEL(level);
      \t}
      \t
      \t/**
      \t * Set input filtering and hysteresis
      \t *
      \t * @param[in] cmpFilterSamples Filtering clock pulses
      \t * @param[in] cmpHysteresis    Hysteresis level
      \t *
      \t * @note Window mode may not be selected with external filter.
      \t */
      \t%(static)void setInputConditioning(CmpFilterSamples cmpFilterSamples, CmpHysteresis cmpHysteresis) %(const){
      \t   cmp->CR0 = cmpFilterSamples|cmpHysteresis;
      \t}
      \t\n
   ]]>
   </template>
</for>

<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // General setup
      \t *   CmpEnable_Enabled ,          // Comparator Enable - Comparator is enabled
      \t *   CmpMode_Direct ,             // Operating mode - Direct
      \t *   CmpTrigger_Enabled ,         // Trigger Mode Enable - Trigger mode is enabled
      \t *   CmpPower_HighSpeed ,         // Power Mode Select - High-Speed Comparison mode
      \t *   CmpPolarity_Inverted ,       // Comparator Invert - Inverted
      \t *   CmpOutput_Direct ,           // Comparator output pin source - Direct (unfiltered)
      \t *   CmpHysteresis_Level_2 ,      // Comparator hard block hysteresis control - Level 2
      \t *   CmpDma_Disabled ,            // DMA Enable Control - Disabled
      \t *
      \t *   // Interrupt handling - must be in this order
      \t *   CmpEvent_OnFalling ,         // Action on transition - Falling edge
      \t *   cmpCallback,                 // Call-back to execute on event (if interrupts are enabled)
      \t *
      \t *   // Filter settings - must be in this order
      \t *   CmpFilterSamples_4 ,         // Filter Sample Count - 4 sample must agree
      \t *   100_ticks ,                  // Filter Sample Period in ticks or seconds (if support is enabled)
      \t *
      \t *   // DAC Settings - must be in this order
      \t *   CmpDacEnable_Enabled ,       // DAC Enable - Enabled
      \t *   CmpDacrefSel_Vdd ,           // DAC Reference Voltage Select - Vin2 (Vdd)
      \t *   31 ,                         // DAC level
      \t *
      \t *   // Inputs
      \t *   cmp0Input_D7.plusPin ,       // Plus Input Mux Control - D7
      \t *   Cmp0Input_D21::minusPin,     // Minus Input Mux Control - D21
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo::Init class Member variables ________ -->

   <for keys=" type        : variables                                            : init    "
       values="%baseType   : cmp_cr0_filter_cnt,cmp_cr0_hystctr                   :   0      ;
               %baseType   : cmp_cr1_se,cmp_cr1_we,cmp_cr1_pmode,cmp_cr1_inv,
                             cmp_cr1_cos,cmp_cr1_ope,cmp_cr1_en                   :   0      ;
               %baseType   : cmp_fpr_filt_per                                     :   0      ;
               %baseType   : cmp_scr_dmaen,cmp_scr_interrupt,cmp_scr_cfr,
                             cmp_scr_cff                                          :   0      ;
               %baseType   : cmp_daccr_dacen,cmp_daccr_vrsel,cmp_daccr_vosel      :   0      ;
               %baseType   : cmp_muxcr_psel,cmp_muxcr_msel                        :   0      ;
               %baseType   : cmp_filterPeriod                                     :   0_s       " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx" >
      <![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]>
      </variableTemplate>
   </for>

   <!-- ____ BasicInfo::Init class Constructors ____________ -->

   <for keys="r"
      values="
            cmp_cr1_en;cmp_cr1_mode;cmp_cr1_trigm;
            cmp_cr1_pmode;cmp_cr1_inv;cmp_cr1_output;
            cmp_cr0_hystctr;
            cmp_scr_dmaen;cmp_scr_interrupt;
            cmp_muxcr_psel;cmp_muxcr_msel;
            cmp_cr0_filter_cnt;cmp_fpr_filt_per;cmp_filterPeriod;
            cmp_daccr_dacen;cmp_daccr_vrsel;cmp_daccr_vosel
            " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::Init class      -->
<!-- ====================================================================================================== -->

   <!-- ____ Interrupt handling _____________ -->

   <template where="definitions" discardRepeats="true" >
   <![CDATA[
      \t/**
      \t * Comparator event identification
      \t */
      \t/**
      \t * Used to represent the comparator status for interrupt handler
      \t */
      \tstruct CmpStatus {
      \t   CmpEventId event:8;   //!< Event triggering handler
      \t   bool       state:8;   //!< State of CMPO at event
      \t
      \t   constexpr CmpStatus(CmpEventId event, uint8_t  state) : event(event), state(state) {}
      \t};
      \t\n
   ]]>
   </template>

   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t/**
      \t * $(_Class) interrupt handler
      \t * Passes control to call-back function
      \t */
      \tstatic void irqHandler() {
      \t
      \t   // Get status bits (+ current register value)
      \t   uint8_t status = cmp->SCR;
      \t
      \t   // Clear interrupt flags
      \t   cmp->SCR = status;
      \t
      \t   // Create status from snapshot
      \t   CmpStatus cmpStatus {
      \t      // Extract status bits
      \t      CmpEventId(
      \t         status&(CMP_SCR_CFR_MASK|CMP_SCR_CFF_MASK)),
      \t                 bool(status&CMP_SCR_COUT_MASK)
      \t   };
      \t
      \t   // Execute call-back
      \t   sCallback($(irq_call));
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo class Configure methods ____ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/*                                                             CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT   FPR.FILT_PER
      \t * 1  Disabled                              0      X      X      X                X
      \t * 2a/b Continuous                          1      0      0     (0     or         0)    COUT == COUTA
      \t * 3a   Sampled, Non-Filtered, external     1      0      1      1                X     COUTA combinational, COUT sampled by external clk pin
      \t * 3b   Sampled, Non-Filtered, internal     1      0      0      1               >=1    COUTA combinational, COUT sampled by busclk/PFR
      \t * 4a   Sampled, Filtered, external         1      0      1     >=2               X     COUTA combinational, COUT filtered by external clk pin
      \t * 4b   Sampled, Filtered, internal         1      0      0     >=2              >=1    COUTA combinational, COUT filtered by busclk/PFR
      \t * 5a/b Windowed                            1      1      0      0                0     COUT == COUTA clocked by bus clock when Window=1
      \t * 6    Windowed, Re-sampled                1      1      0      1               >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
      \t * 7    Windowed, Filtered                  1      1      0     >=2              >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
      \t */
      \t
      \t/**
      \t * Base configuration - Continuous sampling: Modes 2a/2b.
      \t * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
      \t * DAC is initially disabled.
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
      \t *
      \t * @param cmpPower        Power level. Tradeoff between speed and power consumption
      \t * @param cmpHysteresis   Hysteresis level for analogue comparator
      \t * @param cmpPolarity     Allows inversion of the comparator output
      \t */
      \tvoid configure(
      \t      CmpPower       cmpPower       = CmpPower_HighSpeed,
      \t      CmpHysteresis  cmpHysteresis  = CmpHysteresis_Level_2,
      \t      CmpPolarity    cmpPolarity    = CmpPolarity_Normal
      \t      ) const {
      \t
      \t   // Initialise hardware
      \t   cmp->CR1   = CmpEnable_Enabled|cmpPower|cmpPolarity;
      \t   cmp->CR0   = CMP_CR0_FILTER_CNT(0)|cmpHysteresis;
      \t   cmp->FPR   = 0;
      \t   cmp->SCR   = CMP_SCR_IER(0)|CMP_SCR_IEF(0);
      \t   cmp->DACCR = (CMP_DACCR_VOSEL_MASK>>1)&CMP_DACCR_VOSEL_MASK;
      \t}
      \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param $(_basename)           Hardware instance pointer
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(
      \t               volatile $(_Type) *$(_basename),
      \t               const Init    &init) {
      \t\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values=" cmp_cr1_en                                             : %register = 0 ;
               cmp_fpr_filt_per                                       : uint8_t %registerName = init.%registerName " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx" >
      <![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)&amp;&amp;secondsSupport"
      variables="cmp_fpr_filt_per, cmp_fpr_filt_per"  >
   <![CDATA[
      \t   if (init.filterperiod != 0) {
      \t      %registerName0 = convertSecondsToTicks(init.filterperiod);
      \t   }
   ]]>
   </variableTemplate>
   <for keys=
             " var                                                    : statement            "
      values=" cmp_fpr_filt_per                                       : %register = %registerName ;
               cmp_daccr_dacen,cmp_daccr_vrsel,cmp_daccr_vosel        : %configRegAssignment ;
               cmp_muxcr_psel,cmp_muxcr_msel                          : %configRegAssignment ;
               cmp_cr0_filter_cnt,cmp_cr0_hystctr                         : %configRegAssignment ;
               cmp_scr_dmaen,cmp_scr_interrupt                        : %configRegAssignment ;
               cmp_cr1_en,cmp_cr1_mode,cmp_cr1_pmode,cmp_cr1_inv,
               cmp_cr1_output                                         : %configRegAssignment  " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="%(var)"
      linePadding="xxx"
      ><![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const Init &init) const {
      \t
      \t   configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START Info class      -->
<!-- ====================================================================================================== -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/*                                                             CmpFilterSamples cmpFilterSamplePeriod
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT   FPR.FILT_PER
      \t * 1  Disabled                              0      X      X      X                X
      \t * 2a/b Continuous                          1      0      0     (0     or         0)    COUT == COUTA
      \t * 3a   Sampled, Non-Filtered, external     1      0      1      1                X     COUTA combinational, COUT sampled by external clk pin
      \t * 3b   Sampled, Non-Filtered, internal     1      0      0      1               >=1    COUTA combinational, COUT sampled by busclk/PFR
      \t * 4a   Sampled, Filtered, external         1      0      1     >=2               X     COUTA combinational, COUT filtered by external clk pin
      \t * 4b   Sampled, Filtered, internal         1      0      0     >=2              >=1    COUTA combinational, COUT filtered by busclk/PFR
      \t * 5a/b Windowed                            1      1      0      0                0     COUT == COUTA clocked by bus clock when Window=1
      \t * 6    Windowed, Re-sampled                1      1      0      1               >=1    COUTA clocked by bus clock when Window=1, COUT re-sampled
      \t * 7    Windowed, Filtered                  1      1      0     >=2              >=1    COUTA clocked by bus clock when Window=1, COUT filtered by bus clock/PFR
      \t */
      \t
      \t/**
      \t * Base configuration - Continuous sampling: Modes 2a/2b.
      \t * Includes enabling clock and configuring all pins if mapPinsOnEnable is selected on configuration
      \t * DAC is initially disabled.
      \t *                                        CR1.EN CR1.WE CR1.SE CR0.FILTER_CNT FPR.FILT_PER
      \t * 2a/b Continuous                          1      0      0      0              0     COUT == COUTA
      \t *
      \t * @param cmpPower        Power level. Tradeoff between speed and power consumption
      \t * @param cmpHysteresis   Hysteresis level for analogue comparator
      \t * @param cmpPolarity     Allows inversion of the comparator output
      \t */
      \tstatic void configure(
      \t      CmpPower       cmpPower       = CmpPower_HighSpeed,
      \t      CmpHysteresis  cmpHysteresis  = CmpHysteresis_Level_2,
      \t      CmpPolarity    cmpPolarity    = CmpPolarity_Normal
      \t      ) {
      \t   enable();
      \t
      \t   // Initialise hardware
      \t   cmp->CR1   = CmpEnable_Enabled|cmpPower|cmpPolarity;
      \t   cmp->CR0   = CMP_CR0_FILTER_CNT(0)|cmpHysteresis;
      \t   cmp->FPR   = 0;
      \t   cmp->SCR   = CMP_SCR_IER(0)|CMP_SCR_IEF(0);
      \t   cmp->DACCR = (CMP_DACCR_VOSEL_MASK>>1)&CMP_DACCR_VOSEL_MASK;
      \t   cmp->MUXCR = DefaultInitValue.muxcr;
      \t}
      \t\n
   ]]>
   </template>

   <!--   _____ Misc __________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/// Pin mapped to CMP output
      \ttypedef PcrTable_T<$(_Info), outputPin> OutputPin;
      \t\n
   ]]>
   </template>

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure all input pins associated with this CMP
      \t * The pins are set to analogue mode so no PCR settings are active.
      \t * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
      \t */
      \tstatic void setInputs() {
      \t   initPCRs();
      \t}
      \t\n
   ]]>
   </template>

   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
      variables="/GPIOA/port_pcr_dse,/GPIOA/port_pcr_ode,/GPIOA/port_pcr_sre"
      defaultParamValue="OutputPin::defaultPcrValue" >
   <![CDATA[
      \t/**
      \t * @brief
      \t * Enable comparator output pin as output.
      \t * Mux value is set appropriately for the pin function being used.
      \t * The clock to the port will be enabled before changing the PCR.
      \t *
      \t * @param pcrValue PCR value to use
      \t *
      \t */
      \tstatic void setOutput(PcrValue pcrValue) {
      \t//   CheckOutputIsMapped<outputPin, $(_Info)>::check();
      \t
      \t   // Enable CMP_OUT
      \t   cmp->CR1 = cmp->CR1 | CMP_CR1_OPE_MASK;
      \t
      \t   // Map CMP_OUT to pin
      \t   OutputPin::setPCR(pcrValue);
      \t}
      \t
      \t/**
      \t * @brief
      \t * Enable comparator output pin as output.\n
      \t * The Pin Control Register Attributes are set to the default values determined by Configure.usbdmProject.
      \t * The clock to the port will be enabled before changing the PCR.
      \t */
      \tstatic void setOutput() {
      \t   setOutput(OutputPin::defaultPcrValue.value);
      \t}
      \t
      \t/**
      \t * @brief
      \t * Set subset of Pin Control Register Attributes associated with output direction
      \t *
      \t * Mux value is set appropriately for the pin function being used. Other attributes are cleared.
      \t * The clock to the port will be enabled before changing the PCR.
      \t *
         %paramDescription
      \t */
      \tstatic void setOutput(%params)  {
      \t
      \t   setOutput(%paramExpression);
      \t}\n
   ]]>
   </variableTemplate>

   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
      variables="cmp_muxcr_psel,cmp_muxcr_msel"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Configure Comparator input sources
      \t *
      %paramDescription
      \t */
      \tstatic void selectInputs(%params) {
      \t
      \t   //! MUX Control Register
      \t   %register = %paramExpression;
      \t}
      \t
      \t/**
      \t * Class representing a Comparator pin
      \t *
      \t * @tparam cmpInput Number of comparator input (0-7) for associated pin.
      \t */
      \ttemplate<CmpInputMinus cmpInput>
      \tclass Pin {
      \t   using Pcr = PcrTable_T<Cmp$(_instance)Info,cmpInput>;
      \t
      \tpublic:
      \t   static constexpr CmpInputPlus  plusPin  = CmpInputPlus(CMP_MUXCR_PSEL(cmpInput));
      \t   static constexpr CmpInputMinus minusPin = cmpInput;
      \t
      \t   constexpr operator CmpInputPlus()  const { return plusPin;  }
      \t   constexpr operator CmpInputMinus() const { return minusPin; }
      \t
      \t   constexpr Pin() {}
      \t
      \t   static void setInput() {
      \t      Pcr::setPCR();
      \t   }
      \t};
      \t\n
   ]]>
   </variableTemplate>

   <!-- ____ Info constructors ________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/*
      \t *   Default Constructor
      \t */
      \t$(_Info)() : $(_BasicInfo)($(_basename)) {
      \t   defaultConfigure();
      \t}
      \t
      \t/*
      \t *   Constructor
      \t */
      \t$(_Info)(const Init &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- Init configure methods -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount==1)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount>1)"
      variables="irq_enum"
      immediateVariables="_hardwareIrqCount">
   <![CDATA[
      \t   for(int index=0; index<$(_hardwareIrqCount); index++) {
      \t      if (init.callbacks[index] != nullptr) {
      \t         // Configure call-back
      \t         setCallback(%returnType0(index), init.callbacks[index]);
      \t         enableNvicInterrupts(%returnType0(index), init.priorities[index]);
      \t      }
      \t   }
      \t\n
   ]]>
   </variableTemplate>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t   $(_BasicInfo)::configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr $(_BasicInfo)::Init DefaultInitValue = {\n
   ]]>
   <!-- Interrupt information -->
   </template>
   <for keys="irqName" values="=_hardwareIrqNums">
      <equation key="irqEnum" value='=ReplaceAll("%(irqName)","^(.*?)_(.*)_IRQn$","IrqNum_$2")' />
      <equation key="var"     value='=ReplaceAll("%(irqName)","^(.*?)_(.*)_IRQn$","irqLevel_$2")' />
      <!--
      <print text="(irqName) = %(irqName)"/>
      <printVar key="irqEnum" />
      <printVar key="var" />
      -->
      <variableTemplate where="info" codeGenCondition='$(_InfoIrqGuard)&amp;&amp;!IsZero(@var)'
         variables='=var'
         separator=","
         terminator=","
         padToComments="40"
         immediateVariables="irqEnum" >
      <![CDATA[
         \t   $(irqEnum), %initExpression,
         \t   unhandledCallback,\n
      ]]></variableTemplate>
   </for>

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      padToComments="30"
      variables="
            cmp_cr1_en,cmp_cr1_mode,cmp_cr1_trigm,cmp_cr1_pmode,cmp_cr1_inv,cmp_cr1_output,
            cmp_cr0_hystctr,
            cmp_scr_dmaen,cmp_scr_interrupt,
            cmp_cr0_filter_cnt,cmp_fpr_filt_per,
            cmp_daccr_dacen,cmp_daccr_vrsel,cmp_daccr_vosel,
            cmp_muxcr_psel,cmp_muxcr_msel" >
   <![CDATA[
      \t%initNonZeroValues
      \t};
      \t\n
   ]]>
   </variableTemplate>
<!-- ====================================================================================================== -->
<!--     END Info class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     Common      -->
<!-- ====================================================================================================== -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Info) $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="cmp_files" >
      <copy source="Project_Headers/cmp.h"    target="Project_Headers/cmp.h"    overwrite="true" derived="true"/>
      <copy source="Snippets/cmp-example.cpp" target="Snippets/cmp-example.cpp" overwrite="true" derived="true"/>
   </projectActionList>

   <!-- ____ Startup ____ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ____ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping ____ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</fragment>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- lptmr0.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Low Power Timer" >

   <!-- ____ Class Declarations ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <constant key="input_pins" condition="!input_pins" value='"CMP0;$(_NAME)_ALT1;$(_NAME)_ALT2"' />

   <equation key="irq_parameters"             value=""          />
   <equation key="irq_dummy_parameters"       value=""          />
   <equation key="irq_call_parameters"        value=""          />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <!-- ____ CSR ____ -->

   <binaryOption key="lptmr_csr_ten" condition="lptmr_csr_ten_present"
      hidden="true"
      derived="true"
      typeName="LptmrCsrTen"
      baseType="uint8_t"
      description="Timer Enable"
      toolTip="Enables timer" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="lptmr_csr_tms" condition="lptmr_csr_tms_present"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrMode"
      baseType="uint8_t"
      toolTip="Selects between timer Interval and Pulse Counting\n
                   Should only be altered when timer is disabled."
      description="Operation mode of the LPTMR" >
      <choice value="0" name="Time Interval mode" enum="TimeInterval"  />
      <choice value="1" name="Pulse Counter mode" enum="PulseCounting" />
   </binaryOption>

   <binaryOption key="lptmr_csr_tie" condition="lptmr_csr_tie_present"
      enabledBy="irqHandlingMethod"
      typeName="LptmrEventAction"
      baseType="uint8_t"
      toolTip="Enables LPTMR interrupts"
      description="Timer action on event" >
      <choice value="0" name="None"       enum="None" />
      <choice value="1" name="Interrupt"  enum="Interrupt"  />
   </binaryOption>

   <binaryOption key="lptmr_csr_tfc" condition="lptmr_csr_tfc_present"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrCounterActionOnEvent"
      baseType="uint8_t"
      toolTip="Counter action when compare event occurs\n
               The counter can continue counting or be reset to zero.\n
               Should only be altered when timer is disabled."
      description="Counter Action on Compare Event" >
      <choice value="0" name="Counter is reset on event" enum="Reset"  />
      <choice value="1" name="No effect on counter"      enum="None" />
   </binaryOption>

   <binaryOption key="lptmr_csr_tcf" condition="lptmr_csr_tcf_present"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrCompareFlag"
      baseType="uint8_t"
      toolTip="Flag is set when the LPTMR is enabled and the CNR equals the CMR and increments.\n
               Flag is cleared when the LPTMR is disabled or a logic 1 is written to it."
      description="Timer Compare Flag" >
      <choice name="No event"    value="0" enum="NoEvent"/>
      <choice name="Event"       value="1" enum="Event"/>
   </binaryOption >

   <!-- _________ CMR ______________ -->

   <intOption key="lptmr_cmr_compare" condition="lptmr_cmr_compare_present"
      enabledBy="enablePeripheralSupport"
      description="Timer Compare Value"
      units="ticks"
      baseType="uint16_t"
      toolTip="Comparison value\n
               The timer comparison flag is set when the counter reaches this value and increments. \n
               The hardware trigger will assert until the next time the counter increments. \n
               This value determines the period in TimeInterval mode or the event time in Pulse Counting mode\n
               The CMR must only be altered when timer is disabled or when TCF is set."
      value="65535" min="1" max="65535" />

   <choiceOption key="lptmr_psr_pcs" condition="lptmr_psr_pcs_present"
      enabledBy="enablePeripheralSupport"
      target="inputClockFrequency"
      typeName="LptmrClockSel"
      baseType="uint8_t"
      description="Clock source for LPTMR"
      toolTip="Selects the clock source for LPTMR\n
               Should only be altered when timer is disabled." >
      <choice value="0" name="MCG Internal Reference Clock (MCGIRCLK)"        enum="Mcgirclk" ref="/MCG/system_mcgirclk_clock[0]" code="McgInfo::getMcgIrClock()"  />
      <choice value="1" name="Low power oscillator (LPO - 1kHz)"              enum="Lpoclk"   ref="/PMC/system_low_power_clock"   code="SimInfo::getLpoClock()"    isDefault="true" />
      <choice value="2" name="32kHz Clock Source (ERCLK32)"                   enum="Erclk32"  ref="/SIM/system_erclk32k_clock"    code="SimInfo::getErc32kClock()" />
      <choice value="3" name="Oscillator External Reference Clock (OSCERCLK)" enum="Oscerclk" ref="/OSC0/oscer_clock"             code="Osc0Info::getOscerClock()" />
   </choiceOption>

   <intOption key="inputClockFrequency"
      description="Frequency of input clock to timer"
      units="Hz"
      derived="true"
      locked="true" />

   <!-- _________ Time Interval Mode ______________ -->

   <title description="Time Interval Mode" />

   <!-- _________ PSR ______________ -->

   <choiceOption key="lptmr_psr_prescaler" condition="lptmr_psr_prescale_present"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      target="counterFrequency"
      description="Prescaler Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      typeName="LptmrPrescale"
      baseType="uint8_t"
      toolTip="Configures the size of the Prescaler in Time Interval mode\n
               Should only be altered when timer is disabled." >
      <choice value="1,0"  name="Prescaler = 1"      ref="(inputClockFrequency)"        enum="Direct"       />
      <choice value="0,0"  name="Prescaler = 2"      ref="(inputClockFrequency)/2."     enum="DivBy_2"      />
      <choice value="0,1"  name="Prescaler = 4"      ref="(inputClockFrequency)/4."     enum="DivBy_4"      />
      <choice value="0,2"  name="Prescaler = 8"      ref="(inputClockFrequency)/8."     enum="DivBy_8"      />
      <choice value="0,3"  name="Prescaler = 16,"    ref="(inputClockFrequency)/16."    enum="DivBy_16"     />
      <choice value="0,4"  name="Prescaler = 32,"    ref="(inputClockFrequency)/32."    enum="DivBy_32"     />
      <choice value="0,5"  name="Prescaler = 64"     ref="(inputClockFrequency)/64."    enum="DivBy_64"     />
      <choice value="0,6"  name="Prescaler = 128"    ref="(inputClockFrequency)/128."   enum="DivBy_128"    />
      <choice value="0,7"  name="Prescaler = 256"    ref="(inputClockFrequency)/256."   enum="DivBy_256"    />
      <choice value="0,8"  name="Prescaler = 512"    ref="(inputClockFrequency)/512."   enum="DivBy_512"    />
      <choice value="0,9"  name="Prescaler = 1024"   ref="(inputClockFrequency)/1024."  enum="DivBy_1024"   />
      <choice value="0,10" name="Prescaler = 2048"   ref="(inputClockFrequency)/2048."  enum="DivBy_2048"   />
      <choice value="0,11" name="Prescaler = 4096"   ref="(inputClockFrequency)/4096."  enum="DivBy_4096"   />
      <choice value="0,12" name="Prescaler = 8192"   ref="(inputClockFrequency)/8192."  enum="DivBy_8192"   />
      <choice value="0,13" name="Prescaler = 16384"  ref="(inputClockFrequency)/16384." enum="DivBy_16384"  />
      <choice value="0,14" name="Prescaler = 32768"  ref="(inputClockFrequency)/32768." enum="DivBy_32768"  />
      <choice value="0,15" name="Prescaler = 65536"  ref="(inputClockFrequency)/65536." enum="DivBy_65536"  />
   </choiceOption>

   <floatOption key="counterFrequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      locked="true"
      description="Frequency of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="Hz"/>

   <floatOption key="maximumPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="65536/(counterFrequency)"
      typeName="Seconds"
      locked="true"
      description="Maximum period of timer"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="s"/>

   <floatOption key="lptmr_cmrPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(lptmr_cmr_compare+1)/counterFrequency#counterFrequency"
      description="Timer Compare Interval"
      toolTip="Comparison value\n
               The timer comparison flag is set when the counter reaches this value and increments. \n
               The hardware trigger will assert until the next time the counter increments. \n
               This value determines the period in TimeInterval mode or the event time in Pulse Counting mode"
      derived="true"
      min="0" units="s"/>

   <floatOption key="lptmr_cmrFrequency"  description="Timer Compare Frequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(counterFrequency)/(lptmr_cmr_compare+1)"
      toolTip="This is determined from lptmr_cmr register and clock frequency.\n
               When lptmr_csr_tfc=0 this is the lptmr_cnr roll-over frequency"
      derived="true"
      min="0" units="Hz"/>

   <!-- _________ Pulse Counting Mode ______________ -->

   <title description="Pulse Counting Mode" />

   <choiceOption key="lptmr_psr_glitchFilter"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      target="filterDuration"
      description="Filter Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      typeName="LptmrGlitchFilter"
      baseType="uint8_t"
      toolTip="Configures the size of the glitch filter in Pulse Counting mode\n
               Should only be altered when timer is disabled." >
      <choice value="1,0"  name="No glitch filter"                 ref="0."                         enum="Direct"       />
      <choice value="0,1"  name="2 clock cycle glitch filter"      ref="2./inputClockFrequency"     enum="2_clocks"     />
      <choice value="0,2"  name="4 clock cycle glitch filter"      ref="4./inputClockFrequency"     enum="4_clocks"     />
      <choice value="0,3"  name="8 clock cycle glitch filter"      ref="8./inputClockFrequency"     enum="8_clocks"     />
      <choice value="0,4"  name="16 clock cycle glitch filter"     ref="16./inputClockFrequency"    enum="16_clocks"    />
      <choice value="0,5"  name="32 clock cycle glitch filter"     ref="32./inputClockFrequency"    enum="32_clocks"    />
      <choice value="0,6"  name="64 clock cycle glitch filter"     ref="64./inputClockFrequency"    enum="64_clocks"    />
      <choice value="0,7"  name="128 clock cycle glitch filter"    ref="128./inputClockFrequency"   enum="128_clocks"   />
      <choice value="0,8"  name="256 clock cycle glitch filter"    ref="256./inputClockFrequency"   enum="256_clocks"   />
      <choice value="0,9"  name="512 clock cycle glitch filter"    ref="512./inputClockFrequency"   enum="512_clocks"   />
      <choice value="0,10" name="1024 clock cycle glitch filter"   ref="1024./inputClockFrequency"  enum="1024_clocks"  />
      <choice value="0,11" name="2048 clock cycle glitch filter"   ref="2048./inputClockFrequency"  enum="2048_clocks"  />
      <choice value="0,12" name="4096 clock cycle glitch filter"   ref="4096./inputClockFrequency"  enum="4096_clocks"  />
      <choice value="0,13" name="8192 clock cycle glitch filter"   ref="81924./inputClockFrequency" enum="81924_clocks" />
      <choice value="0,14" name="16384 clock cycle glitch filter"  ref="16384./inputClockFrequency" enum="16384_clocks" />
      <choice value="0,15" name="32768 clock cycle glitch filter"  ref="32768./inputClockFrequency" enum="32768_clocks" />
   </choiceOption>

   <floatOption key="filterDuration"
      locked="true"
      description="Input filter duration"
      toolTip="Determined from timer clock source and glitch filter selection"
      derived="true"
      units="s" />

   <!--  printVar key="input_pins" / -->

   <choiceOption key="lptmr_csr_tps" condition="lptmr_csr_tps_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      typeName="LptmrInput"
      baseType="uint8_t"
      description="Input Pin"
      toolTip="Input source to be used in Pulse Counter mode\n
               Should only be altered when timer is disabled." >
      <choiceExpansion
         keys="name" values='=input_pins' delimiter=";"
         name='@SignalDescription("%(name)","^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
         value="%(i)"
         enum='=ReplaceAll("%(name)","^.*?_(.*)$","$1")'
         signal="%(name)"
         condition='=HardwareExists("%(name)")' />
   </choiceOption >

   <binaryOption key="lptmr_csr_tpp" condition="lptmr_csr_tpp_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      typeName="LptmrInputEdge"
      baseType="uint8_t"
      description="Pin Polarity"
      toolTip="Polarity of the input source in Pulse Counter mode\n
               Should only be altered when timer is disabled." >
      <choice value="0" name="Active-high, increment count on rising-edge"  enum="Rising"  />
      <choice value="1" name="Active-low, increment count on falling-edge"  enum="Falling" />
   </binaryOption >


   <!-- ____ CNR ____ -->

   <intOption key="lptmr_cnr_counter" condition="lptmr_cnr_counter_present"
      hidden="true"
      derived="true"
      typeName="uint16_t"
      baseType="uint16_t"
      toolTip="Current counter value\n
               This is a read-only register."
      description="Counter Value"
   />
<!-- ====================================================================================================== -->
<!--     START BasicInfo Class      -->
<!-- ====================================================================================================== -->

   <!-- BasicInfo Instance pointer and Constructors  -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Pointer to $(_BASENAME) hardware instance
      \tvolatile $(_Type) * const $(_basename);
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Constructor
      \t *
      \t * @param $(_basename) $(_BASENAME) hardware instance
      \t */
      \tconstexpr $(_BasicInfo)(volatile $(_Type) * $(_basename)) : $(_basename)($(_basename)) {
      \t}
      \t\n
   ]]></template>

   <!-- Shared clock selection -->
   <clockCodeTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variable="lptmr_psr_pcs"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description frequency
      \t * (%variables)
      \t *
      %paramDescription
      \t
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default:
      %body
      \t   }
      \t}
      \t\n
   ]]></clockCodeTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Calculate timing information based on desired duration and selected clock (from psr.pcs)
      \t *
      \t * @param[in]     duration   Desired period or event duration
      \t * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
      \t * @param[out]    cmr        Compare register value
      \t *
      \t * @return E_NO_ERROR      => Success
      \t * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
      \t */
      \tstatic ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint16_t &cmr) {
      \t
      \t   float inputClock = getInputClockFrequency(LptmrClockSel(psr&LPTMR_PSR_PCS_MASK));
      \t
      \t   int      prescaleFactor=1;
      \t   uint32_t prescalerValue=0;
      \t   while (prescalerValue<=16) {
      \t      float    clockFrequency = inputClock/prescaleFactor;
      \t      uint32_t mod   = rintf(float(duration*clockFrequency))-1;
      \t      if (mod <= LPTMR_CMR_COMPARE_MASK) {
      \t         cmr  = mod;
      \t         psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
      \t         return E_NO_ERROR;
      \t      }
      \t      prescalerValue++;
      \t      prescaleFactor <<= 1;
      \t   }
      \t   // Too long a period
      \t   return setAndCheckErrorCode(E_TOO_LARGE);
      \t}
      \t\n
   ]]></template >

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Truncate Tick value to correct range for modulo calculations.
      \t *
      \t * @param ticks Value to truncate in Ticks
      \t *
      \t * @return Truncated value in Ticks
      \t */
      \tstatic Ticks modulo(const Ticks &ticks) {
      \t
      \t   return Ticks(unsigned(ticks) & LPTMR_CNR_COUNTER_MASK);
      \t}\n\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     START BasicInfo/Info duplicated methods -->
<!-- ====================================================================================================== -->

<for
   keys="   static    : const    : where     : guard                                      "
   values=" ''        : 'const ' : basicInfo : $(_BasicInfoGuard)                         ;
            'static ' : ''       : info      : $(_InfoGuard)                              "  >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field                   : set   : get   : clear : genCode                 : name"
        values="

         lptmr_csr_tcf                : false : true  : w1cIm : enablePeripheralSupport : EventFlag;
         lptmr_csr_tie                : true  : true  : false : enablePeripheralSupport : EventAction;
         lptmr_csr_tps                : true  : true  : false : enableGettersAndSetters : InputSelect;
         lptmr_csr_tpp                : true  : true  : false : enableGettersAndSetters : InputEdge;
         lptmr_csr_tfc                : true  : true  : false : enableGettersAndSetters : CounterActionOnEvent;
         lptmr_csr_tms                : true  : true  : false : enableGettersAndSetters : Mode;
         lptmr_csr_ten                : true  : true  : false : enableGettersAndSetters : Enable;
         lptmr_csr_tps,lptmr_csr_tpp  : true  : false : false : enableGettersAndSetters : Input;

         lptmr_psr_pcs                : true  : true  : false : enablePeripheralSupport : ClockSource;

         lptmr_cmr_compare            : true  : true  : false : enablePeripheralSupport : CompareThreshold" >
      <variableTemplate location="%(where)" condition="%(set)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition="%(get)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Get %description
         \t * (%variables)
         \t *
         \t * @return %tooltip
         \t */
         \t%(static)%returnType get%(name)() %(const){
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1c"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void clear%(name)(%params) %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1cIm"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void clear%(name)() %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <variableTemplate location="%(where)" codeGenCondition="%(guard)"
      variables="lptmr_psr_pcs,lptmr_psr_prescaler"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t * (%variables)
      \t *
      \t * These settings are used for the clock prescaler in timer mode.
      \t *
      %paramDescription
      \t */
      \t%(static)void setClock(%params) %(const){
      \t
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = csr&~LPTMR_CSR_TEN_MASK;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></variableTemplate>

   <variableTemplate location="%(where)" codeGenCondition="%(guard)"
      variables="lptmr_psr_pcs,lptmr_psr_glitchFilter"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t * (%variables)
      \t *
      \t * These settings are used for the glitch filter in pulse-counting mode.
      \t *
      %paramDescription
      \t */
      \t%(static)void setClock(%params) %(const){
      \t
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = csr&~LPTMR_CSR_TEN_MASK;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></variableTemplate>

   <clockCodeTemplate location="%(where)" codeGenCondition="%(guard)"
      variable="lptmr_psr_pcs"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description frequency
      \t * (%variables)
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \t%(static)uint32_t getInputClockFrequency() %(const){
      \t
      \t   return LptmrBasicInfo::getInputClockFrequency(LptmrClockSel(%mask&%register));
      \t}
      \t
      \t/**
      \t * Get clock frequency after prescaler
      \t * (%variables)
      \t *
      \t * @return Frequency as a float in Hz
      \t */
      \t%(static)float getClockFrequencyF() %(const){
      \t
      \t   float freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}
      \t
      \t/**
      \t * Get clock frequency
      \t * (%variables)
      \t *
      \t * @return Frequency as a uint32_t in Hz (may underflow)
      \t */
      \t%(static)uint32_t getClockFrequency() %(const){
      \t
      \t   uint32_t freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}
      \t
      \t/**
      \t * Converts a number in ticks to time in microseconds.
      \t *
      \t * @param[in]  ticks Time in ticks
      \t *
      \t * @return Time in microseconds
      \t *
      \t * @note Assumes prescale has been chosen appropriately.
      \t * @note Rudimentary range checking only. Sets error code.
      \t */
      \t%(static)uint32_t convertTicksToMicroseconds(Ticks ticks) %(const){
      \t   uint32_t tickRate = getClockFrequency();
      \t   uint64_t rv       = (((uint64_t)ticks)*1000000)/(unsigned)tickRate;
      \t
      #ifdef DEBUG_BUILD
      \t   if (rv > UINT_MAX) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (rv == 0) {
      \t      // Attempt to set too short a period
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      #endif
      \t   return rv;
      \t}
      \t
      \t/**
      \t * Converts a number in ticks to time in milliseconds.
      \t *
      \t * @param[in]  ticks Time in ticks
      \t *
      \t * @return Time in milliseconds
      \t *
      \t * @note Assumes prescale has been chosen appropriately.
      \t * @note Rudimentary range checking only. Sets error code.
      \t */
      \t%(static)unsigned convertTicksToMilliseconds(Ticks ticks) %(const){
      \t   uint32_t tickRate = getClockFrequency();
      \t   uint64_t rv       = (((uint64_t)ticks)*1000)/(unsigned)tickRate;
      \t
      #ifdef DEBUG_BUILD
      \t   if (rv > UINT_MAX) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (rv == 0) {
      \t      // Attempt to set too short a period
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      #endif
      \t   return unsigned(rv);
      \t}
      \t
      \t/**
      \t * Converts a number in ticks to time in seconds.
      \t *
      \t * @param[in]  ticks Time in ticks
      \t *
      \t * @return Time in seconds (as float)
      \t *
      \t * @note Assumes prescale has been chosen appropriately.
      \t */
      \t%(static)Seconds convertTicksToSeconds(Ticks ticks) %(const){
      \t   float tickRate = getClockFrequencyF();
      \t   return Seconds(((float)ticks)/tickRate);
      \t}
      \t
      \t/**
      \t * Converts a time in microseconds to number of ticks.
      \t *
      \t * @param[in]  time Time in microseconds
      \t *
      \t * @return Time in ticks
      \t *
      \t * @note Assumes prescale has been chosen appropriately.
      \t */
      \t%(static)Ticks convertMicrosecondsToTicks(int time) %(const){
      \t
      \t   // Calculate period
      \t   uint32_t tickRate = getClockFrequency();
      \t   uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000000;
      \t
      #ifdef DEBUG_BUILD
      \t   if (rv > UINT_MAX) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (rv == 0) {
      \t      // Attempt to set too short a period
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      #endif
      \t   return Ticks(uint32_t(rv));
      \t}
      \t/**
      \t * Converts a time in milliseconds to number of ticks.
      \t *
      \t * @param[in]  time Time in milliseconds
      \t *
      \t * @return Time in ticks
      \t *
      \t * @note Assumes prescale has been chosen appropriately.
      \t */
      \t%(static)Ticks convertMillisecondsToTicks(int time) %(const){
      \t
      \t   // Calculate period
      \t   uint32_t tickRate = getClockFrequency();
      \t   uint64_t rv       = (unsigned)((uint64_t)time*tickRate)/1000;
      \t
      #ifdef DEBUG_BUILD
      \t   if (rv > UINT_MAX) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (rv == 0) {
      \t      // Attempt to set too short a period
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      #endif
      \t   return Ticks(uint32_t(rv));
      \t}
      \t
      \t/**
      \t * Converts a time in seconds to number of ticks
      \t *
      \t * @param[in]  time Time in seconds (float!)
      \t *
      \t * @return Time in ticks
      \t *
      \t * @note Uses floating point
      \t * @note Rudimentary range checking only. Sets error code.
      \t */
      \t%(static)Ticks convertSecondsToTicks(Seconds time) %(const){
      \t
      \t   // Calculate period
      \t   float    tickRate = getClockFrequencyF();
      \t   uint64_t rv       = (unsigned)((float)time*tickRate);
      \t
      #ifdef DEBUG_BUILD
      \t   if (rv > UINT_MAX) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (rv == 0) {
      \t      // Attempt to set too long a period
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      #endif
      \t   return Ticks(uint32_t(rv));
      \t}
      \t
      \t/**
      \t * Calculate filter information based on desired interval
      \t * This calculates a clock prescaler so that the filter interval is at least the given value.
      \t *
      \t * @param[in]     interval   Desired filter interval
      \t * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
      \t *
      \t * @return E_NO_ERROR      => Success
      \t * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
      \t */
      \t%(static)ErrorCode calculateFilterValues(Seconds interval, uint8_t &psr) %(const){
      \t
      \t   float    inputClock = LptmrBasicInfo::getInputClockFrequency(LptmrClockSel(psr&LPTMR_PSR_PCS_MASK));
      \t   int      prescaleFactor=1;
      \t   uint32_t prescalerValue=0;
      \t   while (prescalerValue<=16) {
      \t      if ((float)(interval*prescaleFactor) < inputClock) {
      \t         psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
      \t         return E_NO_ERROR;
      \t      }
      \t      prescalerValue++;
      \t      prescaleFactor <<= 1;
      \t   }
      \t   // Too long a duration
      \t   return setAndCheckErrorCode(E_TOO_LARGE);
      \t}
      \t
      \t/**
      \t * Set period of timer.
      \t *
      \t * @param[in]  period Period in seconds as a float
      \t *
      \t * @note Will enable and adjust the pre-scaler to appropriate value.\n
      \t *       The clock source should be selected by setClock() before using this function.
      \t *
      \t * @return E_NO_ERROR      => Success
      \t * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
      \t */
      \t%(static)ErrorCode setPeriod(Seconds period) %(const){
      \t
      \t   uint8_t  psr = lptmr->PSR;
      \t   uint16_t cmr;
      \t   ErrorCode rc = LptmrBasicInfo::calculateDurationValues(period, psr, cmr);
      \t   if (rc != E_NO_ERROR) {
      \t      return rc;
      \t   }
      \t   // Disable before changing clock
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = csr&~LPTMR_CSR_TEN_MASK;
      \t   (void)(lptmr->CSR);
      \t
      \t   lptmr->CMR  = cmr;
      \t   lptmr->PSR  = psr;
      \t
      \t   lptmr->CSR  = csr;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set glitch filter interval.
      \t * This adjusts the clock prescaler so that the filter interval is at least the given value.
      \t *
      \t * @param[in]  interval Interval in seconds as a float
      \t *
      \t * @note Will enable and adjust the pre-scaler to appropriate value.\n
      \t *       The clock source should be selected by setClock() before using this function.
      \t *
      \t * @return E_NO_ERROR      => Success
      \t * @return E_ILLEGAL_PARAM => Failed to find suitable values for PBYP & PRESCALE
      \t */
      \t%(static)ErrorCode setFilterInterval(Seconds interval) %(const){
      \t
      \t   uint8_t  psr = lptmr->PSR;
      \t
      \t   ErrorCode rc = calculateFilterValues(interval, psr);
      \t   if (rc != E_NO_ERROR) {
      \t      return rc;
      \t   }
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = csr&~LPTMR_CSR_TEN_MASK;
      \t   (void)(lptmr->CSR);
      \t
      \t   lptmr->PSR  = psr;
      \t
      \t   lptmr->CSR  = csr;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Get timer counter value
      \t *
      \t * @return Timer value in ticks.
      \t */
      \t%(static)Ticks getCounterValue() %(const){
      \t   // It is necessary to write to the CNR to capture current value
      \t   lptmr->CNR = 0;
      \t   return (Ticks)(lptmr->CNR);
      \t}
      \t
      \t/**
      \t * Restarts the counter
      \t * This restarts the timer by disabling and re-enabling with the same configuration
      \t */
      \t%(static)void restart() %(const){
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = csr&~LPTMR_CSR_TEN_MASK;
      \t   lptmr->CSR   = csr;
      \t}
      \t\n
   ]]></clockCodeTemplate>
</for>

<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = delete;
      \t
      \tprotected:
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t
      \tpublic:\n
   ]]></template >

   <!-- ____ BasicInfo::Init class Member variables ________ -->

   <for keys=" type        : variables                                            : init           "
       values="%returnType : lptmr_cmrPeriod                                      : 0_s            ;
               %baseType   : lptmr_cmr_compare                                    : 0              ;
               %baseType   : lptmr_psr_prescaler,lptmr_psr_pcs                    : 0              ;
               %baseType   : lptmr_csr_tie,lptmr_csr_tfc                          : 0              " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx" >
      <![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START BasicInfo::TimeIntervalModeInit class      -->
<!-- ====================================================================================================== -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Time Interval Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * %(static)const Lptmr$(_instance)::TimeIntervalModeInit lptmrInit {
      \t *    LptmrResetOn_Compare,    // Timer Free-Running Counter enable
      \t *    LptmrInterrupt_Disabled, // Timer interrupt enable
      \t *    LptmrClockSel_Oscerclk,  // Clock Source
      \t *    LptmrPrescale_Direct,    // Prescaler Value
      \t *    100_ms,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Time Interval mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass TimeIntervalModeInit : public Init {
      \t
      \tprivate:
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit(const Init &other) = delete;
      \t
      \tpublic:
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit() : Init() {
      \t
      \t      csr = (csr & ~LPTMR_CSR_TMS_MASK) | LptmrMode_TimeInterval;
      \t   }
      \t\n
   ]]>
   </template >

   <!-- ____ BasicInfo::TimeIntervalModeInit class Constructors ____________ -->

   <for keys="variable           : condition"
     values="
             lptmr_csr_tie       : $(_BasicInfoGuard) ;
             lptmr_csr_tfc       : $(_BasicInfoGuard) ;
             lptmr_psr_prescaler : $(_BasicInfoGuard) ;
             lptmr_psr_pcs       : $(_BasicInfoGuard) ;
             lptmr_cmr_compare   : $(_BasicInfoGuard) ;
             lptmr_cmrPeriod     : $(_BasicInfoGuard) ">
      <variableTemplate where="basicInfo" codeGenCondition="%(condition)"
         variables="%(variable)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr TimeIntervalModeInit(%params, Types... rest) : TimeIntervalModeInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::TimeIntervalModeInit
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::TimeIntervalModeInit class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START BasicInfo::PulseCountingModeInit class      -->
<!-- ====================================================================================================== -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Pulse Counting Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * static const Lptmr$(_instance)::PulseCountingModeInit lptmrInit {
      \t *    LptmrPinSel_Cmp0,           // Timer Pin Select for Pulse Counter mode
      \t *    LptmrInputEdge_Rising,      // Timer Pin Polarity for Pulse Counter mode
      \t *    LptmrClockSel_Oscerclk,     // Clock Source
      \t *    LptmrGlitchFilter_Direct,   // Filter Value
      \t *    LptmrInterrupt_Disabled,    // Timer interrupt enable
      \t *    LptmrResetOn_Compare,       // Timer Free-Running Counter enable
      \t *    916_ticks,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Pulse Counting mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass PulseCountingModeInit : public Init {
      \t
      \tprivate:
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr PulseCountingModeInit(const Init &other) = delete;
      \t
      \tpublic:
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr PulseCountingModeInit() : Init() {
      \t
      \t      csr = (csr & ~LPTMR_CSR_TMS_MASK) | LptmrMode_PulseCounting;
      \t   }
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo::PulseCountingModeInit class Constructors ____________ -->

   <for keys="variable              : condition"
     values="
             lptmr_csr_tie          : $(_BasicInfoGuard) ;
             lptmr_csr_tfc          : $(_BasicInfoGuard) ;
             lptmr_psr_pcs          : $(_BasicInfoGuard) ;
             lptmr_cmr_compare      : $(_BasicInfoGuard) ;
             lptmr_csr_tps          : $(_BasicInfoGuard) ;
             lptmr_csr_tpp          : $(_BasicInfoGuard) ;
             lptmr_psr_glitchFilter : $(_BasicInfoGuard) ">
      <variableTemplate where="basicInfo" codeGenCondition="%(condition)"
         variables="%(variable)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr PulseCountingModeInit(%params, Types... rest) : PulseCountingModeInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::PulseCountingModeInit
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo class Configure methods ____ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init.
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param $(_basename)           Hardware instance pointer
      \t * @param init            Class containing initialisation values
      \t *
      \t * @return Error code
      \t */
      \tstatic ErrorCode configure(
      \t               volatile $(_Type) *$(_basename),
      \t               const Init    &init) {\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values="
               lptmr_psr_pcs                                          : %baseType %registerName = init.%registerName   ;
               lptmr_cmr_compare                                      : %baseType %registerName = init.%registerName   ;
               lptmr_cmrPeriod                                        :
                  'if (init.cmrperiod != 0) {
               \n\t      // Calculate values from duration in seconds
               \n\t      ErrorCode rc = calculateDurationValues(init.cmrperiod, psr, cmr);
               \n\t      if (rc != E_NO_ERROR) {
               \n\t         return rc;
               \n\t      }
               \n\t   }'                                                                                               ;
               lptmr_csr_tcf,lptmr_csr_tie,
               lptmr_csr_tps,lptmr_csr_tpp,lptmr_csr_tfc,
               lptmr_csr_tms,                                         :
                      '// Configure while disabled
               \n\t   %register = init.%registerName'                 ;
               lptmr_psr_pcs                                          : %register = %registerName                      ;
               lptmr_cmr_compare                                      : %register = %registerName                      ;
               lptmr_csr_ten, lptmr_csr_tcf,lptmr_csr_tie,
               lptmr_csr_tps,lptmr_csr_tpp,lptmr_csr_tfc,
               lptmr_csr_tms,                                         : %register = init.%registerName|%mask0          " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx" >
      <![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]>
      </variableTemplate>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}
      \t\n
   ]]>
   </template>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tErrorCode configure(const Init &init) const {
      \t
      \t   return configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>
<!-- ====================================================================================================== -->
<!--     END BasicInfo class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START Info class      -->
<!-- ====================================================================================================== -->

   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount>1)"
      variables="irq_enum"
      immediateVariables="_hardwareIrqCount"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Information describing the priority and callback function for each interrupt
      \t */
      \ttypedef $(_BasicInfo)::InitVectors<TimeIntervalModeInit,  %returnType0, $(_hardwareIrqCount)> TimeIntervalModeInit;
      \ttypedef $(_BasicInfo)::InitVectors<PulseCountingModeInit, %returnType0, $(_hardwareIrqCount)> PulseCountingModeInit;
      \t\n
   ]]></variableTemplate>

   <template where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount==1)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Information describing the priority and callback function for each interrupt
      \t */
      \ttypedef $(_BasicInfo)::InitVectors<TimeIntervalModeInit,  int, 1> TimeIntervalModeInit;
      \ttypedef $(_BasicInfo)::InitVectors<PulseCountingModeInit, int, 1> PulseCountingModeInit;
      \t\n
   ]]></template>

   <!-- ____ Info constructors ________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/*
      \t *   Default Constructor
      \t */
      \t$(_Info)() : $(_BasicInfo)($(_basename)) {
      \t   defaultConfigure();
      \t}
      \t
      \t/*
      \t *   Constructor
      \t */
      \t$(_Info)(const TimeIntervalModeInit &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t
      \t/*
      \t *   Constructor
      \t */
      \t$(_Info)(const PulseCountingModeInit &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- Init configure methods -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic ErrorCode defaultConfigure() {
      \t
      \t   return configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const TimeIntervalModeInit &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t   return $(_BasicInfo)::configure($(_basename), init);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const PulseCountingModeInit &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t   return $(_BasicInfo)::configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <template where="info" codeGenCondition="$(_InfoGuard)&amp;&amp;!lptmr_csr_tms">
   <![CDATA[
      \t/**
      \t * Default value for $(_Class) in Time Interval Mode
      \t * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t */
      \tstatic constexpr TimeIntervalModeInit DefaultInitValue {\n
   ]]></template>

   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)&amp;&amp;!lptmr_csr_tms"
      terminator=","
      separator=","
      padToComments="45"
      variables="
         irqLevel,
         irqHandlerName" >
   <![CDATA[
      %initExpression\n
   ]]></variableTemplate>

   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)&amp;&amp;!lptmr_csr_tms"
      terminator=","
      separator=","
      padToComments="45"
      variables="
         lptmr_csr_tfc,lptmr_csr_tie,
         lptmr_psr_pcs,lptmr_psr_prescaler,
         lptmr_cmr_compare" >
   <![CDATA[
      \t%initExpression
      \t};
      \t\n
   ]]></variableTemplate>

   <!-- ============================= -->
   <template where="info" codeGenCondition="$(_InfoGuard)&amp;&amp;lptmr_csr_tms" >
   <![CDATA[
      \t/**
      \t * Default value for $(_Class) in Pulse Counting Mode
      \t * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t */
      \tstatic constexpr PulseCountingModeInit DefaultInitValue {\n
   ]]>
   </template>
   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)&amp;&amp;lptmr_csr_tms"
      terminator=","
      separator=","
      padToComments="45"
      variables="
         irqLevel,
         irqHandlerName" >
   <![CDATA[
      %initExpression\n
   ]]></variableTemplate>
   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)&amp;&amp;lptmr_csr_tms"
      terminator=","
      separator=","
      padToComments="45"
      variables="
         lptmr_csr_tps,lptmr_csr_tpp,
         lptmr_psr_pcs,lptmr_psr_glitchFilter,
         lptmr_csr_tie,lptmr_csr_tfc,
         lptmr_cmr_compare"
   ><![CDATA[
      %initExpression
      \t};
      \t\n
   ]]>
   </variableTemplate>

<!-- ====================================================================================================== -->
<!--     END Info class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     Common      -->
<!-- ====================================================================================================== -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class representing $(_STRUCTNAME) instance
      \t */
      \ttypedef $(_BasicInfo) $(_Structname);
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Info) $(_Class);
      \t\n
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.LptmrValidate" >
   </validate>

   <projectActionList id="lptmr_files" >
      <copy source="Project_Headers/lptmr.h"                   target="Project_Headers/lptmr.h"                      overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-example.cpp"                target="Snippets/lptmr-example.cpp"                   overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-reaction-time.cpp"          target="Snippets/lptmr-reaction-time.cpp"             overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"    overwrite="true" derived="true" />
   </projectActionList>

   <!-- ____ Startup ____ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ____ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping ____ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</peripheralPage>

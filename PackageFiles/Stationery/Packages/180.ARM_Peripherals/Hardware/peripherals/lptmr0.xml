<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- lptmr0.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Low Power Timer">

   <constant key="irq_pattern"              type="String"  value="&quot;^.*%b%i.*$&quot;"       />
   <constant key="irq_ClassHandler"         type="String"  value="&quot;%c%i::irqHandler&quot;" />
   <constant key="suppressInstance"         type="Boolean" value="false"            />
   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"             />
   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"     />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;&quot;"     />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"     />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"            />
   <constant key="isSupportedinStartup"     type="Boolean" value="true"             />
   <xi:include href="_enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * %valueExpression[index]         Formatted value as numeric e.g. 0x12
    * %symbolicValueExpression[index] Symbolic formatted value e.g. AdcCompare_Disabled
    * %variable[index]                Variable name /ADC0/adc_sc2_acfe
    * %macro[index](value)            C register macro e.g. ADC_SC2_ACFGT(value)
    * %description[index]             Description from controlVar e.g. Compare Function Enable
    * %shortDescription[index]        Short description from controlVar e.g. Compare Function Enable
    * %tooltip[index]                 Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * %paramDescription[index]        Tool-tip from controlVar formatted as param description @param ...
    * %params                         Formatted parameter list for function
    * %paramType[index]               Based on enumStem or typename e.g. AdcCompare (or uint32_t)
    * %paramName[index]               Based on enumStem with lower-case first letter adcCompare
    * %enumClass[index]               As for %paramType
    * %enumParam[index]               As for %paramName
    * %valueExpression                Numeric variable value e.g. 0x3
    * %symbolicValueExpression        Symbolic variable value e.g. AdcCompare_Disabled
    * %defaultClockExpression         Based on variable etc. Similar to %register = (%register&~%mask) | %paramName;
    * %defaultMaskingExpression       Based on variable etc. Similar to (%register&%mask)
    * %variable[index]                Variable name from condition
    * %mask[index]                    From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * %register[index]                Register associated with variable e.g. adc->APCTL1
    * %registerName[index]            Name of corresponding register (lowercase for Init()) e.g. apctl1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <!-- constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Baseclass)BasicInfo&quot;" / -->

   <!-- ************* CSR ****************** -->

   <!-- binaryOption key="lptmr_csr_ten" condition="lptmr_csr_ten_present"
      enabledBy="enablePeripheralSupport"
      enumStem="LptmrCsrTen"
      description="Timer Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption -->

   <binaryOption key="lptmr_csr_tie" condition="lptmr_csr_tie_present"
      enabledBy="/$(_BASENAME)/irqHandlingMethod"
      enumStem="LptmrInterrupt"
      description="Timer interrupt enable"
      toolTip="Enables LPTMR interrupts">
      <choice value="0" name="Interrupt disabled" enum="Disabled" />
      <choice value="1" name="Interrupt enabled"  enum="Enabled"  />
   </binaryOption>

   <binaryOption key="lptmr_csr_tfc" condition="lptmr_csr_tfc_present"
      enabledBy="enablePeripheralSupport"
      enumStem="LptmrResetOnCompare"
      description="Counter Action on Compare Event"
      toolTip="Counter action when CSR.TCF is set">
      <choice value="0" name="lptmr_cnr is reset whenever CSR.TCF is set" enum="Enabled"  />
      <choice value="1" name="lptmr_cnr is reset on overflow only"        enum="Disabled" />
   </binaryOption>

   <binaryOption key="lptmr_csr_tms" condition="lptmr_csr_tms_present"
      enabledBy="enablePeripheralSupport"
      enumStem="LptmrMode"
      toolTip="Configures the mode of the LPTMR">
      <choice value="0" name="Time Interval mode" enum="TimeInterval"  />
      <choice value="1" name="Pulse Counter mode" enum="PulseCounting" />
   </binaryOption>

   <intOption key="minimumResolution"
      description="Minimum resolution for time interval setting"
      toolTip="This value is used as a minimum value check when setting the time interval.\n
               This is to prevent setting intervals with low resolution"
      value="100" min="1"
   />

   <!-- ************* CMR ****************** -->

   <intOption key="lptmr_cmr_compare" condition="lptmr_cmr_compare_present"
      enabledBy="enablePeripheralSupport"
      description="Timer Compare Register"
      typeName="Ticks &amp;"
      valueFormat="%s_ticks"
      units="ticks"
      toolTip="Comparison value\n
      The timer comparison flag is set when the counter reaches this value and increments. \n
      The hardware trigger will assert until the next time the counter increments. \n
      This value determines the period in TimeInterval mode or the event time in Pulse Counting mode"
      value="65535" min="1" max="65535" />

   <choiceOption key="lptmr_psr_pcs" condition="lptmr_psr_pcs_present"
      enabledBy="enablePeripheralSupport"
      target="inputClockFrequency"
      enumStem="LptmrClockSel"
      toolTip="Clock source for LPTMR">
      <choice value="0" name="MCG Internal Reference Clock (MCGIRCLK)"        enum="Mcgirclk" ref="/MCG/system_mcgirclk_clock[0]" code="McgInfo::getMcgIrClock()"  />
      <choice value="1" name="Low power oscillator (LPO - 1kHz)"              enum="Lpoclk"   ref="/PMC/system_low_power_clock"   code="PmcInfo::getLpoClock()"    isDefault="true" />
      <choice value="2" name="32kHz Clock Source (ERCLK32)"                   enum="Erclk32"  ref="/SIM/system_erclk32k_clock"    code="SimInfo::getErc32kClock()" />
      <choice value="3" name="Oscillator External Reference Clock (OSCERCLK)" enum="Oscerclk" ref="/OSC0/oscer_clock"             code="Osc0Info::getOscerClock()" />
   </choiceOption>

   <intOption key="inputClockFrequency"
      description="Frequency of input clock to timer"
      units="Hz"
      derived="true"
      constant="true" />

   <title description="Time Interval Mode" />

   <!-- ************* PSR ****************** -->

   <choiceOption key="lptmr_psr_prescaler" condition="lptmr_psr_prescale_present"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      target="counterFrequency"
      description="Prescaler Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      enumStem="LptmrPrescale"
      toolTip="Configures the size of the Prescaler in Time Interval mode" >
      <choice value="1,0"  name="Prescaler = 1"      ref="(inputClockFrequency)"        enum="Direct"       />
      <choice value="0,0"  name="Prescaler = 2"      ref="(inputClockFrequency)/2."     enum="DivBy_2"      />
      <choice value="0,1"  name="Prescaler = 4"      ref="(inputClockFrequency)/4."     enum="DivBy_4"      />
      <choice value="0,2"  name="Prescaler = 8"      ref="(inputClockFrequency)/8."     enum="DivBy_8"      />
      <choice value="0,3"  name="Prescaler = 16,"    ref="(inputClockFrequency)/16."    enum="DivBy_16"     />
      <choice value="0,4"  name="Prescaler = 32,"    ref="(inputClockFrequency)/32."    enum="DivBy_32"     />
      <choice value="0,5"  name="Prescaler = 64"     ref="(inputClockFrequency)/64."    enum="DivBy_64"     />
      <choice value="0,6"  name="Prescaler = 128"    ref="(inputClockFrequency)/128."   enum="DivBy_128"    />
      <choice value="0,7"  name="Prescaler = 256"    ref="(inputClockFrequency)/256."   enum="DivBy_256"    />
      <choice value="0,8"  name="Prescaler = 512"    ref="(inputClockFrequency)/512."   enum="DivBy_512"    />
      <choice value="0,9"  name="Prescaler = 1024"   ref="(inputClockFrequency)/1024."  enum="DivBy_1024"   />
      <choice value="0,10" name="Prescaler = 2048"   ref="(inputClockFrequency)/2048."  enum="DivBy_2048"   />
      <choice value="0,11" name="Prescaler = 4096"   ref="(inputClockFrequency)/4096."  enum="DivBy_4096"   />
      <choice value="0,12" name="Prescaler = 8192"   ref="(inputClockFrequency)/8192."  enum="DivBy_8192"   />
      <choice value="0,13" name="Prescaler = 16384"  ref="(inputClockFrequency)/16384." enum="DivBy_16384"  />
      <choice value="0,14" name="Prescaler = 32768"  ref="(inputClockFrequency)/32768." enum="DivBy_32768"  />
      <choice value="0,15" name="Prescaler = 65536"  ref="(inputClockFrequency)/65536." enum="DivBy_65536"  />
   </choiceOption>

   <floatOption key="counterFrequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      constant="true"
      description="Frequency of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="Hz"/>

   <floatOption key="maximumPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="65536/(counterFrequency)"
      typeName="Seconds"
      constant="true"
      description="Maximum period of timer"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="s"/>

   <floatOption key="lptmr_cmrPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(lptmr_cmr_compare+1)/counterFrequency#counterFrequency"
      typeName="Seconds &amp;"
      valueFormat="%s_s"
      description="Timer Compare Interval"
      toolTip="Comparison value\n
               The timer comparison flag is set when the counter reaches this value and increments. \n
               The hardware trigger will assert until the next time the counter increments. \n
               This value determines the period in TimeInterval mode or the event time in Pulse Counting mode"
      derived="true"
      min="0" units="s"/>

   <floatOption key="lptmr_cmrFrequency"  description="Timer Compare Frequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(counterFrequency)/(lptmr_cmr_compare+1)"
      toolTip="This is determined from lptmr_cmr register and clock frequency.\n
               When lptmr_csr_tfc=0 this is the lptmr_cnr roll-over frequency"
      derived="true"
      min="0" units="Hz"/>

   <title description="Pulse Counting Mode" />

   <choiceOption key="lptmr_psr_glitchFilter"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      target="filterDuration"
      description="Filter Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      enumStem="LptmrGlitchFilter"
      toolTip="Configures the size of the glitch filter in Pulse Counting mode" >
      <choice value="1,0"  name="No glitch filter"                 ref="0."                         enum="Direct"       />
      <choice value="0,1"  name="2 clock cycle glitch filter"      ref="2./inputClockFrequency"     enum="2_clocks"     />
      <choice value="0,2"  name="4 clock cycle glitch filter"      ref="4./inputClockFrequency"     enum="4_clocks"     />
      <choice value="0,3"  name="8 clock cycle glitch filter"      ref="8./inputClockFrequency"     enum="8_clocks"     />
      <choice value="0,4"  name="16 clock cycle glitch filter"     ref="16./inputClockFrequency"    enum="16_clocks"    />
      <choice value="0,5"  name="32 clock cycle glitch filter"     ref="32./inputClockFrequency"    enum="32_clocks"    />
      <choice value="0,6"  name="64 clock cycle glitch filter"     ref="64./inputClockFrequency"    enum="64_clocks"    />
      <choice value="0,7"  name="128 clock cycle glitch filter"    ref="128./inputClockFrequency"   enum="128_clocks"   />
      <choice value="0,8"  name="256 clock cycle glitch filter"    ref="256./inputClockFrequency"   enum="256_clocks"   />
      <choice value="0,9"  name="512 clock cycle glitch filter"    ref="512./inputClockFrequency"   enum="512_clocks"   />
      <choice value="0,10" name="1024 clock cycle glitch filter"   ref="1024./inputClockFrequency"  enum="1024_clocks"  />
      <choice value="0,11" name="2048 clock cycle glitch filter"   ref="2048./inputClockFrequency"  enum="2048_clocks"  />
      <choice value="0,12" name="4096 clock cycle glitch filter"   ref="4096./inputClockFrequency"  enum="4096_clocks"  />
      <choice value="0,13" name="8192 clock cycle glitch filter"   ref="81924./inputClockFrequency" enum="81924_clocks" />
      <choice value="0,14" name="16384 clock cycle glitch filter"  ref="16384./inputClockFrequency" enum="16384_clocks" />
      <choice value="0,15" name="32768 clock cycle glitch filter"  ref="32768./inputClockFrequency" enum="32768_clocks" />
   </choiceOption>

   <floatOption key="filterDuration"
      constant="true"
      description="Input filter duration"
      toolTip="Determined from timer clock source and glitch filter selection"
      derived="true"
      units="s" />

   <choiceOption key="lptmr_csr_tps" condition="lptmr_csr_tps_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      enumStem="LptmrPinSel"
      description="Input Pin"
      toolTip="Input source to be used in Pulse Counter mode">
      <choice value="0" name="CMP0 output"    enum="Cmp0" />
      <choice value="1" name="LPTMR_ALT1 pin" enum="AltPin1" />
      <choice value="2" name="LPTMR_ALT2 pin" enum="AltPin2" />
      <choice value="3" name="LPTMR_ALT3 pin" enum="AltPin3" />
   </choiceOption >

   <binaryOption key="lptmr_csr_tpp" condition="lptmr_csr_tpp_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      enumStem="LptmrPulseEdge"
      description="Pin Polarity"
      toolTip="Polarity of the input source in Pulse Counter mode">
      <choice value="0" name="Active-high source, rising-edge increments lptmr_cnr"  enum="Rising"  />
      <choice value="1" name="Active-low source,  falling-edge increments lptmr_cnr" enum="Falling" />
   </binaryOption >

<!--   ========== Methods =============================== -->

<!-- Graphic here -->

   <setTemplate variables="lptmr_csr_tcf" codeGenCondition="enableGettersAndSetters"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \tstatic void clearTimerCompleteFlag() {
      \t   %register = $register|%mask;
      \t}
      \t\n
   ]]></setTemplate>

   <for keys="field:name"
        values="
      lptmr_csr_tie:CsrTie;
      lptmr_csr_tps:CsrTps;
      lptmr_csr_tpp:CsrTpp;
      lptmr_csr_tfc:CsrTfc;
      lptmr_csr_tms:CsrTms;
      lptmr_csr_ten:CsrTen;
      lptmr_psr_prescale:PsrPrescale;
      lptmr_psr_pbyp:PsrPbyp;
      lptmr_psr_pcs:PsrPcs" >
      <setTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %defaultFieldExpression
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></setTemplate>
   </for>

<!--   ========== Methods =============================== -->

   <template><![CDATA[
      \t
      \t/// Minimum resolution for time interval setting
      \tstatic constexpr uint32_t minimumResolution = $(minimumResolution);\n\n
   ]]></template>

   <setTemplate variables="lptmr_cmr_compare" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \tstatic void setCompareThreshold(%params) {
      \t   %register = %paramExpression;
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_csr_tfc" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \tstatic void setActionOnCompare(%params) {
      \t   %defaultFieldExpression
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_csr_tps, lptmr_csr_tpp" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t *
      %paramDescription
      \t */
      \tstatic void selectPulseInput(
      %params) {
      \t   %defaultFieldExpression
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_csr_tie" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \tstatic void enableInterrupts(%params) {
      \t
      \t   if(%paramExpression) {
      \t      %register = %register | %mask;
      \t   }
      \t   else {
      \t      %register = %register & ~%mask;
      \t   }
      \t}
      \t/**
      \t * Clear interrupt flag
      \t */
      \tstatic void clearInterruptFlag() {
      \t
      \t   %register = %register | LPTMR_CSR_TCF_MASK;
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_psr_pcs,lptmr_psr_prescaler" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t *
      \t * These settings are used for the clock prescaler in timer mode.
      \t *
      %paramDescription
      \t */
      \tstatic void setClock(
      %params) {
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = 0;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_psr_pcs,lptmr_psr_glitchFilter" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t *
      \t * These settings are used for the glitch filter in pulse-counting mode.
      \t *
      %paramDescription
      \t */
      \tstatic void setClock(
      %params) {
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = 0;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></setTemplate>

   <clockCodeTemplate variable="lptmr_psr_pcs" codeGenCondition="enablePeripheralSupport"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %enumParam %tooltip
      \t */
      \tstatic void setInputClockSource(%enumClass %enumParam) {
      \t   %defaultFieldExpression
      \t}
      \t
      \t/**
      \t * Get %description frequency
      \t *
      %paramDescription
      \t
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default:
      %body
      \t   }
      \t}
      \t
      \t/**
      \t * Get %description frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency() {
      \t
      \t   return getInputClockFrequency((LptmrClockSel)(%defaultMaskingExpression));
      \t}
      \t
      \t/**
      \t * Get clock frequency after prescaler
      \t *
      \t * @return Frequency as a float in Hz
      \t */
      \tstatic float getClockFrequencyF() {
      \t
      \t   float freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}
      \t
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Frequency as a uint32_t in Hz (may underflow)
      \t */
      \tstatic uint32_t getClockFrequency() {
      \t
      \t   uint32_t freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}\n\n
   ]]></clockCodeTemplate>

   <setTemplate key="/LPTMR/StaticMethods" namespace="all" codeGenCondition="enablePeripheralSupport"
      nonDefaultParams="3"
      discardRepeats="true"
      variables="
         lptmr_csr_tfc,
         lptmr_csr_tie,
         lptmr_psr_pcs,
         lptmr_cmr_compare,
         lptmr_psr_prescaler"
   ><![CDATA[
      \t/**
      \t * Configure LPTMR in time counting mode.
      \t * The timer is enabled
      \t *
      %paramDescription
      \t */
      \tstatic void configureTimeIntervalMode(
      %params) {
      \t
      \t   enable();
      \t   // Change settings with timer disabled
      \t   %register0 = %enumParam0|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;
      \t
      \t   // Set clock source and prescaler
      \t   %register2 = %enumParam2|%enumParam4;
      \t
      \t   // Set event time
      \t   %register3 = %enumParam3;
      \t
      \t   // Enable timer
      \t   %register0 = %enumParam0|%enumParam1|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
      \t}\n\n
   ]]></setTemplate>

   <setTemplate key="/LPTMR/StaticMethods" namespace="all"
      nonDefaultParams="3"
      discardRepeats="true"
      variables="
         lptmr_csr_tfc,
         lptmr_csr_tie,
         lptmr_cmrPeriod,
         lptmr_psr_pcs"
   ><![CDATA[
      \t/**
      \t * Configure LPTMR in time counting mode.
      \t * The timer is enabled
      \t *
      %paramDescription
      \t */
      \tstatic ErrorCode configureTimeIntervalMode(
      %params) {
      \t
      \t   enable();
      \t
      \t   uint8_t  %registerName3 = %enumParam3;
      \t   uint32_t cmr;
      \t
      \t   ErrorCode rc = calculateDurationValues(%enumParam2, %registerName3, cmr);
      \t   if (rc != E_NO_ERROR) {
      \t      return rc;
      \t   }
      \t
      \t   // Change settings with timer disabled
      \t   %register0 = %enumParam0|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK;
      \t
      \t   // Set clock source and prescaler
      \t   %register3 = %registerName3;
      \t
      \t   // Set event time
      \t   lptmr->CMR = cmr;
      \t
      \t   // Enable timer
      \t   %register0 = %enumParam0|%enumParam1|LptmrMode_TimeInterval|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></setTemplate>

   <setTemplate key="/LPTMR/StaticMethods" namespace="all"
      nonDefaultParams="2"
      discardRepeats="true"
      variables="
         lptmr_csr_tps,
         lptmr_csr_tpp,
         lptmr_psr_pcs,
         lptmr_psr_glitchFilter,
         lptmr_csr_tfc,
         lptmr_csr_tie,
         lptmr_cmr_compare"
   ><![CDATA[
      \t/**
      \t * Configure LPTMR in pulse counting mode.
      \t * Provides selection of input pin, edge selection and reset mode.
      \t * The timer is enabled and pins configured.
      \t *
      %paramDescription
      \t */
      \tstatic void configurePulseCountingMode(
      %params) {
      \t
      \t   enable();
      \t
      \t   // Change settings with timer disabled
      \t   %register0 = %enumParam0|%enumParam1|%enumParam4|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK;
      \t
      \t   // Set clock source and prescaler
      \t   %register2 = %enumParam2|%enumParam3;
      \t
      \t   // Set Event time
      \t   %register6 = %enumParam6;
      \t
      \t   // Enable timer
      \t   %register0 = %enumParam0|%enumParam1|%enumParam4|%enumParam5|LptmrMode_PulseCounting|LPTMR_CSR_TCF_MASK|LPTMR_CSR_TEN_MASK;
      \t}\n\n
   ]]></setTemplate>

   <template key="/LPTMR/declarations" namespace="all"  ><![CDATA[
      \t/**
      \t * MACRO defining the start of a interrupt handler for a LPTMR
      \t * This will override the handler incorporated within the LPTMR class.
      \t *
      \t * @example
      \t * LPTMR$(_instance)_HANDLER() {
      \t *    console.writeln("PIT Channel $(_instance) Handler");
      \t *    // Clear interrupt flag
      \t *    lptmr->CSR = lptmr->CSR | LPTMR_CSR_TCF_MASK;
      \t * }
      \t */
      \t#define LPTMR$(_instance)_HANDLER() template<> void $(_Class)::irqHandler()\n\n
   ]]></template>

   <setTemplate variables="irqHandlingMethod"><![CDATA[
      \t/// Type for %description
      \ttypedef void (*%enumClass)();\n\n
   ]]></setTemplate>

<!--   ========== LPTMR Init class =============================== -->

   <template><![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR
      \t */
      \tclass Init {
      \t
      \tprotected:
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = delete;
      \t
      \t   /**
      \t    * No Default Constructor
      \t    */
      \t   constexpr Init() = delete;
      \t
      \t   /**
      \t    * Usual Constructor
      \t    */
      \t   constexpr Init(LptmrMode lptmrMode) : csr(lptmrMode|LPTMR_CSR_TEN_MASK) {
      \t   }\n
      \t
      \tpublic:
   ]]></template >

<!-- Member variables -->

   <setTemplate variables="irqHandlingMethod"
    ><![CDATA[
      \t
      #if $(irqHandlingMethod)
      \t   /// %description
      \t   %params = nullptr;
      #endif\n\n
   ]]></setTemplate>

   <setTemplate variables="lptmr_cmrPeriod"
    ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_s;\n\n
   ]]></setTemplate >

   <setTemplate variables="lptmr_cmr_compare"
    ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></setTemplate >

   <setTemplate
      variables=
         "lptmr_psr_prescaler,
          lptmr_psr_pcs"
    ><![CDATA[
      \t   /// Prescale Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></setTemplate >

   <initialValueTemplate
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

   <setTemplate
      variables=
         "lptmr_csr_tie,
          lptmr_csr_tfc"
    ><![CDATA[
      \t   /// Control and Status Register
      \t   uint8_t %registerName;\n\n
   ]]></setTemplate >

   <template><![CDATA[
      \t};\n\n
   ]]></template >

<!--   ========== LPTMR TimeIntervalModeInit class =============================== -->

   <template><![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Time Interval Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Lptmr$(_instance)::TimeIntervalModeInit lptmrInit {
      \t *    LptmrResetOn_Compare,    // Timer Free-Running Counter enable
      \t *    LptmrInterrupt_Disabled, // Timer interrupt enable
      \t *    LptmrClockSel_Oscerclk,  // Clock Source
      \t *    LptmrPrescale_Direct,    // Prescaler Value
      \t *    100_ms,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Time Interval mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass TimeIntervalModeInit : public Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit(const TimeIntervalModeInit &other) = delete;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit() : Init(LptmrMode_TimeInterval) {
      \t   };
      \t\n
   ]]></template >

<!--  Constructors -->

   <constructorTemplate
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      #if $(irqHandlingMethod)
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr TimeIntervalModeInit(%params, Types... rest) : TimeIntervalModeInit(rest...) {
      \t
      \t      this->%enumParam0 = %paramExpression;
      \t   }
      #endif\n\n
   ]]></constructorTemplate>

   <for keys="v"
      values="
         /PCR/nvic_irqLevel">
      <constructorTemplate
         variables="%(v)"
         linePadding="xxx"><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr TimeIntervalModeInit(%params, Types... rest) : TimeIntervalModeInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <for keys="v"
      values="
         lptmr_csr_tie;
         lptmr_csr_tfc;
         lptmr_psr_prescaler;
         lptmr_psr_pcs">
      <constructorTemplate
         variables="%(v)"
         linePadding="xxx"><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr TimeIntervalModeInit(%params, Types... rest) : TimeIntervalModeInit(rest...) {
         \t
         \t      %registerName = (%registerName & ~%mask) | %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <for keys="v"
      values="
         lptmr_cmr_compare;
         lptmr_cmrPeriod">
      <constructorTemplate
         variables="%(v)"
         linePadding="xxx"><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         %paramDescription
         \t    */
         \t   constexpr TimeIntervalModeInit(%params) : Init(LptmrMode_TimeInterval) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <template><![CDATA[
      \t};\n\n
   ]]></template>

<!--   ========== LPTMR PulseCountingModeInit class =============================== -->

   <template><![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Pulse Counting Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Lptmr$(_instance)::PulseCountingModeInit lptmrInit {
      \t *    LptmrPinSel_Cmp0,           // Timer Pin Select for Pulse Counter mode
      \t *    LptmrPulseEdge_Rising,      // Timer Pin Polarity for Pulse Counter mode
      \t *    LptmrClockSel_Oscerclk,     // Clock Source
      \t *    LptmrGlitchFilter_Direct,   // Filter Value
      \t *    LptmrInterrupt_Disabled,    // Timer interrupt enable
      \t *    LptmrResetOn_Compare,       // Timer Free-Running Counter enable
      \t *    916_ticks,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Pulse Counting mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass PulseCountingModeInit : public Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr PulseCountingModeInit(const PulseCountingModeInit &other) = delete;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr PulseCountingModeInit() : Init(LptmrMode_PulseCounting) {
      \t   }
      \t\n
   ]]></template>

<!-- Constructors -->

   <constructorTemplate
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      #if $(irqHandlingMethod)
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr PulseCountingModeInit(%params, Types... rest) : PulseCountingModeInit(rest...) {
      \t
      \t      this->%enumParam0 = %enumParam0;
      \t   }
      #endif\n\n
   ]]></constructorTemplate>

   <for keys="v"
      values="
         /PCR/nvic_irqLevel">
      <constructorTemplate
         variables="%(v)"
         linePadding="xxx"><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr PulseCountingModeInit(%params, Types... rest) : PulseCountingModeInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <for keys="v"
      values="
         lptmr_csr_tie;
         lptmr_csr_tps;
         lptmr_csr_tpp;
         lptmr_csr_tfc;
         lptmr_psr_pcs;
         lptmr_psr_glitchFilter;">
      <constructorTemplate variables="%(v)"
         linePadding="xxx" ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr PulseCountingModeInit(%params, Types... rest) : PulseCountingModeInit(rest...) {
         \t
         \t      %registerName = (%registerName & ~%mask) | %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <for keys="v"
      values="
         lptmr_cmr_compare">
      <constructorTemplate
         variables="%(v)"
         linePadding="xxx"><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         %paramDescription
         \t    */
         \t   constexpr PulseCountingModeInit(%params) : Init(LptmrMode_PulseCounting) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <template><![CDATA[
      \t};\n\n
   ]]></template>

<!--  Default Values -->

   <template key="/LPTMR/declarations" namespace="all"  ><![CDATA[
      \t/**
      \t * Class representing LPTMR$(_instance)
      \t *
      \t * <b>Example</b>
      \t * @code
      \t *
      \t * // LPTMR callback
      \t * void flash(void) {
      \t *    RED_LED::toggle();
      \t * }
      \t *
      \t * ...
      \t *
      \t * // Configure LPTMR in time counting mode
      \t * $(_Class)::configureTimeIntervalMode(
      \t *      LptmrResetOn_Compare,
      \t *      LptmrInterrupt_Enabled,
      \t *      LptmrClockSel_Lpoclk);
      \t *
      \t * // Set period of timer event
      \t * $(_Class)::setPeriod(5_s);
      \t *
      \t * // Set call-back
      \t * $(_Class)::setCallback(flash);
      \t * @endcode
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {
      \tpublic:\n
   ]]></template>
   <template key="/LPTMR/declarations" namespace="all" ><![CDATA[
      \t   /**
      \t    * Default value for Lptmr::PulseCountingModeInit
      \t    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t    */
      \t   static constexpr PulseCountingModeInit DefaultPulseCountingModeInitValue {\n
   ]]></template>
   <for keys="v" values="
            lptmr_csr_tps;
            lptmr_csr_tpp;
            lptmr_psr_pcs;
            lptmr_psr_glitchFilter;
            lptmr_csr_tie;
            lptmr_csr_tfc;
            lptmr_cmr_compare">
      <setTemplate key="/LPTMR/declarations" namespace="all"
         variables="%(v)"
         terminator=","
         separator=","
         linePadding="xxx"
      ><![CDATA[
         %initExpression\n
      ]]></setTemplate>
   </for>
   <template key="/LPTMR/declarations" namespace="all" ><![CDATA[
      \t   };\n\n
   ]]></template>

   <template key="/LPTMR/declarations" namespace="all" ><![CDATA[
      \t   /**
      \t    * Default value for Lptmr::TimeIntervalModeInit
      \t    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t    */
      \t   static constexpr TimeIntervalModeInit DefaultTimeIntervalModeInitValue {\n
   ]]></template>
   <for keys="v" values="
            lptmr_csr_tfc;
            lptmr_csr_tie;
            lptmr_psr_pcs;
            lptmr_psr_prescaler;
            lptmr_cmr_compare">
      <setTemplate key="/LPTMR/declarations" namespace="all"
         variables="%(v)"
         terminator=","
         separator=","
         linePadding="xxx"
      ><![CDATA[
         %initExpression\n
      ]]></setTemplate>
   </for>
   <template key="/LPTMR/declarations" namespace="all" ><![CDATA[
      \t   };\n\n
   ]]></template>

   <!-- ************* Common ****************** -->

   <template key="/LPTMR/declarations" namespace="all" ><![CDATA[
      \t   /**
      \t    * Enable LPTMR with default configuration.
      \t    *
      \t    * Includes enabling clock and any pins used.
      \t    * Sets LPTMR to default configuration
      \t    */
      \t   static void defaultConfigure() {
      \t
      \t      if constexpr ($(lptmr_csr_tms)) {
      \t         configure(DefaultPulseCountingModeInitValue);
      \t      }
      \t      else {
      \t         configure(DefaultTimeIntervalModeInitValue);
      \t      }
      \t   }
      \t};\n\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.LptmrValidate">
   </validate>

   <projectActionList id = "lptmr_files" >
      <copy source="Project_Headers/lptmr.h"                   target="Project_Headers/lptmr.h"                      overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-example.cpp"                target="Snippets/lptmr-example.cpp"                   overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-reaction-time.cpp"          target="Snippets/lptmr-reaction-time.cpp"             overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"    overwrite="true" derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" namespace="all" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" namespace="all" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* Signal mapping ****************** -->
   <signals enabledBy="enablePeripheralSupport" />

</peripheralPage>

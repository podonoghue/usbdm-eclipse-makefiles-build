<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- lptmr0.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Low Power Timer" >

   <constant key="input_pins" condition="!input_pins" value='"CMP0;$(_NAME)_ALT1;$(_NAME)_ALT2"' />

   <equation key="irq_pattern"                value='="^.*%b%i.*$"'       />
   <equation key="irq_ClassHandler"           value='="%c%i::irqHandler"' />
   <equation key="irq_parameters"             value=""          />
   <equation key="irq_dummy_parameters"       value=""          />
   <equation key="irq_call"                   value=""          />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <!-- ____ Class Declaration ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <!-- ____ CSR ____ -->

   <binaryOption key="lptmr_csr_ten" condition="lptmr_csr_ten_present"
      hidden="true"
      derived="true"
      typeName="LptmrCsrTen"
      baseType="uint8_t"
      description="Timer Enable"
      toolTip="Enables timer" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="lptmr_csr_tms" condition="lptmr_csr_tms_present"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrMode"
      baseType="uint8_t"
      toolTip="Selects between timer Interval and Pulse Counting\n
                   Should only be altered when timer is disabled."
      description="Operation mode of the LPTMR" >
      <choice value="0" name="Time Interval mode" enum="TimeInterval"  />
      <choice value="1" name="Pulse Counter mode" enum="PulseCounting" />
   </binaryOption>

   <binaryOption key="lptmr_csr_tie" condition="lptmr_csr_tie_present"
      enabledBy="irqHandlingMethod"
      typeName="LptmrEventAction"
      baseType="uint8_t"
      toolTip="Enables LPTMR interrupts"
      description="Timer action on event" >
      <choice value="0" name="None"       enum="None" />
      <choice value="1" name="Interrupt"  enum="Interrupt"  />
   </binaryOption>

   <binaryOption key="lptmr_csr_tfc" condition="lptmr_csr_tfc_present"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrCounterActionOnEvent"
      baseType="uint8_t"
      toolTip="Counter action when compare event occurs\n
               The counter can continue counting or be reset to zero.\n
               Should only be altered when timer is disabled."
      description="Counter Action on Compare Event" >
      <choice value="0" name="Counter is reset on event" enum="Reset"  />
      <choice value="1" name="Counter rolls over"        enum="None" />
   </binaryOption>

   <binaryOption key="lptmr_csr_tcf" condition="lptmr_csr_tcf_present"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="LptmrCompareFlag"
      baseType="uint8_t"
      toolTip="Flag is set when the LPTMR is enabled and the CNR equals the CMR and increments.\n
               Flag is cleared when the LPTMR is disabled or a logic 1 is written to it."
      description="Timer Compare Flag" >
      <choice name="No event"    value="0" enum="NoEvent"/>
      <choice name="Event"       value="1" enum="Event"/>
   </binaryOption >

   <!-- _________ CMR ______________ -->

   <intOption key="lptmr_cmr_compare" condition="lptmr_cmr_compare_present"
      enabledBy="enablePeripheralSupport"
      description="Timer Compare Value"
      units="ticks"
      baseType="uint16_t"
      toolTip="Comparison value\n
               The timer comparison flag is set when the counter reaches this value and increments. \n
               The hardware trigger will assert until the next time the counter increments. \n
               This value determines the period in TimeInterval mode or the event time in Pulse Counting mode\n
               The CMR must only be altered when timer is disabled or when TCF is set."
      value="65535" min="1" max="65535" />

   <choiceOption key="lptmr_psr_pcs" condition="lptmr_psr_pcs_present"
      enabledBy="enablePeripheralSupport"
      target="inputClockFrequency"
      typeName="LptmrClockSel"
      baseType="uint8_t"
      description="Clock source for LPTMR"
      toolTip="Selects the clock source for LPTMR\n
               Should only be altered when timer is disabled." >
      <choice value="0" name="MCG Internal Reference Clock (MCGIRCLK)"        enum="Mcgirclk" ref="/MCG/system_mcgirclk_clock[0]" code="McgInfo::getMcgIrClock()"  />
      <choice value="1" name="Low power oscillator (LPO - 1kHz)"              enum="Lpoclk"   ref="/PMC/system_low_power_clock"   code="SimInfo::getLpoClock()"    isDefault="true" />
      <choice value="2" name="32kHz Clock Source (ERCLK32)"                   enum="Erclk32"  ref="/SIM/system_erclk32k_clock"    code="SimInfo::getErc32kClock()" />
      <choice value="3" name="Oscillator External Reference Clock (OSCERCLK)" enum="Oscerclk" ref="/OSC0/oscer_clock"             code="Osc0Info::getOscerClock()" />
   </choiceOption>

   <intOption key="inputClockFrequency"
      description="Frequency of input clock to timer"
      units="Hz"
      derived="true"
      locked="true" />

   <!-- _________ Time Interval Mode ______________ -->

   <title description="Time Interval Mode" />

   <!-- _________ PSR ______________ -->

   <choiceOption key="lptmr_psr_prescaler" condition="lptmr_psr_prescale_present"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      target="counterFrequency"
      description="Prescaler Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      typeName="LptmrPrescale"
      baseType="uint8_t"
      toolTip="Configures the size of the Prescaler in Time Interval mode\n
               Should only be altered when timer is disabled." >
      <choice value="1,0"  name="Prescaler = 1"      ref="(inputClockFrequency)"        enum="Direct"       />
      <choice value="0,0"  name="Prescaler = 2"      ref="(inputClockFrequency)/2."     enum="DivBy_2"      />
      <choice value="0,1"  name="Prescaler = 4"      ref="(inputClockFrequency)/4."     enum="DivBy_4"      />
      <choice value="0,2"  name="Prescaler = 8"      ref="(inputClockFrequency)/8."     enum="DivBy_8"      />
      <choice value="0,3"  name="Prescaler = 16,"    ref="(inputClockFrequency)/16."    enum="DivBy_16"     />
      <choice value="0,4"  name="Prescaler = 32,"    ref="(inputClockFrequency)/32."    enum="DivBy_32"     />
      <choice value="0,5"  name="Prescaler = 64"     ref="(inputClockFrequency)/64."    enum="DivBy_64"     />
      <choice value="0,6"  name="Prescaler = 128"    ref="(inputClockFrequency)/128."   enum="DivBy_128"    />
      <choice value="0,7"  name="Prescaler = 256"    ref="(inputClockFrequency)/256."   enum="DivBy_256"    />
      <choice value="0,8"  name="Prescaler = 512"    ref="(inputClockFrequency)/512."   enum="DivBy_512"    />
      <choice value="0,9"  name="Prescaler = 1024"   ref="(inputClockFrequency)/1024."  enum="DivBy_1024"   />
      <choice value="0,10" name="Prescaler = 2048"   ref="(inputClockFrequency)/2048."  enum="DivBy_2048"   />
      <choice value="0,11" name="Prescaler = 4096"   ref="(inputClockFrequency)/4096."  enum="DivBy_4096"   />
      <choice value="0,12" name="Prescaler = 8192"   ref="(inputClockFrequency)/8192."  enum="DivBy_8192"   />
      <choice value="0,13" name="Prescaler = 16384"  ref="(inputClockFrequency)/16384." enum="DivBy_16384"  />
      <choice value="0,14" name="Prescaler = 32768"  ref="(inputClockFrequency)/32768." enum="DivBy_32768"  />
      <choice value="0,15" name="Prescaler = 65536"  ref="(inputClockFrequency)/65536." enum="DivBy_65536"  />
   </choiceOption>

   <floatOption key="counterFrequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      locked="true"
      description="Frequency of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="Hz"/>

   <floatOption key="maximumPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="65536/(counterFrequency)"
      typeName="Seconds"
      locked="true"
      description="Maximum period of timer"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="s"/>

   <floatOption key="lptmr_cmrPeriod"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(lptmr_cmr_compare+1)/counterFrequency#counterFrequency"
      description="Timer Compare Interval"
      toolTip="Comparison value\n
               The timer comparison flag is set when the counter reaches this value and increments. \n
               The hardware trigger will assert until the next time the counter increments. \n
               This value determines the period in TimeInterval mode or the event time in Pulse Counting mode"
      derived="true"
      min="0" units="s"/>

   <floatOption key="lptmr_cmrFrequency"  description="Timer Compare Frequency"
      enabledBy="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      ref="(counterFrequency)/(lptmr_cmr_compare+1)"
      toolTip="This is determined from lptmr_cmr register and clock frequency.\n
               When lptmr_csr_tfc=0 this is the lptmr_cnr roll-over frequency"
      derived="true"
      min="0" units="Hz"/>

   <!-- _________ Pulse Counting Mode ______________ -->

   <title description="Pulse Counting Mode" />

   <choiceOption key="lptmr_psr_glitchFilter"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      target="filterDuration"
      description="Filter Value"
      valueFormat="LPTMR_PSR_PBYP(%s),LPTMR_PSR_PRESCALE(%s)"
      typeName="LptmrGlitchFilter"
      baseType="uint8_t"
      toolTip="Configures the size of the glitch filter in Pulse Counting mode\n
               Should only be altered when timer is disabled." >
      <choice value="1,0"  name="No glitch filter"                 ref="0."                         enum="Direct"       />
      <choice value="0,1"  name="2 clock cycle glitch filter"      ref="2./inputClockFrequency"     enum="2_clocks"     />
      <choice value="0,2"  name="4 clock cycle glitch filter"      ref="4./inputClockFrequency"     enum="4_clocks"     />
      <choice value="0,3"  name="8 clock cycle glitch filter"      ref="8./inputClockFrequency"     enum="8_clocks"     />
      <choice value="0,4"  name="16 clock cycle glitch filter"     ref="16./inputClockFrequency"    enum="16_clocks"    />
      <choice value="0,5"  name="32 clock cycle glitch filter"     ref="32./inputClockFrequency"    enum="32_clocks"    />
      <choice value="0,6"  name="64 clock cycle glitch filter"     ref="64./inputClockFrequency"    enum="64_clocks"    />
      <choice value="0,7"  name="128 clock cycle glitch filter"    ref="128./inputClockFrequency"   enum="128_clocks"   />
      <choice value="0,8"  name="256 clock cycle glitch filter"    ref="256./inputClockFrequency"   enum="256_clocks"   />
      <choice value="0,9"  name="512 clock cycle glitch filter"    ref="512./inputClockFrequency"   enum="512_clocks"   />
      <choice value="0,10" name="1024 clock cycle glitch filter"   ref="1024./inputClockFrequency"  enum="1024_clocks"  />
      <choice value="0,11" name="2048 clock cycle glitch filter"   ref="2048./inputClockFrequency"  enum="2048_clocks"  />
      <choice value="0,12" name="4096 clock cycle glitch filter"   ref="4096./inputClockFrequency"  enum="4096_clocks"  />
      <choice value="0,13" name="8192 clock cycle glitch filter"   ref="81924./inputClockFrequency" enum="81924_clocks" />
      <choice value="0,14" name="16384 clock cycle glitch filter"  ref="16384./inputClockFrequency" enum="16384_clocks" />
      <choice value="0,15" name="32768 clock cycle glitch filter"  ref="32768./inputClockFrequency" enum="32768_clocks" />
   </choiceOption>

   <floatOption key="filterDuration"
      locked="true"
      description="Input filter duration"
      toolTip="Determined from timer clock source and glitch filter selection"
      derived="true"
      units="s" />

   <!--  printVar key="input_pins" / -->

   <choiceOption key="lptmr_csr_tps" condition="lptmr_csr_tps_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      typeName="LptmrInput"
      baseType="uint8_t"
      description="Input Pin"
      toolTip="Input source to be used in Pulse Counter mode\n
               Should only be altered when timer is disabled." >
      <choiceExpansion
         keys="name" values='=input_pins' delimiter=";"
         name="%(name)" value="%(i)"
         enum='=ReplaceAll("%(name)","^.*?_(.*)$","$1")'
         signal="%(name)"
         condition='=HardwareExists("%(name)")' />
   </choiceOption >

   <binaryOption key="lptmr_csr_tpp" condition="lptmr_csr_tpp_present"
      enabledBy="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      typeName="LptmrInputEdge"
      baseType="uint8_t"
      description="Pin Polarity"
      toolTip="Polarity of the input source in Pulse Counter mode\n
               Should only be altered when timer is disabled." >
      <choice value="0" name="Active-high, increment count on rising-edge"  enum="Rising"  />
      <choice value="1" name="Active-low, increment count on falling-edge"  enum="Falling" />
   </binaryOption >


   <!-- ____ CNR ____ -->

   <intOption key="lptmr_cnr_counter" condition="lptmr_cnr_counter_present"
      hidden="true"
      derived="true"
      baseType="uint16_t"
      description="Counter Value"
      toolTip="Current counter value\n
               This is a read-only register."
   />

   <!-- ____ Getters and Setters ________ -->

   <for keys="field                   : set   : get   : clear : genCode                 : name"
        values="
         lptmr_csr_tcf                : false : true  : true  : enablePeripheralSupport : EventFlag;
         lptmr_csr_tie                : true  : true  : false : enablePeripheralSupport : EventAction;
         lptmr_csr_tps                : true  : true  : false : enableGettersAndSetters : InputSelect;
         lptmr_csr_tpp                : true  : true  : false : enableGettersAndSetters : InputEdge;
         lptmr_csr_tfc                : true  : true  : false : enableGettersAndSetters : CounterActionOnEvent;
         lptmr_csr_tms                : true  : true  : false : enableGettersAndSetters : Mode;
         lptmr_csr_ten                : true  : true  : false : enableGettersAndSetters : Enable;
         lptmr_csr_tps,lptmr_csr_tpp  : true  : false : false : enableGettersAndSetters : Input;

         lptmr_psr_pcs                : true  : true  : false : enablePeripheralSupport : ClockSource;

         lptmr_cmr_compare            : true  : true  : false : enablePeripheralSupport : CompareThreshold;


         lptmr_cnr_counter            : false : true  : false : enablePeripheralSupport : Counter;

         lptmr_cnr_counter            : false : false : false : enableGettersAndSetters : Counter" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t * (%(field))
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %returnType get%(name)() {
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
         tooltipPadding="x*x"
      ><![CDATA[
         \t/**
         \t * Clear %description
         \t * (%(field))
         \t *
         \t * %tooltip
         \t */
         \tstatic void clear%(name)() {
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate variables="lptmr_psr_pcs,lptmr_psr_prescaler" codeGenCondition="enablePeripheralSupport"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t *
      \t * These settings are used for the clock prescaler in timer mode.
      \t *
      %paramDescription
      \t */
      \tstatic void setClock(%params) {
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = 0;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></variableTemplate>

   <variableTemplate variables="lptmr_psr_pcs,lptmr_psr_glitchFilter" codeGenCondition="enablePeripheralSupport"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Set %description0 and %description1
      \t *
      \t * These settings are used for the glitch filter in pulse-counting mode.
      \t *
      %paramDescription
      \t */
      \tstatic void setClock(%params) {
      \t   // Disable LPTMR before prescale change
      \t   uint32_t csr = lptmr->CSR;
      \t   lptmr->CSR   = 0;
      \t   (void)(lptmr->CSR);
      \t   %register   = %paramExpression;
      \t   lptmr->CSR   = csr;
      \t}\n\n
   ]]></variableTemplate>

   <clockCodeTemplate variable="lptmr_psr_pcs" codeGenCondition="enablePeripheralSupport"
      returnFormat="%s"
   ><![CDATA[
      \t// Make visible
      \tusing LptmrBasicInfo::getInputClockFrequency;
      \t
      \t/**
      \t * Get %description frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency() {
      \t
      \t   return getInputClockFrequency(LptmrClockSel(%maskingExpression));
      \t}
      \t
      \t/**
      \t * Get clock frequency after prescaler
      \t *
      \t * @return Frequency as a float in Hz
      \t */
      \tstatic float getClockFrequencyF() {
      \t
      \t   float freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}
      \t
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Frequency as a uint32_t in Hz (may underflow)
      \t */
      \tstatic uint32_t getClockFrequency() {
      \t
      \t   uint32_t freq = getInputClockFrequency();
      \t   if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
      \t      return freq;
      \t   }
      \t   return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
      \t}\n\n
   ]]></clockCodeTemplate>

   <!--   ______ LPTMR Init class ___________ -->

   <clockCodeTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variable="lptmr_psr_pcs"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description frequency
      \t *
      %paramDescription
      \t
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default:
      %body
      \t   }
      \t}
      \t\n
   ]]></clockCodeTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Calculate timing information based on desired duration and selected clock (from psr.pcs)
      \t *
      \t * @param[in]     duration   Desired period or event duration
      \t * @param[inout]  psr        Input: psr.pcs Output: updated with psr.prescale and psr.pbyp
      \t * @param[out]    cmr        Compare register value
      \t *
      \t * @return E_NO_ERROR      => Success
      \t * @return E_ILLEGAL_PARAM => Failed to find suitable values for psr.prescale and psr.pbyp
      \t */
      \tstatic ErrorCode calculateDurationValues(Seconds duration, uint8_t &psr, uint32_t &cmr) {
      \t
      \t   float inputClock = getInputClockFrequency(LptmrClockSel(psr&LPTMR_PSR_PCS_MASK));
      \t
      \t   int      prescaleFactor=1;
      \t   uint32_t prescalerValue=0;
      \t   while (prescalerValue<=16) {
      \t      float    clockFrequency = inputClock/prescaleFactor;
      \t      uint32_t mod   = rintf(float(duration*clockFrequency))-1;
      \t      if (mod <= LPTMR_CMR_COMPARE_MASK) {
      \t         cmr  = mod;
      \t         psr  = (psr&LPTMR_PSR_PCS_MASK)|LPTMR_PSR_PRESCALE(prescalerValue-1)|LPTMR_PSR_PBYP(prescalerValue==0);
      \t         return E_NO_ERROR;
      \t      }
      \t      prescalerValue++;
      \t      prescaleFactor <<= 1;
      \t   }
      \t   // Too long a period
      \t   return setAndCheckErrorCode(E_TOO_LARGE);
      \t}
      \t\n
   ]]></template >

   <!--   ______ LPTMR Init class ___________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = delete;
      \t
      \tprotected:
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() {};
      \t
      \tpublic:\n
   ]]></template >

   <!-- ____ Init class Member variables ________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName = nullptr;\n\n
   ]]></variableTemplate>

   <for keys=" type        : variables                                            : init           "
       values="%returnType : lptmr_cmrPeriod                                      : 0_s            ;
               %baseType   : lptmr_cmr_compare                                    : 0              ;
               %baseType   : lptmr_psr_prescaler,lptmr_psr_pcs                    : 0              ;
               %baseType   : lptmr_csr_tie,lptmr_csr_tfc                          : 0              ;
               %paramType  : /PCR/nvic_irqLevel                                   : %defaultValue  " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t}; // class $(_BasicInfo)::Init\n\n
   ]]></template >

<!--   ______ LPTMR TimeIntervalModeInit class ___________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Time Interval Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Lptmr$(_instance)::TimeIntervalModeInit lptmrInit {
      \t *    LptmrResetOn_Compare,    // Timer Free-Running Counter enable
      \t *    LptmrInterrupt_Disabled, // Timer interrupt enable
      \t *    LptmrClockSel_Oscerclk,  // Clock Source
      \t *    LptmrPrescale_Direct,    // Prescaler Value
      \t *    100_ms,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Time Interval mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass TimeIntervalModeInit : public Init {
      \t
      \tprivate:
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit(const Init &other) = delete;
      \t
      \tpublic:
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr TimeIntervalModeInit() : Init() {
      \t
      \t      csr = (csr & ~LPTMR_CSR_TMS_MASK) | LptmrMode_TimeInterval;
      \t   }
      \t\n
   ]]></template >

   <!-- ____ TimeIntervalModeInit class Constructors ________ -->

   <for keys="variable           : condition"
     values="
             /PCR/nvic_irqLevel  : $(_BasicInfoGuard) ;
             irqHandlingMethod   : $(_BasicInfoIrqGuard) ;
             lptmr_csr_tie       : $(_BasicInfoGuard) ;
             lptmr_csr_tfc       : $(_BasicInfoGuard) ;
             lptmr_psr_prescaler : $(_BasicInfoGuard) ;
             lptmr_psr_pcs       : $(_BasicInfoGuard) ;
             lptmr_cmr_compare   : $(_BasicInfoGuard) ;
             lptmr_cmrPeriod     : $(_BasicInfoGuard) ">
      <variableTemplate where="basicInfo" codeGenCondition="%(condition)"
         variables="%(variable)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr TimeIntervalModeInit(%params, Types... rest) : TimeIntervalModeInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t}; // class $(_BasicInfo)::TimeIntervalModeInit\n\n
   ]]></template>

<!--   ______ LPTMR PulseCountingModeInit class ___________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of LPTMR in Pulse Counting Mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Lptmr$(_instance)::PulseCountingModeInit lptmrInit {
      \t *    LptmrPinSel_Cmp0,           // Timer Pin Select for Pulse Counter mode
      \t *    LptmrInputEdge_Rising,      // Timer Pin Polarity for Pulse Counter mode
      \t *    LptmrClockSel_Oscerclk,     // Clock Source
      \t *    LptmrGlitchFilter_Direct,   // Filter Value
      \t *    LptmrInterrupt_Disabled,    // Timer interrupt enable
      \t *    LptmrResetOn_Compare,       // Timer Free-Running Counter enable
      \t *    916_ticks,                  // Timer Compare Register
      \t * };
      \t *
      \t * // Initialise LPTMR$(_instance) in Pulse Counting mode using values specified above
      \t * Lptmr$(_instance).configure(lptmrInit)
      \t * @endcode
      \t */
      \tclass PulseCountingModeInit : public Init {
      \t
      \tprivate:
      \t   /**
      \t    * No Copy Constructor
      \t    */
      \t   constexpr PulseCountingModeInit(const Init &other) = delete;
      \t
      \tpublic:
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr PulseCountingModeInit() : Init() {
      \t
      \t      csr = (csr & ~LPTMR_CSR_TMS_MASK) | LptmrMode_PulseCounting;
      \t   }
      \t\n
   ]]></template>

<!-- Constructors -->

   <for keys="variable              : condition"
     values="
             /PCR/nvic_irqLevel     : $(_BasicInfoGuard) ;
             irqHandlingMethod      : $(_BasicInfoIrqGuard) ;
             lptmr_csr_tie          : $(_BasicInfoGuard) ;
             lptmr_csr_tfc          : $(_BasicInfoGuard) ;
             lptmr_psr_pcs          : $(_BasicInfoGuard) ;
             lptmr_cmr_compare      : $(_BasicInfoGuard) ;
             lptmr_csr_tps          : $(_BasicInfoGuard) ;
             lptmr_csr_tpp          : $(_BasicInfoGuard) ;
             lptmr_psr_glitchFilter : $(_BasicInfoGuard) ">
      <variableTemplate where="basicInfo" codeGenCondition="%(condition)"
         variables="%(variable)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr PulseCountingModeInit(%params, Types... rest) : PulseCountingModeInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::PulseCountingModeInit
      \t\n
   ]]>
   </template>

<!--   ______ Default Values ___________ -->

   <variableTemplate codeGenCondition="enablePeripheralSupport&amp;&amp;!lptmr_csr_tms"
      terminator=","
      separator=","
      padToComments="35"
      variables="
         lptmr_csr_tfc,lptmr_csr_tie,
         lptmr_psr_pcs,lptmr_psr_prescaler,
         lptmr_cmr_compare,
         irqLevel"
   ><![CDATA[
      \t/**
      \t * Default value for Lptmr in Time Interval Mode
      \t * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t */
      \tstatic constexpr TimeIntervalModeInit DefaultInitValue {%initNonZeroValues
      \t};
      \t\n
   ]]></variableTemplate>

   <variableTemplate  codeGenCondition="enablePeripheralSupport&amp;&amp;lptmr_csr_tms"
      variables=" lptmr_csr_tps,lptmr_csr_tpp,
                  lptmr_psr_pcs,lptmr_psr_glitchFilter,
                  lptmr_csr_tie,lptmr_csr_tfc,
                  lptmr_cmr_compare,
                  irqLevel"
      terminator=","
      separator=","
   ><![CDATA[
      \t/**
      \t * Default value for Lptmr in Pulse Counting Mode
      \t * This value is created from Configure.usbdmProject settings (Peripheral Parameters->LPTMR)
      \t */
      \tstatic constexpr PulseCountingModeInit DefaultInitValue {%initNonZeroValues
      \t};
      \t\n
   ]]></variableTemplate>

   <!-- ____ Configure methods and helpers ______________ -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure LPTMR from values specified in init.
      \t *
      \t * @param init Class containing initialisation information
      \t */
      \tstatic ErrorCode configure(const Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="irqHandlingMethod" ><![CDATA[
      \t   // Configure call-back
      \t   setCallback(init.callbackfunction);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   enableNvicInterrupts(init.irqlevel);
      \t
      \t   uint8_t  psr = init.psr;
      \t   uint32_t cmr = init.cmr;
      \t
      \t   if (init.cmrperiod != 0) {
      \t      // Calculate values from duration in seconds
      \t      ErrorCode rc = calculateDurationValues(init.cmrperiod, psr, cmr);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }
      \t   }
      \t   // Change settings with timer disabled
      \t   lptmr->CSR = 0;
      \t
      \t   // Update clock setting
      \t   lptmr->PSR = psr;
      \t
      \t   // Timer Compare Register
      \t   lptmr->CMR = cmr;
      \t
      \t   // Enable timer
      \t   lptmr->CSR = init.csr|LPTMR_CSR_TEN_MASK;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Enable LPTMR with default configuration.
      \t *
      \t * Includes enabling clock and any pins used.
      \t * Sets LPTMR to default configuration
      \t */
      \tstatic void defaultConfigure() {
      \t   configure(DefaultInitValue);
      \t}
      \t\n
   ]]></template>

   <!-- ____ Common ______________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Info)> {};
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.LptmrValidate" >
   </validate>

   <projectActionList id="lptmr_files" >
      <copy source="Project_Headers/lptmr.h"                   target="Project_Headers/lptmr.h"                      overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-example.cpp"                target="Snippets/lptmr-example.cpp"                   overwrite="true" derived="true" />
      <copy source="Snippets/lptmr-reaction-time.cpp"          target="Snippets/lptmr-reaction-time.cpp"             overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"    overwrite="true" derived="true" />
   </projectActionList>

   <!-- ____ Startup ______________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ______________ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping ______________ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</peripheralPage>

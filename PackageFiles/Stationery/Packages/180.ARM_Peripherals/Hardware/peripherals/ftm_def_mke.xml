<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- ftm_def-mke.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <constant key="suppressInstance"         type="Boolean" value="false"         />
   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"          />
   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"  />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="true"          />
   <xi:include href="_enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%variable[index]            Variable name
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <!-- ====================== constants ====================== -->
   <constant key = "disable_peripheral"      value = "&quot;ftm->SC = FTM_SC_CLKS(0);&quot;" type="String"  />

   <intOption key="NumChannels"
      locked="true"
      derived="true"
      description="Number of Channels"
      toolTip="The number of timer channels available"
      value="=_channelCount" />

   <intOption key="NumChannelVectors"
      locked="true"
      derived="true"
      description="Number of Channel interrupt vectors"
      toolTip="Number of channel event interrupt vectors - \n
               Multiple Channels may be mapped to the same vector"
      value="=_irqCount" />

   <template><![CDATA[
      \t//! Number of channels implemented
      \tstatic constexpr unsigned NumChannels = $(NumChannels);

      \t//! Number of channel event vectors implemented
      \tstatic constexpr unsigned NumChannelVectors = $(NumChannelVectors);\n\n
   ]]></template>

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Baseclass)BasicInfo&quot;" />

   <binaryOption key="individualChannelCallbacks" condition="=_channelCount>_irqCount"
      enabledBy="irqHandlingMethod"
      description="Use individual channel call-backs"
      toolTip="The different FTM channels use a common hardware interrupt handler. \n
               If this option is enabled, then the hardware handler examines the interrupt source \n
               and dispatches to individual channel call-backs. \n
               This is more convenient but will increase the interrupt latency. \n
               If disabled, then a common call-back is used for all channels which leads to lower latency. \n
               The common call-back will then have to determine the interrupt source as needed." >
      <choice value="false"  name="Shared call-back"      isDefault="true" />
      <choice value="true"   name="Individual call-backs" />
   </binaryOption>

   <binaryOption key="check_minimums"
      enabledBy="enablePeripheralSupport"
      description="Check minimum interval and minimum resolution"
      toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
      <choice value="0" name="No checks done" />
      <choice value="1" name="Do checks"  isDefault="true" />
   </binaryOption>

   <intOption key="minimumInterval"
      enabledBy="check_minimums"
      description="Minimum usable interval in ticks"
      toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
               when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
      value="20" min="0" max="65535"/>

   <intOption key="minimumResolution"
      enabledBy="check_minimums"
      description="Minimum resolution for PWM interval"
      toolTip="This value is used as a minimum value for the timer period in ticks \n
         so that a reasonable resolution is available for PWM duty-cycle"
      value="100" min="0" max="65535" />

   <title description="Clocking" />

   <choiceOption key="ftm_sc_clks" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      description="Clock Source"
      typeName="FtmClockSource"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module">
      <choice value="0" name="Disabled"              ref="disabled"                      code="0"                enum="Disabled"            />
      <choice value="1" name="System clock"          ref="/SIM/system_bus_clock[0]"      code="SystemBusClock"   enum="SystemClock"         isDefault="true" />
      <choice value="2" name="Fixed frequency clock" ref="/MCG/system_mcgffclk_clock[0]" code="SystemMcgFFClock" enum="FixedFrequencyClock" />
      <choice value="3" name="External clock"        ref="ftmExternalClock"              code="ftmExternalClock" enum="ExternalClock"       />
   </choiceOption>

   <choiceOption key="ftm_sc_clks"  condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      description="FTM Clock Source"
      typeName="FtmClockSource"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module">
      <choice value="0" name="Disabled"              ref="disabled"                      code="0"                enum="Disabled"            />
      <choice value="1" name="System timer clock"    ref="/SIM/system_timer_clock[0]"    code="SystemTimerClock" enum="SystemTimerClock"    isDefault="true" />
      <choice value="2" name="Fixed frequency clock" ref="/ICS/system_icsffclk_clock[0]" code="SystemIcsFFClock" enum="FixedFrequencyClock" />
      <choice value="3" name="External clock"        ref="ftmExternalClock"              code="ftmExternalClock" enum="ExternalClock"       />
   </choiceOption>

   <intOption key="ftmExternalClock"
      enabledBy="enablePeripheralSupport&amp;&amp;(ftm_sc_clks==3)"
      description="FTM External clock"
      toolTip="Assumed clock frequency used for calculations when External clock is selected"
      value="0" min="0" units="Hz"/>

   <intOption key="inputClockFrequency"
      enabledBy="enablePeripheralSupport"
      locked="true"
      description="Frequency of input clock to timer"
      derived="true"
      units="Hz"/>

   <choiceOption key="ftm_sc_ps"
      enabledBy="enablePeripheralSupport"
      description="Clock prescaler"
      typeName="FtmPrescale"
      target="clock"
      toolTip="Selects the prescaler for the module">
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"        enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="(inputClockFrequency)/2."   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="(inputClockFrequency)/4."   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="(inputClockFrequency)/8."   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="(inputClockFrequency)/16."  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="(inputClockFrequency)/32."  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="(inputClockFrequency)/64."  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="(inputClockFrequency)/128." enum="DivBy128" />
   </choiceOption>

   <floatOption key="clock"
      description="Counter tick rate"
      toolTip="The tick rate of the main FTM counter"
      derived="true"
      locked="true"
      units="Hz"
    />

   <floatOption key="clockPeriod"
      ref="(1.0/clock)"
      hidden="true"
      locked="true"
      derived="true"
   />

   <title description="Common configuration"/>

   <choiceOption key="ftm_sc_mode"
      enabledBy="enablePeripheralSupport"
      valueFormat="FTM_SC_TOF(%s),FTM_SC_CPWMS(%s)"
      typeName="FtmMode"
      description="Alignment and whether interval or free-running mode"
      toolTip="Left-aligned   (cntin...mod) or\n
               Centre-aligned (cntin...mod...cntin) or\n
               Free-running   (0...65535)">
      <choice value="0,0" name="Left-aligned (count up)"         enum="LeftAligned"    />
      <choice value="0,1" name="Centre-aligned (count up-down)"  enum="CentreAligned"  />
      <choice value="1,0" name="Free-running (count up)"         enum="FreeRunning"  isDefault="true" />
   </choiceOption>

   <intOption key="ftm_cntin"
      description="Start value for counter"
      enabledBy="ftm_sc_mode!=2"
      toolTip="The timer counts from this value to ftm_mod"
      typeName="Ticks &amp;"
      units="ticks"
      value="0" min="0" max="65535" />

   <intOption key="ftm_mod"
      description="End value for counter"
      enabledBy="ftm_sc_mode!=2"
      toolTip="The timer counts from ftm_cntin to this value"
      typeName="Ticks &amp;"
      units="ticks"
      value="65535" min="0" max="65535" />

   <floatOption key="ftm_modPeriod"
      ref="clockPeriod*((ftm_sc_mode==2)?(65536):((ftm_sc_mode==1)?(2*(ftm_mod-ftm_cntin)):(ftm_mod-ftm_cntin+1)))"
      typeName="Seconds &amp;"
      unlockedBy="ftm_sc_mode!=2"
      valueFormat="%s_s"
      description="Period or minimum interval of timer"
      toolTip="In left-aligned or centre-aligned this is the period of the timer\n
               In free-running mode it is the minimum interval"
      derived="true"
      units="s" />

   <choiceOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;ftm_sc_dma_present"
      enabledBy="irqHandlingMethod"
      valueFormat="FTM_SC_TOIE(%s),FTM_SC_DMA(%s)"
      enumType="uint16_t"
      typeName="FtmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt and/or DMA on counter overflow">
       <choice value="0,0" name="No action"                    enum="None"             />
       <choice value="0,1" name="DMA request"                  enum="Dma"              />
       <choice value="1,0" name="Interrupt request"            enum="Interrupt"        />
       <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  />
   </choiceOption>

   <binaryOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;!ftm_sc_dma_present"
      enabledBy="irqHandlingMethod"
      valueFormat="FTM_SC_TOIE(%s)"
      enumType="uint8_t"
      typeName="FtmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt on counter overflow">
      <choice value="0" name="No action"          enum="None"       />
      <choice value="1" name="Overflow Interrupt" enum="Interrupt"  />
   </binaryOption>

   <!-- ************* MODE ****************** -->

   <category name="Miscellaneous" description="Miscellaneous" >
      <!-- not sensible to initialise these -->
      <!-- binaryOption key="ftm_mode_captest" condition="ftm_mode_captest_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmCaptestMode"
         description="Capture Test Mode Enable" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption -->

      <binaryOption key="ftm_mode_pwmsync" condition="ftm_mode_pwmsync_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModePwmsync"
         description="PWM Synchronization Mode"
         toolTip="Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.\n
                  It only configures the synchronization when SYNCMODE is 0.\n
                  No restriction:  MOD, CnV, OUTMASK and FTM counter synch, may use softwar or hardware trigger,\n
                  MOD,CnV use software trigger, OUTMASK,FTM counter synch use hardware trigger." >
         <choice name="No restrictions (hardware or software)."  value="0" enum="NoRestrictions"/>
         <choice name="MOD,CnV use software, OUTMASK, counter synch use hardware"    value="1" enum="Restricted"/>
      </binaryOption >

      <binaryOption key="ftm_mode_wpdis" condition="ftm_mode_wpdis_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModeWpdis"
         description="Write Protection Disable"
         toolTip="This value is applied after main FTM configuration" >
         <choice name="Enabled"     value="0" enum="Enabled"/>
         <choice name="Disabled"    value="1" enum="Disabled"/>
      </binaryOption >

      <binaryOption key="ftm_mode_ftmen" condition="ftm_mode_ftmen_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModeFtmen"
         description="FTM Mode Enable"
         toolTip="This field is write protected. It can be written only when MODE[WPDIS] = 1" >
         <choice name="TPM registers only"  value="0" enum="TpmRegistersOnly"/>
         <choice name="All registers"       value="1" enum="AllRegisters"/>
      </binaryOption >

      <binaryOption key="ftm_mode_init" condition="ftm_mode_init_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmInitialiseOutputs"
         description="Initialisation of Channel Outputs"
         toolTip="When written to 1 the channels outputs are initialized according to the state of\n
                  their corresponding bit in the OUTINIT register\n
                  This is applied after the main FTM configuration">
         <choice name="No initialisation" value="0" enum="Unchanged"/>
         <choice name="Initialised"       value="1" enum="Initialised"/>
      </binaryOption >

      <!-- ************* OUTINIT ****************** -->
      <bitmaskOption key="ftm_outinit_choi" condition="ftm_outinit_choi_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="FtmInitialValue"
         enumType="uint8_t"
         enumText="\t   FtmInitialValue_AllLow  = 0x00,\n\t   FtmInitialValue_AllHigh = 0xFF"
         description="Channel Output Initialization Value"
         toolTip="Bitmask defining the value that is forced\n
                  into the channel output when initialization occurs."
         value="0"
         bitmask="0"
         bitList="CH(0-7)" />

      <!-- ************* POL ****************** -->
      <bitmaskOption key="ftm_pol_pol" condition="ftm_pol_pol_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="FtmPolarity"
         enumType="uint8_t"
         enumText="\t   FtmPolarity_AllActiveHigh = 0x00,\n\t   FtmPolarity_AllActiveLow  = 0xFF"
         description="Channel Output Polarity"
         toolTip="Bitmask defining the polarity of the channel output.\n
                  0=ActiveHigh, 1=ActiveLow\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1."
         value="0"
         bitmask="0"
         bitList="CH(0-7)" />

   </category>

   <!-- ************* TRIGGERING ****************** -->

   <category name="Triggering" description="Triggering" >

      <bitmaskOption key="ftm_sync_trig" condition="hardwareTriggerPinMap"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHardwareTrigger"
         enumType="uint32_t"
         valueFormat="FtmHardwareTrigger(%s)"
         description="Hardware trigger inputs"
         toolTip="Enables hardware trigger to the PWM synchronization.\n
                  Hardware trigger occurs on a rising edge of the corresponding trigger input signal."
         bitmask="0"
         bitList="=hardwareTriggerPinMap"
         pinMap="=&quot;FTM$(_instance)_TRIG%i:&quot;+hardwareTriggerPinMap"
         value="0" />

      <binaryOption key="ftm_sync_swsync" condition="ftm_sync_swsync_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncSwsync"
         description="PWM Synchronization Software Trigger" >
         <choice name="Not selected"  value="0" enum="NotSelected"/>
         <choice name="Selected"      value="1" enum="Selected"/>
      </binaryOption >

      <binaryOption key="ftm_sync_synchom" condition="ftm_sync_synchom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncSynchom"
         description="Output Mask Synchronization with buffer"
         toolTip="Selects when the OUTMASK register is updated with the value of its buffer" >
         <choice name="Rising edges of the system clock"  value="0" enum="RisingEdgesOfSystemClock"/>
         <choice name="PWM synchronization"               value="1" enum="PwmSynchronization"/>
      </binaryOption >

      <binaryOption key="ftm_sync_reinit" condition="ftm_sync_reinit_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncReinit"
         description="Counter Reinitialization"
         toolTip="Determines if the FTM counter is reinitialized when \n
                  the selected synchronization trigger is detected. \n
                  It only configures the synchronization when SYNCMODE is zero." >
         <choice name="Counts normally"                         value="0" enum="CountsNormally"/>
         <choice name="Updated with initial value on triggerd"  value="1" enum="UpdatedWithInitialValueOnTriggerd"/>
      </binaryOption >

      <binaryOption key="ftm_sync_cntmax" condition="ftm_sync_cntmax_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncCntmax"
         description="Maximum Loading Point Enable"
         toolTip="Selects the maximum loading point to PWM synchronization. \n
                  See Boundary cycle and loading points. \n
                  If CNTMAX is 1, the selected loading point is when the FTM counter \n
                  reaches its maximum value (MOD register)." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <binaryOption key="ftm_sync_cntmin" condition="ftm_sync_cntmin_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncCntmin"
         description="Minimum Loading Point Enable"
         toolTip="Selects the minimum loading point to PWM synchronization. \n
                  See Boundary cycle and loading points. \n
                  If CNTMIN is one, the selected loading point is when the FTM counter \n
                  reaches its minimum value (CNTIN register).">
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >
   </category>

   <category name="Functions For Linked Channels" description="Channels (0,1) (2,3) (4,5) (6,7)"
      toolTip="Configure the Fault control, Synchronization, Dead-time insertion, \n
               Dual Edge Capture mode, Complementary, and Combine mode for each pair of channels" >

      <for keys   =" num : pair"
           values =" 0   : 0 &amp; 1 ;
                     1   : 2 &amp; 3 ;
                     2   : 4 &amp; 5 ;
                     3   : 6 &amp; 7 ;
           ">
         <bitmaskOption key="ftm_combine%(num)" condition="ftm_combine_comb%(num)_present"
            enabledBy="enablePeripheralSupport"
            typeName="FtmCombine%(num)"
            enumType="uint8_t"
            bitmask="0"
            bitList="COMBINE%(num), COMP%(num), DECAPEN%(num), DECAP%(num), DTEN%(num), SYNCEN%(num), FAULTEN%(num)"
            description="Paired Channels %(pair)"
            bitDescription="
               Combine Channels enable,
               Complementary output mode enable,
               Dual Edge Capture Mode captures,
               Dual Edge Capture Mode enable,
               Dead-time Insertion enable,
               PWM synchronization enable,
               Fault Control enable"
            toolTip="Options controlling paired operation of channels" />
      </for>

      <!-- ************* DEADTIME ****************** -->

      <choiceOption key="ftm_deadtime_dtps" condition="ftm_deadtime_dtps_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmDeadtimePrescale"
         description="Dead-time Prescaler Value"
         toolTip="Scale value for dead-time" >
         <choice name="Divide by 1"   value="0" enum="DivideBy1"/>
         <choice name="Divide by 4"   value="2" enum="DivideBy4"/>
         <choice name="Divide by 16"  value="3" enum="DivideBy16"/>
      </choiceOption >

      <intOption key="ftm_deadtime_dtval" condition="ftm_deadtime_dtval_present"
         enabledBy="enablePeripheralSupport"
         units="ticks"
         description="Dead-time Value"
         toolTip="This tick value is scaled by the dead-time prescaler"
         min="0" max="0x3F"
      />

      <timeOption key="ftm_deadtime"
         ref="ftm_deadtime_dtval*((ftm_deadtime_dtps==0)?1:((ftm_deadtime_dtps==1)?4:16))"
         periodEquation="ftm_deadtime*clockPeriod"
         description="Calculated dead-time"
         toolTip="Dead-time calculated using clock specified in clocking"
         units="ticks"
       />

      <!-- ************* INVCTRL ****************** -->

      <!-- Not sensible to configure statically -->
      <for keys="    Num : Left : Right"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <binaryOption key="ftm_invctrl_inv%(Num)en" condition="ftm_invctrl_inv0en_present"
            enabledBy="enablePeripheralSupport"
            typeName="FtmInvctrl%(Left)_%(Right)"
            description="Paired Channels %(Left) &amp; %(Right) Inverting Enable"
            toolTip="Selects the inverting operation for the corresponding pair channels\n
                     This register has a write buffer. \n
                     The INVmEN bit is updated by the INVCTRL register synchronization." >
            <choice name="Not inverted"  value="0" enum="NotInverted" />
            <choice name="Inverted"      value="1" enum="Inverted"    />
         </binaryOption >
      </for>

   </category>

   <!-- ************* QUAD ****************** -->

   <category name="Quadrature decoder"  description="Quadrature decoder" >
      <binaryOption key="ftm_qdctrl_quadmode" condition="ftm_qdctrl_quadmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmQuadratureMode"
         description="Quadrature decoding mode"
         toolTip="Determines how the inputs control the counting sequence">
         <choice value="0" name="Phase-AB Mode"         enum="Phase_AB_Mode" />
         <choice value="1" name="Count-Direction Mode"  enum="Count_Direction_Mode"  />
      </binaryOption>

      <binaryOption key="ftm_qdctrl_phapol" condition="ftm_qdctrl_phapol_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPhaseAPolarity"
         description="Polarity of Phase A input"
         toolTip="Polarity of Phase A input">
         <choice value="0" name="Active High" enum="ActiveHigh" />
         <choice value="1" name="Active Low"  enum="ActiveLow"  />
      </binaryOption>

      <binaryOption key="ftm_qdctrl_phbpol" condition="ftm_qdctrl_phbpol_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPhaseBPolarity"
         description="Polarity of Phase B input"
         toolTip="Polarity of Phase B input">
         <choice value="0" name="Active High" enum="ActiveHigh" />
         <choice value="1" name="Active Low"  enum="ActiveLow"  />
      </binaryOption>

      <choiceOption key="ftm_qdfilter_a" condition="ftm_qdctrl_phafltren_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="(FTM_QDCTRL_PHAFLTREN(%s)&lt;&lt;8),FTM_FILTER_CH0FVAL(%s)"
         enumType="uint16_t"
         typeName="FtmPhaseAFilter"
         description="Filtering on Phase A input"
         toolTip="Filtering on Phase A input">
         <choice value="0,0"  name="No Filter"      enum="Disabled" />
         <choice value="1,1"  name="1 clock cycle"  enum="1_Clock"  />
         <choice value="1,2"  name="2 clock cycle"  enum="2_Clock"  />
         <choice value="1,3"  name="3 clock cycle"  enum="3_Clock"  />
         <choice value="1,4"  name="4 clock cycle"  enum="4_Clock"  />
         <choice value="1,5"  name="5 clock cycle"  enum="5_Clock"  />
         <choice value="1,6"  name="6 clock cycle"  enum="6_Clock"  />
         <choice value="1,7"  name="7 clock cycle"  enum="7_Clock"  />
         <choice value="1,8"  name="8 clock cycle"  enum="8_Clock"  />
         <choice value="1,9"  name="9 clock cycle"  enum="9_Clock"  />
         <choice value="1,10" name="10 clock cycle" enum="10_Clock" />
         <choice value="1,11" name="11 clock cycle" enum="11_Clock" />
         <choice value="1,12" name="12 clock cycle" enum="12_Clock" />
         <choice value="1,13" name="13 clock cycle" enum="13_Clock" />
         <choice value="1,14" name="14 clock cycle" enum="14_Clock" />
         <choice value="1,15" name="15 clock cycle" enum="15_Clock" />
      </choiceOption>

      <choiceOption key="ftm_qdfilter_b" condition="ftm_qdctrl_phbfltren_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="(FTM_QDCTRL_PHBFLTREN(%s)&lt;&lt;8),FTM_FILTER_CH1FVAL(%s)"
         enumType="uint16_t"
         typeName="FtmPhaseBFilter"
         description="Filtering on Phase B input"
         toolTip="Filtering on Phase B input">
         <choice value="0,0"  name="No Filter"      enum="Disabled" />
         <choice value="1,1"  name="1 clock cycle"  enum="1_Clock"  />
         <choice value="1,2"  name="2 clock cycle"  enum="2_Clock"  />
         <choice value="1,3"  name="3 clock cycle"  enum="3_Clock"  />
         <choice value="1,4"  name="4 clock cycle"  enum="4_Clock"  />
         <choice value="1,5"  name="5 clock cycle"  enum="5_Clock"  />
         <choice value="1,6"  name="6 clock cycle"  enum="6_Clock"  />
         <choice value="1,7"  name="7 clock cycle"  enum="7_Clock"  />
         <choice value="1,8"  name="8 clock cycle"  enum="8_Clock"  />
         <choice value="1,9"  name="9 clock cycle"  enum="9_Clock"  />
         <choice value="1,10" name="10 clock cycle" enum="10_Clock" />
         <choice value="1,11" name="11 clock cycle" enum="11_Clock" />
         <choice value="1,12" name="12 clock cycle" enum="12_Clock" />
         <choice value="1,13" name="13 clock cycle" enum="13_Clock" />
         <choice value="1,14" name="14 clock cycle" enum="14_Clock" />
         <choice value="1,15" name="15 clock cycle" enum="15_Clock" />
      </choiceOption>
   </category>

   <choiceOption key="ftm_channel_number"
      hidden="true"
      derived="true"
      enumType="uint8_t"
      valueFormat="%s"
      typeName="FtmChannelNum"
      description="Channel Number"
      toolTip="Select a channel">
      <choice value="0"             name="Channel 0"      enum="0" />
      <choice value="1"             name="Channel 1"      enum="1" />
      <choice value="2"             name="Channel 2"      enum="2" />
      <choice value="3"             name="Channel 3"      enum="3" />
      <choice value="4"             name="Channel 4"      enum="4" />
      <choice value="5"             name="Channel 5"      enum="5" />
      <choice value="6"             name="Channel 6"      enum="6" />
      <choice value="7"             name="Channel 7"      enum="7" />
      <choice value="(uint8_t(-1))" name="No Channel"     enum="None" />
   </choiceOption>

   <category name="Global timebase" description="Global timebase" >

      <binaryOption key="ftm_conf_gtbeout" condition="ftm_conf_gtbeout_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfGtbeout"
         description="Global Time Base Output"
         toolTip="Enables the global time base signal generation to other FTMs" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <binaryOption key="ftm_conf_gtbeen" condition="ftm_conf_gtbeen_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfGtbeen"
         description="External Global Time Base Enable"
         toolTip="Configures the FTM to use an external global time base signal that is generated by another FTM." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <choiceOption key="ftm_conf_bdmmode" condition="ftm_conf_bdmmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfBdmmode"
         toolTip="Selects the ratio between the number of counter overflows to the number of times the TOF bit is set"
         description="Controls operation in BDM Mode" >
         <choice name="Stopped, outputs functional"            value="0" enum="Stopped_OutputsFunctional"/>
         <choice name="Stopped, outputs forced to safe value"  value="1" enum="Stopped_OutputsForcedToSafeValue"/>
         <choice name="Stopped, outputs frozen"                value="2" enum="Stopped_OutputsFrozen"/>
         <choice name="Functioning"                            value="3" enum="Functioning"/>
      </choiceOption >

      <intOption key="ftm_conf_numtof" condition="ftm_conf_numtof_present"
         enabledBy="enablePeripheralSupport"
         typeName="uint32_t"
         description="TOF Frequency"
         toolTip="Selects the ratio between the number of counter overflows to the number of times the TOF bit is set."
      />
   </category>

   <category description="Synchronization Configuration" name="Synchronization">

      <binaryOption key="ftm_synconf_hwsoc" condition="ftm_synconf_hwsoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncSwoctrl"
         description="SWOCTRL sync by hardware"
         toolTip="Controls SWOCTRL synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="SWOCTRL register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwinvc" condition="ftm_synconf_hwinvc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncInvctrl"
         description="INVCTRL sync by hardware"
         toolTip="Controls INVCTRL synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="INVCTRL register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwom" condition="ftm_synconf_hwom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncOutmask"
         description="OUTMASK sync by hardware"
         toolTip="Controls OUTMASK synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="OUTMASK register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwwrbuf" condition="ftm_synconf_hwwrbuf_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncRegs"
         description="MOD/CNTIN/CV sync by hardware"
         toolTip="Controls MOD/CNTIN/CV synchronization by hardware trigger" >
         <choice name="Unaffected"                       value="0" enum="Unaffected"/>
         <choice name="MOD/CNTIN/CV registers synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwrstcnt" condition="ftm_synconf_hwrstcnt_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncCounter"
         description="Counter sync by hardware"
         toolTip="Controls Counter synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="Counter register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swsoc" condition="ftm_synconf_swsoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncSwoctrl"
         description="SWOCTRL sync by software"
         toolTip="Controls SWOCTRL synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="SWOCTRL register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swinvc" condition="ftm_synconf_swinvc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncInvCtrl"
         description="INVCTRL synch by software"
         toolTip="Controls INVCTRL synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="INVCTRL register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swom" condition="ftm_synconf_swom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncOutmask"
         description="OUTMASK sync by software"
         toolTip="Controls OUTMASK synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="OUTMASK register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swwrbuf" condition="ftm_synconf_swwrbuf_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncRegs"
         description="MOD/CNTIN/CV synch by software"
         toolTip="Controls MOD/CNTIN/CV synchronization by software trigger" >
         <choice name="Unaffected"                      value="0" enum="Unaffected"/>
         <choice name="MOD/CNTIN/CV register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swrstcnt" condition="ftm_synconf_swrstcnt_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncCounter"
         description="Counter synch by software"
         toolTip="Controls counter synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="Counter register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_syncmode" condition="ftm_synconf_syncmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncPwm"
         description="Synchronization Mode"
         toolTip="Selects the PWM Synchronization mode" >
         <choice name="Legacy PWM synch"    value="0" enum="LegacyPwmSynch"/>
         <choice name="Enhanced PWM synch"  value="1" enum="EnhancedPwmSynch"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swoc" condition="ftm_synconf_swoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncSwoctrl"
         description="SWOCTRL Register Synch"
         toolTip="Controls SWOCTRL Register Synchronization with buffer" >
         <choice name="On rising edges of system clock"  value="0" enum="OnRisingClockEdge" />
         <choice name="By PWM synchronization"           value="1" enum="OnPwmSynch"        />
      </binaryOption >

      <binaryOption key="ftm_synconf_invc" condition="ftm_synconf_invc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncInvctrl"
         description="INVCTRL Register Synch"
         toolTip="Controls INVCTRL Register Synchronization with buffer" >
         <choice name="On rising edges of system clock"  value="0" enum="OnRisingClockEdge" />
         <choice name="By PWM synchronization"           value="1" enum="OnPwmSynch"        />
      </binaryOption >

      <binaryOption key="ftm_synconf_cntinc" condition="ftm_synconf_cntinc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncCounter"
         description="CNTIN Register Synch"
         toolTip="CNTIN Register Synchronization with buffer" >
         <choice name="Updated on rising edges of system clock"  value="0" enum="OnRisingClockEdge"/>
         <choice name="Updated by PWM synchronization"           value="1" enum="OnPwmSynch"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwtrigmode" condition="ftm_synconf_hwtrigmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmTriggerSyncr"
         description="Hardware Trigger Mode"
         toolTip="Controls how hardware triggers are cleared" >
         <choice name="TRIGj cleared on trigger detect"  value="0" enum="OnTrigger"/>
         <choice name="TRIGj unaffected"                 value="1" enum="Unaffected"/>
      </binaryOption >
   </category>

   <!-- ************* SWOCTRL ****************** -->

   <!-- Not sensible to configure statically -->
   <for keys="Ch" dim="8" >
      <choiceOption key="ftm_swoctrl_ch%(Ch)ocv" condition="ftm_swoctrl_choc_present&amp;&amp;ftm_swoctrl_chocv_present"
         hidden="true"
         valueFormat="FTM_SWOCTRL_CH%(Ch)OC(%s),FTM_SWOCTRL_CH%(Ch)OCV(%s)"
         enabledBy="enablePeripheralSupport"
         typeName="FtmForceOutput%(Ch)"
         description="Channel %(Ch) Output Control"
         toolTip="Enables and selects value to force to channel output" >
         <choice name="Output not forced"  value="0,0" enum="NotForced" />
         <choice name="Forces output 0"    value="1,0" enum="Forces0"   />
         <choice name="Forces output 1"    value="1,1" enum="Forces1"   />
      </choiceOption >
   </for>

   <category name="PWM load" description="PWM load" >
      <!-- ************* PWMLOAD ****************** -->

      <binaryOption key="ftm_pwmload_ldok" condition="ftm_pwmload_ldok_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPwmload"
         description="Load Enable"
         toolTip="Enables loading of MOD/CNTIN/CnV from buffers when Counter=MOD" >
         <choice name="Loading disabled"  value="0" enum="Disabled"/>
         <choice name="Loading enabled"   value="1" enum="Enabled"/>
      </binaryOption >

      <bitmaskOption key="ftm_pwmload_chsel" condition="ftm_pwmload_chsel_present"
         enabledBy="enablePeripheralSupport"
         typeName="uint32_t"
         description="Match Channel Select"
         toolTip="Selects which channels trigger loading of MOD/CNTIN/CnV from buffers"
         bitmask="0xFF"
         bitList="CH%i"
      />
   </category>

<!-- ============================ FAULT INPUTS ============================= -->

   <category name="Fault Control" description="Options for fault control" >

      <choiceOption key="ftm_mode_faultm"
         hidden="true"
         condition="ftm_mode_faultm_present"
         enabledBy="ftm_mode_ftmen"
         typeName="FtmFaultMode"
         description="Fault Control Mode"
         toolTip="This is a write-once after reset setting" >
         <choice name="Disabled"                                    value="0" enum="Disabled"/>
         <choice name="Even channels with manual fault clearing"    value="1" enum="EvenChannelsManualFaultClearing"/>
         <choice name="All channels with manual fault clearing"     value="2" enum="AllChannelsManualFaultClearing"/>
         <choice name="All channels with automatic fault clearing"  value="3" enum="AllChannelsAutomaticFaultClearing"/>
      </choiceOption >
      <aliasOption key="ftm_mode_faultm" optional="true" locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))" />

      <binaryOption key="ftm_mode_faultie"
         hidden="true"
         condition="ftm_mode_faultie_present"
         enabledBy="ftm_mode_faultm>0"
         typeName="FtmFaultInterrupt"
         description="Fault Interrupt Enable" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >
      <aliasOption key="ftm_mode_faultie" optional="true" locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))" />

      <choiceOption key="ftm_fltctrl_ffval"
         hidden="true"
         condition="ftm_fltctrl_ffval_present"
         enabledBy="ftm_mode_faultm>0"
         description="Fault Input Filter"
         typeName="FtmFaultFilter"
         toolTip="Selects the filter value for the fault inputs..">
         <choice value="0"  name="Filter Disabled"  enum="Disabled" isDefault="true" />
         <choice value="1"  name="1 Clock cycle "   enum="1_clock"   />
         <choice value="2"  name="2 Clock cycles"   enum="2_clocks"  />
         <choice value="3"  name="3 Clock cycles"   enum="3_clocks"  />
         <choice value="4"  name="4 Clock cycles"   enum="4_clocks"  />
         <choice value="5"  name="5 Clock cycles"   enum="5_clocks"  />
         <choice value="6"  name="6 Clock cycles"   enum="6_clocks"  />
         <choice value="7"  name="7 Clock cycles"   enum="7_clocks"  />
         <choice value="8"  name="8 Clock cycles"   enum="8_clocks"  />
         <choice value="9"  name="9 Clock cycles"   enum="9_clocks"  />
         <choice value="10" name="10 Clock cycles"  enum="10_clocks" />
         <choice value="11" name="11 Clock cycles"  enum="11_clocks" />
         <choice value="12" name="12 Clock cycles"  enum="12_clocks" />
         <choice value="13" name="13 Clock cycles"  enum="13_clocks" />
         <choice value="14" name="14 Clock cycles"  enum="14_clocks" />
         <choice value="15" name="15 Clock cycles"  enum="15_clocks" />
      </choiceOption>

      <aliasOption key="ftm_fltctrl_ffval" optional="true"  locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))"
      />
      <floatOption key="ftm_fltctrl_filterdelay"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))"
         locked="true"
         derived="true"
         ref="ftm_fltctrl_ffval*clockPeriod"
         description="Filter delay"
         units="s"
       />

      <for keys="inp" dim="8" >
         <choiceOption key="ftm_fltctrl_fault%(inp)en" condition="ftm_fltctrl_fault%(inp)en_present"
            hidden="true"
            valueFormat="FTM_FLTCTRL_FAULT%(inp)EN(%s),FTM_FLTCTRL_FFLTR%(inp)EN(%s)"
            enabledBy="ftm_mode_faultm>0"
            description="Fault Input %(inp) Enable and Filter"
            toolTip="Enables the fault input.\n
                     This field is write protected. It can be written only when MODE[WPDIS] = 1."
            typeName="FtmFault%(inp)Mode"
         >
            <choice value="0,0" name="Fault input disabled"             enum="Disabled"  />
            <choice value="1,0" name="Fault input enabled"              enum="Direct"    />
            <choice value="1,1" name="Fault input enabled with filter"  enum="Filtered"  />
         </choiceOption>

         <binaryOption key="ftm_fltpol_flt%(inp)pol" condition="ftm_fltpol_flt%(inp)pol_present"
            hidden="true"
            enabledBy="ftm_fltctrl_fault%(inp)en>0"
            description="Fault Input %(inp) Polarity"
            toolTip="Defines the polarity of the fault input.\n
                     This field is write protected. It can be written only when MODE[WPDIS] = 1."
            typeName="FtmFault%(inp)Polarity"
         >
            <choice value="0" name="Active High" enum="ActiveHigh" />
            <choice value="1" name="Active Low" enum="ActiveLow"   />
         </binaryOption>

         <if condition="SignalExists(&quot;$(_NAME)_FLT%(inp)&quot;)" >
            <title description="Fault Input %(inp)" />
            <aliasOption key="ftm_fltctrl_fault%(inp)en" optional="true" locked="false" />
            <aliasOption key="ftm_fltpol_flt%(inp)pol"   optional="true" locked="false" />
         </if>
      </for>

   </category>

   <!--  **************** Channels **************** -->
   <choiceOption key="ftm_filter_chnfval" condition="ftm_filter_ch0fval_present"
      hidden="true"
      description="Channel Input Filter"
      typeName="FtmInputFilter"
      valueFormat="(%s)"
      enumType="uint8_t"
      toolTip="Selects the filter value for the channel input">
      <choice value="0"  name="Filter Disabled"  enum="Disabled" isDefault="true" />
      <choice value="1"  name="1 Clock cycle "   enum="1_clock"   />
      <choice value="2"  name="2 Clock cycles"   enum="2_clocks"  />
      <choice value="3"  name="3 Clock cycles"   enum="3_clocks"  />
      <choice value="4"  name="4 Clock cycles"   enum="4_clocks"  />
      <choice value="5"  name="5 Clock cycles"   enum="5_clocks"  />
      <choice value="6"  name="6 Clock cycles"   enum="6_clocks"  />
      <choice value="7"  name="7 Clock cycles"   enum="7_clocks"  />
      <choice value="8"  name="8 Clock cycles"   enum="8_clocks"  />
      <choice value="9"  name="9 Clock cycles"   enum="9_clocks"  />
      <choice value="10" name="10 Clock cycles"  enum="10_clocks" />
      <choice value="11" name="11 Clock cycles"  enum="11_clocks" />
      <choice value="12" name="12 Clock cycles"  enum="12_clocks" />
      <choice value="13" name="13 Clock cycles"  enum="13_clocks" />
      <choice value="14" name="14 Clock cycles"  enum="14_clocks" />
      <choice value="15" name="15 Clock cycles"  enum="15_clocks" />
   </choiceOption>

   <for keys="ch" dim="NumChannels">
      <title description="FTM Channel %(ch)" toolTip="" />

      <if condition="!ftm_combine_decap0_present" >
         <!-- All channels without DECAP -->
         <choiceOption key="ftm_cnsc_mode[%(ch)]"
            target="captureMode[%(ch)]"
            condition="!ftm_combine_decap0_present"
            enabledBy="enablePeripheralSupport"
            valueFormat="FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
            enumType="uint16_t"
            typeName="FtmChannelMode"
            description="Channel Mode"
            toolTip="Determines channel operation (PWM/Input capture/Output compare)">
            <!--              +......... MS(B:A)   -->
            <!--              |    +.... ELS(B:A)  -->
            <!--              |    |               -->
            <!--              v    v               -->
             <choice value="0b00,0b00" name="Channel Disabled"                    enum="Disabled"                ref="false" />
             <choice value="0b00,0b01" name="Input Capture Rising-edge"           enum="InputCaptureRisingEdge"  ref="true"  />
             <choice value="0b00,0b10" name="Input Capture Falling-edge"          enum="InputCaptureFallingEdge" ref="true"  />
             <choice value="0b00,0b11" name="Input Capture Either-edge"           enum="InputCaptureEitherEdge"  ref="true"  />
             <choice value="0b01,0b00" name="Output Compare No action"            enum="OutputCompare"           ref="false" />
             <choice value="0b01,0b01" name="Output Compare Toggle"               enum="OutputCompareToggle"     ref="false" />
             <choice value="0b01,0b10" name="Output Compare Clear"                enum="OutputCompareClear"      ref="false" />
             <choice value="0b01,0b11" name="Output Compare Set"                  enum="OutputCompareSet"        ref="false" />
             <choice value="0b10,0b10" name="Pwm High-true Pulses (Edge/Centre)"  enum="PwmHighTruePulses"       ref="false" />
             <choice value="0b10,0b01" name="Pwm Low-true Pulses (Edge/Centre)"   enum="PwmLowTruePulses"        ref="false" />
         </choiceOption>

         <binaryOption key="captureMode[%(ch)]"
            hidden="true"
            description="Capture mode"
            toolTip="One of the input-capture modes"
            locked="true"
            derived="true"
         >
            <choice value="false" name="False" />
            <choice value="true"  name="True" />
         </binaryOption>

         <constant key="combine[%(ch)]"     type="Boolean" value="false" />
         <constant key="decap[%(ch)]"       type="Boolean" value="false" />

       <else />
         <if condition="(%(ch)&amp;1)==0" >

            <!-- Even channel with DECAP -->
            <choiceOption key="ftm_cnsc_mode[%(ch)]"
               target="decap[%(ch)];combine[%(ch)];captureMode[%(ch)]"
               enabledBy="enablePeripheralSupport"
               valueFormat="(FTM_COMBINE_DECAPEN0(%s)&lt;&lt;8),(FTM_COMBINE_COMBINE0(%s)&lt;&lt;8),FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
               enumType="uint16_t"
               typeName="FtmChannelMode"
               description="Channel Mode"
               toolTip="Determines channel operation (PWM/Input capture/Output compare)">
               <!--            +............... DECAPEN   -->
               <!--            | +............. COMBINE   -->
               <!--            | |   +......... MS(B:A)   -->
               <!--            | |   |    +.... ELS(B:A)  -->
               <!--            | |   |    |               -->
               <!--            v v   v    v               -->
                <choice value="0,0,0b00,0b00" name="Channel Disabled"                           enum="Disabled"                                ref="false;false;false" />
                <!-- 1-3 ................ -->
                <choice value="0,0,0b00,0b01" name="Input Capture Rising-edge"                  enum="InputCaptureRisingEdge"                  ref="false;false;true"  />
                <choice value="0,0,0b00,0b10" name="Input Capture Falling-edge"                 enum="InputCaptureFallingEdge"                 ref="false;false;true"  />
                <choice value="0,0,0b00,0b11" name="Input Capture Either-edge"                  enum="InputCaptureEitherEdge"                  ref="false;false;true"  />
                <!-- 4-7 ................ -->
                <choice value="0,0,0b01,0b00" name="Output Compare No action"                   enum="OutputCompare"                           ref="false;false;false" />
                <choice value="0,0,0b01,0b01" name="Output Compare Toggle"                      enum="OutputCompareToggle"                     ref="false;false;false" />
                <choice value="0,0,0b01,0b10" name="Output Compare Clear"                       enum="OutputCompareClear"                      ref="false;false;false" />
                <choice value="0,0,0b01,0b11" name="Output Compare Set"                         enum="OutputCompareSet"                        ref="false;false;false" />
                <!-- 8-9 ................ -->
                <choice value="0,0,0b10,0b10" name="Pwm High-true Pulses (Edge/Centre)"         enum="PwmHighTruePulses"                       ref="false;false;false" />
                <choice value="0,0,0b10,0b01" name="Pwm Low-true Pulses (Edge/Centre)"          enum="PwmLowTruePulses"                        ref="false;false;false" />
                <!-- 10-11 ................ -->
                <choice value="0,1,0b00,0b10" name="Combined PWM Positive-pulse"                enum="CombinePositivePulse"                    ref="false;true;false" enabledBy="ftm_mode_ftmen" />
                <choice value="0,1,0b00,0b01" name="Combine PWM Negative-pulse"                 enum="CombineNegativePulse"                    ref="false;true;false" enabledBy="ftm_mode_ftmen" />
                <!-- 12- 17................ -->
                <choice value="1,0,0b00,0b01" name="Dual-edge Capture One-Shot Rising-edge"     enum="DualEdgeCaptureOneShotRisingEdge"        ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
                <choice value="1,0,0b01,0b01" name="Dual-edge Capture Continuous Rising-edge"   enum="DualEdgeCaptureContinuousRisingEdge"     ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
                <choice value="1,0,0b00,0b10" name="Dual-edge Capture One-Shot Falling-edge"    enum="DualEdgeCaptureOneShotFallingEdge"       ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
                <choice value="1,0,0b01,0b10" name="Dual-edge Capture Continuous Falling-edge"  enum="DualEdgeCaptureContinuousFallingEdge"    ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
                <choice value="1,0,0b00,0b11" name="Dual-edge Capture One-Shot Either-edge"     enum="DualEdgeCaptureOneShotEitherEdge"        ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
                <choice value="1,0,0b01,0b11" name="Dual-edge Capture Continuous Either-edge"   enum="DualEdgeCaptureContinuousEitherEdge"     ref="true;false;true"  enabledBy="ftm_mode_ftmen" />
            </choiceOption>

            <binaryOption key="captureMode[%(ch)]"
               hidden="true"
               description="Capture mode"
               toolTip="One of the input-capture modes"
               locked="true"
               derived="true"
            >
               <choice value="false" name="False" />
               <choice value="true"  name="True"  />
            </binaryOption>

            <binaryOption key="combine[%(ch)]"
               hidden="true"
               description="Combined PWM output mode"
               toolTip="This combines a pair of channels to provide related outputs "
               locked="true"
               derived="true"
            >
               <choice value="false" name="False" />
               <choice value="true"  name="True"  />
            </binaryOption>

            <binaryOption key="decap[%(ch)]"
               hidden="true"
               description="Dual capture mode"
               toolTip="This combines a pair of channels to allow capturing of consecutive events"
               locked="true"
               derived="true"
            >
               <choice value="false" name="False" />
               <choice value="true"  name="True"  />
            </binaryOption>

         <else />
            <!-- Odd channel with DECAP -->
            <choiceOption key="ftm_cnsc_mode[%(ch)]" condition="(%(ch)&amp;1)==1"
               target="captureMode[%(ch)]"
               enabledBy="enablePeripheralSupport&amp;&amp;!combine[%(ch)-1]&amp;&amp;!decap[%(ch)-1]"
               hiddenBy="combine[%(ch)-1]||decap[%(ch)-1]"
               disabledPinMap=""
               valueFormat="FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
               enumType="uint16_t"
               typeName="FtmChannelMode"
               description="Channel Mode"
               toolTip="Determines channel operation (PWM/Input capture/Output compare)">
               <!--              +......... MS(B:A)   -->
               <!--              |    +.... ELS(B:A)  -->
               <!--              |    |               -->
               <!--              v    v               -->
                <choice value="0b00,0b00" name="Channel Disabled"                    enum="Disabled"                ref="false" />
                <choice value="0b00,0b01" name="Input Capture Rising-edge"           enum="InputCaptureRisingEdge"  ref="true"  />
                <choice value="0b00,0b10" name="Input Capture Falling-edge"          enum="InputCaptureFallingEdge" ref="true"  />
                <choice value="0b00,0b11" name="Input Capture Either-edge"           enum="InputCaptureEitherEdge"  ref="true"  />
                <choice value="0b01,0b00" name="Output Compare No action"            enum="OutputCompare"           ref="false" />
                <choice value="0b01,0b01" name="Output Compare Toggle"               enum="OutputCompareToggle"     ref="false" />
                <choice value="0b01,0b10" name="Output Compare Clear"                enum="OutputCompareClear"      ref="false" />
                <choice value="0b01,0b11" name="Output Compare Set"                  enum="OutputCompareSet"        ref="false" />
                <choice value="0b10,0b10" name="Pwm High-true Pulses (Edge/Centre)"  enum="PwmHighTruePulses"       ref="false" />
                <choice value="0b10,0b01" name="Pwm Low-true Pulses (Edge/Centre)"   enum="PwmLowTruePulses"        ref="false" />
            </choiceOption>

            <binaryOption key="captureMode[%(ch)]"
               hidden="true"
               description="Capture mode"
               toolTip="One of the input-capture modes"
               locked="true"
               derived="true"
            >
               <choice value="false" name="False" />
               <choice value="true"  name="True" />
            </binaryOption>

            <choiceOption key="ftm_cnsc_secondedge[%(ch)]"
               hiddenBy="!decap[%(ch)-1]"
               valueFormat="FTM_CnSC_ELS(%s)"
               description="2nd capture Edge polarity"
               typeName="FtmSecondEdge"
               disabledValue="0b00"
               toolTip="Polarity for capturing the second edge in Dual-edge capture mode (using 2 channels)"
               >
               <!--              +.... ELS(B:A)  -->
               <!--              |               -->
               <!--              v               -->
                <choice value="0b00" name="Input Capture None"         enum="Disabled"    />
                <choice value="0b01" name="Input Capture Rising-edge"  enum="RisingEdge"  isDefault="true" />
                <choice value="0b10" name="Input Capture Falling-edge" enum="FallingEdge" />
                <choice value="0b11" name="Input Capture Either-edge"  enum="EitherEdge"  />
            </choiceOption>
         </if>
      </if>

      <choiceOption key="ftm_cnsc_action[%(ch)]" condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
         hiddenBy="!(irqHandlingMethod&amp;&amp;
                    ((ftm_cnsc_mode[%(ch)]!=0)||
                     (((%(ch)&amp;1)!=0)&amp;&amp;((combine[%(ch)-1]||(decap[%(ch)-1]))))))"
         valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
         enumType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt or DMA on channel event">
          <choice value="0,0" name="No action"          enum="None"  />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt"   />
          <choice value="1,1" name="DMA request"        enum="Dma"   />
      </choiceOption>

      <binaryOption key="ftm_cnsc_action[%(ch)]" condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
         hiddenBy="!(irqHandlingMethod&amp;&amp;
                    ((ftm_cnsc_mode[%(ch)]!=0)||
                     (((%(ch)&amp;1)!=0)&amp;&amp;((combine[%(ch)-1]||(decap[%(ch)-1]))))))"
         valueFormat="FTM_CnSC_CHIE(%s)"
         enumType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt on channel event">
          <choice value="0" name="No action"              enum="None"             />
          <choice value="1" name="Interrupt request"      enum="Interrupt"        />
      </binaryOption>

      <binaryOption key="ftm_cnsc_icrst[%(ch)]" condition="ftm_cnsc_icrst_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="FTM_CnSC_ICRST(%s)"
         typeName="FtmChannelReset"
         enumType="uint8_t"
         description="Reset counter on channel IC event"
         toolTip="Enables the channel IC event to reset the shared counter">
         <choice value="0" name="Disabled" enum="Disabled" />
         <choice value="1" name="Enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="ftm_cnv[%(ch)]"
         hiddenBy="!(((ftm_cnsc_mode[%(ch)]&gt;=4)&amp;&amp;(ftm_cnsc_mode[%(ch)]&lt;=9))||
                    ((ftm_cnsc_mode[%(ch)]&gt;=10)&amp;&amp;(ftm_cnsc_mode[%(ch)]&lt;=11))||
                    (((%(ch)&amp;1)!=0)&amp;&amp;combine[%(ch)-1]))"
         valueFormat="%s_ticks"
         typeName="Ticks &amp;"
         units="ticks"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod" />

      <floatOption key="ftm_cnvEventTime[%(ch)]"
         hiddenBy="ftm_cnv[%(ch)]==0"
         ref="ftm_cnv[%(ch)]*clockPeriod"
         valueFormat="%s_s"
         typeName="Seconds &amp;"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value, converted to ticks, is compared against the main counter"
         value="0" min="0" max="ftm_mod*clockPeriod" />

      <choiceOption key="ftm_filter_ch%(ch)fval" condition="ftm_filter_ch%(ch)fval_present"
         derivedFrom="ftm_filter_chnfval"
         hiddenBy="!(captureMode[%(ch)]||
                    (((%(ch)&amp;1)!=0)&amp;&amp;((decap[%(ch)-1]))))" >
      </choiceOption>

   </for>

   <initialValueTemplate variables="minimumResolution"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumResolution  = $(?check_minimums:$(minimumResolution):0);\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate variables="minimumInterval"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumInterval  = $(?check_minimums:$(minimumInterval):0);\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate variables="ftmExternalClock"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t ftmExternalClock  = $(ftmExternalClock);\n\n
   ]]></initialValueTemplate>

   <bitmaskOption key="ftm_exttrig_trig" condition="ftm_exttrig_inittrigen_present"
      enabledBy="enablePeripheralSupport"
      description="External Trigger Enable"
      toolTip="Bitmask enabling generation of the external trigger when the FTM\n
               counter is equal to a channel CnV register or CNTIN"
      valueFormat="%s"
      typeName="FtmExternalTrigger"
      enumText="\t\n
\tFtmExternalTrigger_ch0   = FTM_EXTTRIG_CH0TRIG_MASK,\n
\tFtmExternalTrigger_ch1   = FTM_EXTTRIG_CH1TRIG_MASK,\n
\tFtmExternalTrigger_ch2   = FTM_EXTTRIG_CH2TRIG_MASK,\n
\tFtmExternalTrigger_ch3   = FTM_EXTTRIG_CH3TRIG_MASK,\n
\tFtmExternalTrigger_ch4   = FTM_EXTTRIG_CH4TRIG_MASK,\n
\tFtmExternalTrigger_ch5   = FTM_EXTTRIG_CH5TRIG_MASK,\n
\tFtmExternalTrigger_cntin = FTM_EXTTRIG_INITTRIGEN_MASK,

"
      enumType="uint8_t"
      value="0"
      bitmask="0"
      bitList="=TriggerChannels"
      />

   <setTemplate key="/$(_BASENAME)/static_functions" namespace="all"
      discardRepeats="true"
      variables="ftm_sc_mode,ftm_sc_clks,ftm_sc_ps"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Enables clock to peripheral and configures all pins.
      \t * Configures main operating settings for timer.
      \t *
      %paramDescription
      \t */
      \tstatic void configure(
      %params) {
      \t
      \t   // Enable clock to peripheral
      \t   enable();
      \t
      \t   // Disable timer to change settings
      \t   %register=0;
      \t
      \t   // Make sure write has completed (disabled)
      \t   (void)(%register);
      \t
      \t   // Write new value
      \t   ftm->SC = %paramExpression;
      \t}\n\n
   ]]></setTemplate>

<!--  ========== Static/Non-Static Methods =============================== -->
   <for  keys  =" k                    : static    : const    : getInputClockFrequency         : channel : Ftm       : isStatic"
         values=" non_static_functions : ''        : ' const' : getInputClockFrequencyVirtual  : CHANNEL : FtmBase   : false ;
                  static_functions     : 'static ' : ''       : 'Info::getInputClockFrequency' : channel : OwningFtm : true
   ">
      <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
         discardRepeats="true"
         variables="ftm_sc_clks,ftm_sc_ps"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask1);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t *
         %paramDescription
         \t */
         \t%(static)void selectClock(
         %params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         \t
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         \t
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         \t
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></setTemplate>

      <for keys="  f           :  n"
         values=" ftm_sc_mode  : Mode;
                  ftm_sc_clks  : ClockSource;
                  ftm_sc_ps    : Prescaler">
         <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);

            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;

            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);

            \t   // Write new value
            \t   %register = %registerName;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)(%register&~%mask);
            \t}\n\n
         ]]></setTemplate>
      </for>

      <for keys="  f           :  n"
         values=" ftm_cntin    : CounterStartValue;
                  ftm_mod      : CounterMaximumValue">
         <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t * This value is write-buffered and updated by CNTIN synchronisation
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Write new value
            \t   %register = %paramExpression;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)%register;
            \t}\n\n
         ]]></setTemplate>
      </for>

      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/**
         \t * Calculate FTM timing parameters to achieve a given period
         \t *
         \t * @param[in]    period  Period in seconds
         \t * @param[inout] sc      Proposed FTM.SC value (must include CLKS, CPWMS fields)
         \t *                       PS field is updated
         \t * @param[out]   mod     Calculated FTM.MOD values
         \t *
         \t * @return E_NO_ERROR   Success!!
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
         \t * @return E_TOO_LARGE  Requested period is too large
         \t */
         \t%(static)ErrorCode calculateTimingParameters(Seconds period, uint8_t &sc, uint16_t &mod)%(const) {
         \t
         \t   float inputClock = %(getInputClockFrequency)((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
         \t   unsigned prescaleFactor=1;
         \t   unsigned prescalerValue=0;
         \t
         \t   // Check if CPWMS is set (affects period calculation)
         \t   bool centreAligned = (sc&FTM_SC_CPWMS_MASK);
         \t
         \t   constexpr uint32_t maxModValue = FTM_MOD_MOD_MASK;
         \t
         \t   while (prescalerValue<=7) {
         \t      float clock    = inputClock/prescaleFactor;
         \t      float modValueF = period*clock;
         \t      if (centreAligned) {
         \t         // PeriodInTicks = 2*MOD
         \t         modValueF = modValueF/2;
         \t      }
         \t      else {
         \t         // PeriodInTicks = MOD+1
         \t         modValueF = modValueF - 1;
         \t      }
         \t      unsigned modValue = round(modValueF);\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t      if constexpr (Info::minimumResolution>0) {
         \t         if (modValue < Info::minimumResolution) {
         \t            usbdm_assert(false, "Interval is too short");
         \t            // Too short a period for minimum resolution
         \t            return setErrorCode(E_TOO_SMALL);
         \t         }
         \t      }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t      if (modValue <= maxModValue) {
         \t         sc   = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
         \t         mod  = modValue;
         \t         return E_NO_ERROR;
         \t      }
         \t      prescalerValue++;
         \t      prescaleFactor <<= 1;
         \t   }
         \t   // Too long a period
         \t   usbdm_assert(false, "Interval is too long");
         \t   return setErrorCode(E_TOO_LARGE);
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/**
         \t * Set period
         \t *
         \t * @param[in] period   Period in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note The counter load value (CNTIN) is cleared
         \t * @note The counter modulo value (MOD) is modified to obtain the requested period
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setPeriod(Seconds period)%(const) {
         \t
         \t   uint16_t modValue = 0;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   ErrorCode rc = calculateTimingParameters(period, sc, modValue);
         \t
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC = 0;
         \t
         \t   // Configure for modulo operation
         \t   ftm->MOD   = modValue;
         \t   ftm->CNTIN = 0_ticks;
         \t
         \t   // Clear counter
         \t   ftm->CNT   = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Set maximum interval for input-capture or output compare.
         \t * Input Capture and Output Compare will be able to operate over
         \t * at least this period without overflow.
         \t *
         \t * @param[in] interval Interval in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note FTM counter is configured for free-running mode i.e. 0-65535
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setMaximumInterval(Seconds interval)%(const) {
         \t
         \t   uint16_t       modValue;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   ErrorCode rc = calculateTimingParameters(interval, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC = 0;
         \t
         \t   // Configure for free-running mode
         \t   // This is the usual value for IC or OC set-up
         \t   ftm->MOD   = 0_ticks;
         \t   ftm->CNTIN = 0_ticks;
         \t
         \t   // Clear counter
         \t   ftm->CNT   = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/**
         \t * Get frequency of timer tick
         \t *
         \t * @return Timer frequency in Hz
         \t */
         \t%(static)float getTickFrequencyAsFloat()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   float prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}
         \t
         \t/**
         \t * Get clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz (may underflow)
         \t */
         \t%(static)uint32_t getTickFrequencyAsInt()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   int prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/**
         \t * Convert time in microseconds to time in ticks
         \t *
         \t * @param[in] time Time in microseconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t * @note Will set error code if calculated value is less the Timer minimum resolution
         \t */
         \t%(static)Ticks convertMicrosecondsToTicks(int time)%(const) {
         \t
         \t   // Calculate period
         \t   uint32_t tickRate = getTickFrequencyAsInt();
         \t   uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if constexpr (Info::minimumInterval>0) {
         \t      if (rv < Info::minimumInterval) {
         \t         // Attempt to set too short a period
         \t         setErrorCode(E_TOO_SMALL);
         \t      }
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Converts time in seconds to time in ticks
         \t *
         \t * @param[in] seconds Time interval in seconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
         \t * @note Will set error code if calculated value is less the minimum resolution
         \t */
         \t%(static)Ticks convertSecondsToTicks(Seconds seconds)%(const) {
         \t
         \t   // Calculate period
         \t   float    tickRate = getTickFrequencyAsFloat();
         \t   uint64_t rv       = rintf((float)seconds*tickRate);
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if (rv < Info::minimumInterval) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in microseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in microseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMicroseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in milliseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in milliseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMilliseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in seconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in seconds
         \t */
         \t%(static)Seconds convertTicksToSeconds(Ticks timeInTicks)%(const) {
         \t   return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
         \t}
         \t/**
         \t * Get Timer count
         \t *
         \t * @return Timer count value
         \t */
         \t%(static)uint16_t getTime()%(const) {
         \t   return ftm->CNT;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/**
         \t * Reset counter to initial value
         \t */
         \t%(static)void resetTime()%(const) {
         \t   // Note: writing ANY value loads CNT from CNTIN
         \t   ftm->CNT = 0;
         \t}
         \t
         \t/**
         \t * Get timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t */
         \t%(static)unsigned getInterruptFlags()%(const) {
         \t   return ftm->STATUS;
         \t}
         \t
         \t/**
         \t * Clear selected timer event flags
         \t *
         \t * @param channelMask Mask indicating which channel flags to clear
         \t *                    There is one bit for each channel
         \t *
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)void clearSelectedInterruptFlags(uint32_t channelMask)%(const) {
         \t   (void)ftm->STATUS;
         \t   ftm->STATUS = ~channelMask;
         \t}
         \t
         \t/**
         \t * Clear timer overflow event flag
         \t */
         \t%(static)void clearOverflowInterruptFlag() {
         \t   // Clear TOI flag (w0c)
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
         \t}
         \t
         \t/**
         \t * Get and clear timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t *
         \t * @note Only flags captured in the return value are cleared
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)unsigned getAndClearInterruptFlags()%(const) {
         \t   // Note requires read and write zero to clear flags
         \t   // so only flags captured in status are cleared
         \t   unsigned status = ftm->STATUS;
         \t   ftm->STATUS = ~status;
         \t   return status;
         \t}
         \t
         \t/**
         \t * Enables/disable external trigger generation by a channel comparison or initialisation event
         \t *
         \t * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
         \t * @param[in] enable             Whether to enable/disable the specified trigger
         \t */
         \t%(static)void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true)%(const) {
         \t   if (enable) {
         \t      ftm->EXTTRIG = ftm->EXTTRIG | ftmExternalTrigger;
         \t   }
         \t   else {
         \t      ftm->EXTTRIG = ftm->EXTTRIG & ~ftmExternalTrigger;
         \t   }
         \t}
         \t
         \t/**
         \t * Enables multiple external trigger generation on a channel comparison or initialisation event
         \t *
         \t * @param[in] externalTriggers Indicates the events to cause the external trigger. \n
         \t *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
         \t * @param[in] enable           Whether to enable/disable the specified triggers
         \t */
         \t%(static)void enableExternalTriggers(int externalTriggers, bool enable=true)%(const) {
         \t   enableExternalTrigger(FtmExternalTrigger(externalTriggers), enable);
         \t}
         \t
         \t/**
         \t * Enable/disable Timer Overflow interrupts
         \t */
         \t%(static)void enableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC | FTM_SC_TOIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable Timer Overflow interrupts
         \t */
         \t%(static)void disableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOIE_MASK;
         \t}
         \t
         \t/**
         \t * Enable fault interrupts
         \t */
         \t%(static)void enableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE | FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable fault interrupts
         \t */
         \t%(static)void disableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE & ~FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t *  Disables fault detection input
         \t *
         \t *  @tparam inputNum        Number of fault input to enable (0..3)
         \t */
         \ttemplate<int inputNum>
         \t%(static)void disableFault()%(const) {
         \t   static_assert(inputNum<=4, "Illegal fault channel");
         \t
         \t   // Enable fault on channel
         \t   ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<inputNum);
         \t}
         \t
         \t/**
         \t *  Enables fault detection input
         \t *
         \t *  @tparam inputNum           Number of fault input to enable (0..3)
         \t *
         \t *  @param[in]  polarity       Polarity of fault input
         \t *  @param[in]  filterEnable   Whether to enable filtering on the fault input
         \t *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
         \t *
         \t *  NOTE - the filter delay is shared by all inputs
         \t */
         public:
         \ttemplate<uint8_t inputNum>
         \t%(static)void enableFault(
         \t      Polarity polarity     = ActiveHigh,
         \t      bool     filterEnable = false,
         \t      uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1))%(const) {
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" condition="/PCR/_present" codeGenCondition="%(isStatic)" ><![CDATA[
         #ifdef DEBUG_BUILD
         \t   static_assert((inputNum<Info::InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex != pinIndex::UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex != pinIndex::INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex == pinIndex::UNMAPPED_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit == INVALID_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit >= 0), "Pcr_T: Illegal signal used for fault");
         #endif
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" condition="/PCR/_present" ><![CDATA[
         \t   PcrTable_T<typename Info::InfoFAULT, inputNum>::setPCR();
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t   if (polarity) {
         \t      // Set active high
         \t      ftm->FLTPOL = ftm->FLTPOL & ~(1<<inputNum);
         \t   }
         \t   else {
         \t      // Set active low
         \t      ftm->FLTPOL = ftm->FLTPOL | (1<<inputNum);
         \t   }
         \t   if (filterEnable) {
         \t      // Enable filter & set filter delay
         \t      ftm->FLTCTRL = ((ftm->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
         \t   }
         \t   else {
         \t      // Disable filter
         \t      ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
         \t   }
         \t   // Enable fault input
         \t   ftm->FLTCTRL = ftm->FLTCTRL | (1<<inputNum);
         \t   // Enable fault mode (All channels, manual)
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_FAULTM(2);
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"
         variables="ftm_pol_pol0_present" ><![CDATA[
         \t/**
         \t * Set polarity of all channels
         \t *
         \t * @param channelMask   Bit mask 0 => active-high, 1 => active-low
         \t */
         \t%(static) void setPolarity(uint32_t channelMask)%(const) {
         \t   ftm->POL = channelMask;
         \t}
         \t
         \t/**
         \t * Set polarity of selected channels
         \t *
         \t * @param polarity      Polarity to set
         \t * @param channelMask   Bit mask indicating channels to affect
         \t */
         \t%(static)void setPolarity(Polarity polarity, uint32_t channelMask)%(const) {
         \t   if (polarity) {
         \t      ftm->POL = ftm->POL & ~channelMask;
         \t   }
         \t   else {
         \t      ftm->POL = ftm->POL | channelMask;
         \t   }
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true"><![CDATA[
         \t/*
         \t * *****************************************************************
         \t *          Channel functions
         \t * *****************************************************************
         \t */
         \t/**
         \t * Set PWM duty cycle.
         \t * Higher precision float version
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage (float)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(float dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*ftm->MOD)/100.0f);
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*(ftm->MOD+1))/100.0f);
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM duty cycle
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(int dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*ftm->MOD)/100;
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*(ftm->MOD+1))/100;
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM high time in ticks
         \t * Assumes value is less than period
         \t *
         \t * @param[in] highTime   PWM high time in ticks
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t * @return E_TOO_LARGE on success
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Ticks highTime, int channel)%(const) {
         \t
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      // In CPWM the pulse width is doubled
         \t      highTime = Ticks((highTime+1_ticks)/2U);
         \t   }
         #ifdef DEBUG_BUILD
         \t   if ((unsigned)highTime > ftm->MOD) {
         \t      return setErrorCode(E_TOO_LARGE);
         \t   }
         #endif
         \t   ftm->CONTROLS[channel].CnV  = (unsigned)highTime;
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Get Timer event time
         \t *
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return Absolute time of last event in ticks i.e. value from timer event register
         \t */
         \t%(static)Ticks getEventTime(int channel)%(const) {
         \t   return Ticks(ftm->CONTROLS[channel].CnV);
         \t}
         \t
         \t/**
         \t * Set Timer event time
         \t *
         \t * This value is write-buffered and updated by Cnv synchronisation.
         \t *
         \t * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
         \t * @param[in] channel    Timer channel
         \t */
         \t%(static)void setEventTime(Ticks eventTime, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = (unsigned)eventTime;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current event time
         \t *
         \t * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setDeltaEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CONTROLS[channel].CnV + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current timer count value
         \t *
         \t * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setRelativeEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CNT + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set PWM high time in seconds
         \t *
         \t * @param[in] highTime   PWM high time in seconds
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t *
         \t * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Seconds highTime, int channel)%(const) {
         \t   return setHighTime(convertSecondsToTicks(highTime), channel);
         \t}
         \t
         \t/**
         \t * Set initial state for channels outputs
         \t *
         \t * @param initialValue  Bit mask value for channels
         \t */
         \t%(static)void setOutputInitialValue(uint32_t initialValue)%(const) {
         \t   ftm->OUTINIT = initialValue;
         \t}
         \t
         \t/**
         \t * Set output mask for channels outputs
         \t *
         \t * The mask of a channel determines if its output responds, that is,
         \t * it is masked or not, when a match occurs
         \t * This value is write-buffered and updated by PWM synchronisation.
         \t *
         \t * @param maskValue  Bit mask value 0 => not masked, 1 => masked
         \t */
         \t%(static)void setOutputMaskValue(uint32_t maskValue)%(const) {
         \t   ftm->OUTMASK = maskValue;
         \t}
         \t
         \t/**
         \t * Set inverting control
         \t *
         \t * This controls when the channel (n) and (n+1) outputs are exchanged.
         \t * Each bit enables the inverting operation for the corresponding channels pair.
         \t * This value is write-buffered and updated by INVCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
         \t */
         \t%(static)void setInvertedChannelPairs(uint32_t enableMask)%(const) {
         \t   ftm->OUTINIT = enableMask;
         \t}
         \t
         \t/**
         \t * Force channel outputs
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
         \t * @param outputMask  Bit mask for values to be forced to selected channels
         \t */
         \t%(static)void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask)%(const) {
         \t   ftm->SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
         \t}
         \t
         \t/**
         \t * Force channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be forced
         \t * @param value    Value to be forced on that channel
         \t */
         \t%(static)void forceChannelOutput(uint32_t channel, bool value)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOCV_SHIFT  = 8;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t   uint32_t valueMask   = 1<<(channel+FTM_SWOCTRL_CHxOCV_SHIFT);
         \t
         \t   // Set control bit + insert control value
         \t   ftm->SWOCTRL = (ftm->SWOCTRL&~valueMask) | (channelMask | (value?valueMask:0));
         \t}
         \t
         \t/**
         \t * Release forced channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be released
         \t */
         \t%(static)void releaseChannelOutput(uint32_t channel)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t
         \t   // Release control bit
         \t   ftm->SWOCTRL = ftm->SWOCTRL & ~channelMask;
         \t}
         \t
         \t/**
         \t * Set current value of channel outputs.\n
         \t * This value is overwritten by the next channel action.
         \t *
         \t * @param channelValueMask Mask indicating desired channel outputs
         \t */
         \t%(static)void setChanelOutputs(uint32_t channelValueMask)%(const) {
         \t   ftm->OUTINIT = channelValueMask;
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_INIT_MASK;
         \t}\n\n
      ]]></template>

<!-- Channel Functions -->

   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true"
      variables="tpm_cnsc_action[]"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void setAction(FtmChannelAction ftmChannelAction)%(const) {
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t            (ftm->CONTROLS[%(channel)].CnSC & ~(FTM_CnSC_CHIE_MASK|FTM_CnSC_DMA_MASK))|
      \t            ftmChannelAction;
      \t   }\n\n
   ]]></template>

   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
      \t   /**
      \t    * Configure channel.
      \t    * No affect on shared settings of owning Timer
      \t    *
      \t    * @param[in] ftmChannelMode    Mode of operation for channel
      \t    * @param[in] ftmChannelAction  Whether to enable the interrupt or DMA function on this channel
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void configure(
      \t         FtmChannelMode    ftmChannelMode,
      \t         FtmChannelAction  ftmChannelAction = FtmChannelAction_None)%(const) {
      \t
      \t      ftm->CONTROLS[%(channel)].CnSC = ftmChannelMode|ftmChannelAction;
      \t   }
      \t
      \t   /**
      \t    * Disables timer channel (sets mode to FtmChannelMode_Disabled)
      \t    */
      \t   %(static) void disable()%(const) {
      \t      setMode(FtmChannelMode_Disabled);
      \t   }
      \t
      \t   /**
      \t    * Get channel mode.
      \t    *
      \t    * @return Current mode of operation for the channel
      \t    */
      \t   %(static) FtmChannelMode getMode()%(const) {
      \t      return static_cast<FtmChannelMode>(ftm->CONTROLS[%(channel)].CnSC &
      \t            (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
      \t   }
      \t
      \t   /**
      \t    * Set channel mode
      \t    *
      \t    * @param[in] ftmChannelMode      Mode of operation for channel
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void setMode(FtmChannelMode ftmChannelMode)%(const) {
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t            (ftm->CONTROLS[%(channel)].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|ftmChannelMode;
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in ticks.
      \t    * Assumes value is less than period
      \t    *
      \t    * @param[in] highTime   PWM high time in ticks
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Ticks highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in seconds.
      \t    * Higher precision float version
      \t    *
      \t    * @param[in] highTime   PWM high time in seconds
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Seconds highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t   /**
      \t    * Set PWM duty cycle.
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDutyCycle(int dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDutyCycle(float dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDeltaEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setDeltaEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time relative to current timer count value.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setRelativeEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setRelativeEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Absolute Timer event time.
      \t    *
      \t    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setEventTime(Ticks eventTime)%(const) {
      \t      %(Ftm)::setEventTime(eventTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Absolute Timer event time.
      \t    *
      \t    * @return Absolute time of last event in ticks i.e. value from timer event register
      \t    */
      \t   %(static) Ticks getEventTime()%(const) {
      \t      return %(Ftm)::getEventTime(%(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Timer interrupt/event flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    */
      \t   %(static) bool getInterruptFlag()%(const) {
      \t      return (ftm->STATUS&CHANNEL_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Get and Clear Timer channel interrupt flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    *
      \t    * @note Only flags captured in the return value are cleared
      \t    */
      \t   %(static) bool getAndClearInterruptFlag()%(const) {
      \t      // Note - requires read and write zero to clear flags
      \t      // so only flags captured in status are cleared
      \t      bool status = (ftm->STATUS&CHANNEL_MASK) != 0;
      \t      ftm->STATUS = ~CHANNEL_MASK;
      \t      return status;
      \t   }
      \t
      \t   /**
      \t    * Clear interrupt flag on channel.
      \t    */
      \t   %(static) void clearInterruptFlag()%(const) {
      \t      // Note - requires read and write zero to clear flag
      \t      ftm->CONTROLS[CHANNEL].CnSC = ftm->CONTROLS[CHANNEL].CnSC & ~FTM_CnSC_CHF_MASK;
      \t   }
      \t
      \t   /**
      \t    * Force channel output.
      \t    *
      \t    * This enables software control of channel output and
      \t    * defines the value forced to the channel output.
      \t    * This value is write-buffered and updated by SWOCTRL synchronisation.
      \t    *
      \t    * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
      \t    */
      \t   %(static) void forceChannelOutput(FtmChannelForce ftmChannelForce)%(const) {
      \t      static const uint32_t MASK = ((1<<%(channel))|(1<<(%(channel)+8)));
      \t      ftm->SWOCTRL = ((ftm->SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      \t   }\n\n
   ]]></template>
   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true"
      variables="ftm_pol_pol0_present" ><![CDATA[
      \t   /**
      \t    * Set polarity of channels.
      \t    *
      \t    * @param polarity Polarity to set
      \t    */
      \t   %(static) void setPolarity(Polarity polarity)%(const) {
      \t      %(Ftm)::setPolarity(polarity, CHANNEL_MASK);
      \t   }\n\n
      ]]></template>
   </for>

   <clockCodeTemplate variable="ftm_sc_clks"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      %paramDescription
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!--   ========== Init class =============================== -->

   <template key="init_description" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * //
      \t * // $(_NAME) call-back
      \t * //
      \t * // @param status  Status reflecting active inputs
      \t * //
      \t * void $(_name)Callback() {
      \t *    ...
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_Class)Init {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmMode_Freerunning,           // Alignment and whether interval or free-running mode
      \t *    FtmOverflowInterrupt_Disabled, // Overflow Interrupt
      \t *    NvicPriority_Normal,           // IRQ level for this peripheral
      \t *    FtmClockSource_SystemClock,    // Clock Source
      \t *
      \t *    // Either
      \t *    FtmPrescale_DivBy16,           // Clock prescaler
      \t *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
      \t *    // OR
      \t *    100_ms,                        // Timer period or minimum interval in seconds
      \t *
      \t *    FtmInitialValue(0xf),          // Channel Output Initialization Value
      \t *    FtmPolarity(0xf0),             // Channel Output Polarity
      \t *
      \t *    $(_name)Callback,              // Call-back to execute on event - call-back function name
      \t *    NvicPriority_Low,              // Priority for interrupt - Low
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_Class)Init)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" discardRepeats="true"  ><![CDATA[
      class $(_Baseclass)BasicInfo {
      \t
      public:
      \t\n
   ]]></template>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" discardRepeats="true"
      variables="/$(_BASENAME)/irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></initialValueTemplate>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   ><![CDATA[
      \t/**
      \t * Type definition for overflow and fault call-back.
      \t */
      \ttypedef void (*CallbackFunction)();
      \t
      \t/**
      \t * Callback to catch unhandled overflow and fault call-back.
      \t */
      \tstatic void unhandledCallback() {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t
      \t/**
      \t * Type definition for channel event call-back
      \t *
      \t * @param mask Mask identifying channel
      \t */
      \ttypedef void (*ChannelCallbackFunction)(uint8_t mask);
      \t
      \t/**
      \t * Callback to catch unhandled channel event call-back
      \t *
      \t * @param mask Mask identifying channel
      \t */
      \tstatic void unhandledChannelCallback(uint8_t mask) {
      \t   (void)mask;
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}\n\n
   ]]></template>

   <template codeGenCondition="irqHandlingMethod">
   <![CDATA[
      \t/** Callback function for Channel Fault and timer overflow */
      \tstatic CallbackFunction sCallback;
      \t\n
   ]]></template>

   <template codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Indicates if individual call-backs can be set for each channel
      \t */
      \tstatic constexpr bool individualChannelCallbacks = $(/$(_NAME)/individualChannelCallbacks);
      \t\n
   ]]></template>

   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for Channel Fault and timer overflow */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallback = $(_Class)Info::unhandledCallback;
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod&amp;&amp;!individualChannelCallbacks" >
   <![CDATA[
      \t/**
      \t * Callback table for programmatically set channel call-backs
      \t * One entry - all hardware interrupt vectors are mapped to a single handler
      \t */
      \tstatic ChannelCallbackFunction channelCallbacks[1];
      \t\n
   ]]></template>

   <template codeGenCondition="irqHandlingMethod&amp;&amp;individualChannelCallbacks" >
   <![CDATA[
      \t/**
      \t * Callback table for programmatically set channel call-backs
      \t * One entry for each channel (one hardware interrupt vector is mapped to multiple channel call-backs by software)
      \t */
      \tstatic ChannelCallbackFunction channelCallbacks[NumChannels];
      \t\n
   ]]></template>

   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Callback table for programmatically set handlers for $(_Class)
      \t */
      \t$(_Class)Info::ChannelCallbackFunction $(_Class)Info::channelCallbacks[] = {\n\n
   ]]></template>
   <for keys="ch" dim="NumChannels">
      <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod&amp;&amp;individualChannelCallbacks" ><![CDATA[
         \t   $(_Class)Info::unhandledChannelCallback,\n
      ]]></template>
   </for>
   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod&amp;&amp;!individualChannelCallbacks" ><![CDATA[
      \t   $(_Class)Info::unhandledChannelCallback,\n
   ]]></template>
   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t};\n\n
   ]]></template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
$(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <initialValueTemplate namespace="usbdm" discardRepeats="true" variables="irqHandlingMethod" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
    ><![CDATA[
      \t   // Shared overflow or fault interrupt call-back
      \t   %params = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   // Shared channel interrupt call-back
      \t   ChannelCallbackFunction channelCallbackFunction = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_sc_action,ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps,ftm_sc_mode"
   ><![CDATA[
      \t   // Status And Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_mode_pwmsync,ftm_mode_wpdis,ftm_mode_ftmen"
   ><![CDATA[
      \t   // Mode register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>
   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_cntin"
   ><![CDATA[
      \t   // %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_mod"
   ><![CDATA[
      \t   // %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables= "ftm_modPeriod"
    ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = 0_s;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables= "ftm_deadtime_dtps,ftm_deadtime_dtval"
    ><![CDATA[
      \t   // %description0 and %description1
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables= "ftm_outinit_choi"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables= "ftm_pol_pol"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables= "ftm_exttrig_trig"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

<!--   Configure method -->

   <setTemplate variables="ftm_sc_clks" discardRepeats="true" key="/$(_BASENAME)/InitMethod" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure FTM from values specified in init
      \t
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const FtmBasicInfo::Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      Info::setCallbacks(init);
      \t   }
      \t
      \t   uint8_t  sc    = init.sc;
      \t   uint16_t cntin = init.cntin;
      \t   uint16_t mod   = init.mod;
      \t
      \t   if (init.modperiod != 0) {
      \t
      \t      // Calculate sc.ps, mod (assumes cntin=0)
      \t      ErrorCode rc = calculateTimingParameters(init.modperiod, sc, mod);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }
      \t      // Configure for modulo operation
      \t      cntin = 0;
      \t   }
      \t   if (init.sc&FtmMode_FreeRunning) {
      \t      // Make free-running
      \t      cntin = 0;
      \t      mod   = FTM_MOD_MOD_MASK;
      \t   }
      \t   // Disable timer to change clock (unable to switch directly between clock sources)
      \t   ftm->SC  = 0;
      \t
      \t   // Start value for counter
      \t   ftm->CNTIN = cntin;
      \t
      \t   // End value for counter
      \t   ftm->MOD = mod;
      \t
      \t   // Restart counter
      \t   ftm->CNT = 0;
      \t
      \t   // Configure timer
      \t   ftm->SC  = sc;
      \t
      \t   // Mode FTMEN,PWNSYNC,WPDIS (apart from fault)
      \t   ftm->MODE     = init.mode;
      \t
      \t   // Channel Output Initialization Value
      \t   ftm->OUTINIT  = init.outinit;
      \t
      \t   // Channel Output Polarity
      \t   ftm->POL      = init.pol;
      \t
      \t   // Dead-time Prescaler Value and Dead-time Value
      \t   ftm->DEADTIME = init.deadtime;
      \t
      \t   // External Trigger Enable
      \t   ftm->EXTTRIG =  init.exttrig;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></setTemplate>

<!--   Constructors -->

   <constructorTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for shared channel interrupt call-back
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param callback Shared channel interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(ChannelCallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->channelCallbackFunction = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for overflow and fault interrupt call-back
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param callback Overflow and fault interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(CallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->callbackFunction = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t   %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="ftm_outinit_choi;
                         ftm_pol_pol" >
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <for keys="r" values="ftm_sc_action;ftm_sc_cpwms;ftm_sc_mode;ftm_sc_clks;
                         ftm_mode_pwmsync;ftm_mode_wpdis;ftm_mode_init;ftm_mode_ftmen" >
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_deadtime_dtps, ftm_deadtime_dtval"
      linePadding="xxx"
      params=",ticks"
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 and %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_exttrig_trig"
      linePadding="xxx"
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName |= %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_sc_ps, ftm_cntin, ftm_mod"
      params=",cntin_ticks,mod_ticks"
      linePadding="xxx"
      nonDefaultParams="3"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0, %description1 and %description2
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName0    = (%registerName0&~%mask0) | %paramName0;
         \t      %registerName1 = %paramName1;
         \t      %registerName2   = %paramName2;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_sc_ps, ftm_mod"
      params=",mod_ticks"
      linePadding="xxx"
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 and %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      cntin = 0_ticks;
         \t      %registerName0    = (%registerName0&~%mask0) | %paramName0;
         \t      %registerName1   = %paramName1;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      nonDefaultParams="2"
      variables="ftm_modPeriod"
      linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      cntin = 0;
         \t      mod   = 0;
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t}; // class $(_Baseclass)BasicInfo::Init\n\n
   ]]></template>

   <initialValueTemplate codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
         ftm_sc_mode,
         ftm_sc_action,
         ftm_sc_clks,
         ftm_sc_ps,
         ftm_cntin,
         ftm_mod,
         ftm_mode_wpdis,
         ftm_mode_init,
         ftm_outinit_choi,
         ftm_pol_pol,
         ftm_exttrig_trig"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression\n
      \t};
      \t\n
   ]]>
   </initialValueTemplate>

<!--   ========== FTM Fault Init class =============================== -->

   <template key="fault_init_description" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Class) Fault handling
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::FaultInit faultInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmFaultMode_EvenChannelsManualFaultClearing , // Fault Control Mode - Even channels with manual fault clearing
      \t *    FtmFaultInterrupt_Disabled ,                   // Fault Interrupt Enable - Disabled
      \t *    FtmFaultFilter_4_clocks,                       // Fault Input Filter - 4 Clock cycles
      \t *    FtmFault0Mode_Disabled ,                       // Fault Input 0 Enable and Filter - Fault input disabled
      \t *    FtmFault0Polarity_ActiveHigh,                  // Fault Input 0 Polarity - Active High
      \t *    FtmFault1Mode_Filtered ,                       // Fault Input 1 Enable and Filter - Fault input enabled with filter
      \t *    FtmFault1Polarity_ActiveHigh,                  // Fault Input 1 Polarity - Active High
      \t *    FtmFault2Mode_Direct ,                         // Fault Input 2 Enable and Filter - Fault input enabled
      \t *    FtmFault2Polarity_ActiveLow,                   // Fault Input 2 Polarity - Active Low
      \t *    FtmFault3Mode_Direct ,                         // Fault Input 3 Enable and Filter - Fault input enabled
      \t *    FtmFault3Polarity_ActiveHigh,                  // Fault Input 3 Polarity - Active High
      \t *
      \t *    // Inherit default value
      \t *    $(_Class)::DefaultFaultInitValue
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configureFaultHandling(faultInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
$(fault_init_description)
      \tclass FaultInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr FaultInit(const FaultInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr FaultInit() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_mode_faultm,ftm_mode_faultie,ftm_mode_pwmsync,ftm_mode_wpdis,ftm_mode_ftmen"
   ><![CDATA[
      \t   // Mode register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_fltctrl_ffval,ftm_fltctrl_fault0en"
   ><![CDATA[
      \t   // Fault Control register
      \t   uint16_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_fltpol_flt0pol"
   ><![CDATA[
      \t   // Fault Input Polarity register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate
   >

<!--  Configure methods -->

   <template discardRepeats="true" key="/$(_BASENAME)/FaultInitMethod" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure fault handling from values specified in faultInit
      \t *
      \t * @param faultInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configureFaultHandling(const $(_Baseclass)BasicInfo::FaultInit &faultInit) {
      \t
      \t   ftm->FLTCTRL = faultInit.fltctrl;
      \t   ftm->FLTPOL  = faultInit.fltpol;
      \t   ftm->MODE    = (ftm->MODE&~(FTM_MODE_FAULTIE_MASK|FTM_MODE_FAULTM_MASK)) | faultInit.mode;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!--  Constructors -->

   <for keys="r" values="ftm_mode_faultm;ftm_mode_faultie;ftm_fltctrl_ffval">
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr FaultInit(%params, Types... rest) : FaultInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   <for keys="pin" dim="8" >
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="ftm_fltctrl_fault%(pin)en,ftm_fltpol_flt%(pin)pol"
         linePadding="xxx"
         tooltipPadding="x*xxxxxxxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr FaultInit(
         %params, Types... rest) : FaultInit(rest...) {
         \t
         \t      %registerName0 = (%registerName0&~%mask0) | %paramName0;
         \t      %registerName1 = (%registerName1&~%mask1) | %paramName1;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

<!--  Fault Init value -->

   <initialValueTemplate codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      condition="SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT3&quot;)"
      separator=","
      terminator=","
      variables=",
         ftm_mode_faultm,
         ftm_mode_faultie,
         ftm_mode_ffval,
         ftm_fltctrl_ffval"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr FaultInit DefaultFaultInitValue = {%initExpression\n
   ]]></initialValueTemplate>

   <for keys="inp" dim="4" >
      <initialValueTemplate codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         condition="SignalExists(&quot;$(_NAME)_FLT%(inp)&quot;)"
         separator=","
         terminator=","
         variables="
            ftm_fltctrl_fault%(inp)en,
            ftm_fltpol_flt%(inp)pol"
      ><![CDATA[
         %initExpression\n
      ]]></initialValueTemplate>
   </for>

   <template codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      condition="SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT3&quot;)"
   >
   <![CDATA[
      \t};
      \t\n
   ]]>
   </template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t}; // class  $(_Baseclass)BasicInfo::FaultInit\n\n
   ]]></template>

<!--   ========== FTM CHANNEL Init class =============================== -->

   <template key="channel_init_description" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Class)Channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::ChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmChannelNum_3,            // Channel to initialise (may be unused if specifically provided as parameter)
      \t *    FtmChannelMode_Disabled ,   // Channel Mode - Disabled
      \t *    FtmChannelAction_None ,     // Action on Channel Event - No action
      \t *    FtmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
      \t *    0_ticks,                    // Output Compare Event time
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[FtmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configureChannel(channelInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
$(channel_init_description)
      \tclass ChannelInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <setTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   // $(_Class) channel interrupt call-back
      \t   ChannelCallbackFunction callbackFunction = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_cnv[]"
   ><![CDATA[
      \t   // %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_cnsc_mode[]"
   ><![CDATA[
      \t   // Channel Status And Control Register
      \t   uint8_t %registerName = 0;
      \t
      \t   // Function For Linked Channels
      \t   uint8_t combine = 0;
      \t\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_channel_number"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_None;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="ftm_filter_ch0fval"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Disabled;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod&amp;&amp;(NumChannelVectors>1)"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></initialValueTemplate>

<!--  Configure methods -->

   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configureChannel(FtmChannelNum channelNum, const $(_Baseclass)BasicInfo::ChannelInit &channelInit) {
      \t\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all"
             codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
   ><![CDATA[
      \t   if constexpr (Info::individualChannelCallbacks) {
      \t      // Individual channel call-backs provided
      \t      Info::setChannelCallback(channelNum, channelInit);
      \t   }
      \t\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" condition="ftm_combine_combine0_present" ><![CDATA[
      \t   // Configure timer combine mode
      \t   if ((channelNum&0b1) == 0) {
      \t      // Even channel value controls paired channels n,n+1
      \t      const unsigned offset = 4*channelNum;
      \t      const uint32_t mask = 0xFF<<offset;
      \t      ftm->COMBINE = (ftm->COMBINE & ~mask) | (uint32_t(channelInit.combine)<<offset);
      \t   }\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" ><![CDATA[
      \t   // Configure timer channel
      \t   ftm->CONTROLS[channelNum].CnSC = channelInit.cnsc;
      \t   ftm->CONTROLS[channelNum].CnV  = channelInit.cnv;\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" condition="ftm_filter_ch0fval" ><![CDATA[
      \t   ftm->FILTER = (ftm->FILTER & (FTM_FILTER_CH0FVAL_MASK<<(channelNum*4)))|(channelInit.filter<<(channelNum*4));\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" ><![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

   <template discardRepeats="true" key="/$(_BASENAME)/ChannelInitMethod" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configureChannel(const typename Info::ChannelInit &channelInit) {
      \t   return configureChannel(channelInit.channel, channelInit);
      \t}
      \t\n
   ]]></template>

<!--  Constructors -->

   <constructorTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param    callback Channel interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(ChannelCallbackFunction callbackFunction, Types... rest) : ChannelInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="
      ftm_cnsc_action[];
      ftm_cnsc_icrst[];
      ftm_cnsc_secondedge[1]">
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <for keys="r" values="
      ftm_cnsc_mode[]">
      <constructorTemplate  namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      cnsc    = %paramExpression&0xFF;
         \t      combine = %paramExpression>>8;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <for keys="r" values="
      ftm_filter_ch0fval;
      ftm_channel_number;
      ftm_cnv[]">
      <constructorTemplate  namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t}; // class  $(_Baseclass)BasicInfo::ChannelInit\n\n
   ]]></template>

<!--  Default Initialisation value -->

  <template codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)ChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
  ]]></template>
   <for keys="ch" dim="NumChannels">
      <initialValueTemplate  codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_mode[%(ch)],
            ftm_cnsc_secondedge[%(ch)],
            ftm_cnsc_action[%(ch)],
            ftm_cnsc_icrst[%(ch)],
            ftm_cnv[%(ch)],
            ftm_filter_ch%(ch)fval"
      ><![CDATA[
         \t{
         \t   FtmChannelNum_%(ch),
         %initExpression\n\t},\n
      ]]></initialValueTemplate>
   </for>
  <template  codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"><![CDATA[
      \n\t};\n\n
  ]]></template>

<!--  ========== FTM QUAD Init class =============================== -->

   <template key="quad_init_description" namespace="all" condition="ftm_qdctrl_quadmode_present" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of FtmQuadDecoder$(_instance)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const FtmQuadDecoder$(_instance)::QuadInit quadInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmQuadratureMode_Phase_AB_Mode , // Quadrature decoding mode
      \t *    FtmPhaseAPolarity_ActiveHigh ,    // Polarity of Phase A input
      \t *    FtmPhaseBPolarity_ActiveHigh ,    // Polarity of Phase B input
      \t *    FtmPhaseAFilter_Disabled ,        // Filtering on Phase A input
      \t *    FtmPhaseBFilter_Disabled ,        // Filtering on Phase B input
      \t *    FtmOverflowInterrupt_Enabled ,    // Overflow Interrupt
      \t *    NvicPriority_Normal ,             // IRQ level for this peripheral
      \t *    FtmPrescale_DivBy32,              // Clock prescaler
      \t *    ftmCallbak,                       // Timer overflow call-back
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultQuadInitValue
      \t * };
      \t *
      \t * // Initialise FTM from values specified above
      \t * FtmQuadDecoder$(_instance)::configure(ftmInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" discardRepeats="true"  condition="ftm_qdctrl_quadmode_present" ><![CDATA[
$(quad_init_description)
      \tclass QuadInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr QuadInit(const QuadInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr QuadInit() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <setTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod"  condition="ftm_qdctrl_quadmode_present"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   // %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_a,ftm_qdfilter_b"
   ><![CDATA[
      \t   // Quad input filter control
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"
      variables="ftm_qdctrl_quadmode"
   ><![CDATA[
      \t   // Quadrature Decoder Control And Status Register
      \t   uint8_t %registerName = FTM_QDCTRL_QUADEN_MASK;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"  condition="ftm_qdctrl_quadmode_present"
      variables="ftm_sc_action,ftm_sc_ps"
   ><![CDATA[
      \t   // Status And Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"  codeGenCondition="/$(_BASENAME)/irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></initialValueTemplate>

<!--  Configure method -->

   <template discardRepeats="true" key="/$(_BASENAME)/QuadInitMethod" namespace="all" condition="ftm_qdctrl_quadmode_present" ><![CDATA[
      \t/**
      \t * Configure QuadDecoder from values specified in init
      \t
      \t * @param quadInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const typename Info::QuadInit &quadInit) {
      \t
      \t   // Assertions placed here so only checked if FtmQuadDecoder actually used
      \t   static_assert(Info::InfoQUAD::info[0].gpioBit >= 0, "FtmQuadDecoder PHA is not mapped to a pin - Modify Configure.usbdm");
      \t   static_assert(Info::InfoQUAD::info[1].gpioBit >= 0, "FtmQuadDecoder PHB is not mapped to a pin - Modify Configure.usbdm");
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled and non-null
      \t      if (quadInit.callbackFunction != nullptr) {
      \t         FtmBase_T<Info>::setCallback(quadInit.callbackFunction);
      \t      }
      \t      enableNvicInterrupts(quadInit.irqlevel);
      \t   }
      \t
      \t   // Disable timer to change clock (unable to switch directly between clock sources)
      \t   ftm->SC  = 0;
      \t
      \t   // Start value for counter
      \t   ftm->CNTIN = 0;
      \t
      \t   // End value for counter
      \t   ftm->MOD =0;
      \t
      \t   // Restart counter
      \t   ftm->CNT = 0;
      \t
      \t   // Configure timer
      \t   ftm->FILTER = quadInit.qdfilter;
      \t   ftm->SC     = quadInit.sc;
      \t   ftm->QDCTRL = quadInit.qdctrl;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!--  Constructors -->

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="
      ftm_sc_action;
      ftm_sc_ps;
      ftm_qdctrl_quadmode;
      ftm_qdctrl_phapol;
      ftm_qdctrl_phbpol">
      <constructorTemplate  namespace="usbdm" discardRepeats="true"   condition="ftm_qdctrl_quadmode_present"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate  namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_a"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      qdctrl   = (qdctrl&~FTM_QDCTRL_PHAFLTREN_MASK) | ((%paramExpression>>8) & FTM_QDCTRL_PHAFLTREN_MASK);
      \t      qdfilter = (qdfilter&~FTM_FILTER_CH0FVAL_MASK) | (%paramExpression&FTM_FILTER_CH0FVAL_MASK);
      \t   }
      \t\n
   ]]></constructorTemplate>

   <constructorTemplate  namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_b"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      qdctrl   = (qdctrl&~FTM_QDCTRL_PHBFLTREN_MASK) | ((%paramExpression>>8) & FTM_QDCTRL_PHBFLTREN_MASK);
      \t      qdfilter = (qdfilter&~FTM_FILTER_CH1FVAL_MASK) | (%paramExpression&FTM_FILTER_CH1FVAL_MASK);
      \t   }
      \t\n
   ]]></constructorTemplate>

   <template namespace="usbdm" discardRepeats="true"   condition="ftm_qdctrl_quadmode_present"><![CDATA[
      \t};\n\n
   ]]></template>

   <template namespace="usbdm" discardRepeats="true"  ><![CDATA[
      }; // class  $(_Baseclass)BasicInfo\n\n
   ]]></template>

<!--  Default Initialisation value -->

   <initialValueTemplate  condition="ftm_qdctrl_quadmode_present"
      separator=","
      terminator=","
      variables="
         ftm_qdctrl_quadmode,
         ftm_qdctrl_phapol,
         ftm_qdctrl_phbpol,
         ftm_qdfilter_a,
         ftm_qdfilter_b,
         ftm_sc_action,
         irqLevel,
         ftm_sc_ps"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)QuadDecoder
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr QuadInit DefaultQuadInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

<!--  ========== Misc =============================== -->

   <template  codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Set overflow and fault interrupt call-back
      \t *
      \t * @param[in] newCallback Callback function to execute on interrupt.
      \t *                        Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t */
      \tstatic ErrorCode setCallback(CallbackFunction newCallback) {
      \t   if (newCallback == nullptr) {
      \t      newCallback = unhandledCallback;
      \t   }
      \t   sCallback = newCallback;
      \t   return E_NO_ERROR;
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="!irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t */
      \tstatic void setCallbacks(const Init &) {
      \t}
      \t
      \t/**
      \t * Set channel callbacks from ChannelInit structure
      \t */
      \tstatic void setChannelCallback(const ChannelInit &) {
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="irqHandlingMethod&amp;&amp;!individualChannelCallbacks" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for shared channel call-backs i.e. all channels use same call-back
      \t *
      \t * @param[in] callback Callback function to execute on channel interrupt.
      \t *                     Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note The channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      \t   if (callback == nullptr) {
      \t      channelCallbacks[0] = unhandledChannelCallback;
      \t      return E_NO_ERROR;
      \t   }
      #ifdef DEBUG_BUILD
      \t   // Callback is shared across all channels. Check if callback already assigned
      \t   if ((channelCallbacks[0] != unhandledChannelCallback) &&
      \t       (channelCallbacks[0] != callback)) {
      \t      return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      \t   }
      #endif
      \t   channelCallbacks[0] = callback;
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void setCallbacks(const Init &init) {
      \t   if (init.callbackFunction != nullptr) {
      \t      setCallback(init.callbackFunction);
      \t   }
      \t   if (init.channelCallbackFunction != nullptr) {
      \t      setChannelCallback(init.channelCallbackFunction);
      \t   }
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t
      \t/**
      \t * Set channel callbacks from ChannelInit structure
      \t */
      \tstatic void setChannelCallback(const ChannelInit &) {
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="irqHandlingMethod&amp;&amp;individualChannelCallbacks" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for individual channel call-backs
      \t *
      \t * @param[in] channelNum Channel to set call-back for
      \t * @param[in] callback   Callback function to execute on channel interrupt.
      \t *                       Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note The channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic ErrorCode setChannelCallback(unsigned channelNum, ChannelCallbackFunction callback) {
      \t
      \t   if (channelNum>=NumChannels) {
      \t      return setErrorCode(ErrorCode::E_ILLEGAL_PARAM);
      \t   }
      \t   if (callback == nullptr) {
      \t      channelCallbacks[channelNum] = unhandledChannelCallback;
      \t      return ErrorCode::E_NO_ERROR;
      \t   }
      \t   channelCallbacks[channelNum] = callback;
      \t   return ErrorCode::E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \t static void setCallbacks(const Init &init) {
      \t    if (init.callbackFunction != nullptr) {
      \t       setCallback(init.callbackFunction);
      \t    }
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t
      \t/**
      \t * Set channel callbacks from ChannelInit structure
      \t */
      \tstatic void setChannelCallback(const ChannelInit &init) {
      \t   if (init.callbackFunction != nullptr) {
      \t      setChannelCallback(init.channel, init.callbackFunction);
      \t   }
      \t}
      \t\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.FtmValidate">
   </validate>

   <projectActionList id = "ftm_common_files" >
      <copy source="Project_Headers/ftm-MKE.h"            target="Project_Headers/ftm.h"                overwrite="true" derived="true" />
      <copy source="Snippets/ftm-pwm-example.cpp"         target="Snippets/ftm-pwm-example.cpp"         overwrite="true" derived="true" />
      <copy source="Snippets/ftm-ic-example.cpp"          target="Snippets/ftm-ic-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-oc-example.cpp"          target="Snippets/ftm-oc-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-oc-init-example.cpp"     target="Snippets/ftm-oc-init-example.cpp"     overwrite="true" derived="true" />
      <copy source="Snippets/ftm-servo-example.cpp"       target="Snippets/ftm-servo-example.cpp"       overwrite="true" derived="true" />
      <copy source="Snippets/ftm-quadrature-example.cpp"  target="Snippets/ftm-quadrature-example.cpp"  overwrite="true" derived="true" />
      <copy source="Snippets/neopixel-example.cpp"        target="Snippets/neopixel-example.cpp"        overwrite="true" derived="true" />
   </projectActionList>

   <template key="/$(_BASENAME)/declarations" namespace="all" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
   /**
    * Class representing $(_NAME)
    */
   class $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};\n\n
   ]]></template>

   <template key="/$(_BASENAME)/quadDeclarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_Class) as Quadrature decoder
   \t */
   \ttypedef $(_Baseclass)QuadDecoder_T<$(_Class)Info> $(_Baseclass)QuadDecoder$(_instance);\n
   ]]></template>

   <!-- ************* Signal mapping ****************** -->

   <category name="SIM" description="Pin mapping and clock enables">
      <aliasOption key="/SIM/sim_scgc_$(_name)"     locked="false" optional="true" />
      <aliasOption key="/SIM/sim_scgc_$(_basename)" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel_$(_name)clkps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel0_$(_name)clkps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_sopt_ftmic" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_sopt_rxdce" locked="false" optional="true" />

      <aliasOption key="/SIM/sim_sopt0_acic"  locked="false" optional="true" condition="$(_instance)==0" />
      <aliasOption key="/SIM/sim_sopt0_rtcc"  locked="false" optional="true" condition="$(_instance)==0" />
      <aliasOption key="/SIM/sim_sopt0_rxdce" locked="false" optional="true" condition="$(_instance)==0" />

      <aliasOption key="/SIM/sim_sopt0_actrg" locked="false" optional="true" condition="$(_instance)==2" />
      <aliasOption key="/SIM/sim_sopt0_delay" locked="false" optional="true" condition="$(_instance)==2" />

      <for keys="ch" dim="NumChannels" >
         <aliasOption key="/SIM/sim_pinsel_$(_name)ps%(ch)"  locked="false" optional="true" />
         <aliasOption key="/SIM/sim_pinsel0_$(_name)ps%(ch)" locked="false" optional="true" />
         <aliasOption key="/SIM/sim_pinsel1_$(_name)ps%(ch)" locked="false" optional="true" />
      </for>
   </category>

   <signals enabledBy="enablePeripheralSupport" locked="true" />
   <signals name="FTM" optional="true" />

</fragment>

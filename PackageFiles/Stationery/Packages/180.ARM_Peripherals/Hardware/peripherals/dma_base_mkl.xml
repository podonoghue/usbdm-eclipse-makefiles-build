<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- dma_base_mkl.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Enhanced direct memory access controller" >

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <equation key="suppressIrqHandler"        value="" />

   <equation key="irq_parameters"            value="DmaChannelNum channel" />
   <equation key="irq_dummy_parameters"      value="DmaChannelNum"         />
   <equation key="irq_call_parameters"       value="dmaChannel"            />
   <equation key="generateDefault"           value="false" />
   <xi:include href="enablePeripheral.xml"  />
   <title />

   <!-- ____ Class Declaration ________ -->
   <constant key="_class_declaration" type="String"
      value='"$(_Info) : public $(_BasicInfo)"' />

   <!-- _____ Constants __________________ -->
   <intOption key="NumChannels" locked="true" derived="true"
      value="=dma_dma_dim"
      description="Number of DMA channels"
      toolTip="The number of DMA channels available" />

   <intOption key="NumVectors" locked="true" derived="true"
      value="=_hardwareIrqCount"
      description="Number of DMA interrupt vectors"
      toolTip="Number of DMA interrupt vectors - \n
               Multiple channels may be mapped to the same vector" />

   <intOption key="NumPeriodicChannels" locked="true" derived="true"
      value="=/PIT/pit_channel_dim"
      description="Number of DMA channels with periodic feature"
      toolTip="Each periodic channel may be controlled by the corresponding PIT channel"  />

   <for keys="var" values="NumVectors;NumChannels;NumPeriodicChannels" >
      <variableTemplate variables="%(var)"
         initExpressionOnSameLine="true"
         linePadding="//x"
         tooltipPadding=""
      ><![CDATA[
         \t// %tooltip
         \tstatic constexpr unsigned %(var) = %initExpression;
         \t\n
      ]]></variableTemplate>
   </for>

   <choiceOption key="DmaChannelNum"
      description="DMA channel number"
      toolTip="Used to select DMA channel or indicate result of channel allocation"
      typeName="DmaChannelNum"
      baseType="uint8_t"
      valueFormat="%s" >
      <choiceExpansion keys="ch" dim="=NumChannels" value="%(ch)"        name="DMA channel %(ch)"         enum="%(ch)" />
      <choice                                       value="(1&lt;&lt;6)" name="All channels"              enum="All"   />
      <choice                                       value="(1&lt;&lt;7)" name="None or Failed allocation" enum="None"  />
   </choiceOption>

    <!-- _____ Source __________________ -->

   <title description="Source" />

   <intOption key="dma_sar_addr" condition="dma_sar_addr_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceAddress"
      baseType="uint32_t"
      description="Source Address"
      toolTip="Each SAR contains the byte address used by the DMA controller to read data.\n
               The SARn is typically aligned on a 0-modulo-ssize boundary—that is, on the natural alignment of the source data.\n
               Restriction: Bits 31-20 of this register must be written with one of only four allowed values.\n
               Each of these four allowed values corresponds to a valid region of the device's memory map. \n
               The allowed values are:\n
               • 0x000x_xxxx\n
               • 0x1FFx_xxxx\n
               • 0x200x_xxxx\n
               • 0x400x_xxxx\n
               After being written with one of the allowed values, bits 31-20 read back as the written value.\n
               After being written with any other value, bits 31-20 read back as an indeterminate value."
      radix="16"
      value="0" />

   <binaryOption key="dma_dcr_sinc" condition="dma_dcr_sinc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceIncrement"
      baseType="uint32_t"
      toolTip="Controls whether the source address increments"
      description="Source increment" >
      <choice name="No increment"                 value="0" enum="NoIncrement" />
      <choice name="Increments by transfer size"  value="1" enum="IncrementBySize" />
   </binaryOption >

   <choiceOption key="dma_dcr_ssize" condition="dma_dcr_ssize_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceSize"
      baseType="uint32_t"
      toolTip="Determines the data size of the source bus cycle for the DMA controller."
      description="Source size" >
      <choice name="32-bit"      value="0" enum="32Bit"     />
      <choice name="8-bit"       value="1" enum="8Bit"      />
      <choice name="16-bit"      value="2" enum="16Bit"     />
      <choice name="Reserved"    value="3" enum="Reserved"  />
   </choiceOption >

   <choiceOption key="dma_dcr_smod" condition="dma_dcr_smod_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceModulo"
      baseType="uint32_t"
      toolTip="Defines the size of the data circular buffer used by the DMA Controller.\n
               If enabled, the buffer base address is located on a boundary of the buffer size.\n
               The value of this boundary depends on the initial transfer address (SAR).\n
               The base address should be aligned to a 0-modulo-(circular buffer size) boundary.\n
               Misaligned buffers are not possible. The boundary is forced to the value determined by the
               upper address bits in the field selection.      "
      description="Source address modulo">
      <choice name="Buffer disabled"  value="0" enum="Disabled" />
      <choice name="16 bytes"         value="1" enum="16Bytes"  />
      <choice name="32 bytes"         value="2" enum="32Bytes"  />
      <choice name="64 bytes"         value="3" enum="64Bytes"  />
      <choice name="128 bytes"        value="4" enum="128Bytes" />
      <choice name="256 bytes"        value="5" enum="256Bytes" />
      <choice name="512 bytes"        value="6" enum="512Bytes" />
      <choice name="1 KB"             value="7" enum="1Kb"      />
      <choice name="2 KB"             value="8" enum="2Kb"      />
      <choice name="4 KB"             value="9" enum="4Kb"      />
      <choice name="8 KB"            value="10" enum="8Kb"      />
      <choice name="16 KB"           value="11" enum="16Kb"     />
      <choice name="32 KB"           value="12" enum="32Kb"     />
      <choice name="64 KB"           value="13" enum="64Kb"     />
      <choice name="128 KB"          value="14" enum="128Kb"    />
      <choice name="256 KB"          value="15" enum="256Kb"    />
   </choiceOption >

   <!-- _____ Destination __________________ -->

   <title description="Destination" />

   <intOption key="dma_dar_addr" condition="dma_dar_addr_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationAddress"
      baseType="uint32_t"
      description="Destination Address"
      toolTip="Each SAR contains the byte address used by the DMA controller to write data.\n
               The SARn is typically aligned on a 0-modulo-dsize boundary—that is, on the natural alignment of the source data.\n
               Restriction: Bits 31-20 of this register must be written with one of only four allowed values.\n
               Each of these four allowed values corresponds to a valid region of the device's memory map. \n
               The allowed values are:\n
               • 0x000x_xxxx\n
               • 0x1FFx_xxxx\n
               • 0x200x_xxxx\n
               • 0x400x_xxxx\n
               After being written with one of the allowed values, bits 31-20 read back as the written value.\n
               After being written with any other value, bits 31-20 read back as an indeterminate value."
      radix="16"
      value="0" />

   <binaryOption key="dma_dcr_dinc" condition="dma_dcr_dinc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationIncrement"
      baseType="uint32_t"
      toolTip="Controls whether the destination address increments"
      description="Destination increment" >
      <choice name="No increment"                 value="0" enum="NoIncrement"     />
      <choice name="Increments by transfer size"  value="1" enum="IncrementBySize" />
   </binaryOption >

   <choiceOption key="dma_dcr_dsize" condition="dma_dcr_dsize_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationSize"
      baseType="uint32_t"
      toolTip="Determines the data size of the destination bus cycle for the DMA controller."
      description="Destination size" >
      <choice name="32-bit"      value="0" enum="32Bit"    />
      <choice name="8-bit"       value="1" enum="8Bit"     />
      <choice name="16-bit"      value="2" enum="16Bit"    />
      <choice name="Reserved"    value="3" enum="Reserved" />
   </choiceOption >

   <choiceOption key="dma_dcr_dmod" condition="dma_dcr_dmod_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationModulo"
      baseType="uint32_t"
      toolTip="Defines the size of the data circular buffer used by the DMA Controller.\n
               If enabled, the buffer base address is located on a boundary of the buffer size.\n
               The value of this boundary depends on the initial transfer address (DAR).\n
               The base address should be aligned to a 0-modulo-(circular buffer size) boundary.\n
               Misaligned buffers are not possible. The boundary is forced to the value determined by the
               upper address bits in the field selection."
      description="Destination address modulo" >
      <choice name="Buffer disabled"  value="0" enum="Disabled"  />
      <choice name="16 bytes"         value="1" enum="16Bytes"   />
      <choice name="32 bytes"         value="2" enum="32Bytes"   />
      <choice name="64 bytes"         value="3" enum="64Bytes"   />
      <choice name="128 bytes"        value="4" enum="128Bytes"  />
      <choice name="256 bytes"        value="5" enum="256Bytes"  />
      <choice name="512 bytes"        value="6" enum="512Bytes"  />
      <choice name="1 KB"             value="7" enum="1Kb"       />
      <choice name="2 KB"             value="8" enum="2Kb"       />
      <choice name="4 KB"             value="9" enum="4Kb"       />
      <choice name="8 KB"            value="10" enum="8Kb"       />
      <choice name="16 KB"           value="11" enum="16Kb"      />
      <choice name="32 KB"           value="12" enum="32Kb"      />
      <choice name="64 KB"           value="13" enum="64Kb"      />
      <choice name="128 KB"          value="14" enum="128Kb"     />
      <choice name="256 KB"          value="15" enum="256Kb"     />
   </choiceOption >

  <!-- _____ Transfer Options __________________ -->

   <title description="Transfer Options" />

   <intOption key="dma_dsr_bcr_bcr" condition="dma_dsr_bcr_bcr_present"
      register="dsr_bcr"
      enabledBy="enablePeripheralSupport"
      typeName="DmaByteCount"
      baseType="uint32_t"
      description="Byte Count"
      toolTip="This field contains the number of bytes to be transferred for a given block.\n
               During the transfer it contains the number of bytes remaining."
      radix="16"
      value="0"
      min="0" max="0xFFFFF"
      />

   <choiceOption key="dma_dcr_erq_start"
      enabledBy="enablePeripheralSupport"
      valueFormat="DMA_DCR_ERQ(%s),DMA_DCR_START(%s)"
      typeName="DmaMode"
      baseType="uint32_t"
      description="Channel Mode"
      toolTip="Enables and selects the mode of operation of the channel.\n
               - Peripheral request = Transfers are initiated by an associated peripheral.\n
               - Immediate = Transfers start immediately (software start)">
      <choice name="Disabled"                                       value="0,0" enum="Disabled" />
      <choice name="Peripheral controls transfer (peripheral req.)" value="1,0" enum="PeripheralRequest" />
      <choice name="Immediately start transfer (software req.)"     value="0,1" enum="Immediate"         />
   </choiceOption>

   <binaryOption key="dma_dcr_d_req" condition="dma_dcr_d_req_present"
      enabledBy="enablePeripheralSupport&amp;&amp;(dma_dcr_erq_start==1)"
      typeName="DmaModeOnComplete"
      baseType="uint32_t"
      description="Disable peripheral request on completion"
      toolTip="Control whether the Peripheral requests are disabled when the BCR is exhausted">
      <choice name="Request not affected"           value="0" enum="Unchanged" />
      <choice name="Request disabled on completion" value="1" enum="Disabled"  />
   </binaryOption >

   <binaryOption key="dma_dsr_bcr_done" condition="dma_dsr_bcr_done_present"
      register="dsr_bcr"
      hidden="true"
      derived="true"
      typeName="DmaDone"
      baseType="uint32_t"
      toolTip="Indicates if the transfer has been completed\n
               Writing a 1 to this bit clears all DMA status bits and the BCR (byte count).\n
               This should be used in an ISR to clear the DMA interrupt and error bits"
      description="Transactions done" >
      <choice name="Transfer not complete"  value="0" enum="TransferNotComplete" />
      <choice name="Transfer complete"      value="1" enum="TransferComplete"    />
   </binaryOption >

   <!-- _____ DSR __________________ -->

   <binaryOption key="dma_dsr_ce" condition="dma_dsr_ce_present"
      hidden="true"
      typeName="DmaConfigError"
      baseType="uint8_t"
      description="Configuration error"
      toolTip="Indicates error detection in initial configuration" >
      <choice name="No configuration error"  value="0" enum="NoConfigurationError" />
      <choice name="Configuration error"     value="1" enum="ConfigurationError" />
   </binaryOption >

   <binaryOption key="dma_dsr_bes" condition="dma_dsr_bes_present"
      hidden="true"
      typeName="DmaSourceError"
      baseType="uint8_t"
      description="Bus error on source"
      toolTip="Indicates the DMA channel terminated with a bus error during the read portion of a transfer" >
      <choice name="No bus error"    value="0" enum="NoBusError" />
      <choice name="Read bus error"  value="1" enum="ReadBusError" />
   </binaryOption >

   <binaryOption key="dma_dsr_bed" condition="dma_dsr_bed_present"
      hidden="true"
      typeName="DmaDestinationError"
      baseType="uint8_t"
      description="Bus error on destination"
      toolTip="Indicates the DMA channel terminated with a bus error during the write portion of a transfer" >
      <choice name="No bus error"     value="0" enum="NoBusError" />
      <choice name="Write bus error"  value="1" enum="WriteBusError" />
   </binaryOption >

   <binaryOption key="dma_dsr_req" condition="dma_dsr_req_present"
      hidden="true"
      typeName="DmaRequestPending"
      baseType="uint8_t"
      description="Request pending"
      toolTip="Indicates a request is pending and channel has not been selected" >
      <choice name="No request pending"  value="0" enum="NoRequestPending" />
      <choice name="Request pending"     value="1" enum="RequestPending" />
   </binaryOption >

   <binaryOption key="dma_dsr_bsy" condition="dma_dsr_bsy_present"
      hidden="true"
      typeName="DmaBusy"
      baseType="uint8_t"
      description="Channel Busy"
      toolTip="Indicates the channel is busy.\n
               Cleared when the DMA has finished the last transaction\n
               Set the first time the channel is enabled after a transfer is initiated" >
      <choice name="Channel inactive"  value="0" enum="ChannelInactive" />
      <choice name="Channel is busy"   value="1" enum="ChannelIsBusy" />
   </binaryOption >

   <binaryOption key="dma_dsr_done" condition="dma_dsr_done_present"
      hidden="true"
      derived="true"
      typeName="DmaComplete"
      baseType="uint8_t"
      toolTip="Indicates if the transfer has been completed\n
               Writing a 1 to this bit clears all DMA status bits and the BCR (byte count).\n
               This should be used in an ISR to clear the DMA interrupt and error bits"
      description="Transactions done" >
      <choice name="Transfer not complete"  value="0" enum="TransferNotComplete"/>
      <choice name="Transfer complete"      value="1" enum="TransferComplete"/>
   </binaryOption >

   <!-- _____ DCR __________________ -->

   <binaryOption key="dma_dcr_eint" condition="dma_dcr_eint_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaActionOnComplete"
      baseType="uint32_t"
      toolTip="Determines action on completing a transfer\n
               or the occurrence of an error condition"
      description="Action on completion of transfer" >
      <choice name="No Action"  value="0" enum="NoAction"  />
      <choice name="Interrupt"  value="1" enum="Interrupt" />
   </binaryOption >

   <binaryOption key="dma_dcr_cs" condition="dma_dcr_cs_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaTransferMode"
      baseType="uint32_t"
      toolTip="Controls whether cycle-stealing is used or the DMA monopolises the bus until complete"
      description="Cycle steal" >
      <choice name="DMA is continuously"                     value="0" enum="Continuous"       />
      <choice name="Single read/write transfer per request"  value="1" enum="SinglePerRequest" />
   </binaryOption >

   <binaryOption key="dma_dcr_aa" condition="dma_dcr_aa_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaAutoAlign"
      baseType="uint32_t"
      toolTip="If enabled:\n
               If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned;\n
               otherwise, destination accesses are auto-aligned.\n
               Source alignment takes precedence over destination alignment.\n
               If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC"
      description="Auto-align" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled"  />
   </binaryOption >

   <binaryOption key="dma_dcr_eadreq" condition="dma_dcr_eadreq_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaAsynchronousRequest"
      baseType="uint32_t"
      toolTip="Enables the channel to support asynchronous data requests while the MCU is in Stop mode"
      description="Asynchronous requests" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled"  />
   </binaryOption >

   <title description="Channel Linking" />

   <choiceOption key="dma_dcr_linkcc" condition="dma_dcr_linkcc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaLinkAction"
      baseType="uint32_t"
      description="Control Linking action of channel"
      toolTip="Allows DMA channels to have their transfers linked.\n
               The current DMA channel triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the condition described by DmaLink bits.\n
               DmaLink_Both and DmaLink_CycleSteal only link to LCH1 when in cycle-steal transfer mode (DCRn[CS]=DmaMode_CycleSteal)." >
      <choice name="No linking"                                                            value="0" enum="None"       />
      <choice name="Link to LCH1 after cycle-steal transfer; Link to LCH2 after BCR zero"  value="1" enum="Both"       />
      <choice name="Link to LCH1 after cycle-steal transfer"                               value="2" enum="CycleSteal" />
      <choice name="Link to LCH1 after the BCR decrements to zero"                         value="3" enum="Complete"   />
   </choiceOption >

   <choiceOption key="dma_dcr_lch1" condition="dma_dcr_lch1_present"
      enabledBy="dma_dcr_linkcc>0"
      typeName="DmaLinkChannelSel1"
      baseType="uint32_t"
      description="Link channel 1"
      toolTip="This selects a channel to be used for linking" >
      <choice name="DMA Channel 0"  value="0" enum="Channel0" />
      <choice name="DMA Channel 1"  value="1" enum="Channel1" />
      <choice name="DMA Channel 2"  value="2" enum="Channel2" />
      <choice name="DMA Channel 3"  value="3" enum="Channel3" />
   </choiceOption >

   <choiceOption key="dma_dcr_lch2" condition="dma_dcr_lch2_present"
      enabledBy="dma_dcr_linkcc==1"
      typeName="DmaLinkChannelSel2"
      baseType="uint32_t"
      description="Link channel 2"
      toolTip="This selects a channel to be used for linking" >
      <choice name="DMA Channel 0"  value="0" enum="Channel0" />
      <choice name="DMA Channel 1"  value="1" enum="Channel1" />
      <choice name="DMA Channel 2"  value="2" enum="Channel2" />
      <choice name="DMA Channel 3"  value="3" enum="Channel3" />
   </choiceOption >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field           : set   : get   : clear : genCode                 : context                 : name"
        values="
         dma_sar_addr         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : SourceAddress;

         dma_dar_addr         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : DestinationAddress;

         dma_dsr_bcr_bcr      : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : ByteCount;

         dma_dsr_ce           : false : true  : false : enableGettersAndSetters : DMA[index].SAR       : ConfigErrorFlag;
         dma_dsr_bes          : false : true  : false : enableGettersAndSetters : DMA[index].SAR       : SourceErrorFlag;
         dma_dsr_bed          : false : true  : false : enableGettersAndSetters : DMA[index].SAR       : DestinationErrorFlag;
         dma_dsr_req          : false : true  : false : enableGettersAndSetters : DMA[index].SAR       : RequestFlag;
         dma_dsr_bsy          : false : true  : false : enableGettersAndSetters : DMA[index].SAR       : BusyFlag;
         dma_dsr_done         : false : true  : true  : enableGettersAndSetters : DMA[index].SAR       : CompletedFlag;

         dma_dcr_erq_start    : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : Mode;

         dma_dcr_eint         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : EnableInterrupt;
         dma_dcr_cs           : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : EnableCycleSteal;
         dma_dcr_aa           : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : EnableAutoAlign;
         dma_dcr_eadreq       : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : EnableAsynchronousRequests;
         dma_dcr_sinc         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : SourceIncrement;
         dma_dcr_ssize        : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : SourceSize;
         dma_dcr_dinc         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : DestinationIncrement;
         dma_dcr_dsize        : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : DestinationSize;
         dma_dcr_smod         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : SourceModulo;
         dma_dcr_dmod         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : DestinationModulo;
         dma_dcr_d_req        : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : CLearRequestonComplete;
         dma_dcr_linkcc       : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : LinkMode;
         dma_dcr_lch1         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : LinkChannel1;
         dma_dcr_lch2         : true  : true  : false : enableGettersAndSetters : DMA[index].SAR       : LinkChannel2" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(int index, %params) {
         \t   $(_basename)->%(context) = ($(_basename)->%(context) & ~%mask)|%paramExpression;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t * (%(field))
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)(int index) {
         \t   return %paramType($(_basename)->%(context)&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Clear %description
         \t * (%(field))
         \t */
         \tstatic void clear%(name)(int index) {
         \t   $(_basename)->%(context) = $(_basename)->%(context)|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!-- ____ Interrupt handling _____________ -->

   <variableTemplate codeGenCondition="irqHandlingMethod" variables="irq_enum" >
   <![CDATA[
      \t/**
      \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t *
      \t * @tparam %params %tooltip
      \t */
      \ttemplate<%params>
      \tstatic void irqHandler() {
      \t
      \t   const DmaChannelNum dmaChannel = DmaChannelNum(%paramName0);
      \t
      \t   // Clear interrupt flag
      \t   dma->DMA[dmaChannel].DSR = dma->DMA[dmaChannel].DSR &~ DMA_DSR_DONE_MASK;
      \t
      \t   // Execute call-back
      \t   sCallbacks[%paramName0]($(irq_call_parameters));
      \t}
      \t\n
   ]]>
   </variableTemplate>

   <!-- ________ DMA Init class ____________________________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_Baseclass) channel
      \t *
      \t * This class has a templated constructor that accepts various values.  <br>
      \t * Parameters available may vary with device - see $(_Class)::ExampleValue for relevant example.  <br>
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.  <br>
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(uint32_t status) {
      \t *    (void) status;
      \t * }
      \t *
      \t * Transfer Control
      \t * @verbatim
      \t * +------------------------------+  DMA mode
      \t * | Loop =                       |  ===============================================================
      \t * | +--------------------------+ |
      \t * | | Each transfer            | |  The following are used during a loop:
      \t * | |   mem[SADDR]->mem[DADDR] | |   - SADDR      Source address
      \t * | |   SADDR += DCR.SSIZE     | |   - DCR.SSIZE  Adjustment applied to SADDR after each transfer
      \t * | |   DADDR += DCR.DSIZE     | |   - DADDR      Destination address
      \t * | +--------------------------+ |   - DCR.DSIZE  Adjustment applied to DADDR after each transfer
      \t * |   Total transfer is BCR      |   - BCR        Number of bytes to transfer
      \t * +------------------------------+
      \t * @endverbatim
      \t *
      \t * static const uint8_t source[] = {1,2,3,4,5,6};
      \t * static uint8_t destination[]  = {1,2,3,4,5,6};
      \t *
      \t * static const Dma0::Init initValue = {
      \t *    DmaChannelNum_0 ,                               // (DmaChannelNum) DMA channel number - DMA channel 0
      \t *    DmaByteCount(sizeof(source)) ,                  // (dma_dsr_bcr_bcr) Byte Count
      \t *    DmaMode_Immediate,
      \t *
      \t *    // Source
      \t *    DmaSourceAddress(intptr_t(source)) ,            // (dma_sar_addr) Source Address
      \t *    dmaSourceSize(source[0]) ,                      // (dma_dcr_ssize) Source size
      \t *    DmaSourceModulo_Disabled ,                      // (dma_dcr_smod) Source address modulo - Buffer disabled
      \t *    DmaSourceIncrement_IncrementBySize ,            // (dma_dcr_sinc) Source increment - Increment
      \t *
      \t *    // Destination
      \t *    DmaDestinationAddress(intptr_t(destination)) ,  // (dma_dar_addr) Destination Address
      \t *    dmaDestinationSize(destination[0]) ,            // (dma_dcr_dsize) Destination size
      \t *    DmaDestinationModulo_Disabled ,                 // (dma_dcr_dmod) Destination address modulo - Buffer disabled
      \t *    DmaSourceIncrement_IncrementBySize ,            // (dma_dcr_dinc) Destination increment - Increment
      \t *
      \t *    // Options
      \t *    DmaTransferMode_Continuous ,                    // (dma_dcr_cs) Cycle steal - DMA is continuously
      \t *    DmaAutoAlign_Disabled ,                         // (dma_dcr_aa) Auto-align - Disabled
      \t *    DmaAsynchronousRequest_Disabled ,               // (dma_dcr_eadreq) Enable asynchronous DMA requests - Disabled
      \t *    DmaModeOnComplete_Disabled ,                    // (dma_dcr_d_req) Disable request on completion - ERQ cleared
      \t *    DmaActionOnComplete_Interrupt ,                 // (dma_dcr_eint) Enable interrupt on completion of transfer - Interrupt enabled
      \t *
      \t *    // Linking
      \t *    DmaLinkAction_None ,                            // (dma_dcr_linkcc) Control Linking action of channel - No linking
      \t *    DmaLinkChannelSel1_Channel0 ,                   // (dma_dcr_lch1) Link channel 1 - DMA Channel 0
      \t *    DmaLinkChannelSel2_Channel0,                    // (dma_dcr_lch2) Link channel 2 - DMA Channel 0
      \t *
      \t *    $(_name)Callback,                // Call-back to execute on event - call-back function name
      \t *    NvicPriority_Low,                // Priority for interrupt - Low
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure(initValue)
      \t   $(_Class)::waitUntilComplete(initValue.dmaChannelNum);
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ Init class Member variables ________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="DmaChannelNum"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %paramType %paramName = DmaChannelNum_None;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <for keys=" type        : variables                                            : init    "
       values="%baseType   : dma_sar_addr                                         :   0      ;
               %baseType   : dma_dar_addr                                         :   0      ;
               %baseType   : dma_dsr_bcr_bcr                                      :   0      ;
               %baseType   : dma_dcr_eint,dma_dcr_erq,dma_dcr_cs,dma_dcr_aa,
                             dma_dcr_eadreq,dma_dcr_sinc,dma_dcr_ssize,
                             dma_dcr_dinc,dma_dcr_dsize,dma_dcr_start,
                             dma_dcr_smod,dma_dcr_dmod,dma_dcr_d_req,dma_dcr_linkcc,
                             dma_dcr_lch1,dma_dcr_lch2                            :   0      " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="/PCR/nvic_irqLevel,irqLevel"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %paramType %registerName0 = %defaultValue;
      \t\n
   ]]></variableTemplate>

   <!-- ____ Init class Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="DmaChannelNum"
      linePadding="xxx" >
   <![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName = %paramExpression;
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <for keys="r"
      values="
            dma_dsr_bcr_bcr;

            dma_sar_addr;
            dma_dcr_ssize;
            dma_dcr_smod;
            dma_dcr_sinc;

            dma_dar_addr;
            dma_dcr_dsize;
            dma_dcr_dmod;
            dma_dcr_dinc;

            dma_dcr_cs;
            dma_dcr_aa;
            dma_dcr_eadreq;
            dma_dcr_erq_start;
            dma_dcr_d_req;
            dma_dcr_eint;

            dma_dcr_linkcc;
            dma_dcr_lch1;
            dma_dcr_lch2" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <!-- ____ Init class Configure method ____ -->

   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t   // Configure call-backs
      \t   setCallback(IrqNum(init.dmaChannelNum), init.callbackFunction);
      \t   enableNvicInterrupts(IrqNum(init.dmaChannelNum), init.irqlevel);
      \t\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values=" dma_dsr_bcr_done,dma_dsr_bcr_bcr                       : dma->DMA[init.dmaChannelNum].DSR_BCR = init.dsr_bcr|DMA_DSR_BCR_DONE_MASK ;
               dma_sar_addr                                           : dma->DMA[init.dmaChannelNum].SAR     = init.sar ;
               dma_dar_addr                                           : dma->DMA[init.dmaChannelNum].DAR     = init.dar ;
               dma_dcr_eint,dma_dcr_erq,dma_dcr_cs,dma_dcr_aa,
               dma_dcr_eadreq,dma_dcr_sinc,dma_dcr_ssize,
               dma_dcr_dinc,dma_dcr_dsize,dma_dcr_start,
               dma_dcr_smod,dma_dcr_dmod,dma_dcr_d_req,dma_dcr_linkcc,
               dma_dcr_lch1,dma_dcr_lch2                              : dma->DMA[init.dmaChannelNum].DCR = init.dcr " >
      <variableTemplate codeGenCondition="enablePeripheralSupport"
      variables="%(var)"
      linePadding="xxx"
      ><![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            DmaChannelNum,

            dma_dsr_bcr_bcr,

            dma_sar_addr,
            dma_dcr_ssize,
            dma_dcr_smod,
            dma_dcr_sinc,

            dma_dar_addr,
            dma_dcr_dsize,
            dma_dcr_dmod,
            dma_dcr_dinc,

            dma_dcr_cs,
            dma_dcr_aa,
            dma_dcr_eadreq,
            dma_dcr_erq_start,
            dma_dcr_d_req,
            dma_dcr_eint,

            dma_dcr_linkcc,
            dma_dcr_lch1,
            dma_dcr_lch2
         "
   ><![CDATA[
      \t/**
      \t * Example initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init ExampleValue = {%initExpression
      \t};
      \t\n
   ]]>
   </variableTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

   <!-- ____ Common __________________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Baseclass)_T<$(_Info)> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="dma_files" >
      <copy source="Project_Headers/dma-MKL.h"                    target="Project_Headers/dma.h"                        overwrite="always"  derived="true" />
      <copy source="Snippets/dma-memory-example-mkl.cpp"          target="Snippets/dma-memory-example-mkl.cpp"          overwrite="always"  derived="true" />
      <copy source="Snippets/dma-memory-template-example-mkl.cpp" target="Snippets/dma-memory-template-example-mkl.cpp" overwrite="always"  derived="true" />
      <copy source="Snippets/dma-uart-example-mkl25.cpp"          target="Snippets/dma-uart-example-mkl25.cpp"          overwrite="always"  derived="true" />
   </projectActionList>

   <!-- ____ Startup __________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "../Project_Headers/$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration __________________ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

</peripheralPage>

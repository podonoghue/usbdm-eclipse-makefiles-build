<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- vref_def.xml -->
<!--
Devices using this peripheral: 
-->
<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="VREF">

   <xi:include href="_default_instance.xml"/>

   <template><![CDATA[
      \t//! Pin number in Info table for VREF output if mapped to a pin
      \tstatic constexpr int outputPin  = 0;\n\n
   ]]></template>
   
   <constant key="disable_peripheral"  value = "vref->SC = 0;"  />
   <xi:include href="_mapPinsOption.xml"/>   

   <binaryOption key="vref_sc_vrefen" condition="vref_sc_vrefen_present"
      enumStem="VrefEnable"
      description="Internal Voltage Reference enable"
      toolTip="This controls the bandgap reference within the Voltage Reference module">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="vref_trm_chopen" condition="vref_trm_chopen_present" 
      enabledBy="vref_sc_vrefen"
      enumStem="VrefChop"
      description="Chop oscillator enable"
      toolTip="Controls the internal chopping operation to minimise the internal analogue offset\n
               This option is enabled during factory trimming of the VREF voltage.\n
               This should be enabled to achieve the performance stated in the data sheet.\n
               If the chop oscillator is to be used in very low power modes, the system (bandgap)\n
               voltage reference must also be enabled. See PmcBandgapLowPowerEnable">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="vref_sc_regen" condition="vref_sc_regen_present"
      enabledBy="vref_sc_vrefen"
      enumStem="VrefReg"
      description="Regulator enable"
      toolTip="This controls the internal 1.75 V regulator which produce a constant\n
         internal voltage supply in order to reduce the sensitivity to external supply noise and variation\n
         If it is desired to keep the regulator enabled in very low power modes see PmcBandgapLowPowerEnable">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled"  isDefault="true" />
   </binaryOption>

   <binaryOption key="vref_sc_icompen" condition="vref_sc_icompen_present"
      enabledBy="vref_sc_vrefen"
      enumStem="VrefIcomp"
      description="Second order curvature compensation enable"
      toolTip="This should be enabled to achieve the performance stated in the data sheet">
      <choice value="0" name="Disabled" enum="Disabled" />
      <choice value="1" name="Enabled"  enum="Enabled" isDefault="true" />
   </binaryOption>

   <choiceOption key="vref_sc_mode_lv" 
      enabledBy="vref_sc_vrefen"
      enumStem="VrefBuffer"
      description="Buffer Mode selection"
      toolTip="This selects the buffer modes for the Voltage Reference module">
      <choice value="0" name="Bandgap on only, for stabilisation and startup" enum="Bandgap"    />
      <choice value="1" name="High power buffer mode enabled"                 enum="HighPower"  isDefault="true" />
      <choice value="2" name="Low-power buffer mode enabled"                  enum="LowPower"   />
   </choiceOption>

<!--  ========== VREF Init class =============================== -->

   <template key="init_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of the VREF
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Vref$(_instance)::Init vrefInit {
      \t      VrefEnable_Enabled ,   // Internal Voltage Reference enable
      \t      VrefChop_Enabled ,     // Chop oscillator enable
      \t      VrefReg_Enabled ,      // Regulator enable
      \t      VrefIcomp_Enabled ,    // Second order curvature compensation enable
      \t      VrefBuffer_HighPower,  // Buffer Mode selection
      \t * };
      \t *
      \t * // Initialise VREF from values specified above
      \t * Vref$(_instance)::configure(vrefInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" ><![CDATA[
      class $(_class)BasicInfo {
      \t
      public:
      \t
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**                               
      \t    * Copy Constructor                  
      \t    */                             
      \t   constexpr Init(const Init &other) = delete;
      \t   
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>
   
<!--  Member variables -->
  
   <initialValueTemplate namespace="usbdm" 
      variables="
         vref_trm_chopen"
   ><![CDATA[
      \t   ///  Voltage Reference Trim Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate namespace="usbdm" 
      variables="
         vref_sc_regen"
   ><![CDATA[
      \t   ///  Voltage Reference Status and Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>
   
<!--  Configure method -->
  
   <setTemplate  key="/VREF/InitMethod" namespace="all"  discardRepeats="true"
      variables="vref_sc_regen, vref_trm_chopen" 
   ><![CDATA[
      \t/**
      \t * Configure VREF from values specified in init
      \t
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t   
      \t   enable();
      \t
      \t   %register1 = (%register1&~%mask1)|init.%registerName1;
      \t   %register0 = init.%registerName0 & ~%mask0;
      \t   
      \t   // Regulator must be enabled >300ns after other settings
      \t   waitUS(1);
      \t   %register0 = init.%registerName0;
      \t
      \t   while ((vref->SC & VREF_SC_VREFST_MASK) == 0) {
      \t      // Wait until stable
      \t   }
      \t}\n\n
   ]]></setTemplate>

   <setTemplate  key="/VREF/InitMethod" namespace="all"  discardRepeats="true"
      variables="vref_sc_regen, vref_trm_chopen" 
   ><![CDATA[
      \t/**
      \t * Configure VREF with default settings
      \t */
      \tstatic void defaultConfigure() {
      \t   
      \t   configure(Info::DefaultInitValue);
      \t}\n\n
   ]]></setTemplate>

   <setTemplate key="/VREF/InitMethod" discardRepeats="true" namespace="all" 
      variables="
         vref_sc_mode_lv,
         vref_sc_regen,
         vref_sc_icompen,
         vref_trm_chopen
         "
   ><![CDATA[ 
      \t/**
      \t * Configure VREF from values specified
      \t *
      %paramDescription
      \t */
      \tstatic void configure(
      %params) {\n\n
      \t   enable();\n
   ]]></setTemplate>
   <setTemplate key="/VREF/InitMethod" discardRepeats="true" namespace="all" 
      condition="vref_sc_regen&amp;&amp;vref_trm_chopen"
      variables="vref_sc_regen,vref_trm_chopen"
   ><![CDATA[
      \t 
      \t   if (%enumParam0) {
      \t      // Chop must be enabled if regulator enabled
      \t      %enumParam1 = %enumClass1_Enabled;
      \t   }\n
   ]]></setTemplate>
   <setTemplate key="/VREF/InitMethod" discardRepeats="true" namespace="all" 
      variables="vref_trm_chopen"
   ><![CDATA[ 
      \t   %register = (%register&~%mask)|%enumParam0;\n
   ]]></setTemplate>
   <setTemplate key="/VREF/InitMethod" discardRepeats="true" namespace="all" 
      variables="
         vref_sc_mode_lv,
         vref_sc_icompen"
   ><![CDATA[
      \t   %register = %paramExpression;
      \t\n
   ]]></setTemplate>
   <setTemplate key="/VREF/InitMethod" discardRepeats="true" namespace="all" 
      variables="
         vref_sc_mode_lv,
         vref_sc_regen,
         vref_sc_icompen"
   ><![CDATA[ 
      \t   // Regulator must be enabled >300ns after other settings
      \t   waitUS(1);
      \t   %register = %paramExpression;
      \t
      \t   while ((vref->SC & VREF_SC_VREFST_MASK) == 0) {
      \t      // Wait until stable
      \t   }
      \t}\n\n
   ]]></setTemplate>

<!--  Constructors -->
  
   <setTemplate namespace="usbdm"  
      variables="vref_sc_regen"
      linePadding="xxx" 
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %comments
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t\n
   ]]></setTemplate>
   <if condition="vref_sc_regen&amp;&amp;vref_trm_chopen">
      <setTemplate namespace="usbdm"  
         variables="vref_sc_regen, vref_trm_chopen"
         linePadding="xxx" 
      ><![CDATA[
         \t      if (%enumParam0) {
         \t         // Chop must be enabled as well
         \t         %registerName1 |= %enumClass1_Enabled;
         \t      }
         \t\n
      ]]></setTemplate>
   </if>
   <setTemplate namespace="usbdm"  
      variables="vref_sc_regen"
      linePadding="xxx" 
   ><![CDATA[      
      \t      %registerName = (%registerName&%mask) | %paramExpression;
      \t   }
      \t\n
   ]]></setTemplate>
   
   <for keys="r" values="
         vref_trm_chopen;
         vref_sc_vrefen;
         vref_sc_icompen;
         vref_sc_mode_lv">
      <setTemplate  namespace="usbdm" variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName = (%registerName&%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></setTemplate>
   </for>
      
   <template namespace="usbdm" ><![CDATA[
      \t};\n\n
   ]]></template>

   <template namespace="usbdm" ><![CDATA[
      };\n\n
   ]]></template>

<!--  Default Initialisation value -->
  
   <initialValueTemplate
      separator=","
      terminator=","     
      variables="
         vref_trm_chopen,
         vref_sc_vrefen,
         vref_sc_regen,
         vref_sc_icompen,
         vref_sc_mode_lv"     
   ><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * Default initialisation value for Vref$(_instance)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <!--  ********************* MISC ********************* -->

   <validate class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" />
   
   <template key="/VREF/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_name)
   \t */
   \tclass $(_class) : public $(_base_class)Base_T<$(_class)Info> {};\n
   ]]></template>

   <projectActionList id = "vref_files">
      <copy source="Project_Headers/vref.h"  target="Project_Headers/vref.h"  overwrite="true"  derived="true" />
   </projectActionList>
         
   <xi:include href="_clockOption.xml"/>

   <signals/>
</peripheralPage>

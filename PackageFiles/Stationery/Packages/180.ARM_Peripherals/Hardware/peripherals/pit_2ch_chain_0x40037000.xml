<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- pit_2ch_chain_0x40037000.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Periodic Interrupt Timer (2 channels)" >

   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"          />
   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"  />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"  />
   <constant key="irq_pattern"              type="String"  value="&quot;^%b(\d+)$&quot;"                           />
   <constant key="irq_ClassHandler"         type="String"  value="&quot;%c%i::Channel&lt;$1&gt;::irqHandler&quot;" />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="false" />
   <xi:include href="_enablePeripheral.xml" />
   <title />

   <constant key="numChannels" value="2" type="Long" />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2                    (fProvider.getName())
    *  $(_Baseclass)    => e.g FTM0 => Ftm             (fPeripheral.getClassBaseName())
    *  $(_instance)     => e.g FTM0 => 0, PTA => A     (fPeripheral.getInstance())
    *  $(_Class)        => e.g FTM2 => Ftm2            (fPeripheral.getClassName())
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT  (fPeripheral.getBaseName())
-->

<!--
    * Template substitutions
    *
    * %valueExpression[index]         Formatted value as numeric e.g. 0x12
    * %symbolicValueExpression[index] Symbolic formatted value e.g. AdcCompare_Disabled
    * %variable[index]                Variable name /ADC0/adc_sc2_acfe
    * %macro[index](value)            C register macro e.g. ADC_SC2_ACFGT(value)
    * %description[index]             Description from controlVar e.g. Compare Function Enable
    * %shortDescription[index]        Short description from controlVar e.g. Compare Function Enable
    * %tooltip[index]                 Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * %paramDescription[index]        Tool-tip from controlVar formatted as param description @param ...
    * %params                         Formatted parameter list for function
    * %paramType[index]               Based on enumStem or typename e.g. AdcCompare (or uint32_t)
    * %paramName[index]               Based on enumStem with lower-case first letter adcCompare
    * %enumClass[index]               As for %paramType
    * %enumParam[index]               As for %paramName
    * %valueExpression                Numeric variable value e.g. 0x3
    * %symbolicValueExpression        Symbolic variable value e.g. AdcCompare_Disabled
    * %defaultClockExpression         Based on variable etc. Similar to %register = (%register&~%mask) | %paramName;
    * %defaultMaskingExpression       Based on variable etc. Similar to (%register&%mask)
    * %variable[index]                Variable name from condition
    * %mask[index]                    From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * %register[index]                Register associated with variable e.g. adc->APCTL1
    * %registerName[index]            Name of corresponding register (lowercase for Init()) e.g. apctl1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Baseclass)BasicInfo&quot;" />

   <template><![CDATA[
      \t//! Number of PIT channels
      \tstatic constexpr uint32_t NumChannels  = $(numChannels);\n\n
   ]]></template>

   <binaryOption key="secondsSupport"
      enabledBy="enablePeripheralSupport"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point libraries is necessary to support routines using seconds in runtime code.\n
               This is seldom needed and the overhead can be avoided by disabling this option" >
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <choiceOption key="pit_channelNumber"
      hidden="true"
      description="Pit Channel Number"
      enumStem="PitChannelNum"
      valueFormat="%s"
      enumType="uint8_t"
      toolTip="Selected PIT channel" >
      <choice value="0"          name="Channel 0"     enum="0" />
      <choice value="1"          name="Channel 1"     enum="1" />
      <choice value="2"          name="Channel 2"     enum="2" />
      <choice value="3"          name="Channel 3"     enum="3" />
      <choice value="0b10000000" name="Channel Not Allocated"  enum="None" />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="pitInputClock"
      enabledBy="enablePeripheralSupport"
      constant="true"
      derived="true"
      description="PIT input clock"
      toolTip="The PIT uses the bus clock for timing.\n
               The frequency shown is based on the selected clock configuration.\n
               This frequency is used as the basis for calculations on this page."
      units="Hz"
      />

   <binaryOption key="pit_mcr_mdis" condition="pit_mcr_mdis_present"  enabledBy="enablePeripheralSupport"
      hidden="true"
      enumStem="PitMcrMdis"
      toolTip="Disabled PIT module clock"
      description="Module Disable" >
      <choice name="Clock enabled"   value="0" enum="ClockEnabled" isDefault="true" />
      <choice name="Clock disabled"  value="1" enum="ClockDisabled"  />
   </binaryOption>

   <binaryOption key="pit_mcr_frz" condition="pit_mcr_frz_present"  enabledBy="enablePeripheralSupport"
      enumStem="PitDebugMode"
      description="Freeze in Debug"
      toolTip="Determines if timers are stopped in Debug mode" >
      <choice name="Timers run in Debug"   value="0" enum="Run"    />
      <choice name="Timers stop in Debug"  value="1" enum="Freeze" isDefault="true" />
   </binaryOption>

   <for keys="ch" dim="numChannels" >
      <title description="Channel %(ch)" />

      <binaryOption key="pit_tctrl_ten[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="enablePeripheralSupport"
         enumStem="PitChannelEnable"
         description="Timer Channel Enable"
         toolTip="Allows operation of this channel" >
         <choice value="0" name="Channel disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Channel enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_ldval_tsv[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Ticks &amp;"
         units="ticks"
         description="Reload value channel %(ch)"
         toolTip="Value loaded in timer register on roll-over"
         min="0" max="0xFFFFFFFF" />

      <floatOption key="pit_period[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Seconds &amp;"
         valueFormat="%s_s"
         description="Default period of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1m" min="0" units="s" />

      <floatOption key="pit_frequency[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Hertz"
         valueFormat="%s_Hz"
         description="Default frequency of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1k" min="0" units="Hz" />

      <binaryOption key="pit_tctrl_chn[%(ch)]"  condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         enabledBy="pit_tctrl_ten[%(ch)]"
         enumStem="PitChannelChain"
         description="Chain with previous channel"
         toolTip="Controls whether the timer channels are chained to create a larger counter" >
         <choice value="0" name="Timers are not chained" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Timers are chained"     enum="Enabled"  />
      </binaryOption>

      <binaryOption key="pit_tctrl_tie[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="pit_tctrl_ten[%(ch)] &amp;&amp;irqHandlingMethod"
         enumStem="PitChannelIrq"
         description="Timer Interrupt Enable"
         toolTip="Allows interrupts from this channel" >
         <choice value="0" name="Interrupts are disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Interrupts are enabled"  enum="Enabled"  />
      </binaryOption>
   </for>

<!-- Graphic here -->

   <for keys="field:name"
        values="
      pit_mcr_mdis:McrMdis;
      pit_mcr_frz:McrFrz" >
      <setTemplate variables="%(field)" codeGenCondition="enablePeripheralSupport"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void configure%(name)(%params) {
         \t   %defaultFieldExpression
         \t}\n\n
      ]]></setTemplate>
   </for>

<!--   ========== static/member functions =============================== -->

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : staticFunctions ;
                     : const : chan    : memberFunctions" >
      <template key="%(location)" namespace="all" codeGenCondition="enablePeripheralSupport" >
      <![CDATA[
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in timer ticks (usually bus clock)
         \t    *  @param[in]  pitChannelIrq     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Ticks             interval,
         \t         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelIrq);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in seconds
         \t    *  @param[in]  pitChannelIrq     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Seconds           interval,
         \t         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelIrq);
         \t   }
         #endif
         \t
         \t   /**
         \t    *  Enables and configures the PIT if not already done.
         \t    *  This also disables all channel interrupts and channel reservations if newly configured.
         \t    *
         \t    *  @param[in]  pitDebugMode  Determined whether the PIT halts when suspended during debug
         \t    */
         \t   %(static) void  configureIfNeeded(PitDebugMode pitDebugMode=PitDebugMode_Freeze) %(const) {
         \t      PitBase_T<Info>::configureIfNeeded(pitDebugMode);
         \t   }
         \t
         \t   /**
         \t    *   Enable the PIT channel
         \t    */
         \t   %(static) void enable() %(const) {
         \t      PitBase_T<Info>::enableChannel(%(chan));
         \t   }
         \t
         \t   /**
         \t    *   Disable the PIT channel
         \t    */
         \t   %(static) void disable() %(const) {
         \t      PitBase_T<Info>::disableChannel(%(chan));
         \t   }
         \t
         \t   /**
         \t    * Enable/disable channel interrupts.
         \t    *
         \t    * @param[in]  enable  True => enable, False => disable
         \t    *
         \t    * @note It is also necessary to modify NVIC using enableNvicInterrupts().
         \t    */
         \t   %(static) void enableInterrupts(bool enable=true) %(const) {
         \t      PitBase_T<Info>::enableInterrupts(%(chan), enable);
         \t   }
         \t
         \t   /**
         \t    * Enable interrupts in NVIC
         \t    */
         \t   %(static) void enableNvicInterrupts() %(const) {
         \t      PitBase_T<Info>::enableNvicInterrupts(%(chan));
         \t   }
         \t
         \t   /**
         \t    * Enable and set priority of interrupts in NVIC
         \t    * Any pending NVIC interrupts are first cleared.
         \t    *
         \t    * @param[in]  nvicPriority  Interrupt priority
         \t    */
         \t   %(static) void enableNvicInterrupts(NvicPriority nvicPriority) %(const) {
         \t      PitBase_T<Info>::enableNvicInterrupts(%(chan), nvicPriority);
         \t   }
         \t
         \t   /**
         \t    * Disable interrupts in NVIC
         \t    */
         \t   %(static) void disableNvicInterrupts() %(const) {
         \t      PitBase_T<Info>::disableNvicInterrupts(%(chan));
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set period in seconds
         \t    *
         \t    * @param[in]  interval Interval in seconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Seconds interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         #endif
         \t
         \t   /**
         \t    * Set period in ticks
         \t    *
         \t    * @param[in]  interval Interval in ticks
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Ticks interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         \t
         \t   /**
         \t    * Set period in microseconds
         \t    *
         \t    * @param[in]  microseconds Interval in microseconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriodInMicroseconds(uint32_t microseconds) %(const) {
         \t      unsigned long interval = ((unsigned long)microseconds*Info::getClockFrequency())/1000000;
         \t      usbdm_assert(interval<0xFFFFFFFFUL,"Interval too long");
         \t      PitBase_T<Info>::setPeriod(%(chan), Ticks((unsigned)microseconds));
         \t   }
         \t
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Ticks interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in seconds
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Seconds interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         #endif
         \t\n
      ]]>
      </template>
   </for>

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : staticFunctions ;
                     : const : chan    : memberFunctions" >
      <template key="%(location)" namespace="all" codeGenCondition="irqHandlingMethod" >
      <![CDATA[
         \t   /**
         \t    * Set callback on event
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout
         \t    */
         \t   %(static) void setCallback(CallbackFunction callback) %(const) {
         \t      PitBase_T<Info>::setCallback(%(chan), callback);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set one-shot timer callback.
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  interval          Interval in seconds until callback is executed
         \t    */
         \t   %(static) void  oneShot(CallbackFunction callback, Seconds interval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, interval);
         \t   }
         #endif
         \t
         \t   /**
         \t    * Set one-shot timer callback in microseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  microseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMicroseconds(CallbackFunction callback, uint32_t microseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMicroseconds(%(chan), callback, microseconds);
         \t   }
         \t
         \t   /**
         \t    * Set one-shot timer callback in milliseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  milliseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMilliseconds(CallbackFunction callback, uint32_t milliseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMilliseconds(%(chan), callback, milliseconds);
         \t   }
         \t
         \t   /**
         \t    * Set one-shot timer callback
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
         \t    */
         \t   %(static) void oneShot(CallbackFunction callback, Ticks tickInterval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, tickInterval);
         \t   }\n
         ]]>
      </template>
   </for>

<!--   ========== PIT ChannelInit class =============================== -->

   <template key="init_description" namespace="all" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Class)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init init {
      \t *
      \t *   // Setup values
      \t *   PitMcrMdis_ClockEnabled                   // Module Disable,
      \t *   PitMcrFrz_TimersRunInDebug                // Freeze,
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure(init)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template key="pitchannelinit_description" namespace="all" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_Class) channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_Class) channel
      \t * // Parameters available may vary with device - see $(_Class)::DefaultChannelInitValues[] for relevant example
      \t * static const Pit::ChannelInit pitInit {
      \t *       PitChannelNum_0,
      \t *
      \t *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      \t *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      \t *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
      \t *       callBackFunction,          // Call-back function to use
      \t *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
      \t *       3999_ticks,                // Reload value for channel (in ticks or seconds)
      \t *
      \t *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
      \t *                                            This becomes a base value modified by earlier values.
      \t * };
      \t *
      \t * // Initialise PIT channel from values specified above
      \t * Pit::configure(pitInit)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm" >
   <![CDATA[
      class $(_Baseclass)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t\n
   ]]>
   </template>

   <template namespace="all" key="protectedMethods" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t *  Enables and configures the PIT if not already done.
      \t *  This also disables all channel interrupts and channel reservations if newly configured.
      \t *
      \t *  @param[in]  pitDebugMode  Determined whether the PIT halts when suspended during debug
      \t */
      \tstatic void configureIfNeeded(PitDebugMode pitDebugMode=PitDebugMode_Freeze) {
      \t   enable();
      \t   // Check if disabled and configure if so
      \t   if ((pit->MCR & PIT_MCR_MDIS_MASK) != 0) {
      \t      configure(pitDebugMode);
      \t   }
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="all" key="protectedMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Class) interrupt call back.
      \t */
      \ttypedef $(_Class)BasicInfo::CallbackFunction CallbackFunction;
      \t
      \t/** Callback functions for ISRs */
      \tstatic CallbackFunction sCallbacks[Info::NumChannels];
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="all" key="publicMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t *  @param[in]  pitChannelNum   Channel to configure
      \t *  @param[in]  callback        Callback function to be executed on interrupt.
      \t *                              Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(PitChannelNum pitChannelNum, CallbackFunction callback) {
      \t
      \t   if (callback == nullptr) {
      \t      callback = unhandledCallback;
      \t   }
      \t   sCallbacks[pitChannelNum] = callback;
      \t}
      \t\n
   ]]>
   </template>

   <template discardRepeats="true" key="staticDefinitions" namespace="all"  codeGenCondition="irqHandlingMethod" ><![CDATA[
      /**
       * Callback table for programmatically set handlers
       */
      template<class Info>
      typename PitBase_T<Info>::CallbackFunction PitBase_T<Info>::sCallbacks[] = {\n
   ]]></template>
   <for keys="ch" dim="numChannels" >
      <template discardRepeats="true" key="staticDefinitions" namespace="all"  codeGenCondition="irqHandlingMethod" ><![CDATA[
         \tPitBase_T<Info>::unhandledCallback,\n
      ]]></template>
   </for>
   <template discardRepeats="true" key="staticDefinitions" namespace="all"  codeGenCondition="irqHandlingMethod" ><![CDATA[
      };\n\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      $(pitchannelinit_description)
      \tclass ChannelInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]>
   </template>

<!--   Member variables -->

   <setTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pit_ldval_tsv[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="secondsSupport"
      variables="pit_period[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_s;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pit_tctrl_ten[],pit_tctrl_chn[],pit_tctrl_tie[]"
   ><![CDATA[
      \t   /// Timer Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName0 = %symbolicValueExpression1;
      \t\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pit_channelNumber"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = PitChannelNum_None;\n\n
   ]]></initialValueTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true"
      codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t *  Enables and configures the PIT.
      \t *  This also disables all channel interrupts and channel reservations.
      \t *
      \t *  @param[in]  pitDebugMode  Determined whether the PIT halts when suspended during debug
      \t */
      \tstatic void configure(PitDebugMode pitDebugMode) {
      \t   enable();
      \t   for (PitChannelNum pitChannelNum = PitChannelNum_0;
      \t         pitChannelNum < Info::NumChannels;
      \t         pitChannelNum = pitChannelNum+1U) {
      \t      //sCallbacks[pitChannelNum] = unhandledCallback; // todo
      \t      disableNvicInterrupts(pitChannelNum);
      \t   }
      \t   pit->MCR = pitDebugMode|PIT_MCR_MDIS(0); // MDIS cleared => enabled!
      \t   allocatedChannels = -1;
      \t}
      \t
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t   configure(PitDebugMode_Freeze);
      \t}
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true"
             codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure $(_BASENAME) channel from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::ChannelInit &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   // Configure PIT
      \t   pit->MCR = Info::mcr;
      \t
      \t   // Disable channel
      \t   pit->CHANNEL[init.channelnumber].TCTRL = 0;
      \t
      \t   Ticks ldval = init.ldval;
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true"
             codeGenCondition="secondsSupport" ><![CDATA[
      \t   if (init.period != 0) {
      \t      ldval = Ticks(convertSecondsToTicks(init.period)-1);
      \t   }\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true"
             codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   pit->CHANNEL[init.channelnumber].LDVAL = ldval;
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true"
             codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t   setCallback(init.channelnumber, init.callbackFunction);
      \t   enableNvicInterrupts(init.channelnumber, init.irqlevel);
      \t\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/InitMethod" namespace="all"
             codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Configure channel
      \t   pit->CHANNEL[init.channelnumber].TCTRL = init.tctrl;
      \t}
      \t
      \t/**
      \t * Configure multiple PIT channels
      \t *
      \t * @tparam N   Number of channels (deduced)
      \t *
      \t * @param ar   Array of channel-init structures
      \t */
      \ttemplate<int N>
      \tstatic void configure(const typename Info::ChannelInit (&ar)[N]) {
      \t   for (int i=0; i<N; i++) {
      \t      configure(ar[i]);
      \t   }
      \t}\n\n
   ]]></template>

<!--   Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <constructorTemplate namespace="usbdm"  codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="pit_channelNumber;pit_ldval_tsv[]" >
      <constructorTemplate namespace="usbdm"  codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm"  codeGenCondition="secondsSupport"
      variables="pit_period[]"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="pit_tctrl_ten[];pit_tctrl_tie[];pit_tctrl_chn[1]" >
      <constructorTemplate namespace="usbdm"  codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </constructorTemplate>
   </for>

<!--   Default Initialisation value -->

   <setTemplate  codeGenCondition="enablePeripheralSupport"
      variables="pit_mcr_frz"
   ><![CDATA[
      \t/// %description
      \tstatic constexpr uint32_t %registerName = %initExpression; \n\n
   ]]></setTemplate>

   <template  codeGenCondition="irqHandlingMethod"
   ><![CDATA[
      \t/**
      \t * $(_Class) interrupt call back
      \t */
      \ttypedef $(_Class)BasicInfo::CallbackFunction CallbackFunction;
      \t
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Default initialisation values for PIT channels
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
   ]]></template>

   <for keys="ch" dim="numChannels" >
      <setTemplate  codeGenCondition="enablePeripheralSupport"
         separator=","
         terminator=","
         variables="
            pit_tctrl_ten[%(ch)],
            pit_tctrl_chn[%(ch)],
            pit_tctrl_tie[%(ch)],
            pit_ldval_tsv[%(ch)]"
         >
      <![CDATA[
         \t   {
         \t   PitChannelNum_%(ch),
         %initExpression
         \t   },\n
      ]]></setTemplate>
   </for>

   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t}; // DefaultChannelInitValues\n\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t};// $(_Baseclass)BasicInfo::ChannelInit\n\n
   ]]>
   </template>

   <template namespace="usbdm" >
   <![CDATA[
      }; // $(_Baseclass)BasicInfo\n\n
   ]]>
   </template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <!-- condition="pit_ltmr64l_lth"  -->
   <template condition="pit_ltmr64h_lth_present" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @param[out] upper Upper 32-bits of combined counter
      \t * @param[out] lower Lower 32-bits of combined counter
      \t */
      \tstatic void readChainedCounter(uint32_t &upper, uint32_t &lower) {
      \t   upper = pit->LTMR64H;
      \t   lower = pit->LTMR64L;
      \t}\n\n
   ]]></template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" namespace="all" codeGenCondition="enablePeripheralSupport" ><![CDATA[

   /**
    * Class representing $(_NAME)
    */
   class $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};
   \n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" namespace="all" codeGenCondition="irqHandlingMethod" ><![CDATA[
   /**
    * MACRO defining the start of a interrupt handler for a PIT channel
    * This will override the handler incorporated within the PIT class.
    *
    * @param channel Channel being used.
    *
    * @example
    * PIT$(_instance)_CHANNEL0_HANDLER() {
    *    console.writeln("PIT$(_instance) Channel 0 Handler");
    *    // Clear interrupt flag
    *    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
    * }
    */
    \n
   ]]></template>
   <for keys="ch" dim="numChannels" >
      <template key="/PIT/declarations" namespace="all"  ><![CDATA[
         #define PIT$(_instance)_CHANNEL%(ch)_HANDLER() template<>template<> void Pit$(_instance)::Channel<%(ch)>::irqHandler()\n
      ]]></template>
   </for>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PitValidate" >
   </validate>

   <projectActionList id = "pit_files" >
      <copy source="Snippets/pit-example1.cpp"       target="Snippets/pit-example1.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example2-MK.cpp"    target="Snippets/pit-example2.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example3-MK.cpp"    target="Snippets/pit-example3.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"   overwrite="true" derived="true" />
      <copy source="Project_Headers/pit-MKE.h"  target="Project_Headers/pit.h"  overwrite="true"  derived="true" />
   </projectActionList>

   <signals enabledBy="enablePeripheralSupport" />

</peripheralPage>

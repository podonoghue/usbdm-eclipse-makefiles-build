<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- mcm_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <xi:include href="_default_instance.xml"/>
   
   <if condition="irqOption_present" >
      <xi:include href="_irqOption.xml"/>
   </if>   
   
   <!-- 
      ******************** Flash Controller  ******************** 
   -->   
   <binaryOption key="mcm_placr_esfc" condition="mcm_placr_esfc_present"
      enumStem="McmStallFlashController"
      description="Enable Stalling Flash Controller"
      toolTip="Enables stalling flash controller when flash is busy \n
      When software needs to access the flash memory while a flash memory resource is being manipulated \n
      by a flash command, software can enable a stall mechanism to avoid a read collision.  \n
      The stall mechanism allows software to execute code from the same block on which flash operations \n
      are being performed. \n
      However, software must ensure the sector the flash operations are being performed on is not \n
      the same sector from which the code is executing. \n
      This must be set only just before the flash operation is executed and cleared when the operation completes"
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled"  />
   </binaryOption>
   
   <setTemplate  
      variables="mcm_placr_esfc"
   > <![CDATA[
      \t/**
      \t * Set %description
      \t *
      %comments
      \t */
      \tstatic void setStallFlashController(%params) {
      
      \t   %register = (%register&~(%mask)) | %paramExpression;
      \t}\n\n
   ]]></setTemplate>
         
   <choiceOption key="mcm_placr_flash_speculation" condition="mcm_placr_flash_speculation_present"
      enumStem="McmFlashSpeculation"
      valueFormat="MCM_PLACR_DFCS(%s),MCM_PLACR_EFDS(%s)"
      description="Flash Controller Speculation Buffer"
      toolTip="Controls the operation of the Flash Controller Speculation Buffer"
      >
      <choice value="0,0" name="Instructions Only"     enum="InstructionsOnly"       isDefault="true" />
      <choice value="0,1" name="Instructions and Data" enum="InstructionsAndData"    />
      <choice value="1,0" name="Off"                   enum="Off"                    />
   </choiceOption>
   
   <setTemplate  
      variables="mcm_placr_flash_speculation"
   > <![CDATA[
      \t/**
      \t * Configure Flash Controller
      \t *
      %comments
      \t */
      \tstatic void setFlashControllerSpeculation(%params) {
      
      \t   %register = (%register&~%mask)|%paramExpression;
      \t}\n\n
   ]]></setTemplate>      

   <choiceOption key="mcm_placr_flash_cache" condition="mcm_placr_flash_cache_present"
      enumStem="McmFlashCache"
      valueFormat="MCM_PLACR_DFCC(%s),MCM_PLACR_DFCIC(%s),MCM_PLACR_DFCDA(%s)"
      description="Flash Controller Cache"
      toolTip="Controls the operation of the Flash Controller Cache"
      >
      <choice value="0,0,0" name="Instructions and Data"  enum="InstructionsAndData" isDefault="true" />
      <choice value="0,0,1" name="Instructions Only"      enum="InstructionsOnly"    />
      <choice value="0,1,0" name="Data Only"              enum="DataOnly"            />
      <choice value="1,0,0" name="Disabled"               enum="Disabled"            />
   </choiceOption>
   
   <setTemplate  
      variables="mcm_placr_flash_cache"
   > <![CDATA[
      \t/**
      \t * Set %description
      \t *
      %comments
      \t */
      \tstatic void setFlashControllerCache(%params) {
      
      \t   %register = (%register&~%mask) | %paramExpression;
      \t}\n\n
   ]]></setTemplate>
         
   <binaryOption key="mcm_placr_cfcc" condition="mcm_placr_cfcc_present"
      enumStem="McmFlashControllerCache"
      description="Clear Flash Controller Cache"
      toolTip="Write to clear flash controller cache"
      >
      <choice name="Clear" value="1" enum="Clear" isDefault="true" />
   </binaryOption>
   
   <setTemplate  
      variables="mcm_placr_cfcc"
   > <![CDATA[
      \t/**
      \t * %description
      \t * %tooltip
      \t */
      \tstatic void clearFlashControllerCache() {
      \t
      \t   %register = %register | %mask;
      \t}\n\n
   ]]></setTemplate>   
   
   <setTemplate  
      variables="mcm_placr_flash_speculation,mcm_placr_flash_cache"
      nonDefaultParams="2" 
   > <![CDATA[
      \t/**
      \t * Configure Flash Controller
      \t *
      %comments
      \t */
      \tstatic void configureFlashController(
      %params) {
      
      \t   %register = (%register&~%mask)|
      \t                %paramExpression;
      \t}\n\n
   ]]></setTemplate>
         
   
   <setTemplate variables="mcm_placr_flash_cache,mcm_placr_flash_speculation" > 
      ><![CDATA[
      \t/**
      \t **
      \t * Class used to do initialisation of MCM flash control.
      \t * Options not explicitly mentioned are cleared to 0.
      \t *
      \t * This class has a templated constructor that accepts a range of options
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example1:
      \t * @code
      \t * const Mcm::FlashInit flashInit {
      \t *    // List of options
      \t *    McmFlashCache_Disabled, 
      \t *    McmFlashSpeculation_InstructionsAndData,
      \t * };
      \t *
      \t * flashInit.initialise();  // Configure selected options
      \t * @endcode
      \t */
      \tclass FlashInit {
      \t
      \tprivate:
      \t   /// Value for PLACR register
      \t   uint32_t placr = 0;
      \t
      \tpublic:
      \t   /**
      \t    * Configure Flash options as specified in the constructor
      \t    */
      \t   inline void initialise() const {
      \t      %register = (%register & ~%mask)|
      \t                   placr;
      \t   }
      \t   
      \t   /**
      \t    * Constructor
      \t    */
      \t   constexpr FlashInit()  {
      \t   }
      \t\n
   ]]></setTemplate>

   <for keys="n" values="mcm_placr_flash_cache;mcm_placr_flash_speculation" >      
      <setTemplate 
         variables="%(n)"
      ><![CDATA[
         \t   /**
         \t    * Constructor
         \t    *
         \t    * @param %enumParam %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr FlashInit(%enumClass %enumParam, Types... rest) : FlashInit(rest...)  {
         \t   
         \t      placr |= %enumParam;
         \t   }\n\n
      ]]></setTemplate>
   </for>
   
   <template condition="mcm_placr_flash_cache_present||mcm_placr_flash_speculation" > 
      ><![CDATA[
      \t};\n\n
   ]]></template>
   
   <!-- 
      ******************** Bus arbitration ******************** 
   -->   
   <binaryOption key="mcm_placr_arb" condition="mcm_placr_arb_present"
      enumStem="McmArbitration"
      description="Arbitration select for the crossbar masters"
      toolTip="Arbitration select for the crossbar masters"
      >
      <choice name="Fixed-priority" value="0" enum="FixedPriority" isDefault="true" />
      <choice name="Round-robin"    value="1" enum="RoundRobin"    />
   </binaryOption>
   
   <setTemplate 
      variables="mcm_placr_arb"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %enumParam %tooltip
      \t */
      \tstatic void setCrossbarArbitration(%enumClass %enumParam) {
      \t
      \t   %defaultClockExpression
      \t}\n\n
   ]]></setTemplate>
   
   <!-- 
      ******************** Compute Mode ******************** 
   -->   
   <choiceOption key="mcm_cpo_request" condition="mcm_cpo_present"
      enumStem="McmComputeOnlyMode"
      valueFormat="MCM_CPO_CPOREQ(%s),MCM_CPO_CPOWOI(%s)"
      description="Request Compute Operation (with Wake on interrupt)"
      toolTip="Request for Compute Operation with optional wake-on-interrupt"
      >
      <choice value="0,0" name="No request"                     enum="Disable"                   isDefault="true" />
      <choice value="1,0" name="Request"                        enum="Enable"                    />
      <choice value="1,1" name="Request with wake-on-interrupt" enum="EnableWithWakeOnInterrupt" />
   </choiceOption>
   
   <setTemplate  
      variables="mcm_cpo_request"
   > <![CDATA[
      \t/**
      \t * Exit %description
      \t *
      \t */
      \tstatic void exitComputeMode() {
      \t     
      \t   %register = McmComputeOnlyMode_Disable;
      \t   while ((%register & MCM_CPO_CPOACK_MASK) != 0) {
      \t      __asm__("nop");
      \t   }
      \t}\n\n
      \t/**
      \t * Set %description
      \t *
      %comments
      \t */
      \tstatic void enterComputeMode(%params) {
      \t     
      \t   %register = %paramExpression;
      \t   while ((%register & MCM_CPO_CPOACK_MASK) == 0) {
      \t      __asm__("nop");
      \t   }
      \t}\n\n
   ]]></setTemplate>      

   <binaryOption key="mcm_cpo_cpoack" condition="mcm_cpo_present"
      enumStem="McmCpoAcknowledge"
      description="Acknowledge entry to Computer Operation mode"
      toolTip="Acknowledge entry to Computer Operation mode"
      >
      <choice name="Ack" value="1" enum="Ack" isDefault="true" />
   </binaryOption>
   
   <!-- 
      ******************** Floating point exceptions ******************** 
   -->   
   <binaryOption key="mcm_iscr_fidce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuDenormalIrq"
      description="FPU input de-normalized interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <binaryOption key="mcm_iscr_fixce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuInexactIrq"
      description="FPU inexact interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <binaryOption key="mcm_iscr_fufce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuUnderflowIrq"
      description="FPU underflow interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <binaryOption key="mcm_iscr_fofce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuOverflowIrq"
      description="FPU overflow interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <binaryOption key="mcm_iscr_fdzce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuDivideByZeroIrq"
      description="FPU divide-by-zero interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <binaryOption key="mcm_iscr_fioce" condition="mcm_iscr_floating_present"
      enumStem="McmFpuInvalidOperationIrq"
      description="FPU invalid-operation interrupt"
      toolTip=""
      >
      <choice name="Disabled" value="0" enum="Disabled" isDefault="true" />
      <choice name="Enabled"  value="1" enum="Enabled" />
   </binaryOption>
   
   <setTemplate variables="mcm_iscr_fidce,mcm_iscr_fixce,mcm_iscr_fufce,mcm_iscr_fofce,mcm_iscr_fdzce,mcm_iscr_fioce" > 
      ><![CDATA[
      \t/**
      \t **
      \t * Class used to do initialisation of Floating Point interrupts
      \t *
      \t * This class has a templated constructor that accepts a list of interrupts to modify.
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example1:
      \t * @code
      \t * const Mcm::FloatingPointIrqInit fpIrqInit {
      \t *    // List of interrupts to modify
      \t *    McmFpuDenormalIrq_Enabled, 
      \t *    McmFpuDivideByZeroIrq_Enabled,
      \t * };
      \t *
      \t * fpIrqInit.initialise();  // Enable listed interrupts and disable others
      \t * fpIrqInit.disableInterrupts();    // Disable listed interrupts
      \t * fpIrqInit.enableInterrupts();     // Enable listed interrupts
      \t * @endcode
      \t *
      \t * Example2:
      \t * @code
      \t * Mcm::FloatingPointIrqInit{
      \t *    // List of interrupts to modify
      \t *    McmFpuDenormalIrq_Enabled, 
      \t *    McmFpuDivideByZeroIrq_Enabled}.initialise();
      \t * @endcode
      \t */
      \tclass FloatingPointIrqInit {
      \t
      \tprivate:
      \t   /// Mask indicating bits to set or clear in register
      \t   uint32_t irqEnables = 0;
      \t
      \tpublic:
      \t   /**
      \t    * Initialise Floating Point interrupts as specified in the constructor
      \t    */
      \t   inline void initialise() const {
      \t      %register = irqEnables;
      \t   }
      \t   
      \t   /**
      \t    * Enable Floating Point interrupts as specified in the constructor
      \t    */
      \t   inline void enableInterrupts() const {
      \t      %register = %register|irqEnables;
      \t   }
      \t   
      \t   /**
      \t    * Disable Floating Point interrupts as specified in the constructor
      \t    */
      \t   inline void disableInterrupts() const {
      \t      %register = %register&~irqEnables;
      \t   }
      \t   
      \t   /**
      \t    * Constructor
      \t    */
      \t   constexpr FloatingPointIrqInit()  {
      \t   }
      \t\n
   ]]></setTemplate>

   <for keys="n" values="mcm_iscr_fidce;mcm_iscr_fixce;mcm_iscr_fufce;mcm_iscr_fofce;mcm_iscr_fdzce;mcm_iscr_fioce" >      
      <setTemplate 
         variables="%(n)"
      ><![CDATA[
         \t   /**
         \t    * Constructor
         \t    *
         \t    * @param %enumParam %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr FloatingPointIrqInit(%enumClass %enumParam, Types... rest) : FloatingPointIrqInit(rest...)  {
         \t   
         \t      irqEnables |= %enumParam;
         \t   }\n\n
      ]]></setTemplate>
   </for>
   
   <template condition="mcm_iscr_floating_present" > 
      ><![CDATA[
      \t};\n\n
   ]]></template>
   
   <!-- 
      ******************** MCM_CR ******************** 
   -->
   
   <binaryOption key="mcm_cr_sramlwp" condition="mcm_cr_sraml_present"
      enumStem="McmSramLowerAccess"
      description="SRAM Lower access control (write protect)"
      toolTip="When protected, writes to SRAM array generates a bus error"
      >
      <choice name="Read and Write" value="0" enum="ReadWrite"  isDefault="true"/>
      <choice name="Read Only"      value="1" enum="ReadOnly" />
   </binaryOption>
   
   <choiceOption key="mcm_cr_sramlap" condition="mcm_cr_sraml_present"
      enumStem="McmSramLowerArbitration"
      description="SRAM Lower arbitration priority"
      toolTip="Defines the arbitration scheme and priority for the processor and SRAM backdoor accesses to the SRAM array"
      >
      <choice value="0b00" name="Round Robin"                                 enum="RoundRobin"               isDefault="true" />
      <choice value="0b01" name="Special Round Robin (backoor>processor)"     enum="SpecialRoundRobin"        />
      <choice value="0b10" name="Fixed (processor highest, backdoor lowest)"  enum="ProcessorHighBackdoorLow" />
      <choice value="0b11" name="Fixed (backdoor highest, processor lowest)"  enum="BackDoorHighProcessorLow" />
   </choiceOption>
   
   
   <binaryOption key="mcm_cr_sramuwp" condition="mcm_cr_sramu_present"
      enumStem="McmSramUpperAccess"
      description="SRAM Upper access control (write protect)"
      toolTip="When protected, writes to SRAM array generates a bus error"
      >
      <choice name="Read and Write" value="0" enum="ReadWrite"  isDefault="true"/>
      <choice name="Read Only"      value="1" enum="ReadOnly" />
   </binaryOption>
   
   <choiceOption key="mcm_cr_sramuap" condition="mcm_cr_sramu_present"
      enumStem="McmSramUpperArbitration"
      description="SRAM Upper arbitration priority"
      toolTip="Defines the arbitration scheme and priority for the processor and SRAM backdoor accesses to the SRAM array"
      >
      <choice value="0b00" name="Round Robin"                                 enum="RoundRobin"               isDefault="true" />
      <choice value="0b01" name="Special Round Robin (backoor>processor)"     enum="SpecialRoundRobin"        />
      <choice value="0b10" name="Fixed (processor highest, backdoor lowest)"  enum="ProcessorHighBackdoorLow" />
      <choice value="0b11" name="Fixed (backdoor highest, processor lowest)"  enum="BackDoorHighProcessorLow" />
   </choiceOption>

   <setTemplate variables="mcm_cr_sramlwp,mcm_cr_sramlap,mcm_cr_sramuwp,mcm_cr_sramuap" > 
      ><![CDATA[
      \t/**
      \t **
      \t * Class used to do initialisation of Floating Point interrupts
      \t *
      \t * This class has a templated constructor that accepts a list of options to set.
      \t * Options not explicitly mentioned are cleared to 0.
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example1:
      \t * @code
      \t * const Mcm::SramAccessInit sramInit {
      \t *    // List of options
      \t *    McmSramLowerAccess_ReadWrite, 
      \t *    McmSramLowerArbitration_SpecialRoundRobin, 
      \t *    McmSramUpperAccess_ReadOnly, 
      \t *    McmSramUpperArbitration_BackDoorHighProcessorLow, 
      \t * };
      \t *
      \t * sramInit.initialise();  // Enable listed interrupts and disable others
      \t * @endcode
      \t *
      \t * Example2:
      \t * @code
      \t * Mcm::SramAccessInit{
      \t *    // List of options
      \t *    McmSramLowerAccess_ReadWrite, 
      \t *    McmSramLowerArbitration_SpecialRoundRobin, 
      \t *    McmSramUpperAccess_ReadOnly, 
      \t *    McmSramUpperArbitration_BackDoorHighProcessorLow}.initialise();
      \t * @endcode
      \t */
      \tclass SramAccessInit {
      \t
      \tprivate:
      \t   /// Value for register
      \t   uint32_t mcm_cr = 0;
      \t
      \tpublic:
      \t   /**
      \t    * Initialise SRAM access as specified in constructor
      \t    */
      \t   inline void initialise() const {
      \t      %register = mcm_cr;
      \t   }
      \t   
      \t   /**
      \t    * Constructor
      \t    */
      \t   constexpr SramAccessInit()  {
      \t   }
      \t\n
   ]]></setTemplate>

   <for keys="n" values="mcm_cr_sramlwp;mcm_cr_sramlap;mcm_cr_sramuwp;mcm_cr_sramuap" >      
      <setTemplate 
         variables="%(n)"
      ><![CDATA[
         \t   /**
         \t    * Constructor
         \t    *
         \t    * @param %enumParam %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr SramAccessInit(%enumClass %enumParam, Types... rest) : SramAccessInit(rest...)  {
         \t   
         \t      mcm_cr |= %enumParam;
         \t   }\n\n
      ]]></setTemplate>
   </for>
   
   <template condition="mcm_cr_sramlwp||mcm_cr_sramlap||mcm_cr_sramuwp||mcm_cr_sramuap" > 
      ><![CDATA[
      \t};\n\n
   ]]></template>
   
   <!-- 
      ******************** misc ******************** 
   -->
   <template key="/MCM/declarations" namespace="all" ><![CDATA[
      \t/**
      \t * Class representing $(_name)
      \t */\n
   ]]></template>
   <template key="/MCM/declarations" namespace="all" condition="irqOption_present" ><![CDATA[
      \tclass $(_class) : public $(_base_class)Info, public $(_base_class)Interrupt_T<$(_class)Info> {};\n
   ]]></template>
   <template key="/MCM/declarations" namespace="all" condition="!irqOption_present" ><![CDATA[
      \tclass $(_class) : public $(_base_class)Info {};\n
   ]]></template>
   
   <projectActionList id = "mcm_files" >
      <copy source="Project_Headers/mcm.h"         target="Project_Headers/mcm.h"          overwrite="true" derived="true" />
   </projectActionList>

</fragment>

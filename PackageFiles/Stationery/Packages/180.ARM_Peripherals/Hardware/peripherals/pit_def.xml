<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pit_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <constant key = "irq_pattern"      value = "&quot;^%b(\d+)$&quot;"                            type="String" />
   <constant key = "irq_classHandler" value = "&quot;%c%i::Channel&lt;$1&gt;::irqHandler&quot;"  type="String" />
   <xi:include href="_irqOptionSubstituted.xml"/>

   <xi:include href="_default_instance.xml"/>

   <template><![CDATA[
      \t//! Number of PIT channels
      \tstatic constexpr uint32_t NumChannels  = $(numChannels);\n\n
   ]]></template>

   <choiceOption key="pit_channelNumber"
      hidden="true"
      description="Pit Channel Number"
      enumStem="PitChannelNum"
      valueFormat="%s"
      enumType="uint8_t"
      toolTip="Selected PIT channel">
      <choice value="0"          name="Channel 0"     enum="0" />
      <choice value="1"          name="Channel 1"     enum="1" />
      <choice value="2"          name="Channel 2"     enum="2" />
      <choice value="3"          name="Channel 3"     enum="3" />
      <choice value="0b10000000" name="Channel Not Allocated"  enum="None" />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/MCG/$present"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/ICS/$present"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="pitInputClock"
      constant="true"
      derived="true"
      description="PIT input clock"
      toolTip="The PIT uses the bus clock for timing\n
               The frequency used is based on the current clock configuration"
      units="Hz"
      />

   <binaryOption key="pit_mcr_frz" condition="pit_mcr_frz_present"
      enumStem="PitDebugMode"
      description="Freeze in Debug"
      toolTip="Determines if timers are stopped in Debug mode">
      <choice name="Timers run in Debug"   value="0" enum="Run"    />
      <choice name="Timers stop in Debug"  value="1" enum="Freeze" isDefault="true" />
   </binaryOption>

   <for keys="ch" dim="numChannels">
      <title description="----- Channel %(ch) -----" />

      <binaryOption key="pit_tctrl_ten[%(ch)]"  condition="pit_tctrl_tie_present"
         enumStem="PitChannelEnable"
         description="Timer Channel Enable"
         toolTip="Allows operation of this channel">
         <choice value="0" name="Channel disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Channel enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_ldval_tsv[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Ticks &amp;"
         valueFormat="%s_ticks"
         description="Reload value channel %(ch)"
         toolTip="Value loaded in timer register on roll-over"
         min="0" max="0xFFFFFFFF" />

      <floatOption key="pit_period[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Seconds &amp;"
         valueFormat="%s_s"
         description="Default period of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1m" min="0" units="s" />

      <floatOption key="pit_frequency[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Hertz"
         valueFormat="%s_Hz"
         description="Default frequency of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1k" min="0" units="Hz" />

      <binaryOption key="pit_tctrl_chn[%(ch)]"  condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         enabledBy="pit_tctrl_ten[%(ch)]"
         enumStem="PitChannelChain"
         description="Chain with previous channel"
         toolTip="Controls whether the timer channels are chained to creater a larger counter">
         <choice value="0" name="Timers are not chained" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Timers are chained"     enum="Enabled"  />
      </binaryOption>

      <binaryOption key="pit_tctrl_tie[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="pit_tctrl_ten[%(ch)] &amp;&amp;irqHandlingMethod"
         enumStem="PitChannelIrq"
         description="Timer Interrupt Enable"
         toolTip="Allows interrupts from this channel">
         <choice value="0" name="Interrupts are disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Interrupts are enabled"  enum="Enabled"  />
      </binaryOption>
   </for>

<!-- Graphic here -->

   <!--  ========== PIT Init class =============================== -->

   <template key="init_description" namespace="all" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_class) channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_class) channel
      \t * // Parameters available may vary with device - see $(_class)::DefaultChannelInitValues[] for relevant example
      \t * static const Pit::Init pitInit {
      \t *       PitChannelNum_0,
      \t *
      \t *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      \t *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      \t *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
      \t *       callBackFunction,          // Call-back function to use
      \t *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
      \t *       3999_ticks,                // Reload value for channel (in ticks or seconds)
      \t * };
      \t *
      \t * // Initialise PIT channel from values specified above
      \t * Pit::configure(pitInit)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm" >
   <![CDATA[
      class $(_class)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)();
      \t\n
   ]]>
   </template>

   <template namespace="all" key="protectedMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef $(_class)BasicInfo::CallbackFunction CallbackFunction;
      \t
      \t/** Callback functions for ISRs */
      \tstatic CallbackFunction sCallbacks[Info::NumChannels];
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback() {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="all" key="publicMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t *  @param[in]  pitChannelNum   Channel to configure
      \t *  @param[in]  callback        Callback function to be executed on interrupt.
      \t *                              Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(PitChannelNum pitChannelNum, CallbackFunction callback) {
      \t
      \t   if (callback == nullptr) {
      \t      callback = unhandledCallback;
      \t   }
      \t   sCallbacks[pitChannelNum] = callback;
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="usbdm">
   <![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!-- Member variables -->

   <setTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pit_ldval_tsv[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pit_period[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_s;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pit_tctrl_ten[],pit_tctrl_chn[],pit_tctrl_tie[]"
   ><![CDATA[
      \t   /// Timer Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName0 = %symbolicValueExpression1;
      \t\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pit_channelNumber"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = PitChannelNum_None;\n\n
   ]]></initialValueTemplate>

<!--  Configure method -->

   <setTemplate key="/$(_basename)/InitMethod" codeGenCondition="enablePeripheralSupport"
                variables="pit_tctrl_ten[]" discardRepeats="true" namespace="all" ><![CDATA[
      \t/**
      \t * Configure $(_basename) channel from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   // Configure PIT
      \t   pit->MCR = Info::mcr;
      \t
      \t   // Disable channel
      \t   pit->CHANNEL[init.channelnumber].TCTRL = 0;
      \t
      \t   Ticks ldval = init.ldval;
      \t\n
   ]]></template>
   <setTemplate key="/$(_basename)/InitMethod" codeGenCondition="supportFloat"
                variables="pit_tctrl_ten[]" discardRepeats="true" namespace="all" ><![CDATA[
      \t   if (init.period != 0) {
      \t      ldval = convertSecondsToTicks(init.period)-1;
      \t   }\n
   ]]></template>
   <setTemplate key="/$(_basename)/InitMethod" codeGenCondition="enablePeripheralSupport"
                variables="pit_tctrl_ten[]" discardRepeats="true" namespace="all" ><![CDATA[
      \t
      \t   pit->CHANNEL[init.channelnumber].LDVAL = ldval;
      \t
   ]]></template>
   <template key="/$(_basename)/InitMethod" codeGenCondition="irqHandlingMethod"
                variables="pit_tctrl_ten[]" discardRepeats="true" namespace="all" ><![CDATA[
      \t   setCallback(init.channelnumber, init.callbackFunction);
      \t   enableNvicInterrupts(init.channelnumber, init.irqlevel);
      \t\n
   ]]></template>
   <setTemplate key="/$(_basename)/InitMethod" codeGenCondition="enablePeripheralSupport"
                variables="pit_tctrl_ten[]" discardRepeats="true" namespace="all" ><![CDATA[
      \t   // Configure channel
      \t   pit->CHANNEL[init.channelnumber].TCTRL = init.tctrl;
      \t}\n\n
   ]]></template>

<!--  Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <for keys="r" values="pit_channelNumber;pit_ldval_tsv[];pit_period[];/PCR/nvic_irqLevel">
      <constructorTemplate namespace="usbdm"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <for keys="r" values="pit_tctrl_ten[];pit_tctrl_chn[1];pit_tctrl_tie[]">
      <constructorTemplate namespace="usbdm"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </constructorTemplate>
   </for>

<!--   Default Initialisation value -->

   <setTemplate
      variables="pit_mcr_frz"
   ><![CDATA[
      \t/// %description
      \tstatic constexpr uint32_t %registerName = %initExpression; \n\n
   ]]></setTemplate>

   <template><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * $(_class) interrupt call back
      \t */
      \ttypedef $(_class)BasicInfo::CallbackFunction CallbackFunction;
      \t
      \t/**
      \t * Default initialisation values for PIT channels
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultChannelInitValues[] = {\n
   ]]></template>

   <for keys="ch" dim="numChannels">
      <setTemplate
         separator=","
         terminator=","
         variables="
            pit_tctrl_ten[%(ch)],
            pit_tctrl_chn[%(ch)],
            pit_tctrl_tie[%(ch)],
            irqLevel,
            pit_ldval_tsv[%(ch)]"
         >
      <![CDATA[
         \t   {
         \t   PitChannelNum_%(ch),
         %initExpression
         \t   },\n
      ]]></setTemplate>
   </for>

   <template namespace="usbdm" >
   <![CDATA[
      \t};// $(_class)BasicInfo::Init\n\n
   ]]>
   </template>

   <template namespace="usbdm" >
   <![CDATA[
      }; // $(_class)BasicInfo\n\n
   ]]>
   </template>

   <template><![CDATA[
         \t};// $(_class)Info\n\n
   ]]></template>

   <!--  ==================== Common ======================== -->

   <template discardRepeats="true" key="CallBackDefinition" namespace="all" ><![CDATA[
      /**
       * Callback table for programmatically set handlers
       */
      template<class Info>
      typename Info::CallbackFunction PitBase_T<Info>::sCallbacks[] = {\n
   ]]></template>
   <for keys="ch" dim="numChannels">
      <template discardRepeats="true" key="/PIT/CallBackDefinition" namespace="all" ><![CDATA[
         \tPitBase_T<Info>::unhandledCallback,\n
      ]]></template>
   </for>
   <template discardRepeats="true" key="/PIT/CallBackDefinition" namespace="all" ><![CDATA[
      };\n\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PitValidate">
   </validate>

   <projectActionList id = "pit_files" >
      <copy source="Snippets/pit-example1.cpp"       target="Snippets/pit-example1.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example2-MK.cpp"    target="Snippets/pit-example2.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example3-MK.cpp"    target="Snippets/pit-example3.cpp" overwrite="true" derived="true" />
      <copy source="Project_Headers/pit-MK.h"        target="Project_Headers/pit.h"     overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"   overwrite="true" derived="true" />
   </projectActionList>

   <!-- condition="pit_ltmr64l_lth"  -->
   <template condition="pit_ltmr64h_lth_present" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @param[out] upper Upper 32-bits of combined counter
      \t * @param[out] lower Lower 32-bits of combined counter
      \t */
      \tstatic void readChainedCounter(uint32_t &upper, uint32_t &lower) {
      \t   upper = pit->LTMR64H;
      \t   lower = pit->LTMR64L;
      \t}\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <template key="/$(_basename)/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_name)
   \t */
   \tclass $(_class) : public $(_base_class)Base_T<$(_class)Info> {};\n
   ]]></template>

   <template key="/PIT/declarations" namespace="all"  ><![CDATA[

   \t/**
   \t * @brief class representing a PIT channel
   \t */
   \tusing $(_class)Channel = $(_class)::PitChannel;
   ]]></template>

   <template key="/$(_basename)/declarations" namespace="all" ><![CDATA[
   \t/**
   \t * MACRO defining the start of a interrupt handler for a PIT channel
   \t * This will override the handler incorporated within the PIT class.
   \t *
   \t * @param channel Channel being used.
   \t *
   \t * @example
   \t * PIT$(_instance)_CHANNEL0_HANDLER() {
   \t *    console.writeln("PIT$(_instance) Channel 0 Handler");
   \t *    // Clear interrupt flag
   \t *    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
   \t * }
   \t */\n
   ]]></template>
   <for keys="ch" dim="numChannels">
      <template key="/PIT/declarations" namespace="all"  ><![CDATA[
         #define PIT$(_instance)_CHANNEL%(ch)_HANDLER() template<>template<> void Pit$(_instance)::Channel<%(ch)>::irqHandler()\n
      ]]></template>
   </for>

   <xi:include href="_clockOption.xml"/>

   <signals/>

</fragment>

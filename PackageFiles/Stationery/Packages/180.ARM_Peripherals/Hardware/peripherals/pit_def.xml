<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pit_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <choiceOption key="irq_enum" condition="=_irqCount>1"
      valueFormat="%s"
      hidden="true"
      derived="true"
      typeName="$(_Class)IrqNum"
      description="$(_Class) Interrupt indices"
      toolTip="Used to identify peripheral interrupt" >
      <choice value="0"  enum="Ch0"     name="Periodic Interrupt Timer" />
      <choice value="1"  enum="Ch1"     name="Periodic Interrupt Timer" />
      <choice value="2"  enum="Ch2"     name="Periodic Interrupt Timer" />
      <choice value="3"  enum="Ch3"     name="Periodic Interrupt Timer" />
   </choiceOption>

   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"  />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"  />
   <if condition="@_irqCount==1" >
      <!-- PIT_IRQHandler => Pit::irqHandler -->
      <constant key="irq_pattern"              type="String"  value="&quot;^$(_NAME)$&quot;"           />
      <constant key="irq_ClassHandler"         type="String"  value="&quot;$(_Class)::irqHandler&quot;" />
   <else />
      <!-- PITx_IRQHandler => Pit::irqHandler<x> -->
      <constant key="irq_pattern"              type="String"  value="&quot;^$(_NAME)(\d+)$&quot;"           />
      <constant key="irq_ClassHandler"         type="String"  value="&quot;$(_Class)::irqHandler&lt;PitChannelNum_$1&gt;&quot;" />
   </if>
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="true" />
   <xi:include href="enablePeripheral.xml" />
   <title />

<!-- ==================== Constants ==================== -->
   <!-- Defined in SIM -->
   <intOption key="NumChannels" locked="true" derived="true"
      hidden="true"
      value="=pit_channel_dim"
      description="Number of PIT channels" />

   <!-- Derived from SVD -->
   <intOption key="NumVectors" locked="true" derived="true"
      hidden="true"
      value="=_irqCount"
      description="Number of PIT IRQ vectors" />

   <aliasOption key="NumChannels" condition="=_debugcode"/>
   <aliasOption key="NumVectors"  condition="=_debugcode"/>

   <template><![CDATA[
      \t//! Number of PIT channels
      \tstatic constexpr uint32_t NumChannels  = $(NumChannels);\n\n
   ]]></template>

   <template condition="=_irqCount > 1" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Enable interrupts in NVIC
      \t *
      \t * @param[in]  pitChannelNum  Channel being modified
      \t */
      \tstatic void enableNvicInterrupts(PitChannelNum pitChannelNum) {
      \t   enableNvicInterrupts(PitIrqNum(pitChannelNum));
      \t}
      \t
      \t/**
      \t * Enable and set priority of interrupts in NVIC
      \t * Any pending NVIC interrupts are first cleared.
      \t *
      \t * @param[in]  pitChannelNum  Channel being modified
      \t * @param[in]  nvicPriority   Interrupt priority
      \t */
      \tstatic void enableNvicInterrupts(PitChannelNum pitChannelNum, NvicPriority nvicPriority) {
      \t   enableNvicInterrupts(PitIrqNum(pitChannelNum), nvicPriority);
      \t}
      \t
      \t/**
      \t * Disable interrupts in NVIC
      \t *
      \t * @param[in]  pitChannelNum  Channel being modified
      \t */
      \tstatic void disableNvicInterrupts(PitChannelNum pitChannelNum) {
      \t   disableNvicInterrupts(PitIrqNum(pitChannelNum));
      \t}
      \t\n
   ]]></template>

<!--
   <template condition="=_irqCount == 1" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Map channel number to corresponding IRQ number
      \t * This is needed as multiple channels may be handled by a single IRQ vector
      \t *
      \t * @param pitChannelNum Channel number to map (ignored as only one vector)
      \t *
      \t * @return Interrupt number
      \t */
      \tstatic constexpr IRQn_Type mapChannelToIrq(PitChannelNum) {
      \t   return irqNums[0];
      \t}
      \t\n
   ]]></template>
   <template condition="=pit_channel_dim == _irqCount" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Map channel number to corresponding IRQ number
      \t * This is needed as multiple channels may be handled by a single IRQ vector
      \t *
      \t * @param pitChannelNum Channel number to map
      \t *
      \t * @return Interrupt number
      \t */
      \tstatic constexpr IRQn_Type mapChannelToIrq(PitChannelNum pitChannelNum) {
      \t   // 1:1 mapping
      \t   return irqNums[pitChannelNum];
      \t}
      \t\n
   ]]></template>
   <template condition="=(_irqCount!=1) &amp;&amp; (pit_channel_dim&gt;_irqCount)" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Map channel number to corresponding IRQ number
      \t * This is needed as multiple channels may be handled by a single IRQ vector
      \t *
      \t * @param pitChannelNum Channel number to map
      \t *
      \t * @return Interrupt number
      \t */
      \tstatic constexpr IRQn_Type mapChannelToIrq(PitChannelNum pitChannelNum) {
      \t   // Assume repeated linear mapping
      \t   return irqNums[pitChannelNum%PitInfo::irqCount];
      \t}
      \t\n
   ]]></template>
-->

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * %valueExpression[index]         Formatted value as numeric e.g. 0x12
    * %symbolicExpression[index] Symbolic formatted value e.g. AdcCompare_Disabled
    * %variable[index]                Variable name /ADC0/adc_sc2_acfe
    * %macro[index](value)            C register macro e.g. ADC_SC2_ACFGT(value)
    * %description[index]             Description from controlVar e.g. Compare Function Enable
    * %shortDescription[index]        Short description from controlVar e.g. Compare Function Enable
    * %tooltip[index]                 Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * %paramDescription[index]        Tool-tip from controlVar formatted as param description @param ...
    * %params                         Formatted parameter list for function
    * %paramType[index]               Based on enumStem or typename e.g. AdcCompare (or uint32_t)
    * %paramName[index]               Based on enumStem with lower-case first letter adcCompare
    * %paramType[index]               As for %paramType
    * %paramName[index]               As for %paramName
    * %valueExpression                Numeric variable value e.g. 0x3
    * %symbolicExpression        Symbolic variable value e.g. AdcCompare_Disabled
    * %fieldAssignment         Based on variable etc. Similar to %register = (%register&~%mask) | %paramName;
    * %maskingExpression       Based on variable etc. Similar to (%register&%mask)
    * %variable[index]                Variable name from condition
    * %mask[index]                    From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * %register[index]                Register associated with variable e.g. adc->APCTL1
    * %registerName[index]            Name of corresponding register (lowercase for Init()) e.g. apctl1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Structname)BasicInfo&quot;" />

   <binaryOption key="/$(_BASENAME)/secondsSupport"
      enabledBy="/$(_STRUCTNAME)/generateSharedInfo"
      modify="true"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point libraries is necessary to support routines using seconds in runtime code.\n
               This is seldom needed and the overhead can be avoided by disabling this option" >
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <choiceOption key="pit_channelNumber"
      hidden="true"
      description="Pit Channel Number"
      typeName="PitChannelNum"
      valueFormat="%s"
      enumType="uint8_t"
      toolTip="Selected PIT channel" >
      <choiceExpansion keys="ch" dim="=NumChannels" value="%(ch)" name="Channel %(ch)" enum="%(ch)" />
      <choice value="0b10000000" name="Channel Not Allocated"  enum="None" />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="pitInputClock"
      enabledBy="enablePeripheralSupport"
      locked="true"
      derived="true"
      description="PIT input clock"
      toolTip="The PIT uses the bus clock for timing.\n
               The frequency shown is based on the selected clock configuration.\n
               This frequency is used as the basis for calculations on this page."
      units="Hz"
      />

   <!-- ************* MCR ****************** -->

   <binaryOption key="pit_mcr_mdis" condition="pit_mcr_mdis_present"
      enabledBy="enablePeripheralSupport"
      hidden="true"
      typeName="PitOperation"
      toolTip="Disabled PIT module clock"
      description="Module Disable" >
      <choice name="PIT enabled"   value="0" enum="Enabled" isDefault="true" />
      <choice name="PIT disabled"  value="1" enum="Disabled"  />
   </binaryOption>

   <binaryOption key="pit_mcr_frz" condition="pit_mcr_frz_present"
      enabledBy="enablePeripheralSupport"
      typeName="PitDebugMode"
      description="Freeze in Debug"
      toolTip="Determines if timers are stopped in Debug mode" >
      <choice name="Timers run in Debug"   value="0" enum="RunInDebug"    />
      <choice name="Timers stop in Debug"  value="1" enum="StopInDebug" isDefault="true" />
   </binaryOption>

   <for keys="ch" dim="=NumChannels" >
      <title description="Channel %(ch)" />

      <binaryOption key="pit_tctrl_ten[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="enablePeripheralSupport"
         typeName="PitChannelEnable"
         description="Timer Channel Enable"
         toolTip="Allows operation of this channel" >
         <choice value="0" name="Channel disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Channel enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_ldval_tsv[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         valueFormat="%s"
         typeName="Ticks &amp;"
         units="ticks"
         description="Reload value channel %(ch)"
         toolTip="Value loaded in timer register on roll-over"
         value="0"
         min="0" max="0xFFFFFFFF" />

      <floatOption key="pit_period[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Seconds &amp;"
         valueFormat="%s_s"
         description="Default period of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1m" min="0" units="s" />

      <floatOption key="pit_frequency[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="Hertz"
         valueFormat="%s_Hz"
         description="Default frequency of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1k" min="0" units="Hz" />

      <binaryOption key="pit_tctrl_chn[%(ch)]"  condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         enabledBy="pit_tctrl_ten[%(ch)]"
         typeName="PitChannelChain"
         description="Chain with previous channel"
         toolTip="Controls whether the timer channels are chained to create a larger counter" >
         <choice value="0" name="Timers are not chained" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Timers are chained"     enum="Enabled"  />
      </binaryOption>

      <binaryOption key="pit_tctrl_tie[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="pit_tctrl_ten[%(ch)] &amp;&amp;irqHandlingMethod"
         typeName="PitChannelIrq"
         description="Timer Interrupt Enable"
         toolTip="Allows interrupts from this channel" >
         <choice value="0" name="Interrupts are disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Interrupts are enabled"  enum="Enabled"  />
      </binaryOption>
   </for>

<!-- Graphic here -->

   <for keys="field:name"
        values="
      pit_mcr_mdis : Enable;
      pit_mcr_frz  : DebugMode" >
      <variableTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

<!--   ========== static/member functions =============================== -->

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : /$(_BASENAME)/staticFunctions ;
                     : const : chan    : /$(_BASENAME)/memberFunctions" >
      <template key="%(location)" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
      <![CDATA[
         \t   /**
         \t    * Configure PIT channel from values specified in init.
         \t    * The PIT shared hardware will be default initialised if necessary
         \t    *
         \t    * @param init Class containing initialisation values (channel number is ignored)
         \t    */
         \t   %(static) void configure(const typename Info::ChannelInit &init) %(const) {
         \t      PitBase_T<Info>::configure(%(chan), init);
         \t   }
         \t
         \t   /**
         \t    *  Enables and configures the PIT if not already done.
         \t    *  This also disables all channel interrupts and channel reservations if newly configured.
         \t    */
         \t   %(static) void defaultConfigureIfNeeded() %(const) {
         \t      PitBase_T<Info>::defaultConfigureIfNeeded();
         \t   }
         \t
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in timer ticks (usually bus clock)
         \t    *  @param[in]  pitChannelIrq     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Ticks             interval,
         \t         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelIrq);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in seconds
         \t    *  @param[in]  pitChannelIrq     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Seconds           interval,
         \t         PitChannelIrq     pitChannelIrq=PitChannelIrq_Disabled) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelIrq);
         \t   }
         #endif
         \t
         \t   /**
         \t    *   Enable the PIT channel
         \t    */
         \t   %(static) void enable() %(const) {
         \t      PitBase_T<Info>::enableChannel(%(chan));
         \t   }
         \t
         \t   /**
         \t    *   Disable the PIT channel
         \t    */
         \t   %(static) void disable() %(const) {
         \t      PitBase_T<Info>::disableChannel(%(chan));
         \t   }
         \t   /**
         \t    * Set period in ticks
         \t    *
         \t    * @param[in]  interval Interval in ticks
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Ticks interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set period in seconds
         \t    *
         \t    * @param[in]  interval Interval in seconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Seconds interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         #endif
         \t   /**
         \t    * Set period in microseconds
         \t    *
         \t    * @param[in]  microseconds Interval in microseconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriodInMicroseconds(uint32_t microseconds) %(const) {
         \t      uint64_t interval = ((uint64_t)microseconds*Info::getClockFrequency())/1000000;
         \t      usbdm_assert(interval<0xFFFFFFFFUL,"Interval too long");
         \t      PitBase_T<Info>::setPeriod(%(chan), Ticks(uint32_t(interval)));
         \t   }
         \t
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Ticks interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /$(_BASENAME)/secondsSupport
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in seconds
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Seconds interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         #endif
         \t\n
      ]]>
      </template>
   </for>

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : staticFunctions ;
                     : const : chan    : memberFunctions" >

      <!-- Only provide if there is a separate IRQ per channel -->
      <variableTemplate key="%(location)" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
         variables="irq_enum"
      ><![CDATA[
         \t   /**
         \t    * Enable interrupts in NVIC
         \t    */
         \t   %(static) void enableNvicInterrupts() %(const) {
         \t      PitBase_T<Info>::enableNvicInterrupts(%(chan));
         \t   }
         \t
         \t   /**
         \t    * Enable and set priority of interrupts in NVIC
         \t    * Any pending NVIC interrupts are first cleared.
         \t    *
         \t    * @param[in]  nvicPriority  Interrupt priority
         \t    */
         \t   %(static) void enableNvicInterrupts(NvicPriority nvicPriority) %(const) {
         \t      PitBase_T<Info>::enableNvicInterrupts(%(chan), nvicPriority);
         \t   }
         \t
         \t   /**
         \t    * Disable interrupts in NVIC
         \t    */
         \t   %(static) void disableNvicInterrupts() %(const) {
         \t      PitBase_T<Info>::disableNvicInterrupts(%(chan));
         \t   }
         \t
         \t   /**
         \t    * Set callback on event
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout
         \t    */
         \t   %(static) void setCallback(typename Info::CallbackFunction callback) %(const) {
         \t      PitBase_T<Info>::setCallback(%(chan), callback);
         \t   }
         \t\n
         ]]>
      </variableTemplate>
      <template key="%(location)" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
      <![CDATA[
         \t
         \t   /**
         \t    * Enable/disable channel interrupts.
         \t    *
         \t    * @param[in]  enable  True => enable, False => disable
         \t    *
         \t    * @note It is also necessary to modify NVIC using enableNvicInterrupts().
         \t    */
         \t   %(static) void enableInterrupts(bool enable=true) %(const) {
         \t      PitBase_T<Info>::enableInterrupts(%(chan), enable);
         \t   }
         \t
         \t   /**
         \t    * Set one-shot timer callback
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
         \t    */
         \t   %(static) void oneShot(typename Info::CallbackFunction callback, Ticks tickInterval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, tickInterval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set one-shot timer callback.
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  interval          Interval in seconds until callback is executed
         \t    */
         \t   %(static) void  oneShot(typename Info::CallbackFunction callback, Seconds interval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, interval);
         \t   }
         #endif
         \t
         \t   /**
         \t    * Set one-shot timer callback in microseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  microseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMicroseconds(typename Info::CallbackFunction callback, uint32_t microseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMicroseconds(%(chan), callback, microseconds);
         \t   }
         \t
         \t   /**
         \t    * Set one-shot timer callback in milliseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  milliseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMilliseconds(typename Info::CallbackFunction callback, uint32_t milliseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMilliseconds(%(chan), callback, milliseconds);
         \t   }
         \t\n
         ]]>
      </template>
   </for>

   <template namespace="usbdm" >
   <![CDATA[
      class $(_Structname)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="/$(_BASENAME)/irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></variableTemplate>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Baseclass) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback functions for channel ISRs */
      \tstatic CallbackFunction sCallbacks[NumChannels];
      \t\n
   ]]>
   </template>

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Set channel interrupt callback function.
      \t *
      \t *  @param[in]  pitChannelNum   Channel to configure
      \t *  @param[in]  $(_basename)Callback        Callback function to be executed on interrupt.
      \t *                              Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(PitChannelNum pitChannelNum, typename Info::CallbackFunction $(_basename)Callback) {
      \t   if ($(_basename)Callback == nullptr) {
      \t      $(_basename)Callback = Info::unhandledCallback;
      \t   }
      \t   // Allow either no handler set yet or removing handler
      \t   usbdm_assert(
      \t         (Info::sCallbacks[pitChannelNum] == Info::unhandledCallback) || ($(_basename)Callback == Info::unhandledCallback),
      \t         "Handler already set");
      \t   Info::sCallbacks[pitChannelNum] = $(_basename)Callback;
      \t}
      \t\n
   ]]>
   </template>

   <if condition="@NumChannels&gt;@NumVectors" >
      <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="irqHandlingMethod" >
      <![CDATA[
         \t/**
         \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
         \t * Used when all channels share a single handler (needs to poll channel flags)
         \t */
         \tstatic void irqHandler() {
         \t   static_assert((Info::NumChannels>1)&&(Info::irqCount==1), "Internal error - unmatched vectors/channels");
         \t
         \t   for (unsigned pitChannelNum=0; pitChannelNum<Info::NumChannels; pitChannelNum++) {
         \t      if (pit->CHANNEL[pitChannelNum].TFLG & PIT_TFLG_TIF_MASK) {
         \t         // Clear interrupt flag
         \t         pit->CHANNEL[pitChannelNum].TFLG = PIT_TFLG_TIF_MASK;
         \t
         \t         // If a one-shot then stop channel
         \t         if (clearOnEvent&(1<<pitChannelNum)) {
         \t            disableChannel(PitChannelNum(pitChannelNum));
         \t            clearOnEvent &= ~(1<<pitChannelNum);
         \t         }
         \t         // Do call-back
         \t         Info::sCallbacks[pitChannelNum]();
         \t      }
         \t   }
         \t}
         \t\n
      ]]>
      </template>
   <else />
      <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="irqHandlingMethod" >
      <![CDATA[
         \t/**
         \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
         \t * Used when each channel has an individual handler (IRQ vector)
         \t *
         \t *  @tparam pitChannelNum Channel number
         \t */
         \ttemplate<PitChannelNum pitChannelNum>
         \tstatic void irqHandler() {
         \t   static_assert(Info::NumChannels==Info::irqCount, "Internal error - unmatched vectors/channels");
         \t
         \t   // Clear interrupt flag
         \t   pit->CHANNEL[pitChannelNum].TFLG = PIT_TFLG_TIF_MASK;
         \t
         \t   // If a one-shot then stop channel
         \t   if (clearOnEvent&(1<<pitChannelNum)) {
         \t      disableChannel(PitChannelNum(pitChannelNum));
         \t      clearOnEvent &= ~(1<<pitChannelNum);
         \t   }
         \t   Info::sCallbacks[pitChannelNum]();
         \t}
         \t\n
      ]]>
      </template>
   </if>

   <!--  ==================== Common ======================== -->

   <template key="/HARDWARE/StaticObjects" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Callback table of programmatically set handlers for $(_Class)
      \t */
      \tPitInfo::CallbackFunction PitInfo::sCallbacks[] = {\n
   ]]></template>
   <for keys="ch" dim="=pit_channel_dim" >
      <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
         \t   \$(_Structname)BasicInfo::unhandledCallback,\n
      ]]></template>
   </for>
   <template key="/HARDWARE/StaticObjects"  codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t};\n\n
   ]]></template>

<!-- Common Initialisation class -->
   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   PitMcrMdis_ClockEnabled                   // Module Disable,
      \t *   PitMcrFrz_TimersRunInDebug                // Freeze,
      \t *
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--  Common Initialisation class member variables -->

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="pit_mcr_mdis,pit_mcr_frz"
   ><![CDATA[
      \t   /// Module Control Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

<!-- Common Initialisation class configure methods -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * The peripheral is enabled.
      \t * Only shared hardware is initialised. Channel hardware is unchanged.
      \t * Channel reservations are cleared.
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t
      \t   // Configure common settings
      \t   pit->MCR    = init.mcr;
      \t
      \t   // Clear channel reservations
      \t   allocatedChannels = -1;
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) with default settings.
      \t * Shared hardware is initialised.
      \t * All channel hardware is configured with their default settings.
      \t * The configuration is determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update shared hardware
      \t   configure(Info::DefaultInitValue);
      \t
      \t   // Update channel settings
      \t   configure(Info::DefaultChannelInitValues);
      \t}
      \t
      \t/**
      \t * Enables and configures the $(_BASENAME) if not already done.
      \t * If required:
      \t *  - Shared hardware is initialised.
      \t *  - All channel hardware is configured with their default settings.
      \t *  - The configuration is determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigureIfNeeded() {
      \t
      \t    enable();
      \t
      \t   // Check if disabled and configure if so
      \t   if ((pit->MCR & PIT_MCR_MDIS_MASK) != 0) {
      \t      defaultConfigure();
      \t   }
      \t}
      \t\n
   ]]></template>

<!--  Common Initialisation class constructors -->

   <for keys="v" values="pit_mcr_mdis; pit_mcr_frz">
      <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(v)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      this->%registerName = (this->%registerName&~%mask) | %paramExpression;
         \t   }\n\n
      ]]></variableTemplate>
   </for>

<!-- End of Common Initialisation class -->
   <variableTemplate namespace="usbdm" discardRepeats="true" variables="irqHandlingMethod" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t};// class $(_Structname)BasicInfo::Init
      \t\n
      ]]>
   </variableTemplate>

<!--   ========== PIT ChannelInit class =============================== -->

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_Baseclass) channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_Class) channel
      \t * // Parameters available may vary with device - see $(_Class)::DefaultChannelInitValues[] for relevant example
      \t * static const Pit::ChannelInit channelInit {
      \t *       PitChannelNum_0,
      \t *
      \t *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      \t *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      \t *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
      \t *       callBackFunction,          // Call-back function to use
      \t *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
      \t *       3999_ticks,                // Reload value for channel (in ticks or seconds)
      \t *
      \t *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
      \t *                                            This becomes a base value modified by above values.
      \t * };
      \t *
      \t * // Initialise PIT channel from values specified above
      \t * Pit::configure(channelInit)
      \t * @endcode
      \t */
      \tclass ChannelInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]>
   </template>

<!-- Channel Initialisation class member variables -->

   <variableTemplate namespace="usbdm" discardRepeats="true" variables="irqHandlingMethod" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="pit_ldval_tsv[]"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName = 0_ticks;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/secondsSupport"
      variables="pit_period[]"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName = 0_s;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="pit_tctrl_ten[],pit_tctrl_chn[],pit_tctrl_tie[]"
   ><![CDATA[
      \t   /// Timer Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName0 = %symbolicExpression1;
      \t\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="pit_channelNumber"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName = PitChannelNum_None;\n\n
   ]]></variableTemplate>

<!-- Channel Initialisation class Constructors -->

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r" values="pit_channelNumber;pit_ldval_tsv[]" >
      <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo&amp;&amp;secondsSupport"
      variables="pit_period[]"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r" values="pit_tctrl_ten[];pit_tctrl_tie[];pit_tctrl_chn[1]" >
      <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

<!--   Default Initialisation value -->

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      separator=","
      terminator=","
      variables="
            pit_mcr_mdis,
            pit_mcr_frz
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]>
   </variableTemplate>

   <template codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Default initialisation values for PIT channels
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
   ]]></template>

   <for keys="ch" dim="=NumChannels" >
      <variableTemplate  codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         separator=","
         terminator=","
         variables="
            pit_tctrl_ten[%(ch)],
            pit_tctrl_chn[%(ch)],
            pit_tctrl_tie[%(ch)],
            pit_ldval_tsv[%(ch)]"
         >
      <![CDATA[
         \t   {
         \t   PitChannelNum_%(ch),
         %initExpression
         \t   },\n
      ]]></variableTemplate>
   </for>

   <template codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}; // DefaultChannelInitValues\n\n
   ]]>
   </template>

<!-- Channel Initialisation class configure method -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true"
             codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t
      \t/**
      \t * Configure $(_BASENAME) channel from values specified in init
      \t * The PIT shared hardware will be default initialised if necessary.
      \t * This version allows the channel number to be explicitly given to allow
      \t * sharing of an init class for channels requiring the same configuration.
      \t *
      \t * @param channeNum Number of channel to initialise
      \t * @param init      Class containing initialisation values (channel number is ignored)
      \t */
      \tstatic void configure(PitChannelNum channelNum, const typename Info::ChannelInit &init) {
      \t
      \t   // Enable peripheral if needed using default settings
      \t   defaultConfigureIfNeeded();
      \t
      \t   // Disable channel
      \t   pit->CHANNEL[channelNum].TCTRL = 0;
      \t
      \t   Ticks ldval = init.ldval;
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true"
             codeGenCondition="/$(_BASENAME)/secondsSupport" ><![CDATA[
      \t   if (init.period != 0) {
      \t      ldval = Ticks(convertSecondsToTicks(init.period)-1);
      \t   }\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true"
             codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t
      \t   pit->CHANNEL[channelNum].LDVAL = ldval;
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" condition="!irq_enum"
             codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t   setCallback(init.callbackFunction);
      \t   Info::enableNvicInterrupts(init.irqlevel);
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" condition="irq_enum"
             codeGenCondition="/$(_BASENAME)/irqHandlingMethod" ><![CDATA[
      \t   setCallback(channelNum, init.callbackFunction);
      \t   Info::enableNvicInterrupts(channelNum, init.irqlevel);
      \t\n
   ]]></template>
   <template discardRepeats="true" key="/$(_BASENAME)/InitMethod" namespace="all"
             codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t   // Configure channel
      \t   pit->CHANNEL[channelNum].TCTRL = init.tctrl;
      \t}
      \t
      \t/**
      \t * Configure multiple PIT channels
      \t *
      \t * @tparam N   Number of channels (deduced)
      \t *
      \t * @param ar   Array of channel-init structures
      \t */
      \ttemplate<int N>
      \tstatic void configure(const typename Info::ChannelInit (&ar)[N]) {
      \t   for (int i=0; i<N; i++) {
      \t      configure(ar[i]);
      \t   }
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) channel from values specified in init.
      \t * The PIT shared hardware will be default initialised if necessary
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::ChannelInit &init) {
      \t   configure(init.channelnumber, init);
      \t}
      \t\n
   ]]></template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t};// class $(_Structname)BasicInfo::ChannelInit
      \t\n
      ]]>
   </template>

   <template namespace="usbdm" discardRepeats="true" >
   <![CDATA[
      }; // class $(_Structname)BasicInfo\n\n
   ]]>
   </template>

   <template codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <!-- condition="pit_ltmr64l_lth"  -->
   <template condition="pit_ltmr64h_lth_present" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @param[out] upper Upper 32-bits of combined counter
      \t * @param[out] lower Lower 32-bits of combined counter
      \t */
      \tstatic void readChainedCounter(uint32_t &upper, uint32_t &lower) {
      \t   upper = pit->LTMR64H;
      \t   lower = pit->LTMR64L;
      \t}\n\n
   ]]></template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      /**
       * Class representing $(_NAME)
       */
      class $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};
      \n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * @brief class representing a PIT channel
      \t */
      \tusing $(_Class)Channel = $(_Class)::PitChannel;
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      /**
       * MACRO defining the start of a interrupt handler for a PIT channel
       * This will override the handler incorporated within the PIT class.
       *
       * @param channel Channel being used.
       *
       * @example
       * PIT$(_instance)_CHANNEL0_HANDLER() {
       *    console.writeln("PIT$(_instance) Channel 0 Handler");
       *    // Clear interrupt flag
       *    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
       * }
       */
       \n
   ]]></template>

   <for keys="ch" dim="=NumChannels">
      <template key="/PIT/declarations" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
      <![CDATA[
         #define PIT$(_instance)_CHANNEL%(ch)_HANDLER() template<>template<> void Pit$(_instance)::Channel<%(ch)>::irqHandler()\n
      ]]></template>
   </for>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PitValidate" >
   </validate>

   <projectActionList id = "pit_files" >
      <copy source="Snippets/pit-example1.cpp"       target="Snippets/pit-example1.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example2-MK.cpp"    target="Snippets/pit-example2.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example3-MK.cpp"    target="Snippets/pit-example3.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"   overwrite="true" derived="true" />
      <copy source="Project_Headers/pit-MK.h"        target="Project_Headers/pit.h"     overwrite="true" derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* SIM configuration ****************** -->
   <category name="Advanced" description="SIM configuration">
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
   </category>
   <deleteVariable key="_scgc_clock"  mustExist="false" />

   <signals enabledBy="enablePeripheralSupport" />

</fragment>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pit_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <constant key="definitionsInHeader" value="true" type="Boolean" />

<!--
   <if condition="=(_hardwareIrqCount==pit_channel_dim)">
      <for keys="irqNum" values="=_hardwareIrqNums" iterationVar="ch" >
         <choiceOption key="irqLevel_Ch%(ch)"
            hidden="true"
            hiddenBy="!pit_tctrl_ten[%(ch)]"
            enabledBy="pit_tctrl_ten[%(ch)] &amp;&amp;irqHandlingMethod"
            description="IRQ priority level for Ch%(ch)"
            toolTip='="Priority level used to configure the NVIC for channel %(ch)\n
                     Selecting -Interrupts Disabled- will disable interrupts in the NVIC when the channel is configured"'
            valueFormat="%s"
            disabledValue="Interrupts disabled"
            derivedFrom="/PCR/nvic_irqLevel"
            >
         </choiceOption>

         <clipboard key='="handler_template_Ch%(ch)"'
            hidden="true"
            hiddenBy="!pit_tctrl_ten[%(ch)]"
            description="Interrupt handler template"
            toolTip='Interrupt handler example'>
            <![CDATA[="
               \t/**
               \t * Handler for PIT Channel %(ch) interrupt
               \t */
               \tstatic void "+ReplaceAll("%(irqNum)","^(.+)_IRQn$","$1_IRQHandler")+"() {
               \t   Pit::clearInterruptFlag(%(ch));
               \t   ...
               \t};
               \t"
            ]]>
         </clipboard>
      </for>
   </if>
 -->

   <if condition="=(_hardwareIrqCount&lt;pit_channel_dim)">
      <!-- Pretend there is a handler for each channel -->

      <!-- User pseudo-interrupts  -->
      <equation key="_userIrqCount" value="=pit_channel_dim" />

      <!-- IRQ names -->
      <equation key="_userIrqNums" value='=""' />
      <for keys="irq" dim="=_userIrqCount" >
         <if condition='=_userIrqNums!=""'>
            <equation key="_userIrqNums" value='=_userIrqNums+";"'/>
         </if>
         <equation key="_userIrqNums" value='=_userIrqNums+"$(_NAME)_Ch"+"%(irq)_IRQn"'/>
      </for>
   </if>

   <equation key="suppressIrqHandler"         value=""       />
   <equation key="irq_parameters"             value=""          />
   <equation key="irq_dummy_parameters"       value=""          />
   <equation key="irq_call_parameters"        value=""          />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

<!-- ____ Constants ________________ -->
   <!-- Defined in SIM -->
   <intOption key="NumChannels" locked="true" derived="true"
      hidden="true"
      value="=pit_channel_dim"
      description="Number of PIT channels" />

   <!-- Derived from SVD -->
   <intOption key="NumVectors" locked="true" derived="true"
      hidden="true"
      value="=_hardwareIrqCount"
      description="Number of PIT IRQ vectors" />

   <aliasOption key="NumChannels" condition="=_debugcode"/>
   <aliasOption key="NumVectors"  condition="=_debugcode"/>

   <for keys="c" dim="=NumChannels">
      <signal name="$(_NAME)_CH%(c)" pin="PIT_CH%(c)" />
   </for>

   <template><![CDATA[
      \t//! Number of PIT channels
      \tstatic constexpr uint32_t NumChannels  = $(NumChannels);\n\n
   ]]></template>

   <!-- ____ Class Declaration ________________ -->

   <constant key="_class_declaration" type="String"
      value="&quot;$(_Info) : public $(_BasicInfo)&quot;" />

   <binaryOption key="/$(_BASENAME)/secondsSupport"
      enabledBy="$(_BasicInfoGuard)"
      modify="true"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point libraries is necessary to support routines using seconds in runtime code.\n
               This is seldom needed and the overhead can be avoided by disabling this option" >
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <choiceOption key="pit_channelNumber"
      hidden="true"
      description="Pit Channel Number"
      typeName="PitChannelNum"
      valueFormat="%s"
      baseType="uint8_t"
      toolTip="Selected PIT channel" >
      <choiceExpansion keys="ch" dim="=NumChannels"
                       value="%(ch)" name="Channel %(ch)" enum="%(ch)" signal="PIT_CH%(i)" />
      <choice value="0b10000000" name="Channel Not Allocated"  enum="None" />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <choiceOption key="pitClockConfig" condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      target="pitInputClock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for calculations involving the bus clock" >
      <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="pitInputClock"
      enabledBy="enablePeripheralSupport"
      locked="true"
      derived="true"
      description="PIT input clock"
      toolTip="The PIT uses the bus clock for timing.\n
               The frequency shown is based on the selected clock configuration.\n
               This frequency is used as the basis for calculations on this page."
      units="Hz"
      />

   <!-- ____ MCR ________________ -->

   <binaryOption key="pit_mcr_mdis" condition="pit_mcr_mdis_present"
      enabledBy="enablePeripheralSupport"
      hidden="true"
      typeName="PitOperation"
      baseType="uint8_t"
      toolTip="Disabled PIT module clock"
      description="Module Disable" >
      <choice name="PIT enabled"   value="0" enum="Enabled" isDefault="true" />
      <choice name="PIT disabled"  value="1" enum="Disabled"  />
   </binaryOption>

   <binaryOption key="pit_mcr_frz" condition="pit_mcr_frz_present"
      enabledBy="enablePeripheralSupport"
      typeName="PitDebugMode"
      baseType="uint8_t"
      description="Freeze in Debug"
      toolTip="Determines if timers are stopped in Debug mode" >
      <choice name="Timers run in Debug"   value="0" enum="RunInDebug"    />
      <choice name="Timers stop in Debug"  value="1" enum="StopInDebug" isDefault="true" />
   </binaryOption>


   <!-- ____ Each Channel ________________ -->

   <for keys="ch" dim="=NumChannels" >
      <title description="Channel %(ch)" />

      <binaryOption key="pit_tctrl_ten[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="enablePeripheralSupport&amp;&amp;(pitInputClock!=0)##Disabled when clock is 0"
         typeName="PitChannelEnable"
         baseType="uint8_t"
         description="Timer Channel Enable"
         toolTip="Allows operation of this channel"
         signal="PIT_CH%(ch)"
         >
         <choice value="0" name="Channel disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Channel enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_ldval_tsv[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         hiddenBy="!pit_tctrl_ten[%(ch)]"
         valueFormat="%s"
         units="ticks"
         baseType="uint32_t"
         description="Reload value channel %(ch)"
         toolTip="Value loaded in timer register on roll-over"
         value="0"
         min="0" max="0xFFFFFFFF" />

      <floatOption key="pit_period[%(ch)]" condition="pit_ldval_tsv_present"
         enabledBy="pit_tctrl_ten[%(ch)]"
         hiddenBy="!pit_tctrl_ten[%(ch)]"
         description="Default period of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1m" min="0" units="s" />

      <binaryOption key="pit_tctrl_chn[%(ch)]"  condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         enabledBy="pit_tctrl_ten[%(ch)]"
         hiddenBy="!pit_tctrl_ten[%(ch)]"
         typeName="PitChannelChain"
         baseType="uint8_t"
         description="Chain with previous channel"
         toolTip="Controls whether the timer channels are chained to create a larger counter" >
         <choice value="0" name="Timers are not chained" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Timers are chained"     enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_tctrl_chnTicks[%(ch)]" condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         hiddenBy="!pit_tctrl_chn[%(ch)]"
         locked="true"
         derived="true"
         ref="(pit_ldval_tsv[%(ch)-1]+1)*(pit_ldval_tsv[%(ch)]+1)"
         description="Duration of chained timers"
         units="ticks"
      />

      <floatOption key="pit_tctrl_chnDelay[%(ch)]" condition="pit_tctrl_chn_present &amp;&amp; (%(ch)>0)"
         hiddenBy="!pit_tctrl_chn[%(ch)]"
         locked="true"
         derived="true"
         ref="pit_tctrl_chnTicks[%(ch)]/(pitInputClock)"
         description="Duration of chained timers"
         units="s"
      />

      <binaryOption key="pit_tctrl_tie[%(ch)]"  condition="pit_tctrl_tie_present"
         enabledBy="pit_tctrl_ten[%(ch)] &amp;&amp;irqHandlingMethod"
         hiddenBy="!pit_tctrl_ten[%(ch)]"
         typeName="PitChannelAction"
         baseType="uint8_t"
         description="Action on timer event"
         toolTip="Allows interrupts from this channel" >
         <choice value="0" name="None"       enum="None"       isDefault="true"/>
         <choice value="1" name="Interrupt"  enum="Interrupt"  />
      </binaryOption>

      <aliasOption key="irqLevel_Ch%(ch)" optional="true" locked="false" />
      <aliasOption key="handler_template_Ch%(ch)" optional="true" />

   </for>

   <!-- ____ Getters and Setters ________________ -->

   <for keys="field:name"
        values="
      pit_mcr_mdis : Enable;
      pit_mcr_frz  : DebugMode" >
      <variableTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!--   ____ static/member functions ________________ -->

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : /$(_BASENAME)/staticFunctions ;
                     : const : chan    : /$(_BASENAME)/memberFunctions" >
      <template key="%(location)" codeGenCondition="$(_BasicInfoGuard)" >
      <![CDATA[
         \t   /**
         \t    * Configure PIT channel from values specified in init.
         \t    * The PIT shared hardware will be default initialised if necessary
         \t    *
         \t    * @param init Class containing initialisation values (channel number is ignored)
         \t    */
         \t   %(static) void configure(const ChannelInit &init) %(const) {
         \t      PitBase_T<Info>::configure(%(chan), init);
         \t   }
         \t
         \t   /**
         \t    *  Enables and configures the PIT if not already done.
         \t    *  This also disables all channel interrupts and channel reservations if newly configured.
         \t    */
         \t   %(static) void defaultConfigureIfNeeded() %(const) {
         \t      PitBase_T<Info>::defaultConfigureIfNeeded();
         \t   }
         \t
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in timer ticks (usually bus clock)
         \t    *  @param[in]  pitChannelAction     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Ticks             interval,
         \t         PitChannelAction  pitChannelAction=PitChannelAction_None) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelAction);
         \t   }
         \t
         \t   /**
         \t    * Clear channel interrupt flag
         \t    */
         \t   %(static) void clearInterruptFlag() %(const) {
         \t      PitBase_T<Info>::clearInterruptFlag(%(chan));
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    *  Configure the PIT channel
         \t    *
         \t    *  @param[in]  interval          Interval in seconds
         \t    *  @param[in]  pitChannelAction     Whether to enable interrupts
         \t    *
         \t    *  @note The timer channel is disabled before configuring so that period changes
         \t    *        have immediate effect.
         \t    */
         \t   %(static) void configure(
         \t         Seconds           interval,
         \t         PitChannelAction  pitChannelAction=PitChannelAction_None) %(const) {
         \t
         \t      PitBase_T<Info>::configureChannel(%(chan), interval, pitChannelAction);
         \t   }
         #endif
         \t
         \t   /**
         \t    *   Enable the PIT channel
         \t    */
         \t   %(static) void enable() %(const) {
         \t      PitBase_T<Info>::enableChannel(%(chan));
         \t   }
         \t
         \t   /**
         \t    *   Disable the PIT channel
         \t    */
         \t   %(static) void disable() %(const) {
         \t      PitBase_T<Info>::disableChannel(%(chan));
         \t   }
         \t
         \t   /**
         \t    * Set period in ticks
         \t    *
         \t    * @param[in]  interval Interval in ticks
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Ticks interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         \t
         \t   /**
         \t    * Read channel counter
         \t    *
         \t    * @return Current down-counter value
         \t    */
         \t   %(static) uint32_t readCounter() %(const) {
         \t      return pit->CHANNEL[%(chan)].CVAL;
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set period in seconds
         \t    *
         \t    * @param[in]  interval Interval in seconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriod(Seconds interval) %(const) {
         \t      PitBase_T<Info>::setPeriod(%(chan), interval);
         \t   }
         #endif
         \t   /**
         \t    * Set period in microseconds
         \t    *
         \t    * @param[in]  microseconds Interval in microseconds
         \t    *
         \t    * @note If the timer is currently enabled this value will be loaded on the next expiration.
         \t    *       To have immediate effect it is necessary to use configure().
         \t    */
         \t   %(static) void setPeriodInMicroseconds(uint32_t microseconds) %(const) {
         \t      uint64_t interval = ((uint64_t)microseconds*Info::getClockFrequency())/1000000;
         \t      usbdm_assert(interval<0xFFFFFFFFUL,"Interval too long");
         \t      PitBase_T<Info>::setPeriod(%(chan), Ticks(uint32_t(interval)));
         \t   }
         \t
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in timer ticks (usually bus clock period)
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Ticks interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /$(_BASENAME)/secondsSupport
         \t   /**
         \t    *  Use a PIT channel to implement a busy-wait delay
         \t    *
         \t    *  @param[in]  interval  Interval to wait in seconds
         \t    *
         \t    *  @note Function does not return until interval has expired
         \t    */
         \t   %(static) void delay(Seconds interval) %(const) {
         \t      PitBase_T<Info>::delay(%(chan), interval);
         \t   }
         #endif
         \t
         \t   /**
         \t    * Set action to take on event
         \t    *
         \t    * @param[in]  pitChannelAction Action to take on event
         \t    */
         \t   %(static) void setChannelAction(PitChannelAction pitChannelAction) %(const) {
         \t      PitBase_T<Info>::setChannelAction(%(chan), pitChannelAction);
         \t   }
         \t
         \t   /**
         \t    * Enable interrupts in NVIC
         \t    */
         \t   %(static) void enableNvicInterrupts() %(const) {
         \t      Info::enableNvicInterrupts(IrqNum(%(chan)));
         \t   }
         \t
         \t   /**
         \t    * Enable and set priority of interrupts in NVIC
         \t    * Any pending NVIC interrupts are first cleared.
         \t    *
         \t    * @param[in]  nvicPriority   Interrupt priority
         \t    */
         \t   %(static) void enableNvicInterrupts(NvicPriority nvicPriority) %(const) {
         \t      Info::enableNvicInterrupts(IrqNum(%(chan)), nvicPriority);
         \t   }
         \t
         \t   /**
         \t    * Disable interrupts in NVIC
         \t    */
         \t   %(static) void disableNvicInterrupts() %(const) {
         \t      Info::disableNvicInterrupts(IrqNum(%(chan)));
         \t   }
         \t\n
      ]]>
      </template>
   </for>

   <for keys="static : const : chan    : location"
      values="static :       : CHANNEL : staticFunctions ;
                     : const : chan    : memberFunctions" >
      <template key="%(location)" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
      <![CDATA[
         \t   /**
         \t    * Set one-shot timer callback
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  tickInterval      Interval in timer ticks (usually bus clock period)
         \t    */
         \t   %(static) void oneShot(CallbackFunction callback, Ticks tickInterval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, tickInterval);
         \t   }
         \t
         #if $(/PIT/secondsSupport:false) // /PIT/secondsSupport
         \t   /**
         \t    * Set one-shot timer callback.
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  interval          Interval in seconds until callback is executed
         \t    */
         \t   %(static) void  oneShot(CallbackFunction callback, Seconds interval) %(const) {
         \t      PitBase_T<Info>::oneShot(%(chan), callback, interval);
         \t   }
         #endif
         \t
         \t   /**
         \t    * Set one-shot timer callback in microseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  microseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMicroseconds(CallbackFunction callback, uint32_t microseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMicroseconds(%(chan), callback, microseconds);
         \t   }
         \t
         \t   /**
         \t    * Set one-shot timer callback in milliseconds
         \t    *
         \t    *  @note It is necessary to enable NVIC interrupts beforehand
         \t    *
         \t    *  @param[in]  callback          Callback function to be executed on timeout.
         \t    *  @param[in]  milliseconds      Interval in milliseconds
         \t    */
         \t   %(static) void oneShotInMilliseconds(CallbackFunction callback, uint32_t milliseconds) %(const) {
         \t      PitBase_T<Info>::oneShotInMilliseconds(%(chan), callback, milliseconds);
         \t   }
         \t
         \t   /**
         \t    * Set interrupt callback function.
         \t    *
         \t    * @param pitIrqNum Used to identify peripheral interrupt
         \t    * @param callback  Callback function to execute on interrupt
         \t    *                  Use nullptr to remove callback.
         \t    */
         \t   %(static) void setCallback(CallbackFunction callback) %(const) {
         \t      PitBase_T<Info>::setCallback(%(chan), callback);
         \t   }
         \t\n
         ]]>
      </template>
   </for>

   <!--   ____ Interrupt handler ________________ -->

   <template codeGenCondition="irqHandlingMethod" condition="=(_hardwareIrqCount==1)">
   <![CDATA[
      \t/** Bitmask used to indicate a channel call-back is one-shot */
      \tstatic inline uint8_t clearOnEvent = 0;
      \t
      \t/**
      \t *  $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t *  Used when all channels share a single handler (needs to poll channel flags)
      \t */
      \tstatic void irqHandler() {
      \t
      \t   for (unsigned pitChannelNum=0; pitChannelNum<NumChannels; pitChannelNum++) {
      \t
      \t      auto &channel = pit->CHANNEL[pitChannelNum];
      \t
      \t      if ((channel.TCTRL & PIT_TCTRL_TIE_MASK)==0) {
      \t         // IRQ not enable on channel
      \t         continue;
      \t      }
      \t      if (channel.TFLG & PIT_TFLG_TIF_MASK) {
      \t
      \t         // Clear interrupt flag
      \t         channel.TFLG = PIT_TFLG_TIF_MASK;
      \t
      \t         // Call handler
      \t         sCallbacks[pitChannelNum]();
      \t
      \t         // If a one-shot then stop channel
      \t         if (clearOnEvent&(1<<pitChannelNum)) {
      \t            channel.TCTRL = channel.TCTRL & ~PIT_TCTRL_TEN_MASK;
      \t            sCallbacks[pitChannelNum] = unhandledCallback;
      \t            clearOnEvent &= ~(1<<pitChannelNum);
      \t         }
      \t      }
      \t   }
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" condition="=(_hardwareIrqCount>1)" >
   <![CDATA[
      \t/** Bitmask used to indicate a channel call-back is one-shot */
      \tstatic inline uint8_t clearOnEvent = 0;
      \t
      \t/**
      \t *  $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t *  Used when each channel has an individual handler (IRQ vector)
      \t *
      \t *  @tparam pitChannelNum Channel number
      \t */
      \ttemplate<IrqNum pitIrqNum>
      \tstatic void irqHandler() {
      \t
      \t   auto &channel = pit->CHANNEL[pitIrqNum];
      \t
      \t   auto handler = sCallbacks[pitIrqNum];
      \t
      \t   // Clear interrupt flag
      \t   channel.TFLG = PIT_TFLG_TIF_MASK;
      \t
      \t   // If a one-shot then stop channel
      \t   if (clearOnEvent&(1<<pitIrqNum)) {
      \t      channel.TCTRL = channel.TCTRL & ~PIT_TCTRL_TEN_MASK;
      \t      sCallbacks[pitIrqNum] = unhandledCallback;
      \t      clearOnEvent &= ~(1<<pitIrqNum);
      \t   }
      \t
      \t   // Call handler
      \t   handler();
      \t}
      \t\n
   ]]>
   </template>


<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/** Bit-mask of allocated channels */
      \tstatic inline uint32_t allocatedChannels = 0;
      \t
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   PitMcrMdis_ClockEnabled                   // Module Disable,
      \t *   PitMcrFrz_TimersRunInDebug                // Freeze,
      \t *
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--  Common Initialisation class member variables -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)" condition="=(_hardwareIrqCount==1)"
      variables="/PCR/nvic_irqLevel,irqLevel"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName0 = %defaultValue;
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="pit_mcr_mdis,pit_mcr_frz"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

<!--  Common Initialisation class constructors -->

   <!-- Per-channel IRQ handler always -->
   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"  condition="false"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)" condition="=(_hardwareIrqCount==1)"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="v" values="pit_mcr_mdis; pit_mcr_frz">
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(v)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      this->%registerName = (this->%registerName&~%mask) | %paramExpression;
         \t   }\n\n
      ]]></variableTemplate>
   </for>

<!-- End of Common Initialisation class -->
   <variableTemplate where="basicInfo" variables="irqHandlingMethod" codeGenCondition="$(_BasicInfoGuard)"
   ><![CDATA[
      \t};// class $(_BasicInfo)::Init
      \t\n
      ]]>
   </variableTemplate>

<!-- Common Initialisation class configure methods -->

   <for keys="ch" dim="=NumChannels" >
      <equation key="channelsConfigured" value='=channelsConfigured+"||pit_tctrl_ten[%(ch)]"' condition="channelsConfigured"  />
      <equation key="channelsConfigured" value="pit_tctrl_ten[%(ch)]"                         condition="!channelsConfigured" />
      <!-- printVar key="channelsConfigured"/ -->
   </for>

   <template codeGenCondition="enablePeripheralSupport">
   <![CDATA[
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * The peripheral is enabled.
      \t * Only shared hardware is initialised. Channel hardware is unchanged.
      \t * Channel reservations are cleared.
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="@_hardwareIrqCount==1" ><![CDATA[
      \t   // Single shared hardware IRQ
      \t   enableNvicInterrupts(init.irqlevel);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport">
   <![CDATA[
      \t   // Enable peripheral
      \t   enable();
      \t   (void)pit->MCR; // Dummy read to ensure clock enable completed (errata e7914)
      \t
      \t   // Configure common settings
      \t   pit->MCR    = init.mcr;
      \t
      \t   // Clear channel reservations
      \t   allocatedChannels = -1;
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) with default settings.
      \t * Shared hardware is initialised.
      \t * All channel hardware is configured with their default settings.
      \t * The configuration is determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update shared hardware
      \t   configure(DefaultInitValue);
      \t\n
   ]]></template>
   <template codeGenCondition="=channelsConfigured" condition="@_hardwareIrqCount==1" ><![CDATA[
      \t   // Update channel settings
      \t   configure(DefaultChannelInitValues);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport">
   <![CDATA[
      \t}
      \t
      \t/**
      \t * Enables and configures the $(_BASENAME) if not already done.
      \t * If required:
      \t *  - Shared hardware is initialised.
      \t *  - All channel hardware is configured with their default settings.
      \t *  - The configuration is determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigureIfNeeded() {
      \t
      \t    enable();
      \t
      \t   // Check if disabled and configure if so
      \t   if ((pit->MCR & PIT_MCR_MDIS_MASK) != 0) {
      \t      // Update shared hardware
      \t      configure(DefaultInitValue);
      \t   }
      \t}
      \t\n
   ]]></template>

<!-- Default Common Initialisation value -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      padToComments="35"
      variables="
            pit_mcr_mdis,
            pit_mcr_frz,
            irqLevel
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initNonZeroValues
      \t};\n\n
   ]]>
   </variableTemplate>

<!--   ____ PIT ChannelInit class ________________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_Baseclass) channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for $(_Class) channel
      \t * // Parameters available may vary with device - see $(_Class)::DefaultChannelInitValues[] for relevant example
      \t * static const Pit::ChannelInit channelInit {
      \t *       PitChannelNum_0,
      \t *
      \t *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      \t *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      \t *       PitChannelAction_None ,    // Timer Interrupt Enable - Interrupts are disabled
      \t *       callBackFunction,          // Call-back function to use
      \t *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
      \t *       3999_ticks,                // Reload value for channel (in ticks or seconds)
      \t *
      \t *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
      \t *                                            This becomes a base value modified by above values.
      \t * };
      \t *
      \t * // Initialise PIT channel from values specified above
      \t * Pit::configure(channelInit)
      \t * @endcode
      \t */
      \tclass ChannelInit {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   ChannelInit(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]>
   </template>

<!-- Channel Initialisation class member variables -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      %multilineDescription
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="pit_ldval_tsv[]"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName = 0_ticks;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_BASENAME)/secondsSupport"
      variables="pit_period[]"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName = 0_s;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="pit_tctrl_ten[],pit_tctrl_chn[],pit_tctrl_tie[]"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %baseType %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="=(_hardwareIrqCount>1)"
      variables="/PCR/nvic_irqLevel,irqLevel"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName0 = %defaultValue;
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="pit_channelNumber"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %returnType %registerName = PitChannelNum_None;\n\n
   ]]></variableTemplate>

<!-- Channel Initialisation class Constructors -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="=(_hardwareIrqCount>1)"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r" values="pit_channelNumber;pit_ldval_tsv[]" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)&amp;&amp;secondsSupport"
      variables="pit_period[]"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r" values="pit_tctrl_ten[];pit_tctrl_tie[];pit_tctrl_chn[1]" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

<!-- End of PIT ChannelInit class -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
   ><![CDATA[
      \t};// class $(_BasicInfo)::ChannelInit
      \t\n
      ]]>
   </template>

<!-- Channel Initialisation configure method -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t/**
      \t * Configure $(_BASENAME) channel from values specified in init
      \t * The PIT shared hardware will be default initialised if necessary.
      \t * This version allows the channel number to be explicitly given to allow
      \t * sharing of an init class for channels requiring the same configuration.
      \t *
      \t * @param channelNum Number of channel to initialise
      \t * @param init       Class containing initialisation values (channel number is ignored)
      \t */
      \tstatic void configure(PitChannelNum channelNum, const ChannelInit &init) {
      \t
      \t   if (channelNum>=NumChannels) {
      \t      // Illegal PIT channel number
      \t      __BKPT();
      \t      return;
      \t   }
      \t   // Enable peripheral if needed using default settings
      \t   defaultConfigureIfNeeded();
      \t
      \t   // Disable channel
      \t   pit->CHANNEL[channelNum].TCTRL = 0;
      \t
      \t   Ticks ldval = init.ldval;
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(/$(_BASENAME)/secondsSupport)" ><![CDATA[
      \t   if (init.period != 0) {
      \t      ldval = Ticks(convertSecondsToTicks(init.period)-1);
      \t   }\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   pit->CHANNEL[channelNum].LDVAL = ldval;
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t   setCallback(IrqNum(channelNum), init.callbackFunction);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="@_hardwareIrqCount>1" ><![CDATA[
      \t   enableNvicInterrupts(IrqNum(channelNum), init.irqlevel);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Configure channel
      \t   pit->CHANNEL[channelNum].TCTRL = init.tctrl;
      \t}
      \t
      \t/**
      \t * Configure multiple PIT channels
      \t *
      \t * @tparam N   Number of channels (deduced)
      \t *
      \t * @param ar   Array of channel-init structures
      \t */
      \ttemplate<int N>
      \tstatic void configure(const ChannelInit (&ar)[N]) {
      \t   for (int i=0; i<N; i++) {
      \t      configure(ar[i]);
      \t   }
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) channel from values specified in init.
      \t * The PIT shared hardware will be default initialised if necessary
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const ChannelInit &init) {
      \t   configure(init.channelnumber, init);
      \t}
      \t\n
   ]]></template>

<!-- Default Channel Initialisation value -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Default initialisation values for PIT channels
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
   ]]></template>

   <for keys="ch" dim="=NumChannels" >
      <variableTemplate codeGenCondition="$(_InfoGuard)&amp;&amp;pit_tctrl_ten[%(ch)]"
         separator=","
         terminator=","
         padToComments="35"
         variables="
            pit_tctrl_ten[%(ch)],
            pit_tctrl_chn[%(ch)],
            pit_tctrl_tie[%(ch)],
            pit_ldval_tsv[%(ch)]"
         >
      <![CDATA[
         \t   {
         \t   PitChannelNum_%(ch),
         %initExpression\n
      ]]></variableTemplate>
      <variableTemplate codeGenCondition="$(_InfoIrqGuard)&amp;&amp;pit_tctrl_ten[%(ch)]"
         separator=","
         terminator=","
         padToComments="35"
         variables="
            irqLevel_Ch%(ch),
            handlerName_Ch%(ch)"
         >
      <![CDATA[
         %initExpression\n
      ]]></variableTemplate>
      <template codeGenCondition="$(_InfoGuard)&amp;&amp;pit_tctrl_ten[%(ch)]" >
      <![CDATA[
         \t   },\n
      ]]></template>
   </for>

   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t}; // DefaultChannelInitValues\n\n
   ]]>
   </template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(/$(_BASENAME)/secondsSupport)" ><![CDATA[
      \t/**
      \t * Convert time in ticks to time in seconds
      \t *
      \t * @param[in] ticks Time interval in ticks
      \t *
      \t * @return Time interval in seconds
      \t */
      \tstatic Seconds convertTicksToSeconds(Ticks ticks) {
      \t   return Seconds(((float)(unsigned)ticks)/getClockFrequency());
      \t}
      \t
      \t/**
      \t * Converts time in seconds to time in ticks
      \t *
      \t * @param[in] seconds Time interval in seconds
      \t *
      \t * @return Time interval in ticks
      \t *
      \t * @note Will set error code if calculated value is unsuitable
      \t */
      \tstatic Ticks convertSecondsToTicks(Seconds seconds) {
      \t   float intervalInTicks = rintf((float)seconds*getClockFrequency());
      \t   usbdm_assert(intervalInTicks <= 0xFFFFFFFFUL, "Interval is too long");
      \t   usbdm_assert(intervalInTicks > 0, "Interval is too short");
      \t   if (intervalInTicks > 0xFFFFFFFFUL) {
      \t      setErrorCode(E_TOO_LARGE);
      \t   }
      \t   if (intervalInTicks <= 0) {
      \t      setErrorCode(E_TOO_SMALL);
      \t   }
      \t   return Ticks(intervalInTicks);
      \t}
      \t\n
   ]]></template>

   <!-- condition="pit_ltmr64l_lth"  -->
   <template condition="pit_ltmr64h_lth_present" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @param[out] upper Upper 32-bits of chained channels
      \t * @param[out] lower Lower 32-bits of chained channels
      \t */
      \tstatic void readChainedCounter(uint32_t &upper, uint32_t &lower) {
      \t   upper = pit->LTMR64H;
      \t   lower = pit->LTMR64L;
      \t}\n\n
   ]]></template>

   <template condition="pit_ltmr64h_lth_present" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @return 64-bits of chained channels
      \t */
      \tstatic uint64_t readChainedCounter() {
      \t   uint64_t count;
      \t   count  = uint64_t(pit->LTMR64H)<<32;
      \t   count += pit->LTMR64L;
      \t   return count;
      \t}\n\n
   ]]></template>

   <!-- ____ Common ________________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      /**
       * Class representing $(_NAME)
       */
      class $(_Class) : public $(_Baseclass)Base_T<$(_Info)> {};
      \n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * @brief class representing a PIT channel
      \t */
      \tusing $(_Class)Channel = $(_Class)::PitChannel;
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      /**
       * MACRO defining the start of a interrupt handler for a PIT channel
       * This will override the handler incorporated within the PIT class.
       *
       * @param channel Channel being used.
       *
       * @example
       * PIT$(_instance)_CHANNEL0_HANDLER() {
       *    console.writeln("PIT$(_instance) Channel 0 Handler");
       *    // Clear interrupt flag
       *    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
       * }
       */
       \n
   ]]></template>

   <for keys="ch" dim="=NumChannels">
      <template key="/$(_BASENAME)/declarations" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
      <![CDATA[
         #define PIT$(_instance)_CHANNEL%(ch)_HANDLER() template<>template<> void Pit$(_instance)::Channel<%(ch)>::irqHandler()\n
      ]]></template>
   </for>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PitValidate" >
   </validate>

   <projectActionList id = "pit_files" >
      <copy source="Snippets/pit-example1.cpp"       target="Snippets/pit-example1.cpp" overwrite="always" derived="true" />
      <copy source="Snippets/pit-example2-MK.cpp"    target="Snippets/pit-example2.cpp" overwrite="always" derived="true" />
      <copy source="Snippets/pit-example3-MK.cpp"    target="Snippets/pit-example3.cpp" overwrite="always" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"   overwrite="always" derived="true" />
      <copy source="Project_Headers/pit-MK.h"        target="Project_Headers/pit.h"     overwrite="always" derived="true" />
   </projectActionList>

   <!-- ____ Startup ________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "../Project_Headers/$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ________________ -->
   <category name="Advanced" description="SIM configuration">
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <signals enabledBy="enablePeripheralSupport" />

</fragment>

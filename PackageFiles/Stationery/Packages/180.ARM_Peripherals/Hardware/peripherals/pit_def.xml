<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pit_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <xi:include href="_default_instance.xml"/>

   <constant key = "irq_pattern"      value = "^%b(\d+)$"  />
   <constant key = "irq_classHandler" value = "%c%i::Channel&lt;$1&gt;::irqHandler"  />
   <xi:include href="_irqOptionSubstituted.xml"/>
 
   <template><![CDATA[
      \t/// Number of PIT channels
      \tstatic constexpr uint32_t NumChannels  = $(numChannels);
      
      \t/// Type for PIT call-back function
      \ttypedef void (*CallbackFunction)();\n\n
   ]]></template>

   <choiceOption key="pit_channelNumber" 
      hidden="true"
      description="Pit Channel Number"
      enumStem="PitChannelNum"
      valueFormat="%s"
      enumType="uint8_t"
      toolTip="Select a PIT channel">
      <choice value="0"          name="Channel 0"     enum="0" />
      <choice value="1"          name="Channel 1"     enum="1" />
      <choice value="2"          name="Channel 2"     enum="2" />
      <choice value="3"          name="Channel 3"     enum="3" />
      <choice value="0b10000000" name="Channel Not Allocated"  enum="None" />
   </choiceOption>
   
   <intOption key="pitInputClock" constant="true" derived="true"
      ref="/SIM/system_bus_clock"
      description="PIT input clock"  
      units="Hz"
      />

   <binaryOption key="pit_mcr_frz" condition="pit_mcr_frz_present"
      enumStem="PitDebugMode" 
      description="Freeze in debug mode"
      toolTip="Controls whether the timer continues to run in debug mode">
      <choice value="0" name="Timers continue to run in debug mode" enum="Run"  />
      <choice value="1" name="Timers are stopped in Debug mode"     enum="Stop" isDefault="true" />
   </binaryOption>

   <for keys="ch" dim="numChannels">
      <binaryOption key="pit_tctrl_ten[%(ch)]"  condition="pit_tctrl_tie_present"
         enumStem="PitChannelEnable" 
         description="Timer Channel Enable"
         toolTip="Allows operation of this channel">
         <choice value="0" name="Channel disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Channel enabled"  enum="Enabled"  />
      </binaryOption>

      <intOption key="pit_ldval_tsv[%(ch)]" condition="pit_ldval_tsv_present"
         typeName="Ticks"
         valueFormat="%s_ticks"
         description="Reload value channel %(ch)"
         toolTip="Value loaded in timer register on roll-over"
         min="0" max="0xFFFFFFFF" />

      <floatOption key="pit_period[%(ch)]" condition="pit_ldval_tsv_present"
         typeName="Seconds"
         valueFormat="%s_s"
         description="Default period of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1m" min="0" units="s" />
   
      <floatOption key="pit_frequency[%(ch)]" condition="pit_ldval_tsv_present"
         typeName="Hertz"
         valueFormat="%s_Hz"
         description="Default frequency of timer"
         toolTip="Used to calculate the timer load value"
         derived="true"
         value="1k" min="0" units="Hz" />
   
      <binaryOption key="pit_tctrl_chn[%(ch)]"  condition="pit_tctrl_chn_present"
         enumStem="PitChannelChain" 
         description="Chain with previous channel"
         toolTip="Controls whether the timer channels are chained to creater a larger counter">
         <choice value="0" name="Timers are not chained" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Timers are chained"     enum="Enabled"  />
      </binaryOption>

      <binaryOption key="pit_tctrl_tie[%(ch)]"  condition="pit_tctrl_tie_present"
         enumStem="PitChannelIrq" 
         description="Timer Interrupt Enable"
         toolTip="Allows interrupts from this channel">
         <choice value="0" name="Interrupts are disabled" enum="Disabled" isDefault="true"/>
         <choice value="1" name="Interrupts are enabled"  enum="Enabled"  />
      </binaryOption>
   </for>

   <!-- ========== PIT Init class =============================== -->

   <template><![CDATA[
      \t/**
      \t * Class used to do initialisation of a PIT channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Initialisation values for PIT channel
      \t * static const Pit::Init pitInit {
      \t *       PitChannelNum_0,
      \t *
      \t *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      \t *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      \t *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
      \t *       callBackFunction,          // Call-back function to use
      \t *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
      \t *       3999_ticks,                // Reload value for channel (in ticks or seconds)
      \t * };
      \t *
      \t * // Initialise PIT channel from values specified above
      \t * Pit::configure(pitInit)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**                               
      \t    * Copy Constructor                  
      \t    */                             
      \t   constexpr Init(const Init &other) = delete;
      \t   
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!-- Member variables -->
  
   <setTemplate variables="irqHandlingMethod"
    ><![CDATA[
      \t
      #if $(irqHandlingMethod)
      \t   /// %description
      \t   %params = nullptr;
      #endif\n\n
   ]]></setTemplate>
   
   <initialValueTemplate
      variables="pit_ldval_tsv[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate
      variables="pit_period[]"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_s;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate
      variables="pit_tctrl_ten[],pit_tctrl_chn[],pit_tctrl_tie[]"
   ><![CDATA[
      \t   /// Timer Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate
      variables="pit_channelNumber"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = PitChannelNum_None;\n\n
   ]]></initialValueTemplate>

<!-- Configure method -->
  
   <setTemplate variables="pit_tctrl_ten[]" discardRepeats="true" key="/PIT/InitMethod" namespace="all" ><![CDATA[
   \t/**
   \t * Configure a PIT channel from values specified in init
   \t *
   \t * @param init Class containing initialisation values
   \t */
   \tstatic void configure(const typename Info::Init &init) {
   \t   
   \t   // Enable peripheral clock and map pins
   \t   enable();
   \t
   \t   // Configure PIT
   \t   pit->MCR = Info::mcr;
   \t
   \t   // Disable channel
   \t   pit->CHANNEL[init.channelnumber].TCTRL = 0;
   \t
   \t   Ticks ldval = init.ldval;
   \t   if (init.period != 0) {
   \t      ldval = convertSecondsToTicks(init.period);
   \t   }
   \t   pit->CHANNEL[init.channelnumber].LDVAL = ldval;
   \t
   \t   if constexpr (Info::irqHandlerInstalled) {
   \t      // Only set call-back if feature enabled and non-null
   \t      if (init.callbackFunction != nullptr) {
   \t         setCallback(init.channelnumber, init.callbackFunction);
   \t      }
   \t      enableNvicInterrupts(init.channelnumber, init.irqlevel);
   \t   }
   \t   // Configure channel
   \t   pit->CHANNEL[init.channelnumber].TCTRL = init.tctrl;
   \t}\n\n
   ]]></setTemplate>

<!-- Constructors -->
  
   <for keys="r" values="irqHandlingMethod">
      <setTemplate
         variables="%(r)" 
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         #if $(irqHandlingMethod)
         \t      this->%enumParam0 = %paramExpression;
         #else
         \t      (void)%paramExpression;
         #endif
         \t   }\n\n
      ]]></setTemplate>
   </for>
   
   <for keys="r" values="pit_channelNumber;pit_ldval_tsv[];pit_period[];/PCR/nvic_irqLevel">
      <setTemplate
         variables="%(r)" 
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }\n\n
      ]]></setTemplate>
   </for>
   
   <for keys="r" values="pit_tctrl_ten[];pit_tctrl_chn[];pit_tctrl_tie[]">
      <setTemplate
         variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName |= %paramExpression;
         \t   }
         \t\n\n
      ]]></setTemplate>
   </for>
   
   <template><![CDATA[
      \t};\n\n
   ]]></template>

<!-- Default Values -->
  
   <setTemplate 
      variables="pit_mcr_frz"   
   ><![CDATA[
      \t
      \t/// %description
      \tstatic constexpr uint32_t %registerName = %initExpression; \n\n
   ]]></setTemplate>
   
   <for keys="ch" dim="numChannels">
      <template>
      <![CDATA[
         \t/**
         \t * Default initialisation values for PIT channel %(ch)
         \t * This value is created from Configure.usbdmProject settings
         \t */
         \tstatic const Init DefaultChannel%(ch)InitValue;\n\n
      ]]></template>
   </for>
   
   <for keys="ch" dim="numChannels">
      <setTemplate key="/HARDWARE/StaticObjects" namespace="all"
         variables="pit_tctrl_ten[%(ch)],pit_tctrl_chn[%(ch)],pit_tctrl_tie[%(ch)],irqLevel,pit_ldval_tsv[%(ch)]"
         separator=","
         terminator=","
         >
      <![CDATA[
         \t/**
         \t * Default initialisation values for PIT channel %(ch)
         \t * This value is created from Configure.usbdmProject settings
         \t */
         \tconst PitInfo$(_instance)::Init PitInfo$(_instance)::DefaultChannel%(ch)InitValue = {
         \t   PitChannelNum_%(ch),
         %initExpression
         \t   };\n\n
      ]]></setTemplate>
   </for>
   
   <!-- ==================== Misc ======================== -->

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PitValidate">
   </validate>

   <projectActionList id = "pit_files" >
      <copy source="Snippets/pit-example1.cpp"       target="Snippets/pit-example1.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example2-MK.cpp"    target="Snippets/pit-example2.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/pit-example3-MK.cpp"    target="Snippets/pit-example3.cpp" overwrite="true" derived="true" />
      <copy source="Project_Headers/pit-MK.h"        target="Project_Headers/pit.h"     overwrite="true" derived="true" />
      <copy source="Snippets/timer-inline-handler-example.cpp" target="Snippets/timer-inline-handler-example.cpp"   overwrite="true" derived="true" />
   </projectActionList>
         
   <!-- condition="pit_ltmr64l_lth"  -->
   <template condition="pit_ltmr64h_lth_present" ><![CDATA[
      \t/**
      \t * Read chained counter value (Channels 0 and 1)
      \t *
      \t * @param[out] upper Upper 32-bits of combined counter
      \t * @param[out] lower Lower 32-bits of combined counter
      \t */
      \tstatic void readChainedCounter(uint32_t &upper, uint32_t &lower) {
      \t   upper = pit->LTMR64H;
      \t   lower = pit->LTMR64L;
      \t}\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic __attribute__((always_inline)) uint32_t getClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>
   
   <template key="/PIT/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_name)
   \t */
   \tusing $(_class) = $(_base_class)Base_T<$(_class)Info>;

   \t/**
   \t * MACRO defining the start of a interrupt handler for a PIT channel
   \t * This will override the handler incorporated within the PIT class.
   \t *
   \t * @param channel Channel being used.
   \t *
   \t * @example
   \t * PIT$(_instance)_CHANNEL0_HANDLER() {
   \t *    console.writeln("PIT$(_instance) Channel 0 Handler");
   \t *    // Clear interrupt flag
   \t *    pit->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
   \t * }
   \t */
   #define PIT$(_instance)_CHANNEL0_HANDLER() template<>template<> void Pit$(_instance)::Channel<0>::irqHandler()
   #define PIT$(_instance)_CHANNEL1_HANDLER() template<>template<> void Pit$(_instance)::Channel<1>::irqHandler()
   #define PIT$(_instance)_CHANNEL2_HANDLER() template<>template<> void Pit$(_instance)::Channel<2>::irqHandler()
   #define PIT$(_instance)_CHANNEL3_HANDLER() template<>template<> void Pit$(_instance)::Channel<3>::irqHandler()

   \t/**
   \t * @brief class representing a PIT channel
   \t */
   \tusing $(_class)Channel = $(_class)::PitChannel;
   ]]></template>
      
   <xi:include href="_clockOption.xml"/>

   <signals/>

</fragment>

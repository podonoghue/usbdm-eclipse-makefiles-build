<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- dma0_mkl.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Enhanced direct memory access controller" >

   <constant key="irq_pattern"               type="String"  value="&quot;^%b_?(\d+)(_DMA.*)?$&quot;"        />
   <constant key="irq_ClassHandler"          type="String"  value="&quot;%c%i::irqHandler&lt;$1&gt;&quot;"  />
   <constant key="irq_parameters"            type="String"  value="&quot;DmaChannelNum channel&quot;"       />
   <constant key="irq_dummy_parameters"      type="String"  value="&quot;DmaChannelNum&quot;"               />
   <constant key="irq_call"                  type="String"  value="&quot;DmaChannelNum(channel)&quot;"      />
   <constant key="generateDefault"           type="Boolean" value="false"         />
   <constant key="configureInStartupDefault" type="Boolean" value="false"         />
   <xi:include href="enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * %valueExpression[index]         Formatted value as numeric e.g. 0x12
    * %symbolicExpression[index] Symbolic formatted value e.g. AdcCompare_Disabled
    * %variable[index]                Variable name /ADC0/adc_sc2_acfe
    * %macro[index](value)            C register macro e.g. ADC_SC2_ACFGT(value)
    * %description[index]             Description from controlVar e.g. Compare Function Enable
    * %shortDescription[index]        Short description from controlVar e.g. Compare Function Enable
    * %tooltip[index]                 Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * %paramDescription[index]        Tool-tip from controlVar formatted as param description @param ...
    * %params                         Formatted parameter list for function
    * %paramType[index]               Based on enumStem or typename e.g. AdcCompare (or uint32_t)
    * %paramName[index]               Based on enumStem with lower-case first letter adcCompare
    * %paramType[index]               As for %paramType
    * %paramName[index]               As for %paramName
    * %valueExpression                Numeric variable value e.g. 0x3
    * %symbolicExpression        Symbolic variable value e.g. AdcCompare_Disabled
    * %fieldAssignment         Based on variable etc. Similar to %register = (%register&~%mask) | %paramName;
    * %maskingExpression       Based on variable etc. Similar to (%register&%mask)
    * %variable[index]                Variable name from condition
    * %mask[index]                    From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * %register[index]                Register associated with variable e.g. adc->APCTL1
    * %registerName[index]            Name of corresponding register (lowercase for Init()) e.g. apctl1 <br><br>
    * %registerNAME[index]            Name of corresponding register (uppercase for Init()) e.g. APCTL <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Baseclass)BasicInfo&quot;" />

   <!-- ************* Constants ****************** -->
   <intOption key="NumChannels" locked="true" derived="true"
      value="=/$(_NAME)_NumChannels"
      description="Number of DMA channels"
      toolTip="The number of DMA channels available" />

   <intOption key="NumVectors" locked="true" derived="true"
      value="=_irqCount"
      description="Number of DMA interrupt vectors"
      toolTip="Number of DMA interrupt vectors - \n
               Multiple channels may be mapped to the same vector" />

   <intOption key="NumPeriodicChannels" locked="true" derived="true"
      value="=/PIT_NumChannels"
      description="Number of DMA channels with periodic feature"
      toolTip="Each periodic channel may be controlled by the corresponding PIT channel"  />

   <for keys="var" values="NumVectors;NumChannels;NumPeriodicChannels" >
      <variableTemplate variables="%(var)"
         initExpressionOnSameLine="true"
         linePadding="//x"
         tooltipPadding=""
      ><![CDATA[
         \t// %tooltip
         \tstatic constexpr unsigned %(var) = %initExpression;
         \t\n
      ]]></variableTemplate>
   </for>

   <choiceOption key="DmaChannelNum"
      description="DMA channel number"
      toolTip="Used to select DMA channel or indicate result of channel allocation"
      typeName="DmaChannelNum"
      enumType="uint8_t"
      valueFormat="%s" >
      <choiceExpansion keys="ch" dim="=NumChannels" value="%(ch)"        name="DMA channel %(ch)"         enum="%(ch)" />
      <choice                                       value="(1&lt;&lt;6)" name="All channels"              enum="All"   />
      <choice                                       value="(1&lt;&lt;7)" name="None or Failed allocation" enum="None"  />
   </choiceOption>

    <!-- ************* Source ****************** -->

   <title description="Source" />

   <intOption key="dma_sar_addr" condition="dma_sar_addr_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSource"
      enumType="uint32_t"
      description="Source Address"
      toolTip="Each SAR contains the byte address used by the DMA controller to read data.\n
               The SARn is typically aligned on a 0-modulo-ssize boundary—that is, on the natural alignment of the source data.\n
               Restriction: Bits 31-20 of this register must be written with one of only four allowed values.\n
               Each of these four allowed values corresponds to a valid region of the device's memory map. \n
               The allowed values are:\n
               • 0x000x_xxxx\n
               • 0x1FFx_xxxx\n
               • 0x200x_xxxx\n
               • 0x400x_xxxx\n
               After being written with one of the allowed values, bits 31-20 read back as the written value.\n
               After being written with any other value, bits 31-20 read back as an indeterminate value."
      radix="16"
      value="0" />

   <binaryOption key="dma_dcr_sinc" condition="dma_dcr_sinc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceIncrement"
      toolTip="Controls whether the source address increments"
      description="Source increment" >
      <choice name="No increment"                 value="0" enum="NoIncrement" />
      <choice name="Increments by transfer size"  value="1" enum="IncrementBySize" />
   </binaryOption >

   <choiceOption key="dma_dcr_ssize" condition="dma_dcr_ssize_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceSize"
      toolTip="Determines the data size of the source bus cycle for the DMA controller."
      description="Source size" >
      <choice name="32-bit"      value="0" enum="32Bit"     />
      <choice name="8-bit"       value="1" enum="8Bit"      />
      <choice name="16-bit"      value="2" enum="16Bit"     />
      <choice name="Reserved"    value="3" enum="Reserved"  />
   </choiceOption >

   <choiceOption key="dma_dcr_smod" condition="dma_dcr_smod_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaSourceModulo"
      toolTip="Defines the size of the data circular buffer used by the DMA Controller.\n
               If enabled, the buffer base address is located on a boundary of the buffer size.\n
               The value of this boundary depends on the initial transfer address (SAR).\n
               The base address should be aligned to a 0-modulo-(circular buffer size) boundary.\n
               Misaligned buffers are not possible. The boundary is forced to the value determined by the
               upper address bits in the field selection.      "
      description="Source address modulo">
      <choice name="Buffer disabled"  value="0" enum="Disabled" />
      <choice name="16 bytes"         value="1" enum="16Bytes"  />
      <choice name="32 bytes"         value="2" enum="32Bytes"  />
      <choice name="64 bytes"         value="3" enum="64Bytes"  />
      <choice name="128 bytes"        value="4" enum="128Bytes" />
      <choice name="256 bytes"        value="5" enum="256Bytes" />
      <choice name="512 bytes"        value="6" enum="512Bytes" />
      <choice name="1 KB"             value="7" enum="1Kb"      />
      <choice name="2 KB"             value="8" enum="2Kb"      />
      <choice name="4 KB"             value="9" enum="4Kb"      />
      <choice name="8 KB"            value="10" enum="8Kb"      />
      <choice name="16 KB"           value="11" enum="16Kb"     />
      <choice name="32 KB"           value="12" enum="32Kb"     />
      <choice name="64 KB"           value="13" enum="64Kb"     />
      <choice name="128 KB"          value="14" enum="128Kb"    />
      <choice name="256 KB"          value="15" enum="256Kb"    />
   </choiceOption >

   <!-- ************* Destination ****************** -->

   <title description="Destination" />

   <intOption key="dma_dar_addr" condition="dma_dar_addr_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestination"
      enumType="uint32_t"
      description="Destination Address"
      toolTip="Each SAR contains the byte address used by the DMA controller to write data.\n
               The SARn is typically aligned on a 0-modulo-dsize boundary—that is, on the natural alignment of the source data.\n
               Restriction: Bits 31-20 of this register must be written with one of only four allowed values.\n
               Each of these four allowed values corresponds to a valid region of the device's memory map. \n
               The allowed values are:\n
               • 0x000x_xxxx\n
               • 0x1FFx_xxxx\n
               • 0x200x_xxxx\n
               • 0x400x_xxxx\n
               After being written with one of the allowed values, bits 31-20 read back as the written value.\n
               After being written with any other value, bits 31-20 read back as an indeterminate value."
      radix="16"
      value="0" />

   <binaryOption key="dma_dcr_dinc" condition="dma_dcr_dinc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationIncrement"
      toolTip="Controls whether the destination address increments"
      description="Destination increment" >
      <choice name="No increment"                 value="0" enum="NoIncrement"     />
      <choice name="Increments by transfer size"  value="1" enum="IncrementBySize" />
   </binaryOption >

   <choiceOption key="dma_dcr_dsize" condition="dma_dcr_dsize_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationSize"
      toolTip="Determines the data size of the destination bus cycle for the DMA controller."
      description="Destination size" >
      <choice name="32-bit"      value="0" enum="32Bit"    />
      <choice name="8-bit"       value="1" enum="8Bit"     />
      <choice name="16-bit"      value="2" enum="16Bit"    />
      <choice name="Reserved"    value="3" enum="Reserved" />
   </choiceOption >

   <choiceOption key="dma_dcr_dmod" condition="dma_dcr_dmod_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDestinationModulo"
      toolTip="Defines the size of the data circular buffer used by the DMA Controller.\n
               If enabled, the buffer base address is located on a boundary of the buffer size.\n
               The value of this boundary depends on the initial transfer address (DAR).\n
               The base address should be aligned to a 0-modulo-(circular buffer size) boundary.\n
               Misaligned buffers are not possible. The boundary is forced to the value determined by the
               upper address bits in the field selection."
      description="Destination address modulo" >
      <choice name="Buffer disabled"  value="0" enum="Disabled"  />
      <choice name="16 bytes"         value="1" enum="16Bytes"   />
      <choice name="32 bytes"         value="2" enum="32Bytes"   />
      <choice name="64 bytes"         value="3" enum="64Bytes"   />
      <choice name="128 bytes"        value="4" enum="128Bytes"  />
      <choice name="256 bytes"        value="5" enum="256Bytes"  />
      <choice name="512 bytes"        value="6" enum="512Bytes"  />
      <choice name="1 KB"             value="7" enum="1Kb"       />
      <choice name="2 KB"             value="8" enum="2Kb"       />
      <choice name="4 KB"             value="9" enum="4Kb"       />
      <choice name="8 KB"            value="10" enum="8Kb"       />
      <choice name="16 KB"           value="11" enum="16Kb"      />
      <choice name="32 KB"           value="12" enum="32Kb"      />
      <choice name="64 KB"           value="13" enum="64Kb"      />
      <choice name="128 KB"          value="14" enum="128Kb"     />
      <choice name="256 KB"          value="15" enum="256Kb"     />
   </choiceOption >

  <!-- ************* DSR_BCR ****************** -->

   <title description="" />

   <intOption key="dma_dsr_bcr_bcr" condition="dma_dsr_bcr_bcr_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaByteCount"
      enumType="uint32_t"
      description="Byte Count"
      toolTip="This field contains the number of bytes yet to be transferred for a given block.\n
               BCR must be written with a value equal to or less than 0F_FFFFh.\n
               After being written with a value in this range, bits 23-20 of BCR read back as 1110b.\n
               A write to BCR of a value greater than 0F_FFFFh causes a configuration error when the channel starts to execute.\n
               After being written with a value in this range, bits 23-20 of BCR read back as 1111b"
      radix="16"
      value="0" />

   <binaryOption key="dma_dsr_bcr_done" condition="dma_dsr_bcr_done_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDsrBcrDone"
      locked="true"
      toolTip="Indicates if the transfer has been completed\n
               Writing a 1 to this bit clears all DMA status bits and should be used in an ISR\n
               to clear the DMA interrupt and error bits"
      description="Transactions done" >
      <choice name="Transfer not complete"  value="0" enum="TransferNotComplete" />
      <choice name="Transfer complete"      value="1" enum="TransferComplete"    />
   </binaryOption >

   <!-- ************* DSR ****************** -->

   <binaryOption key="dma_dsr_done" condition="dma_dsr_done_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDsrDone"
      toolTip="Indicates if the transfer has been completed\n
               Writing a 1 to this bit clears all DMA status bits and should be used in an ISR to clear the DMA interrupt and error bits"
      description="Transactions done" >
      <choice name="Transfer not complete"  value="0" enum="TransferNotComplete"/>
      <choice name="Transfer complete"      value="1" enum="TransferComplete"/>
   </binaryOption >

   <!-- ************* DCR ****************** -->

   <binaryOption key="dma_dcr_eint" condition="dma_dcr_eint_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDcrEint"
      toolTip="Determines whether an interrupt is generated by completing a transfer\n
               or the occurrence of an error condition"
      description="Enable interrupt on completion of transfer" >
      <choice name="Interrupt masked"   value="0" enum="InterruptMasked"  />
      <choice name="Interrupt enabled"  value="1" enum="InterruptEnabled" />
   </binaryOption >

   <binaryOption key="dma_dcr_erq" condition="dma_dcr_erq_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDcrErq"
      toolTip="Allows the appropriate peripheral request REQC[DMACn] field to initiate transfer.\n
               A software-initiated request (setting the START bit) is always enabled"
      description="Enable peripheral request" >
      <choice name="Peripheral Request ignored"   value="0" enum="RequestIgnored"  />
      <choice name="Peripheral Request honoured"  value="1" enum="RequestHonoured" />
   </binaryOption >

   <binaryOption key="dma_dcr_cs" condition="dma_dcr_cs_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDcrCs"
      toolTip="Control whether cycle-stealing is used or the DMA monopolises the bus until complete"
      description="Cycle steal" >
      <choice name="DMA is continuously"         value="0" enum="Continuously"    />
      <choice name="Single read/write transfers"  value="1" enum="SingleTransfer" />
   </binaryOption >

   <binaryOption key="dma_dcr_aa" condition="dma_dcr_aa_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDcrAa"
      toolTip="If enabled:\n
               If SSIZE indicates a transfer no smaller than DSIZE, source accesses are auto-aligned; otherwise, destination accesses are auto-aligned.\n
               Source alignment takes precedence over destination alignment.\n
               If auto-alignment is enabled, the appropriate address register increments, regardless of DINC or SINC"
      description="Auto-align" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled"  />
   </binaryOption >

   <binaryOption key="dma_dcr_eadreq" condition="dma_dcr_eadreq_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaDcrEadreq"
      toolTip="Enables the channel to support asynchronous DREQs while the MCU is in Stop mode"
      description="Enable asynchronous DMA requests" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled"  />
   </binaryOption >

   <choiceOption key="dma_dcr_start" condition="dma_dcr_start_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaStart"
      toolTip="Set to start the DMA transfer\n
               The DMA begins the transfer in accordance to the values in the TCDn.\n
               START is cleared automatically after one module clock and always reads as logic 0"
      description="Start transfer" >
      <choice name="Start on request"   value="0" enum="OnRequuest"  />
      <choice name="Start Immediately"  value="0" enum="Immediately" />
   </choiceOption >

   <binaryOption key="dma_dcr_d_req" condition="dma_dcr_d_req_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaErqOnComplete"
      toolTip="Control whether the ERQ bit is cleared when the BCR is exhausted"
      description="Disable request on completion" >
      <choice name="ERQ not affected"          value="0" enum="NotAffected" />
      <choice name="ERQ cleared on completion" value="1" enum="Cleared"     />
   </binaryOption >

   <title description="Channel Linking" />

   <choiceOption key="dma_dcr_linkcc" condition="dma_dcr_linkcc_present"
      enabledBy="enablePeripheralSupport"
      typeName="DmaLinkAction"
      description="Control Linking action of channel"
      toolTip="Allows DMA channels to have their transfers linked.\n
               The current DMA channel triggers a DMA request to the linked channels (LCH1 or LCH2) depending on the condition described by DmaLink bits.\n
               DmaLink_Both and DmaLink_CycleSteal only link to LCH1 when in cycle-steal transfer mode (DCRn[CS]=DmaMode_CycleSteal)." >
      <choice name="No linking"                                                            value="0" enum="None"       />
      <choice name="Link to LCH1 after cycle-steal transfer; Link to LCH2 after BCR zero"  value="1" enum="Both"       />
      <choice name="Link to LCH1 after cycle-steal transfer"                               value="2" enum="CycleSteal" />
      <choice name="Link to LCH1 after the BCR decrements to zero"                         value="3" enum="Complete"   />
   </choiceOption >

   <choiceOption key="dma_dcr_lch1" condition="dma_dcr_lch1_present"
      enabledBy="dma_dcr_linkcc>0"
      typeName="DmaLinkChannelSel1"
      description="Link channel 1"
      toolTip="This selects a channel to be used for linking" >
      <choice name="DMA Channel 0"  value="0" enum="Channel0" />
      <choice name="DMA Channel 1"  value="1" enum="Channel1" />
      <choice name="DMA Channel 2"  value="2" enum="Channel2" />
      <choice name="DMA Channel 3"  value="3" enum="Channel3" />
   </choiceOption >

   <choiceOption key="dma_dcr_lch2" condition="dma_dcr_lch2_present"
      enabledBy="dma_dcr_linkcc==1"
      typeName="DmaLinkChannelSel2"
      description="Link channel 2"
      toolTip="This selects a channel to be used for linking" >
      <choice name="DMA Channel 0"  value="0" enum="Channel0" />
      <choice name="DMA Channel 1"  value="1" enum="Channel1" />
      <choice name="DMA Channel 2"  value="2" enum="Channel2" />
      <choice name="DMA Channel 3"  value="3" enum="Channel3" />
   </choiceOption >

<!-- Graphic here -->

   <for keys="field:name"
        values="
         dma_sar_addr         : SarAddr;
         dma_dar_addr         : DarAddr;
         dma_dsr_bcr_ce       : DsrBcrCe;
         dma_dsr_bcr_bes      : DsrBcrBes;
         dma_dsr_bcr_bed      : DsrBcrBed;
         dma_dsr_bcr_req      : DsrBcrReq;
         dma_dsr_bcr_bsy      : DsrBcrBsy;
         dma_dsr_bcr_done     : DsrBcrDone;
         dma_dsr_bcr_bcr      : DsrBcrBcr;
         dma_dsr_ce           : DsrCe;
         dma_dsr_bes          : DsrBes;
         dma_dsr_bed          : DsrBed;
         dma_dsr_req          : DsrReq;
         dma_dsr_bsy          : DsrBsy;
         dma_dsr_done         : DsrDone;
         dma_dcr_eint         : DcrEint;
         dma_dcr_erq          : DcrErq;
         dma_dcr_cs           : DcrCs;
         dma_dcr_aa           : DcrAa;
         dma_dcr_eadreq       : DcrEadreq;
         dma_dcr_sinc         : DcrSinc;
         dma_dcr_ssize        : DcrSsize;
         dma_dcr_dinc         : DcrDinc;
         dma_dcr_dsize        : DcrDsize;
         dma_dcr_start        : DcrStart;
         dma_dcr_smod         : DcrSmod;
         dma_dcr_dmod         : DcrDmod;
         dma_dcr_d_req        : DcrDReq;
         dma_dcr_linkcc       : DcrLinkcc;
         dma_dcr_lch1         : DcrLch1;
         dma_dcr_lch2         : DcrLch2" >
      <variableTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(DmaChannelNum dmaChannelNum, %params) {
         \t   dma->DMA[dmaChannelNum].%registerNAME = (dma->DMA[dmaChannelNum].%registerNAME&~%mask)|%paramExpression;
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)(DmaChannelNum dmaChannelNum) {
         \t   return %paramType(dma->DMA[dmaChannelNum].%registerNAME&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

<!--   ========== DMA Init class =============================== -->

   <template key="init_description" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of a $(_Baseclass) channel
      \t *
      \t * This class has a templated constructor that accepts various values.  <br>
      \t * Parameters available may vary with device - see $(_Class)::ExampleValue for relevant example.  <br>
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.  <br>
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(uint32_t status) {
      \t *    (void) status;
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   DmaChannelNum_2 ,                          // DMA channel number - DMA channel 2
      \t *   DmaByteCount(0x1000) ,                     // Byte Count
      \t *
      \t *   DmaSource(0x2000) ,                        // Source Address
      \t *   DmaSourceSize_32Bit ,                      // Source size - 32-bit
      \t *   DmaSourceModulo_Disabled ,                 // Source address modulo - Buffer disabled
      \t *   DmaSourceIncrement_NoIncrement ,           // Source increment - No increment
      \t *
      \t *   DmaDestination(0x3000) ,                   // Destination Address
      \t *   DmaDestinationSize_32Bit ,                 // Destination size - 32-bit
      \t *   DmaDestinationModulo_Disabled ,            // Destination address modulo - Buffer disabled
      \t *   DmaDestinationIncrement_IncrementBySize ,  // Destination increment - Increments by transfer size
      \t *
      \t *   DmaDcrCs_SingleTransfer ,                  // Cycle steal - Single read/write transfers
      \t *   DmaDcrAa_Disabled ,                        // Auto-align - Disabled
      \t *   DmaStart_OnRequuest ,                      // Start transfer - Start on request
      \t *   DmaDcrEadreq_Disabled ,                    // Enable asynchronous DMA requests - Disabled
      \t *   DmaDcrErq_RequestIgnored ,                 // Enable peripheral request - Peripheral Request ignored
      \t *   DmaErqOnComplete_Cleared ,                 // Disable request on completion - ERQ cleared on completion
      \t *   DmaDcrEint_InterruptEnabled ,              // Enable interrupt on completion of transfer - Interrupt enabled
      \t *   DmaDsrBcrDone_TransferNotComplete ,        // Transactions done - Transfer not complete
      \t *   DmaDsrDone_TransferNotComplete ,           // Transactions done - Transfer not complete
      \t *
      \t *   DmaLinkAction_Complete ,                   // Control Linking action of channel - Link to LCH1 after the BCR decrements to zero
      \t *   DmaLinkChannelSel1_Channel0 ,              // Link channel 1 - DMA Channel 0
      \t *   DmaLinkChannelSel2_Channel0,               // Link channel 2 - DMA Channel 0
      \t *
      \t *   $(_name)Callback,                // Call-back to execute on event - call-back function name
      \t *   NvicPriority_Low,                // Priority for interrupt - Low
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm" discardRepeats="true" >
   <![CDATA[
      class $(_Baseclass)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="/$(_BASENAME)/irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></variableTemplate>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Baseclass) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for ISR */
      \tstatic CallbackFunction sCallbacks[irqCount];
      \t
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t * @param[in]  dmaChannelNum   Channel to configure
      \t * @param[in]  $(_basename)Callback Callback function to execute on interrupt
      \t *                             Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(DmaChannelNum dmaChannelNum, CallbackFunction $(_basename)Callback) {
      \t   if ($(_basename)Callback == nullptr) {
      \t      $(_basename)Callback = unhandledCallback;
      \t   }
      \t   // Allow either no handler set yet or removing handler
      \t   usbdm_assert(
      \t         (sCallbacks[dmaChannelNum] == unhandledCallback) || ($(_basename)Callback == unhandledCallback),
      \t         "Handler already set");
      \t   sCallbacks[dmaChannelNum] = $(_basename)Callback;
      \t}
      \t\n
   ]]>
   </template>

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t *
      \t * @tparam channel Channel number
      \t */
      \ttemplate<unsigned channel>
      \tstatic void irqHandler() {
      \t
      \t   // Clear interrupt flag
      \t   dmac->DMA[channel].DSR = dmac->DMA[channel].DSR &~ DMA_DSR_DONE_MASK;
      \t
      \t   // Execute call-back
      \t   Info::sCallbacks[channel]($(irq_call));
      \t}
      \t\n
   ]]>
   </template>

   <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Callback table of programmatically set handlers for $(_Class)
      \t */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallbacks[] = {\n
   ]]></template>
   <for keys="ch" dim="=NumChannels" >
      <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
         \t   $(_Class)Info::unhandledCallback,\n
      ]]></template>
   </for>
   <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t};\n\n
   ]]></template>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--   Member variables -->

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="DmaChannelNum"
      linePadding=""
      tooltipPadding="///x"
   ><![CDATA[
      \t   /// %description
      \t   /// %tooltip
      \t   %paramType %paramName = DmaChannelNum_None;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" variables="irqHandlingMethod" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      linePadding=""
      tooltipPadding="xxx///x"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dma_sar_addr"
   ><![CDATA[
      \t   /// Source Address Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dma_dar_addr"
   ><![CDATA[
      \t   /// Destination Address Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dma_dsr_bcr_done,dma_dsr_bcr_bcr"
   ><![CDATA[
      \t   /// DMA Status / Byte Count Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dma_dcr_eint,dma_dcr_erq,dma_dcr_cs,dma_dcr_aa,dma_dcr_eadreq,dma_dcr_sinc,dma_dcr_ssize,dma_dcr_dinc,dma_dcr_dsize,dma_dcr_start,dma_dcr_smod,dma_dcr_dmod,dma_dcr_d_req,dma_dcr_linkcc,dma_dcr_lch1,dma_dcr_lch2"
   ><![CDATA[
      \t   /// DMA Control Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName0 = %symbolicExpression1;
      \t\n
   ]]></variableTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t   // ..........  Configure ...........
      \t
      \t   // Enable peripheral clock
      \t   Info::enableClock();
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
             condition="/$(_BASENAME)/irqHandlingMethod" >   <![CDATA[
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-backs if feature enabled
      \t      Info::setCallback(init.dmaChannelNum, init.callbackFunction);
      \t      enableNvicInterrupts(init.dmaChannelNum, init.irqlevel);
      \t   }
      \t\n
   ]]>
   </template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t   // ..........  Regs to init .......... ;
      \t   dmac->DMA[init.dmaChannelNum].SAR      = init.sar;
      \t   dmac->DMA[init.dmaChannelNum].DAR      = init.dar;
      \t   dmac->DMA[init.dmaChannelNum].DSR      = init.dsr;
      \t   dmac->DMA[init.dmaChannelNum].DCR      = init.dcr;
      \t}
      \t\n
   ]]>
   </template>

   <!--   Constructors -->

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="DmaChannelNum"
      linePadding="xxx" >
   <![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName = %paramExpression;
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <for keys="r"
      values="
            dma_dcr_ssize;
            dma_dcr_smod;
            dma_dcr_sinc;

            dma_dcr_dsize;
            dma_dcr_dmod;
            dma_dcr_dinc;

            dma_dcr_cs;
            dma_dcr_aa;
            dma_dcr_start;
            dma_dcr_eadreq;
            dma_dcr_erq;
            dma_dcr_d_req;
            dma_dcr_eint;

            dma_dsr_bcr_done;
            dma_dsr_done;

            dma_dcr_linkcc;
            dma_dcr_lch1;
            dma_dcr_lch2
            " >
      <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <for keys="r"
      values="
            dma_sar_addr;
            dma_dar_addr;
            dma_dsr_bcr_bcr
            " >
      <variableTemplate namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         \t    * @param value %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%paramType0 value, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask0) | %macro0(value);
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>


<!--   Default Initialisation value -->

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      separator=","
      terminator=","
      variables="
            DmaChannelNum,
            dma_dsr_bcr_bcr,

            dma_sar_addr,
            dma_dcr_ssize,
            dma_dcr_smod,
            dma_dcr_sinc,

            dma_dar_addr,
            dma_dcr_dsize,
            dma_dcr_dmod,
            dma_dcr_dinc,

            dma_dcr_cs,
            dma_dcr_aa,
            dma_dcr_start,
            dma_dcr_eadreq,
            dma_dcr_erq,
            dma_dcr_d_req,
            dma_dcr_eint,

            dma_dsr_bcr_done,
            dma_dsr_done,

            dma_dcr_linkcc,
            dma_dcr_lch1,
            dma_dcr_lch2
         "
   ><![CDATA[
      \t/**
      \t * Example initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init ExampleValue = {%initExpression
      \t};\n\n
   ]]>
   </variableTemplate>

   <template namespace="usbdm" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
      <![CDATA[
      \t}; // class $(_Baseclass)BasicInfo::Init
      \t\n
   ]]>
   </template>

   <template namespace="usbdm" discardRepeats="true" >
      <![CDATA[
      }; // class $(_Class)BasicInfo\n\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \t//class $(_Class) : public $(_Baseclass)_T<$(_Class)Info> {};
      \ttypedef $(_Baseclass)_T<$(_Class)Info> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id = "dma_files" >
      <copy source="Project_Headers/dma-MKL.h"                    target="Project_Headers/dma.h"                        overwrite="true"  derived="true" />
      <copy source="Snippets/dma-memory-example-mkl.cpp"          target="Snippets/dma-memory-example-mkl.cpp"          overwrite="true"  derived="true" />
      <copy source="Snippets/dma-memory-template-example-mkl.cpp" target="Snippets/dma-memory-template-example-mkl.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/dma-uart-example-mkl25.cpp"          target="Snippets/dma-uart-example-mkl25.cpp"          overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>


</peripheralPage>

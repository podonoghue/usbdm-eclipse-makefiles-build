<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- adc0_mke04.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Analog-to-Digital Converter" >

   <constant key="suppressInstance"         type="Boolean" value="false"         />
   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"          />
   <constant key="irq_parameters"           type="String"  value="&quot;uint32_t value, int channel&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;xxx,yyy&quot;"  />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="false"         />
   <xi:include href="_enablePeripheral.xml"  />
   <title description="------------------------------------------" />

   <!-- ************* SC1 ****************** -->

   <intOption key="adiclk"
      description="Adc internal asynchronous clock"
      toolTip="This is nominally 8MHz.  (Actually 4MHz in in ADC low power)"
      constant="true"
      value="8_MHz"
   />
   <binaryOption key="adc_sc1_aien[0]" condition="adc_sc1_aien_present"
      enumStem="AdcInterrupt"
      description="Conversion Complete Interrupt" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="adc_sc1_adco[0]" condition="adc_sc1_adco_present"
      enumStem="AdcContinuous"
      toolTip="Selects between single and multiple conversions.\n
               Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,\n
               or following assertion of ADHWT when hardware triggered operation is selected.\n
               When the FIFO function is enabled (AFDEP &gt; 0), a set of conversions are triggered"
      description="Continuous Conversion Enable" >
      <choice name="Single"      value="0" enum="Disabled"/>
      <choice name="Continuous"  value="1" enum="Enabled"/>
   </binaryOption >

   <choiceOption key="adc_sc1_adch[0]" condition="adc_sc1_adch_present"
      enumStem="AdcSc1Adch"
      description="Input Channel Select" >
      <choice name="AD0"                 value="0" enum="Ad0"/>
      <choice name="AD1"                 value="1" enum="Ad1"/>
      <choice name="AD2"                 value="2" enum="Ad2"/>
      <choice name="AD3"                 value="3" enum="Ad3"/>
      <choice name="AD4"                 value="4" enum="Ad4"/>
      <choice name="AD5"                 value="5" enum="Ad5"/>
      <choice name="AD6"                 value="6" enum="Ad6"/>
      <choice name="AD7"                 value="7" enum="Ad7"/>
      <choice name="AD8"                 value="8" enum="Ad8"/>
      <choice name="AD9"                 value="9" enum="Ad9"/>
      <choice name="AD10"               value="10" enum="Ad10"/>
      <choice name="AD11"               value="11" enum="Ad11"/>
      <choice name="AD12"               value="12" enum="Ad12"/>
      <choice name="AD13"               value="13" enum="Ad13"/>
      <choice name="AD14"               value="14" enum="Ad14"/>
      <choice name="AD15"               value="15" enum="Ad15"/>
      <choice name="Vss"                value="16" enum="Vss"/>
      <choice name="Temperature Sensor" value="22" enum="TemperatureSensor"/>
      <choice name="Bandgap"            value="23" enum="Bandgap"/>
      <choice name="VRefH"              value="29" enum="Vrefh"/>
      <choice name="VRefL"              value="30" enum="Vrefl"/>
      <choice name="Module disabled"    value="31" enum="ModuleDisabled"/>
   </choiceOption >

   <!-- ************* SC2 ****************** -->

   <binaryOption key="adc_sc2_adtrg" condition="adc_sc2_adtrg_present"
      enumStem="AdcPretrigger"
      toolTip="Controls whether conversions are triggered by writes to ADC_SC1 (software) or assertion of ADHWT input (hardware)"
      description="Conversion Trigger Select" >
      <choice name="Software trigger"  value="0" enum="SoftwareTrigger"/>
      <choice name="Hardware trigger"  value="1" enum="HardwareTrigger"/>
   </binaryOption >

   <choiceOption key="adc_sc2_acfe" condition="adc_sc2_acfe_present&amp;&amp;adc_sc2_acfgt_present"
      enumStem="AdcCompare"
      valueFormat="ADC_SC2_ACFE(%s),ADC_SC2_ACFGT(%s)"
      description="Compare Function Enable" >
      <choice name="No comparison done"            value="0,0" enum="Disabled"/>
      <choice name="ADC value &lt; compare value"  value="1,0" enum="LessThan"/>
      <choice name="ADC value &gt;= compare value" value="1,1" enum="GreaterThanOrEqual"/>
   </choiceOption >

   <choiceOption key="adc_sc2_refsel" condition="adc_sc2_refsel_present"
      enumStem="AdcRefSel"
      description="Voltage Reference Selection" >
      <choice name="VREFH and VREFL"  value="0" enum="VrefhAndVrefl"/>
      <choice name="VDDA and VSSA"    value="1" enum="VddaAndVssa"/>
      <choice name="Reserved"         value="2" enum="Reserved"/>
   </choiceOption >

   <!-- ************* SC3 ****************** -->

   <binaryOption key="adc_sc3_adlpc" condition="adc_sc3_adlpc_present"
      enumStem="AdcPower"
      toolTip="Controls trade-off between speed and power consumption"
      description="Low-Power Configuration" >
      <choice name="Normal"      value="0" enum="Normal"/>
      <choice name="Low power"   value="1" enum="Low"/>
   </binaryOption >

   <choiceOption key="adc_sc3_adiv" condition="adc_sc3_adiv_present"
      enumStem="AdcClockDivider"
      description="Clock Divide Select" >
      <choice name="Divide by 1"  value="0" enum="DivBy1"/>
      <choice name="Divide by 2"  value="1" enum="DivBy2"/>
      <choice name="Divide by 4"  value="2" enum="DivBy4"/>
      <choice name="Divide by 8"  value="3" enum="DivBy8"/>
   </choiceOption >

   <binaryOption key="adc_sc3_adlsmp" condition="adc_sc3_adlsmp_present"
      enumStem="AdcSample"
      description="Sample Time Configuration" >
      <choice name="Short sample"  value="0" enum="Short"/>
      <choice name="Long sample"   value="1" enum="Long"/>
   </binaryOption >

   <choiceOption key="adc_sc3_mode" condition="adc_sc3_mode_present"
      enumStem="AdcResolution"
      description="ADC resolution" >
      <choice name="8-bit"       value="0" enum="8bit_se"/>
      <choice name="10-bit"      value="1" enum="10bit_se"/>
      <choice name="12-bit"      value="2" enum="12bit_se"/>
   </choiceOption >

   <choiceOption key="adc_sc3_adiclk" condition="adc_sc3_adiclk_present"
      enumStem="AdcClockSource"
      description="Input Clock Select" >
      <choice name="Bus clock"                   value="0" enum="BusClock"     code="SystemBusClock" />
      <choice name="(Bus clock)/2"               value="1" enum="BusClockDiv2" code="SystemBusClock/2" />
      <choice name="Alternate clock (ALTCLK)"    value="2" enum="Altclk"       code="Osc0Info::getOscClock()" />
      <choice name="Asynchronous clock (ADICK)"  value="3" enum="Asynch"       code="adiclk" />
   </choiceOption >

   <!-- ************* SC4 ****************** -->

   <binaryOption key="adc_sc4_htrgme" condition="adc_sc4_htrgme_present"
      enumStem="AdcSc4Htrgme"
      toolTip="This field enables hardware trigger multiple conversions in fifo mode"
      description="Hardware Trigger Multiple Conversion Enable" >
      <choice name="Single"      value="0" enum="Single"/>
      <choice name="Multiple"    value="1" enum="Multiple"/>
   </binaryOption >

   <binaryOption key="adc_sc4_ascane" condition="adc_sc4_ascane_present"
      enumStem="AdcSc4Ascane"
      description="FIFO Scan Mode Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="adc_sc4_acfsel" condition="adc_sc4_acfsel_present"
      enumStem="AdcSc4Acfsel"
      toolTip="When this field is cleared, ADC will OR all of compare triggers and set COCO after at least one of compare trigger occurs. \n
               When this field is set, ADC will AND all of compare triggers and set COCO after all of compare triggers occur"
      description="Compare function select OR/AND when the FIFO function is enabled (AFDEP &gt; 0)." >
      <choice name="ORed triggers"   value="0" enum="OredTriggers"/>
      <choice name="ANDed triggers"  value="1" enum="AndedTriggers"/>
   </binaryOption >

   <choiceOption key="adc_sc4_afdep" condition="adc_sc4_afdep_present"
      enumStem="AdcSc4Afdep"
      description="FIFO Depth" >
      <choice name="FIFO disabled"  value="0" enum="FifoDisabled"/>
      <choice name="2-level FIFO"   value="1" enum="2LevelFifo"/>
      <choice name="3-level FIFO"   value="2" enum="3LevelFifo"/>
      <choice name="4-level FIFO"   value="3" enum="4LevelFifo"/>
      <choice name="5-level FIFO"   value="4" enum="5LevelFifo"/>
      <choice name="6-level FIFO"   value="5" enum="6LevelFifo"/>
      <choice name="7-level FIFO"   value="6" enum="7LevelFifo"/>
      <choice name="8-level FIFO"   value="7" enum="8LevelFifo"/>
   </choiceOption >

   <!-- ************* CV ****************** -->

   <intOption key="adc_cv_cv" condition="adc_cv_cv_present" typeName="uint32_t"
      description="Compare Value"
   />

   <!-- ************* APCTL1 ****************** -->

   <binaryOption key="adc_apctl1_adpc" condition="adc_apctl1_adpc_present"
      enumStem="AdcApctl1Adpc"
      description="Pin Control" >
      <choice name="GPIO control"  value="0" enum="GpioControl"/>
      <choice name="ADx control"   value="1" enum="AdxControl"/>
   </binaryOption >

   <!-- ************* SC5 ****************** -->

   <binaryOption key="adc_sc5_htrgmaske" condition="adc_sc5_htrgmaske_present"
      enumStem="AdcSc5Htrgmaske"
      toolTip="This field enables hardware trigger mask when HTRGMASKSEL is low"
      description="Hardware Trigger Mask Enable" >
      <choice name="Hardware trigger mask disable"                                                    value="0" enum="HardwareTriggerMaskDisable"/>
      <choice name="Hardware trigger mask enable and hardware trigger cannot trigger ADC conversion"  value="1" enum="HardwareTriggerMaskEnableAndHardwareTriggerCannotTriggerAdcConversion"/>
   </binaryOption >

   <binaryOption key="adc_sc5_htrgmasksel" condition="adc_sc5_htrgmasksel_present"
      enumStem="AdcSc5Htrgmasksel"
      toolTip="This field selects hardware trigger mask mode"
      description="Hardware Trigger Mask Mode Enable" >
      <choice name="Hardware trigger mask with HTRGMASKE"                             value="0" enum="HardwareTriggerMaskWithHtrgmaske"/>
      <choice name="Hardware trigger mask automatically when data fifo is not empty"  value="1" enum="HardwareTriggerMaskAutomaticallyWhenDataFifoIsNotEmpty"/>
   </binaryOption >

   <choiceOption key="adc_sc5_htrigger" condition="adc_sc5_htrigger_present"
      enumStem="AdcSc5Htrigger"
      toolTip="This field selects hardware trigger mode"
      description="Hardware Trigger Mode Select" >
      <choice name="Enabled"         value="0" enum="Enabled"/>
      <choice name="Masked by FIFO"  value="1" enum="MaskedByFifo"/>
      <choice name="Disabled"        value="2" enum="Disabled"/>
      <choice name="Reserved"        value="3" enum="Reserved"/>
   </choiceOption >

<!-- Graphic here -->

   <for keys="field:name"
        values="
      adc_sc1_aien:Sc1Aien;
      adc_sc1_adco:Sc1Adco;
      adc_sc1_adch:Sc1Adch;
      adc_sc2_adtrg:Pretrigger;
      adc_sc2_acfe:Compare;
      adc_sc2_refsel:RefSel;
      adc_sc3_adlpc:Power;
      adc_sc3_adiv:ClockDivider;
      adc_sc3_adlsmp:Sample;
      adc_sc3_mode:Resolution;
      adc_sc3_adiclk:ClockSource;
      adc_sc4_htrgme:Sc4Htrgme;
      adc_sc4_ascane:Sc4Ascane;
      adc_sc4_acfsel:Sc4Acfsel;
      adc_sc4_afdep:Sc4Afdep;
      adc_apctl1_adpc:Apctl1Adpc;
      adc_sc5_htrgmaske:Sc5Htrgmaske;
      adc_sc5_htrgmasksel:Sc5Htrgmasksel;
      adc_sc5_htrigger:Sc5Htrigger" >
      <setTemplate variables="%(field)" codeGenCondition="enablePeripheralSupport"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void configure%(name)(%params) {
         \t   %defaultFieldExpression
         \t}\n\n
      ]]></setTemplate>
   </for>

<!--   ========== ADC Init class =============================== -->

   <template key="init_description" namespace="all" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_class)::Init init {
      \t *
      \t *   // Setup values
      \t *   AdcSc1Aien_Disabled                       // Conversion Complete Interrupt,
      \t *   AdcSc1Adco_Single                         // Continuous Conversion Enable,
      \t *   AdcSc1Adch_Ad0                            // Input Channel Select,
      \t *   AdcSc2Adtrg_SoftwareTrigger               // Conversion Trigger Select,
      \t *   AdcSc2Acfe_Disabled                       // Compare Function Enable,
      \t *   AdcSc2Acfgt_TriggerWhenInputLtLevel       // Compare Function Greater Than Enable,
      \t *   AdcSc2Refsel_VrefhAndVrefl                // Voltage Reference Selection,
      \t *   AdcSc3Adlpc_Normal                        // Low-Power Configuration,
      \t *   AdcSc3Adiv_DivideBy1                      // Clock Divide Select,
      \t *   AdcSc3Adlsmp_ShortSample                  // Sample Time Configuration,
      \t *   AdcSc3Mode_8Bit                           // ADC resolution,
      \t *   AdcSc3Adiclk_BusClock                     // Input Clock Select,
      \t *   AdcSc4Htrgme_Single                       // Hardware Trigger Multiple Conversion Enable,
      \t *   AdcSc4Ascane_Disabled                     // FIFO Scan Mode Enable,
      \t *   AdcSc4Acfsel_OredTriggers                 // Compare function select OR/AND when the FIFO function is enabled (AFDEP &gt; 0).,
      \t *   AdcSc4Afdep_FifoDisabled                  // FIFO Depth,
      \t *   0,                                        // Compare Value,
      \t *   AdcApctl1Adpc_GpioControl                 // Pin Control,
      \t *   AdcSc5Htrgmaske_HardwareTriggerMaskDisable    // Hardware Trigger Mask Enable,
      \t *   AdcSc5Htrgmasksel_HardwareTriggerMaskWithHtrgmaske    // Hardware Trigger Mask Mode Enable,
      \t *   AdcSc5Htrigger_Enabled                    // Hardware Trigger Mode Select,
      \t * };
      \t *
      \t * // Initialise $(_class) from values specified above
      \t * $(_class)::configure(init)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      class $(_class)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t\n
   ]]>
   </template>

   <template namespace="all" key="protectedMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef $(_class)BasicInfo::CallbackFunction CallbackFunction;
      \t
      \t/** Callback function for ISR */
      \tstatic CallbackFunction sCallback;
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_call)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="all" key="publicMethods" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t * @param[in]  adcCallback Callback function to execute on interrupt
      \t */
      \tstatic void setCallback(CallbackFunction adcCallback) {
      \t   if (adcCallback == nullptr) {
      \t      adcCallback = unhandledCallback;
      \t   }
      \t   sCallback = adcCallback;
      \t}
      \t
      \t/**
      \t * $(_basename) interrupt handler -  Calls $(_basename) callback
      \t */
      \tstatic void irqHandler() {
      \t
      \t   //.....IRQ handler code here..........
      \t
      \t   sCallback(PmcInterruptReason_LowVoltageWarning);
      \t   return;
      \t}\n
   ]]>
   </template>

   <template namespace="all" key="staticDefinitions" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/** Callback for programmatically set handler */
      \ttemplate<class Info>
      \ttypename $(_base_class)Base_T<Info>::CallbackFunction $(_base_class)Base_T<Info>::sCallback =
      \t              $(_base_class)Base_T<Info>::unhandledCallback;
      \t\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--   Member variables -->

   <setTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_sc2_adtrg,adc_sc2_acfe,adc_sc2_acfgt,adc_sc2_refsel"
   ><![CDATA[
      \t   /// Status and Control Register 2
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_sc3_adlpc,adc_sc3_adiv,adc_sc3_adlsmp,adc_sc3_mode,adc_sc3_adiclk"
   ><![CDATA[
      \t   /// Status and Control Register 3
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_sc4_htrgme,adc_sc4_ascane,adc_sc4_acfsel,adc_sc4_afdep"
   ><![CDATA[
      \t   /// Status and Control Register 4
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_cv_cv"
   ><![CDATA[
      \t   /// Compare Value Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_apctl1_adpc"
   ><![CDATA[
      \t   /// Pin Control 1 Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="adc_sc5_htrgmaske,adc_sc5_htrgmasksel,adc_sc5_htrigger"
   ><![CDATA[
      \t   /// Status and Control Register 5
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName0 = %symbolicValueExpression1;
      \t\n
   ]]></initialValueTemplate>

<!--   Configure methods -->

   <template key="/ADC/InitMethod" namespace="all" discardRepeats="true"
      codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(Info::DefaultInitValue);
      \t}
      \t\n
   ]]></template>

   <template key="/$(_basename)/InitMethod" namespace="all" discardRepeats="true"
             codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure $(_basename) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t   // ..........  Configure stuff ...........
      \t\n
   ]]></template>
   <template key="/$(_basename)/InitMethod" namespace="all" discardRepeats="true"
             condition="irqHandlingMethod"
             codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupts(init.irqlevel);
      \t\n
   ]]></template>

   <template discardRepeats="true" key="/$(_basename)/InitMethod" namespace="all"
             codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // ..........  Regs to init .......... ;
      \t   adc->SC2    = init.sc2;
      \t   adc->SC3    = init.sc3;
      \t   adc->SC4    = init.sc4;
      \t   adc->CV    = init.cv;
      \t   adc->APCTL1    = init.apctl1;
      \t   adc->SC5    = init.sc5;
      \t}
      \t\n
   ]]></template>

<!--   Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t   %registerName = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <for keys="r"
      values="
            adc_sc2_adtrg;
            adc_sc2_acfe;
            adc_sc2_acfgt;
            adc_sc2_refsel;
            adc_sc3_adlpc;
            adc_sc3_adiv;
            adc_sc3_adlsmp;
            adc_sc3_mode;
            adc_sc3_adiclk;
            adc_sc4_htrgme;
            adc_sc4_ascane;
            adc_sc4_acfsel;
            adc_sc4_afdep;
            adc_apctl1_adpc;
            adc_sc5_htrgmaske;
            adc_sc5_htrgmasksel;
            adc_sc5_htrigger
            " >
      <setTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>

   <for keys="r"
      values="
            adc_cv_cv
            " >
      <setTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         \t    * @param value %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%paramType0 value, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask0) | %macro0(value);
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>


<!--   Default Initialisation value -->

   <initialValueTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            adc_sc2_adtrg,
            adc_sc2_acfe,
            adc_sc2_acfgt,
            adc_sc2_refsel,
            adc_sc3_adlpc,
            adc_sc3_adiv,
            adc_sc3_adlsmp,
            adc_sc3_mode,
            adc_sc3_adiclk,
            adc_sc4_htrgme,
            adc_sc4_ascane,
            adc_sc4_acfsel,
            adc_sc4_afdep,
            adc_apctl1_adpc,
            adc_sc5_htrgmaske,
            adc_sc5_htrgmasksel,
            adc_sc5_htrigger
         "
   ><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * Default initialisation value for $(_class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <clockCodeTemplate variable="adc_sc3_adiclk" returnFormat="%s" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/** Internal ADC clock */
      \tstatic constexpr unsigned adiclk = $(adiclk);
      \t
      \t/**
      \t * Set %description
      \t *
      \t * @param %enumParam %tooltip
      \t */
      \tstatic void setClockout(%enumClass %enumParam) {
      \t   %defaultFieldExpression
      \t}
      \t
      \t/**
      \t * Get %description
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getClockFrequency(%enumClass %enumParam) {
      \t
      \t   switch(%enumParam) {
      \t      default: return 0;
      %body
      \t   }
      \t}
      \t
      \t/**
      \t * Get clock frequency
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getClockFrequency() {
      \t   return getClockFrequency((%enumClass)(%defaultMaskingExpression));
      \t}; \n\n
   ]]></clockCodeTemplate>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
      <![CDATA[
      \t}; // $(_class)BasicInfo::Init\n\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" >
      <![CDATA[
      }; // $(_class)BasicInfo\n\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_basename)/declarations" namespace="all" codeGenCondition="enablePeripheralSupport" ><![CDATA[
   \t/**
   \t * Class representing $(_name)
   \t */
   \tclass $(_class) : public $(_base_class)Base_T<$(_class)Info> {};\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id = "adc_files" >
      <copy source="Project_Headers/adc_MKE.h"  target="Project_Headers/adc.h"  overwrite="true"  derived="true" />
   </projectActionList>

   <signals />

</peripheralPage>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- sdhc_def.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Secured Digital Host Controller" >

   <equation key="irq_parameters"             value=""          />
   <equation key="irq_dummy_parameters"       value=""          />
   <equation key="irq_call"                   value=""          />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <!-- ____ Class Declaration ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <title description="DMA Transfer " />

   <!-- ____ DSADDR ____ -->
   <intOption key="sdhc_dsaddr_dsaddr" condition="sdhc_dsaddr_dsaddr_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDmaSourceAddress"
      baseType="uint32_t"
      toolTip="Contains the 32-bit system memory address for a DMA transfer. Because the address must be word (4 bytes) aligned\n
               the least 2 bits are reserved, always 0. When the SDHC stops a DMA transfer, this register\n
               points to the system address of the next contiguous data position.\n
               It can be accessed only when no transaction is executing, that is, after a transaction has stopped.\n
               Read operation during transfers may return an invalid value.\n
               he host driver shall initialize this register before starting a DMA transaction. After\n
               DMA has stopped, the system address of the next contiguous data position can be read from this register.\n
               This register is protected during a data transfer. When data lines are active, write to this register is\n
               ignored. The host driver shall wait, until PRSSTAT[DLA] is cleared, before writing to this register.\n
               The SDHC internal DMA does not support a virtual memory system. It supports only continuous physical\n
               memory access.\n
               Due to AHB burst limitations, if the burst must cross the 1 KB boundary, SDHC will automatically change SEQ burst type to NSEQ.\n
               Because this register supports dynamic address reflecting, when IRQSTAT[TC] bit is set, it automatically\n
               alters the value of internal address counter, so SW cannot change this register when IRQSTAT[TC] is set."
      description="DMA System Address"
      value="0"
      radix="16"
      min="0" max="1073741823"
   />

   <!-- ____ BLKATTR ____ -->
   <intOption key="sdhc_blkattr_blkcnt" condition="sdhc_blkattr_blkcnt_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcBlockCount"
      baseType="uint32_t"
      toolTip="This register is enabled when XFERTYP[BCEN] is set to 1 and is valid only for multiple block transfers.\n
               For single block transfer, this register will always read as 1.\n
               The SDHC decrements the block count after each block transfer and stops when the count reaches zero.\n
               Setting the block count to 0 results in no data blocks being transferred.\n
               This register must be accessed only when no transaction is executing, that is, after transactions are\n
               stopped. During data transfer, read operations on this register may return an invalid value and write\n
               operations are ignored.\n
               When saving transfer content as a result of a suspend command, the number of blocks yet to be\n
               transferred can be determined by reading this register. The reading of this register must be applied after\n
               transfer is paused by stop at block gap operation and before sending the command marked as suspend.\n
               This is because when suspend command is sent out, SDHC will regard the current transfer as aborted and\n
               change BLKCNT back to its original value instead of keeping the dynamical indicator of remained block\n
               count.\n
               When restoring transfer content prior to issuing a resume command, the host driver must restore the\n
               previously saved block count."
      description="Blocks Count For Current Transfer"
      min="0" max="65535" />

   <intOption key="sdhc_blkattr_blksize" condition="sdhc_blkattr_blksize_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcBlockSize"
      baseType="uint32_t"
      toolTip="Specifies the block size for block data transfers. \n
               It can be accessed only when no transaction is executing, that is, after a transaction has\n
               stopped. Read operations during transfers may return an invalid value, and write operations will be\n
               ignored."
      description="Transfer Block Size"
      min="0" max="4096" />

   <!-- ____ CMDARG ____ -->
   <intOption key="sdhc_cmdarg_cmdarg" condition="sdhc_cmdarg_cmdarg_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCommandArgument"
      baseType="uint32_t"
      toolTip="The SD/MMC command argument is specified as bits 39-8 of the command format in the SD or MMC\n
               specification.\n
               This register is write protected when PRSSTAT[CDIHB0] is set."
      description="Command Argument"
      value="0"
      min="0"
   />

   <!-- ____ XFERTYP ____ -->
   <title description="Transfer Control" />

   <choiceOption key="sdhc_xfertyp_cmdinx" condition="sdhc_xfertyp_cmdinx_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCommandIndex"
      baseType="uint32_t"
      toolTip="These bits shall be set to the command number that is specified in bits 45-40 of the command-format in\n
               the SD Memory Card Physical Layer Specification and SDIO Card Specification."
      description="Command Index" >
      <choice value="0"     name="GO_IDLE_STATE"             enum="GO_IDLE_STATE"            />
      <choice value="1"     name="SEND_OP_COND"              enum="SEND_OP_COND"             />
      <choice value="6"     name="SWITCH_FUNC"               enum="SWITCH_FUNC"              />
      <choice value="8"     name="SEND_IF_COND"              enum="SEND_IF_COND"             />
      <choice value="9"     name="SEND_CSD"                  enum="SEND_CSD"                 />
      <choice value="10"    name="SEND_CID"                  enum="SEND_CID"                 />
      <choice value="12"    name="STOP_TRANSMISSION"         enum="STOP_TRANSMISSION"        />
      <choice value="13"    name="SEND_STATUS"               enum="SEND_STATUS"              />
      <choice value="16"    name="SET_BLOCKLEN"              enum="SET_BLOCKLEN"             />
      <choice value="17"    name="READ_SINGLE_BLOCK"         enum="READ_SINGLE_BLOCK"        />
      <choice value="18"    name="READ_MULTIPLE_BLOCK"       enum="READ_MULTIPLE_BLOCK"      />
      <choice value="24"    name="WRITE_BLOCK"               enum="WRITE_BLOCK"              />
      <choice value="25"    name="WRITE_MULTIPLE_BLOCK"      enum="WRITE_MULTIPLE_BLOCK"     />
      <choice value="27"    name="PROGRAM_CSD"               enum="PROGRAM_CSD"              />
      <choice value="28"    name="SET_WRITE_PROT"            enum="SET_WRITE_PROT"           />
      <choice value="29"    name="CLR_WRITE_PROT"            enum="CLR_WRITE_PROT"           />
      <choice value="30"    name="SEND_WRITE_PROT"           enum="SEND_WRITE_PROT"          />
      <choice value="32"    name="ERASE_WR_BLK_START_ADDR"   enum="ERASE_WR_BLK_START_ADDR"  />
      <choice value="33"    name="ERASE_WR_BLK_END_ADDR"     enum="ERASE_WR_BLK_END_ADDR"    />
      <choice value="38"    name="ERASE"                     enum="ERASE"                    />
      <choice value="42"    name="LOCK_UNLOCK"               enum="LOCK_UNLOCK"              />
      <choice value="55"    name="APP_CMD"                   enum="APP_CMD"                  />
      <choice value="56"    name="GEN_CMD"                   enum="GEN_CMD"                  />
      <choice value="58"    name="READ_OCR"                  enum="READ_OCR"                 />
      <choice value="59"    name="CRC_ON_OFF"                enum="CRC_ON_OFF"               />
   </choiceOption>

   <choiceOption key="sdhc_xfertyp_cmdtyp" condition="sdhc_xfertyp_cmdtyp_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCommandType"
      baseType="uint32_t"
      toolTip="There are three types of special commands: suspend, resume, and abort. These bits shall be set to 0b00\n
               for all other commands.\n
               - Suspend command: If the suspend command succeeds, the SDHC shall assume that the card bus\n
               has been released and that it is possible to issue the next command which uses the DAT line.\n
               Because the SDHC does not monitor the content of command response, it does not know if the\n
               suspend command succeeded or not. It is the host driver's responsibility to check the status of the\n
               suspend command and send another command marked as suspend to inform the SDHC that a\n
               suspend command was successfully issued. After the end bit of command is sent, the SDHC\n
               deasserts read wait for read transactions and stops checking busy for write transactions. In 4-bit\n
               mode, the interrupt cycle starts. If the suspend command fails, the SDHC will maintain its current\n
               state, and the host driver shall restart the transfer by setting PROCTL[CREQ].\n
               - Resume command: The host driver restarts the data transfer by restoring the registers saved before\n
               sending the suspend command and then sends the resume command. The SDHC will check for a\n
               pending busy state before starting write transfers.\n
               - Abort command: If this command is set when executing a read transfer, the SDHC will stop reads to\n
               the buffer. If this command is set when executing a write transfer, the SDHC will stop driving the\n
               DAT line. After issuing the abort command, the host driver must issue a software reset (abort\n
               transaction)."
      description="Command Type" >
      <choice name="Normal other commands"                             value="0" enum="Normal"           />
      <choice name="Suspend CMD52 for writing bus suspend in CCCR"     value="1" enum="SuspendCmd52"     />
      <choice name="Resume CMD52 for writing function select in CCCR"  value="2" enum="ResumeCmd52"      />
      <choice name="Abort CMD12, CMD52 for writing I/O abort in CCCR"  value="3" enum="AbortCmd12_Cmd52" />
   </choiceOption >

   <binaryOption key="sdhc_xfertyp_dpsel" condition="sdhc_xfertyp_dpsel_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDataSelect"
      baseType="uint32_t"
      toolTip="Indicates whether data is present and shall be transferred using the DAT lines.\n
               It is set to 0 for the following :\n
               - Commands using only the CMD line, for example: CMD52.\n
               - Commands with no data transfer, but using the busy signal on DAT[0] line, R1b or R5b, for example: CMD38.\n
               NOTE: In resume command, this bit shall be set, and other bits in this register shall be set the same as\n
               when the transfer was initially launched. That is to say, when this bit is set, while the DTDSEL bit\n
               is 0, writes to the register Transfer Type are ignored."
      description="Data Present Select" >
      <choice name="No data present"  value="0" enum="NoDataPresent" />
      <choice name="Data present"     value="1" enum="DataPresent" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_cicen" condition="sdhc_xfertyp_cicen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcIndexCheck"
      baseType="uint32_t"
      toolTip="Configures the SDHC to check the index field in the response to see if it has the same value as\n
               the command index. If it is not, it is reported as a command index error."
      description="Command Index Check Enable" >
      <choice name="Disable"     value="0" enum="Disable" />
      <choice name="Enable"      value="1" enum="Enable" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_cccen" condition="sdhc_xfertyp_cccen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCommandCRC"
      baseType="uint32_t"
      toolTip="Selects whether the SDHC shall check the CRC field in the response.\n
               If an error is detected, it is reported as a Command CRC Error.\n
               The number of bits checked by the CRC field value changes according to the length of the response."
      description="Command CRC Check Enable" >
      <choice name="Disable"     value="0" enum="Disable" />
      <choice name="Enable"      value="1" enum="Enable" />
   </binaryOption >

   <choiceOption key="sdhc_xfertyp_rsptyp" condition="sdhc_xfertyp_rsptyp_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcResponseType"
      baseType="uint32_t"
      toolTip="Selects the expected response type"
      description="Response Type Select" >
      <choice name="No response"                                    value="0" enum="NoResponse" />
      <choice name="Response length 136"                            value="1" enum="Length136"  />
      <choice name="Response length 48"                             value="2" enum="Length48"   />
      <choice name="Response length 48, check busy after response"  value="3" enum="Length48WithCheck" />
   </choiceOption >

   <binaryOption key="sdhc_xfertyp_msbsel" condition="sdhc_xfertyp_msbsel_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcBlockMode"
      baseType="uint32_t"
      toolTip="Enables multiple block DAT line data transfers.\n
               For any other commands, this bit shall be set to 0.\n
               If this bit is 0 then it is not necessary to set the block count register."
      description="Multi/Single Block Select" >
      <choice name="Single block"     value="0" enum="SingleBlock" />
      <choice name="Multiple blocks"  value="1" enum="MultipleBlocks" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_dtdsel" condition="sdhc_xfertyp_dtdsel_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDirection"
      baseType="uint32_t"
      toolTip="Defines the direction of DAT line data transfers.\n
               The bit is selected by the host driver to transfer data from\n
               the SD card to the SDHC and is set to 0 for all other commands."
      description="Data Transfer Direction Select" >
      <choice name="Write (host to card)"  value="0" enum="WriteHostToCard" />
      <choice name="Read (card to host)"   value="1" enum="ReadCardToHost" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_ac12en" condition="sdhc_xfertyp_ac12en_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcAutoCmd12Enable"
      baseType="uint32_t"
      toolTip="Multiple block transfers for memory require a CMD12 to stop the transaction.\n
               When enabled the SDHC will issue a CMD12 automatically when the last block transfer has completed.\n
               Do not set this bit to issue commands that do not require CMD12 to stop a multiple block data transfer. In\n
               particular, secure commands defined in File Security Specification (see reference list) do not require\n
               CMD12.\n
               In single block transfer, the SDHC will ignore this bit whether it is set or not."
      description="Auto CMD12 Enable" >
      <choice name="Disable"     value="0" enum="Disable" />
      <choice name="Enable"      value="1" enum="Enable" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_bcen" condition="sdhc_xfertyp_bcen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcBlockCountEnable"
      baseType="uint32_t"
      toolTip="Enable the Block Count register, which is only relevant for multiple block transfers.\n
               Disabling the counter is useful in executing an infinite transfer."
      description="Block Count Enable" >
      <choice name="Disable"     value="0" enum="Disable" />
      <choice name="Enable"      value="1" enum="Enable" />
   </binaryOption >

   <binaryOption key="sdhc_xfertyp_dmaen" condition="sdhc_xfertyp_dmaen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDmaEnable"
      baseType="uint32_t"
      toolTip="Controls the DMA functionality. \n
               When enabled a DMA operation shall begin when the host driver sets the DPSEL bit. \n
               Whether the simple DMA, or the advanced DMA, is active depends on PROCTL[DMAS]."
      description="DMA Enable" >
      <choice name="Disable"     value="0" enum="Disable" />
      <choice name="Enable"      value="1" enum="Enable" />
   </binaryOption >

   <!-- ____ CMDRSP ____ -->
   <intOption key="sdhc_cmdrsp_cmdrsp0" condition="sdhc_cmdrsp_cmdrsp0_present"
      hidden="true"
      typeName="uint32_t"
      toolTip="Response for usual commands:\n
               Response type             Meaning of response        Field    Response registers\n
               R1,R1b (normal response)  Card status                R[39:8]  CMDRSP0\n
               R1b (Auto CMD12 response) Card status for auto CMD12 R[39:8]  CMDRSP3\n
               R2 (CID, CSD register)    CID/CSD register [127:8]   R[127:8] CMDRSP3[23:0],CMDRSP2,CMDRSP1,CMDRSP0\n
               R3 (OCR register)         OCR register for memory    R[39:8]  CMDRSP0\n
               R4 (OCR register)         OCR register for I/O etc.  R[39:8]  CMDRSP0\n
               R5, R5b                   SDIO response              R[39:8]  CMDRSP0\n
               R6 (Publish RCA)          New published RCA[31:16]   R[39:9]  CMDRSP0\n
                                          and card status[15:0]"
      description="Command Response 0"
   />

   <intOption key="sdhc_datport_datcont" condition="sdhc_datport_datcont_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDataContent"
      baseType="uint32_t"
      toolTip="The Buffer Data Port register is for 32-bit data access by the CPU or the external DMA.\n
               When the internal DMA is enabled, any write to this register is ignored, and any read\n
               from this register will always yield 0."
      description="Data Content"
      value="0"
      min="0" max="0"
   />

   <intOption key="sdhc_prsstat_dlsl" condition="sdhc_prsstat_dlsl_present"
      hidden="true"
      typeName="uint32_t"
      toolTip="Used to check the DAT line level to recover from errors, and for debugging.\n
      This is especially useful in detecting the busy signal level from DAT[0].\n
      The reset value is effected by the external pullup/pulldown resistors.\n
      By default, the read value of this field after reset is 8’b11110111, when DAT[3] is\n
      pulled down and the other lines are pulled up."
      description="DAT Line Signal Levels"
   />

   <binaryOption key="sdhc_prsstat_clsl" condition="sdhc_prsstat_clsl_present"
      hidden="true"
      typeName="SdhcCmdSignalLevel"
      baseType="uint32_t"
      toolTip="Reflects the current level of the CMD line signal"
      description="CMD Line Signal Level" >
      <choice name="Low"  value="0" enum="Low" />
      <choice name="High" value="1" enum="High" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_cins" condition="sdhc_prsstat_cins_present"
      hidden="true"
      typeName="SdhcCardPresent"
      baseType="uint32_t"
      toolTip="Indicates whether a card has been inserted.\n
               The SDHC debounces this signal so that the host driver will not need to wait for it to stabilize.\n
               A change from 0 to 1 generates a card insertion interrupt in the Interrupt Status register.\n
               A change from a 1 to 0 generates a card removal interrupt in the Interrupt Status register."
      description="Card Inserted" >
      <choice name="Power on reset or no card"  value="0" enum="PowerOnResetOrNoCard" />
      <choice name="Card inserted"              value="1" enum="CardInserted" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_bren" condition="sdhc_prsstat_bren_present"
      hidden="true"
      typeName="SdhcBufferReadEnable"
      baseType="uint32_t"
      toolTip="Used for non-DMA read transfers.\n
               The SDHC may implement multiple buffers to transfer data efficiently.\n
               This read-only flag indicates that valid data exists in the host side buffer."
      description="Buffer Read Enable" >
      <choice name="Valid data less than the watermark level in the buffer"    value="0" enum="LessThanWatermark" />
      <choice name="Valid data greater than the watermark level in the buffer" value="1" enum="GreaterThanWatermark" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_bwen" condition="sdhc_prsstat_bwen_present"
      hidden="true"
      typeName="SdhcBufferWriteEnable"
      baseType="uint32_t"
      toolTip="Used for non-DMA write transfers.\n
      The SDHC can implement multiple buffers to transfer data efficiently.\n
      This read-only flag indicates whether space is available for write data."
      description="Buffer Write Enable" >
      <choice name="Buffer can hold valid data less than the write watermark level"     value="0" enum="ValidDataLessThanTheWriteWatermarkLevel" />
      <choice name="Buffer can hold valid data greater than the write watermark level"  value="1" enum="ValidDataGreaterThanTheWriteWatermarkLevel" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_rta" condition="sdhc_prsstat_rta_present"
      hidden="true"
      typeName="SdhcReadTransferActive"
      baseType="uint32_t"
      toolTip="Used for detecting completion of a read transfer.\n
               This bit is set for either of the following conditions:\n
               - After the end bit of the read command.\n
               - When writing a 1 to PROCTL[CREQ] to restart a read transfer.
               A transfer complete interrupt is generated when this bit changes to 0.\n
               This bit is cleared for either of the following conditions:\n
               - When the last data block as specified by block length is transferred to the system.\n
               - When all valid data blocks have been transferred from SDHC internal buffer to the system\n
                 and no current block transfers are being sent as a result of the stop at block gap\n
                 request being set to 1."
      description="Read Transfer Active" >
      <choice name="No valid data"      value="0" enum="NoValidData" />
      <choice name="Transferring data"  value="1" enum="TransferringData" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_wta" condition="sdhc_prsstat_wta_present"
      hidden="true"
      typeName="SdhcWriteTransferActive"
      baseType="uint32_t"
      toolTip="Indicates if a write transfer is active"
      description="Write Transfer Active" >
      <choice name="No valid data"      value="0" enum="NoValidData" />
      <choice name="Transferring data"  value="1" enum="TransferringData" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_sdoff" condition="sdhc_prsstat_sdoff_present"
      hidden="true"
      typeName="SdhcSdClockStatus"
      baseType="uint32_t"
      toolTip="Indicates that the SD clock is internally gated off, because of buffer\n
               over/under-run or read pause without read wait assertion, or the driver\n
               has cleared SYSCTL[SDCLKEN] to stop the SD clock.\n
               Allows the host driver to debug data transaction on the SD bus."
      description="SD Clock Gated Off Internally" >
      <choice name="SD clock is active"     value="0" enum="Active" />
      <choice name="SD clock is gated off"  value="1" enum="GatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_peroff" condition="sdhc_prsstat_peroff_present"
      hidden="true"
      typeName="SdhcSdhcClockStatus"
      baseType="uint32_t"
      toolTip="Indicates that the SDHC clock is internally gated off.\n
      This bit is for the host driver to debug transaction on the SD bus.\n
      When INITA bit is set, SDHC sending 80 clock cycles to the card, SDCLKEN\n
      must be 1 to enable the output card clock, otherwise the will never be gate off,\n
      so and will be always active."
      description="SDHC clock Gated Off Internally" >
      <choice name="SDHC clock is active"     value="0" enum="Active" />
      <choice name="SDHC clock is gated off"  value="1" enum="GatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_hckoff" condition="sdhc_prsstat_hckoff_present"
      hidden="true"
      typeName="SdhcSystemClockStatus"
      baseType="uint32_t"
      toolTip="Indicates that the system clock is internally gated off. \n
               This bit is for the host driver to debug during a data transfer."
      description="System Clock Gated Off Internally" >
      <choice name="System clock is active"     value="0" enum="Active" />
      <choice name="System clock is gated off"  value="1" enum="GatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_ipgoff" condition="sdhc_prsstat_ipgoff_present"
      hidden="true"
      typeName="SdhcBusClockStatus"
      baseType="uint32_t"
      toolTip="Indicates that the bus clock is internally gated off.\n
               This bit is for the host driver to debug."
      description="Bus Clock Internal Gating" >
      <choice name="Bus clock is active"     value="0" enum="Active" />
      <choice name="Bus clock is gated off"  value="1" enum="GatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_sdstb" condition="sdhc_prsstat_sdstb_present"
      hidden="true"
      typeName="SdhcSdClockStatus"
      baseType="uint32_t"
      toolTip="Indicates that the internal card clock is stable.\n
               This bit is for the host driver to poll clock status when changing the clock frequency.\n
               It is recommended to clear SYSCTL[SDCLKEN] to remove glitch on the
               card clock when the frequency is changing."
      description="SD Clock Stable" >
      <choice name="Clock is changing frequency and not stable"  value="0" enum="NotStable" />
      <choice name="Clock is stable"                             value="1" enum="Stable" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_dla" condition="sdhc_prsstat_dla_present"
      hidden="true"
      typeName="SdhcDatLineStatus"
      baseType="uint32_t"
      toolTip="Indicates whether one of the DAT lines on the SD bus is in use.\n
               In the case of read transactions:\n
               This status indicates whether a read transfer is executing on the SD bus. Changes in this value from\n
               1 to 0, between data blocks, generates a block gap event interrupt in the Interrupt Status register.\n
               This bit will be set in either of the following cases:\n
               - After the end bit of the read command.\n
               - When writing a 1 to PROCTL[CREQ] to restart a read transfer.\n
               This bit will be cleared in either of the following cases:\n
               - When the end bit of the last data block is sent from the SD bus to the SDHC.\n
               - When the read wait state is stopped by a suspend command and the DAT2 line is released.\n
               The SDHC will wait at the next block gap by driving read wait at the start of the interrupt cycle.\n
               If the read wait signal is already driven (data buffer cannot receive data), the SDHC can wait for\n
               a current block gap by continuing to drive the read wait signal. It is necessary to support read wait\n
               to use the suspend resume function. This bit will remain 1 during read wait.\n
               In the case of write transactions:\n
               This status indicates that a write transfer is executing on the SD bus. Changes in this value from\n
               1 to 0 generate a transfer complete interrupt in the interrupt status register.\n
               This bit will be set in either of the following cases:\n
               - After the end bit of the write command.\n
               - When writing to 1 to PROCTL[CREQ] to continue a write transfer.\n
               This bit will be cleared in either of the following cases:\n
               - When the SD card releases write busy of the last data block, the SDHC will also detect if the output\n
               is not busy. If the SD card does not drive the busy signal after the CRC status is received, the SDHC\n
               shall assume the card drive Not busy.\n
               - When the SD card releases write busy, prior to waiting for write transfer, and as a result of a\n
               stop at block gap request.\n
               In the case of command with busy pending:\n
               This status indicates that a busy state follows the command and the data line is in use. This bit will\n
               be cleared when the DAT0 line is released."
      description="Data Line Active" >
      <choice name="DAT line inactive"  value="0" enum="Inactive" />
      <choice name="DAT line active"    value="1" enum="Active" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_cdihb" condition="sdhc_prsstat_cdihb_present"
      hidden="true"
      typeName="SdhcCommandInhibitDatLine"
      baseType="uint32_t"
      toolTip="This status bit is generated if either the DLA or the RTA is set to 1. \n
               If this bit is 0, it indicates that the SDHC can issue the next SD/MMC Command.\n
               Commands with a busy signal belong to CDIHB, for example, R1b, R5b type.\n
               Except in the case when the command busy is finished, changing from 1 to 0 generates\n
               a transfer complete interrupt in the Interrupt Status register.\n
               NOTE: The SD host driver can save registers for a suspend transaction after this\n
               bit has changed from 1 to 0."
      description="Command Inhibit (DAT)" >
      <choice name="Can issue command which uses the DAT line"     value="0" enum="CanUsesDat" />
      <choice name="Cannot issue command which uses the DAT line"  value="1" enum="CannotUseDat" />
   </binaryOption >

   <binaryOption key="sdhc_prsstat_cihb" condition="sdhc_prsstat_cihb_present"
      hidden="true"
      typeName="SdhcCommandInhibitDatCmdLine"
      baseType="uint32_t"
      toolTip="If this status bit is 0, it indicates that the CMD line is not in use and the SDHC\n
               can issue a SD/MMC Command using the CMD line.\n
               This bit is set also immediately after the Transfer Type register is written.\n
               This bit is cleared when the command response is received.\n
               Even if the CDIHB bit is set to 1, Commands using only the CMD line can be issued\n
               if this bit is 0.\n
               Changing from 1 to 0 generates a command complete interrupt in the interrupt\n
               status register.\n
               If the SDHC cannot issue the command because of a command conflict error or because\n
               of a command not issued by auto CMD12 error, this bit will remain 1 and the command\n
               complete is not set. The status of issuing an auto CMD12 does not show on this bit."
      description="Command Inhibit (CMD)" >
      <choice name="Can issue command using only CMD line"  value="0" enum="CanIssueCommandUsingOnlyCmdLine" />
      <choice name="Cannot issue command"                   value="1" enum="CannotIssueCommand" />
   </binaryOption >

   <!-- ____ PROCTL ____ -->
   <title description="Protocol Control Register" />

   <binaryOption key="sdhc_proctl_wecrm" condition="sdhc_proctl_wecrm_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcWakeupOnCardRemoval"
      baseType="uint32_t"
      toolTip="Enables a wakeup event, via IRQSTAT[CRM]. FN_WUS (Wake Up Support) in CIS does not effect this bit.
When this bit is set, IRQSTAT[CRM] and the SDHC interrupt can be asserted without SD_CLK toggling.
When the wakeup feature is not enabled, the SD_CLK must be active to assert IRQSTAT[CRM] and the
SDHC interrupt."
      description="Wakeup Event Enable On SD Card Removal" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_wecins" condition="sdhc_proctl_wecins_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcWakeupOnCardInsertion"
      baseType="uint32_t"
      toolTip="Enables a wakeup event, via IRQSTAT[CINS]. FN_WUS (Wake Up Support) in CIS does not effect this
bit. When this bit is set, IRQSTATEN[CINSEN] and the SDHC interrupt can be asserted without SD_CLK
toggling. When the wakeup feature is not enabled, the SD_CLK must be active to assert
IRQSTATEN[CINSEN] and the SDHC interrupt."
      description="Wakeup Event Enable On SD Card Insertion" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_wecint" condition="sdhc_proctl_wecint_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcWakeupOnCardInterrupt"
      baseType="uint32_t"
      toolTip="Enables a wakeup event, via IRQSTAT[CINT]. This bit can be set to 1 if FN_WUS (Wake Up Support) in
CIS is set to 1. When this bit is set, the card interrupt status and the SDHC interrupt can be asserted
without SD_CLK toggling. When the wakeup feature is not enabled, the SD_CLK must be active to assert
the card interrupt status and the SDHC interrupt."
      description="Wakeup Event Enable On Card Interrupt" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_iabg" condition="sdhc_proctl_iabg_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcInterruptAtBlockGap"
      baseType="uint32_t"
      toolTip="Valid only in 4-bit mode, of the SDIO card, and selects a sample point in the interrupt cycle. Setting to 1
enables interrupt detection at the block gap for a multiple block transfer. Setting to 0 disables interrupt
detection during a multiple block transfer. If the SDIO card can't signal an interrupt during a multiple block
transfer, this bit must be set to 0 to avoid an inadvertent interrupt. When the host driver detects an SDIO
card insertion, it shall set this bit according to the CCCR of the card."
      description="Interrupt At Block Gap" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_rwctl" condition="sdhc_proctl_rwctl_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcReadWaitControl"
      baseType="uint32_t"
      toolTip="The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use
of the read wait protocol to stop read data using the DAT[2] line. Otherwise, the SDHC has to stop the SD
Clock to hold read data, which restricts commands generation. When the host driver detects an SDIO card
insertion, it shall set this bit according to the CCCR of the card. If the card does not support read wait, this
bit shall never be set to 1, otherwise DAT line conflicts may occur. If this bit is set to 0, stop at block gap
during read operation is also supported, but the SDHC will stop the SD Clock to pause reading operation."
      description="Read Wait Control" >
      <choice name="Disabled (stop SD clock at block gap when SABGREQ is set)"       value="0" enum="StopClock" />
      <choice name="Enable (assert read wait at block gap when SABGREQ bit is set)"  value="1" enum="ReadWait" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_creq" condition="sdhc_proctl_creq_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcContinueRequest"
      baseType="uint32_t"
      toolTip="Used to restart a transaction which was stopped using the PROCTL[SABGREQ]. When a suspend
operation is not accepted by the card, it is also by setting this bit to restart the paused transfer. To cancel
stop at the block gap, set PROCTL[SABGREQ] to 0 and set this bit to 1 to restart the transfer.
The SDHC automatically clears this bit, therefore it is not necessary for the host driver to set this bit to 0. If
both PROCTL[SABGREQ] and this bit are 1, the continue request is ignored."
      description="Continue Request" >
      <choice name="No effect"   value="0" enum="NoEffect" />
      <choice name="Restart"     value="1" enum="Restart" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_sabgreq" condition="sdhc_proctl_sabgreq_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcStopAtBlockGapRequest"
      baseType="uint32_t"
      toolTip="Used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers. Until the
IRQSTATEN[TCSEN] is set to 1, indicating a transfer completion, the host driver shall leave this bit set to
1. Clearing both PROCTL[SABGREQ] and PROCTL[CREQ] does not cause the transaction to restart.
Read Wait is used to stop the read transaction at the block gap. The SDHC will honor the
PROCTL[SABGREQ] for write transfers, but for read transfers it requires that SDIO card support read
wait. Therefore, the host driver shall not set this bit during read transfers unless the SDIO card supports
read wait and has set PROCTL[RWCTL] to 1, otherwise the SDHC will stop the SD bus clock to pause the
read operation during block gap. In the case of write transfers in which the host driver writes data to the
data port register, the host driver shall set this bit after all block data is written. If this bit is set to 1, the
host driver shall not write data to the Data Port register after a block is sent. Once this bit is set, the host
driver shall not clear this bit before IRQSTATEN[TCSEN] is set, otherwise the SDHC's behavior is
undefined.
This bit effects PRSSTAT[RTA], PRSSTAT[WTA], and PRSSTAT[CDIHB]."
      description="Stop At Block Gap Request" >
      <choice name="Transfer"    value="0" enum="Transfer" />
      <choice name="Stop"        value="1" enum="Stop" />
   </binaryOption >

   <choiceOption key="sdhc_proctl_dmas" condition="sdhc_proctl_dmas_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDmaMode"
      baseType="uint32_t"
      toolTip="This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA mode."
      description="DMA Select" >
      <choice name="No DMA or simple DMA is selected"  value="0" enum="NoDmaOrSimpleDma" />
      <choice name="ADMA1 is selected"                 value="1" enum="Adma1" />
      <choice name="ADMA2 is selected"                 value="2" enum="Adma2" />
   </choiceOption >

   <binaryOption key="sdhc_proctl_cdss" condition="sdhc_proctl_cdss_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCardDetectLevelSelect"
      baseType="uint32_t"
      toolTip="Selects the source for the card detection."
      description="Card Detect Signal Selection" >
      <choice name="Normal"                          value="0" enum="Normal" />
      <choice name="Test level (test purpose only)"  value="1" enum="TestLevel" />
   </binaryOption >

   <binaryOption key="sdhc_proctl_cdtl" condition="sdhc_proctl_cdtl_present"
      hidden="true"
      derived="true"
      typeName="SdhcCardDetectLevel"
      baseType="uint32_t"
      toolTip="Indicates card inserted (only when enabled by CDSS)."
      description="Card Detect Test Level" >
      <choice name="No card inserted"  value="0" enum="NoCardInserted" />
      <choice name="Card inserted"     value="1" enum="CardInserted" />
   </binaryOption >

   <choiceOption key="sdhc_proctl_emode" condition="sdhc_proctl_emode_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcEndianMode"
      baseType="uint32_t"
      toolTip="The SDHC supports all four endian modes in data transfer."
      description="Endian Mode" >
      <choice name="Big endian mode"            value="0" enum="BigEndianMode"         />
      <choice name="Half word big endian mode"  value="1" enum="HalfWordBigEndianMode" />
      <choice name="Little endian mode"         value="2" enum="LittleEndianMode"      isDefault="true" />
   </choiceOption >

   <binaryOption key="sdhc_proctl_d3cd" condition="sdhc_proctl_d3cd_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCardDetectUsesDat3"
      baseType="uint32_t"
      toolTip="If this bit is set, DAT3 should be pulled down to act as a card detection pin. Be cautious when using this
feature, because DAT3 is also a chip-select for the SPI mode. A pulldown on this pin and CMD0 may set
the card into the SPI mode, which the SDHC does not support. Note: Keep this bit set if SDIO interrupt is
used."
      description="DAT3 as Card Detection Pin" >
      <choice name="DAT3 does not monitor card Insertion"  value="0" enum="Dat3DoesNotMonitorCardInsertion" />
      <choice name="DAT3 as card detection pin"            value="1" enum="Dat3AsCardDetectionPin" />
   </binaryOption >

   <choiceOption key="sdhc_proctl_dtw" condition="sdhc_proctl_dtw_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcTransferWidth"
      baseType="uint32_t"
      toolTip="Selects the data width of the SD bus for a data transfer. The host driver shall set it to match the data width
of the card. Possible data transfer width is 1-bit, 4-bits or 8-bits."
      description="Data Transfer Width" >
      <choice name="1-bit mode"  value="0" enum="1BitMode" />
      <choice name="4-bit mode"  value="1" enum="4BitMode" />
      <choice name="8-bit mode"  value="2" enum="8BitMode" />
   </choiceOption >

   <binaryOption key="sdhc_proctl_lctl" condition="sdhc_proctl_lctl_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcLed"
      baseType="uint32_t"
      toolTip="This bit, fully controlled by the host driver, is used to caution the user not to remove the card while the card
is being accessed. If the software is going to issue multiple SD commands, this bit can be set during all
these transactions. It is not necessary to change for each transaction. When the software issues multiple
SD commands, setting the bit once before the first command is sufficient: it is not necessary to reset the
bit between commands."
      description="LED Control" >
      <choice name="LED off"     value="0" enum="Off" />
      <choice name="LED on"      value="1" enum="On" />
   </binaryOption >

   <!-- ____ SYSCTL ____ -->
   <title description="System Control Register" />

   <binaryOption key="sdhc_sysctl_inita" condition="sdhc_sysctl_inita_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcInitialise"
      baseType="uint32_t"
      toolTip="When this bit is set, 80 SD-clocks are sent to the card. After the 80 clocks are sent, this bit is self-cleared.
This bit is very useful during the card power-up period when 74 SD-clocks are needed and the clock auto
gating feature is enabled. Writing 1 to this bit when this bit is already 1 has no effect. Writing 0 to this bit at
any time has no effect. When either of the PRSSTAT[CIHB] and PRSSTAT[CDIHB] bits are set, writing 1
to this bit is ignored, that is, when command line or data lines are active, write to this bit is not allowed.\n
On the otherhand, when this bit is set, that is, during intialization active period, it is allowed to issue command,
and the command bit stream will appear on the CMD pad after all 80 clock cycles are done. So when this
command ends, the driver can make sure the 80 clock cycles are sent out. This is very useful when the
driver needs send 80 cycles to the card and does not want to wait till this bit is self-cleared."
      description="Initialisation Active" >
      <choice name="Not active"              value="0" enum="Inactive" />
      <choice name="Start Init/Init active"  value="1" enum="active"   />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_rstd" condition="sdhc_sysctl_rstd_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDatReset"
      baseType="uint32_t"
      toolTip="Only part of the data circuit is reset. DMA circuit is also reset.\n
The following registers and bits are cleared by this bit:\n
- Data Port register\n
- Buffer Is Cleared And Initialized.Present State register\n
- Buffer Read Enable\n
- Buffer Write Enable\n
- Read Transfer Active\n
- Write Transfer Active\n
- DAT Line Active\n
- Command Inhibit (DAT) Protocol Control register\n
- Continue Request\n
- Stop At Block Gap Request Interrupt Status register\n
- Buffer Read Ready\n
- Buffer Write Ready\n
- DMA Interrupt\n
- Block Gap Event\n
- Transfer Complete"
      description="Software Reset For DAT Line" >
      <choice name="No reset"    value="0" enum="NoReset" />
      <choice name="Reset"       value="1" enum="Reset" />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_rstc" condition="sdhc_sysctl_rstc_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcCmdReset"
      baseType="uint32_t"
      toolTip="Only part of the command circuit is reset.\n
The following registers and bits are cleared by this bit:\n
- PRSSTAT[CIHB]\n
- IRQSTAT[CC]"
      description="Software Reset For CMD Line" >
      <choice name="No reset"    value="0" enum="NoReset" />
      <choice name="Reset"       value="1" enum="Reset" />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_rsta" condition="sdhc_sysctl_rsta_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcResetAll"
      baseType="uint32_t"
      toolTip="Affects the entire host controller except for the card detection circuit. Register bits of type ROC, RW,
RW1C, RWAC are cleared. During its Initialisation, the host driver shall set this bit to 1 to reset the SDHC.
The SDHC shall reset this bit to 0 when the capabilities registers are valid and the host driver can read
them. Additional use of software reset for all does not affect the value of the capabilities registers. After
this bit is set, it is recommended that the host driver reset the external card and reinitialize it."
      description="Software Reset For ALL" >
      <choice name="No reset"    value="0" enum="NoReset" />
      <choice name="Reset"       value="1" enum="Reset" />
   </binaryOption >

   <choiceOption key="sdhc_sysctl_dtocv" condition="sdhc_sysctl_dtocv_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcDataTimeout"
      baseType="uint32_t"
      toolTip="Determines the interval by which DAT line timeouts are detected. See IRQSTAT[DTOE] for information on
factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the base
clock SDCLK value by this value.\n
The host driver can clear IRQSTATEN[DTOESEN] to prevent inadvertent time-out events."
      description="Data Timeout Counter Value"
   >
   <choiceExpansion keys="i" dim="15"
      name='="SDCLK x 2^"+ToString(%(i)+13)' value="%(i)"
      enum='="SDCLKx2_"+ToString(%(i)+13)' />
   </choiceOption>

   <aliasOption key="/SIM/sim_sopt2_sdhcsrc[0]" locked="false" />
   <aliasOption key="/SIM/system_sdhc_clock[0]" />

   <choiceOption key="sdhc_sysctl_sdclkfs" condition="sdhc_sysctl_sdclkfs_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcClockPrescaler"
      baseType="uint32_t"
      toolTip="Used to select the frequency of the SDCLK pin\n
               This prescaler is used in conjunction with sdhc_sysctl_dvs to determine the SDCLK frequency:\n
               Clock frequency = (Base clock) / (prescaler * divisor)"
      description="SDCLK Prescale Select" >
      <choiceExpansion  keys="i" dim="8"
         name='="Base clock divided by "+ToString(1&lt;&lt;(%(i)+1))' value="=ToString(1&lt;&lt;%(i))"
         enum='="DivBy"+ToString(1&lt;&lt;(%(i)+1))' isDefault="=%(i)==7" />
   </choiceOption >

   <choiceOption key="sdhc_sysctl_dvs" condition="sdhc_sysctl_dvs_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcSysctlDvs"
      baseType="uint32_t"
      toolTip="Used to select the frequency of the SDCLK pin\n
               This divisor is used in conjunction with sdhc_sysctl_sdclkfs to determine the SDCLK frequency:\n
               Clock frequency = (Base clock) / (prescaler * divisor)"
      description="SDCLK Clock Divisor" >
      <choiceExpansion keys="i" dim="16"
         name='="Prescale clock divided by "+ToString(%(i)+1)' value="%(i)"
         enum='="DivBy"+ToString(%(i)+1)' />
   </choiceOption>
   <intOption key="sdhc_clock_freq"
      derived="true"
      locked="true"
      ref="(/SIM/system_sdhc_clock[0])/(1&lt;&lt;(sdhc_sysctl_sdclkfs+1))/(sdhc_sysctl_dvs+1)"
      description="SDHC Clock frequency"
      toolTip="Calculated SDHC Clock frequency"
      units="Hz"
   />
   <binaryOption key="sdhc_sysctl_sdclken" condition="sdhc_sysctl_sdclken_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcClock"
      baseType="uint32_t"
      toolTip="The host controller shall stop SDCLK when writing this bit to 0.\n
               SDCLK frequency can be changed when this bit is 0. Then, the host controller shall\n
               maintain the same clock frequency until SDCLK is stopped (stop at SDCLK = 0).\n
               If the IRQSTAT[CINS] is cleared, this bit must be cleared by the host driver to save power."
      description="SD Clock Enable" >
      <choice name="Clock disabled"  value="0" enum="Disabled" />
      <choice name="Clock enabled"   value="1" enum="Enabled" isDefault="true" />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_peren" condition="sdhc_sysctl_peren_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcPeripheralClock"
      baseType="uint32_t"
      toolTip="If this bit is set, SDHC clock will always be active and no automatic gating is applied.\n
               Thus the SDCLK is active except for when auto gating-off during buffer danger (buffer about to\n
               over-run or under-run). \n
               When this bit is cleared, the SDHC clock will be automatically off whenever there is no transaction\n
               on the SD bus. \n
               Because this bit is only a feature enabling bit, clearing this bit does not stop SDCLK immediately.\n
               The SDHC clock will be internally gated off, if none of the following factors are met:\n
               - The cmd part is reset, or \n
               - Data part is reset, or \n
               - A soft reset, or \n
               - The cmd is about to send, or \n
               - Clock divisor is just updated, or \n
               - Continue request is just set, or \n
               - This bit is set, or \n
               - Card insertion is detected, or \n
               - Card removal is detected, or"
      description="Peripheral Clock Enable" >
      <choice name="SDHC internally gated off"         value="0" enum="InternallyGatedOff"       />
      <choice name="SDHC not automatically gated off"  value="1" enum="NotAutomaticallyGatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_hcken" condition="sdhc_sysctl_hcken_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcSystemClock"
      baseType="uint32_t"
      toolTip="If this bit is set, system clock will always be active and no automatic gating is applied.\n
               When this bit is cleared, the system clock will be automatically off when no data transfer is on the SD bus."
      description="System Clock Enable" >
      <choice name="System clock internally gated off"         value="0" enum="InternallyGatedOff" />
      <choice name="System clock not automatically gated off"  value="1" enum="NotAutomaticallyGatedOff" />
   </binaryOption >

   <binaryOption key="sdhc_sysctl_ipgen" condition="sdhc_sysctl_ipgen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcBusClock"
      baseType="uint32_t"
      toolTip="If this bit is set, bus clock will always be active and no automatic gating is applied.\n
               The bus clock will be internally gated off, if none of the following factors are met:\n
               - The cmd part is reset, or \n
               - Data part is reset, or \n
               - Soft reset, or \n
               - The cmd is about to send, or \n
               - Clock divisor is just updated, or \n
               - Continue request is just set, or \n
               - This bit is set, or \n
               - Card insertion is detected, or \n
               - Card removal is detected, or \n
               - Card external interrupt is detected, or \n
               - The SDHC clock is not gated off"
      description="IPG Clock Enable" >
      <choice name="Bus clock internally gated off"         value="0" enum="InternallyGatedOff" />
      <choice name="Bus clock not automatically gated off"  value="1" enum="NotAutomaticallyGatedOff" />
   </binaryOption >

   <!-- ____ IRQSTAT ____ -->

   <binaryOption key="sdhc_irqstat_dmae" condition="sdhc_irqstat_dmae_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusDma"
      baseType="uint32_t"
      toolTip="Occurs when an Internal DMA transfer has failed. This bit is set to 1, when some error occurs in the data
transfer. This error can be caused by either Simple DMA or ADMA, depending on which DMA is in use.
The value in DMA System Address register is the next fetch address where the error occurs. Because any
error corrupts the whole data block, the host driver shall restart the transfer from the corrupted block
boundary. The address of the block boundary can be calculated either from the current DSADDR value or
from the remaining number of blocks and the block size."
      description="DMA Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_ac12e" condition="sdhc_irqstat_ac12e_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusAc12"
      baseType="uint32_t"
      toolTip="Occurs when detecting that one of the bits in the Auto CMD12 Error Status register has changed from 0 to
1. This bit is set to 1, not only when the errors in Auto CMD12 occur, but also when the Auto CMD12 is not
executed due to the previous command error."
      description="Auto CMD12 Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_debe" condition="sdhc_irqstat_debe_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusDataBit"
      baseType="uint32_t"
      toolTip="Occurs either when detecting 0 at the end bit position of read data, which uses the DAT line, or at the end
bit position of the CRC."
      description="Data End Bit Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_dce" condition="sdhc_irqstat_dce_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusDataCrc"
      baseType="uint32_t"
      toolTip="Occurs when detecting a CRC error when transferring read data, which uses the DAT line, or when
detecting the Write CRC status having a value other than 010."
      description="Data CRC Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_dtoe" condition="sdhc_irqstat_dtoe_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusTimeout"
      baseType="uint32_t"
      toolTip="Occurs when detecting one of following time-out conditions.
- Busy time-out for R1b,R5b type
- Busy time-out after Write CRC status
- Read Data time-out"
      description="Data Timeout Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Time out"    value="1" enum="TimeOut" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cie" condition="sdhc_irqstat_cie_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusCommandIndex"
      baseType="uint32_t"
      toolTip="Occurs if a Command Index error occurs in the command response."
      description="Command Index Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cebe" condition="sdhc_irqstat_cebe_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusEndBitIs0"
      baseType="uint32_t"
      toolTip="Occurs when detecting that the end bit of a command response is 0."
      description="Command End Bit Error" >
      <choice name="No Error"                 value="0" enum="NoError" />
      <choice name="End Bit Error Generated"  value="1" enum="EndBitErrorGenerated" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cce" condition="sdhc_irqstat_cce_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusCommandCrc"
      baseType="uint32_t"
      toolTip="Command CRC Error is generated in two cases.\n
- If a response is returned and the Command Timeout Error is set to 0, indicating no time-out, this bit
is set when detecting a CRC error in the command response.\n
- The SDHC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the
SDHC drives the CMD line to 1, but detects 0 on the CMD line at the next SDCLK edge, then the
SDHC shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout
Error shall also be set to 1 to distinguish CMD line conflict."
      description="Command CRC Error" >
      <choice name="No Error"             value="0" enum="NoError" />
      <choice name="CRC Error Generated"  value="1" enum="CrcErrorGenerated" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_ctoe" condition="sdhc_irqstat_ctoe_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusResponse"
      baseType="uint32_t"
      toolTip="Occurs only if no response is returned within 64 SDCLK cycles from the end bit of the command. If the
SDHC detects a CMD line conflict, in which case a Command CRC Error shall also be set, this bit shall be
set without waiting for 64 SDCLK cycles. This is because the command will be aborted by the SDHC."
      description="Command Timeout Error" >
      <choice name="No Error"    value="0" enum="NoError" />
      <choice name="Time out"    value="1" enum="TimeOut" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cint" condition="sdhc_irqstat_cint_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusInterrupt"
      baseType="uint32_t"
      toolTip="This status bit is set when an interrupt signal is detected from the external card. In 1-bit mode, the SDHC
will detect the Card Interrupt without the SD Clock to support wakeup. In 4-bit mode, the card interrupt
signal is sampled during the interrupt cycle, so the interrupt from card can only be sampled during interrupt
cycle, introducing some delay between the interrupt signal from the SDIO card and the interrupt to the host
system. Writing this bit to 1 can clear this bit, but as the interrupt factor from the SDIO card does not clear,
this bit is set again. To clear this bit, it is required to reset the interrupt factor from the external card
followed by a writing 1 to this bit.\n
When this status has been set, and the host driver needs to service this interrupt, the Card Interrupt Signal
Enable in the Interrupt Signal Enable register should be 0 to stop driving the interrupt signal to the host
system. After completion of the card interrupt service (it must reset the interrupt factors in the SDIO card
and the interrupt signal may not be asserted), write 1 to clear this bit, set the Card Interrupt Signal Enable
to 1, and start sampling the interrupt signal again."
      description="Card Interrupt" >
      <choice name="No Card Interrupt"        value="0" enum="NoCardInterrupt" />
      <choice name="Generate Card Interrupt"  value="1" enum="GenerateCardInterrupt" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_crm" condition="sdhc_irqstat_crm_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusCardInserted"
      baseType="uint32_t"
      toolTip="This status bit is set if the Card Inserted bit in the Present State register changes from 1 to 0. When the
host driver writes this bit to 1 to clear this status, the status of the Card Inserted in the Present State
register must be confirmed. Because the card state may possibly be changed when the host driver clears
this bit and the interrupt event may not be generated. When this bit is cleared, it will be set again if no card
is inserted. To leave it cleared, clear the Card Removal Status Enable bit in Interrupt Status Enable
register."
      description="Card Removal" >
      <choice name="Card state unstable or inserted"  value="0" enum="CardStateUnstableOrInserted" />
      <choice name="Card removed"                     value="1" enum="CardRemoved" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cins" condition="sdhc_irqstat_cins_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusCardRemoved"
      baseType="uint32_t"
      toolTip="This status bit is set if the Card Inserted bit in the Present State register changes from 0 to 1. When the
host driver writes this bit to 1 to clear this status, the status of the Card Inserted in the Present State
register must be confirmed. Because the card state may possibly be changed when the host driver clears
this bit and the interrupt event may not be generated. When this bit is cleared, it will be set again if a card
is inserted. To leave it cleared, clear the Card Inserted Status Enable bit in Interrupt Status Enable
register."
      description="Card Insertion" >
      <choice name="Card state unstable or removed"  value="0" enum="CardStateUnstableOrRemoved" />
      <choice name="Card inserted"                   value="1" enum="CardInserted" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_brr" condition="sdhc_irqstat_brr_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusBufferRead"
      baseType="uint32_t"
      toolTip="This status bit is set if the Buffer Read Enable bit, in the Present State register, changes from 0 to 1. See
the Buffer Read Enable bit in the Present State register for additional information."
      description="Buffer Read Ready" >
      <choice name="Not ready to read buffer"  value="0" enum="NotReadyToReadBuffer" />
      <choice name="Ready to read buffer"      value="1" enum="ReadyToReadBuffer" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_bwr" condition="sdhc_irqstat_bwr_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusBufferWrite"
      baseType="uint32_t"
      toolTip="This status bit is set if the Buffer Write Enable bit, in the Present State register, changes from 0 to 1. See
the Buffer Write Enable bit in the Present State register for additional information."
      description="Buffer Write Ready" >
      <choice name="Not ready to write buffer"  value="0" enum="NotReadyToWriteBuffer" />
      <choice name="Ready to write buffer"      value="1" enum="ReadyToWriteBuffer" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_dint" condition="sdhc_irqstat_dint_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusDmaCompleted"
      baseType="uint32_t"
      toolTip="Occurs only when the internal DMA finishes the data transfer successfully. Whenever errors occur during
data transfer, this bit will not be set. Instead, the DMAE bit will be set. Either Simple DMA or ADMA
finishes data transferring, this bit will be set."
      description="DMA Interrupt" >
      <choice name="No DMA Interrupt"            value="0" enum="NoDmaInterrupt" />
      <choice name="DMA Interrupt is generated"  value="1" enum="DmaInterruptIsGenerated" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_bge" condition="sdhc_irqstat_bge_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusBlockGap"
      baseType="uint32_t"
      toolTip="If PROCTL[SABGREQ] is set, this bit is set when a read or write transaction is stopped at a block gap. If
PROCTL[SABGREQ] is not set to 1, this bit is not set to 1.
In the case of a read transaction: This bit is set at the falling edge of the DAT line active status, when the
transaction is stopped at SD Bus timing. The read wait must be supported in order to use this function.
In the case of write transaction: This bit is set at the falling edge of write transfer active status, after getting
CRC status at SD bus timing."
      description="Block Gap Event" >
      <choice name="No block gap event"                value="0" enum="NoBlockGapEvent" />
      <choice name="Transaction stopped at block gap"  value="1" enum="TransactionStoppedAtBlockGap" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_tc" condition="sdhc_irqstat_tc_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusTransfer"
      baseType="uint32_t"
      toolTip="This bit is set when a read or write transfer is completed.
In the case of a read transaction: This bit is set at the falling edge of the read transfer active status. There
are two cases in which this interrupt is generated. The first is when a data transfer is completed as
specified by the data length, after the last data has been read to the host system. The second is when
data has stopped at the block gap and completed the data transfer by setting PROCTL[SABGREQ], after
valid data has been read to the host system.
In the case of a write transaction: This bit is set at the falling edge of the DAT line active status. There are
two cases in which this interrupt is generated. The first is when the last data is written to the SD card as
specified by the data length and the busy signal is released. The second is when data transfers are
stopped at the block gap, by setting PROCTL[SABGREQ], and the data transfers are completed,after valid
data is written to the SD card and the busy signal released."
      description="Transfer Complete" >
      <choice name="Transfer not complete"  value="0" enum="TransferNotComplete" />
      <choice name="Transfer complete"      value="1" enum="TransferComplete" />
   </binaryOption >

   <binaryOption key="sdhc_irqstat_cc" condition="sdhc_irqstat_cc_present"
      derived="true"
      hidden="true"
      typeName="SdhcIrqStatusEndBit"
      baseType="uint32_t"
      toolTip="This bit is set when you receive the end bit of the command response, except Auto CMD12.\n
               See PRSSTAT[CIHB]."
      description="Command Complete" >
      <choice name="Command not complete"  value="0" enum="CommandNotComplete" />
      <choice name="Command complete"      value="1" enum="CommandComplete" />
   </binaryOption >

   <!-- ____ IRQSTAT ____ -->

   <bitfieldOption key="sdhc_irqstat"
      hidden="true"
      derived="true"
      valueFormat="%s"
      description="Interrupt Status Flags"
      toolTip="Bitmask indicating individual interrupt flags.\n
               Note: To successfully clear the Card Interrupt, it is required that the card stops \n
               asserting the interrupt, otherwise the CINT bit will be immediately asserted again."
      typeName="SdhcStatusFlag"
      enumClass="true"
      baseType="uint32_t"
      value="0"
      >
      <choice name="DMA Error"             enum="DmaError"            value="=ToString(1&lt;&lt;28)" condition="sdhc_irqstat_dmae_present"  />
      <choice name="Auto CMD12 Error"      enum="AutoCommand12Error"  value="=ToString(1&lt;&lt;24)" condition="sdhc_irqstat_ac12e_present" />
      <choice name="Data End Bit Error"    enum="DataEndBitError"     value="=ToString(1&lt;&lt;22)" condition="sdhc_irqstat_debe_present"  />
      <choice name="Data CRC Error"        enum="DataCrcError"        value="=ToString(1&lt;&lt;21)" condition="sdhc_irqstat_dce_present"   />
      <choice name="Data Timeout Error"    enum="DataTimeoutError"    value="=ToString(1&lt;&lt;20)" condition="sdhc_irqstat_dtoe_present"  />
      <choice name="Command Index Error"   enum="CommandIndexError"   value="=ToString(1&lt;&lt;19)" condition="sdhc_irqstat_cie_present"   />
      <choice name="Command End Bit Error" enum="CommandEndBitError"  value="=ToString(1&lt;&lt;18)" condition="sdhc_irqstat_cebe_present"  />
      <choice name="Command CRC Error"     enum="CommandCrcError"     value="=ToString(1&lt;&lt;17)" condition="sdhc_irqstat_cce_present"   />
      <choice name="Command Timeout Error" enum="CommandTimeoutError" value="=ToString(1&lt;&lt;16)" condition="sdhc_irqstat_ctoe_present"  />
      <choice name="Card Interrupt"        enum="CardInterrupt"       value="=ToString(1&lt;&lt;8)"  condition="sdhc_irqstat_cint_present"  />
      <choice name="Card Removal"          enum="CardRemoval"         value="=ToString(1&lt;&lt;7)"  condition="sdhc_irqstat_crm_present"   />
      <choice name="Card Insertion"        enum="CardInsertion"       value="=ToString(1&lt;&lt;6)"  condition="sdhc_irqstat_cins_present"   />
      <choice name="Buffer Read Ready"     enum="BufferReadReady"     value="=ToString(1&lt;&lt;5)"  condition="sdhc_irqstat_brr_present"   />
      <choice name="Buffer Write Ready"    enum="BufferWriteReady"    value="=ToString(1&lt;&lt;4)"  condition="sdhc_irqstat_bwr_present"   />
      <choice name="DMA Interrupt"         enum="DmaComplete"         value="=ToString(1&lt;&lt;3)"  condition="sdhc_irqstat_dint_present"  />
      <choice name="Block Gap Event"       enum="BlockGapEvent"       value="=ToString(1&lt;&lt;2)"  condition="sdhc_irqstat_bge_present"   />
      <choice name="Transfer Complete"     enum="TransferComplete"    value="=ToString(1&lt;&lt;1)"  condition="sdhc_irqstat_tc_present"    />
      <choice name="Command Complete"      enum="CommandComplete"     value="=ToString(1&lt;&lt;0)"  condition="sdhc_irqstat_cc_present"    />
   </bitfieldOption>

   <!-- ____ IRQSTATEN ____ -->

   <bitfieldOption key="sdhc_irqstaten"
      derivedFrom="sdhc_irqstat"
      valueFormat="%s"
      enabledBy="enablePeripheralSupport"
      description="Interrupt Status Flag Enables"
      toolTip="Bitmask allowing individual interrupt status events to set status flags.\n
               If any bit is cleared, the corresponding interrupt status flag is held cleared."
      typeName="SdhcStatusFlagEnable"
      enumClass="true"
      baseType="uint32_t"
      value="0b10001011111110000000100111111"
      >
   </bitfieldOption>

   <!-- ____ IRQSIGEN ____ -->

   <bitfieldOption key="sdhc_irqsigen"
      derivedFrom="sdhc_irqstat"
      valueFormat="%s"
      enabledBy="enablePeripheralSupport"
      description="Interrupt Enables"
      toolTip="Bitmask selecting which interrupt status flags are enabled as interrupt sources.\n
               If any bit is cleared, the corresponding interrupt status flag is ignored."
      typeName="SdhcInterruptEnable"
      enumClass="true"
      baseType="uint32_t"
      value="0" >
   </bitfieldOption>

   <!-- ____ AC12ERR ____ -->

   <bitfieldOption key="sdhc_ac12err"
      valueFormat="%s"
      hidden="true"
      derived="true"
      description="Auto CMD12 Error Status"
      toolTip="When the AC12ESEN bit in the Status register is set, this register identifies what kind of error\n
               the Auto CMD12 indicated.\n
               This register is valid only when the Auto CMD12 Error status bit is set."
      typeName="SdhcAc12Error"
      enumClass="true"
      baseType="uint32_t" >
      <choice name="Auto CMD12 Cmd Not Issued Error"  enum="CmdNotIssuedError"   value="=ToString(1&lt;&lt;7)" condition="sdhc_ac12err_cnibac12e_present" />
      <choice name="Auto CMD12 Index Error"           enum="IndexError"          value="=ToString(1&lt;&lt;4)" condition="sdhc_ac12err_ac12ie_present"    />
      <choice name="Auto CMD12 CRC Error"             enum="CrcError"            value="=ToString(1&lt;&lt;3)" condition="sdhc_ac12err_ac12ce_present"    />
      <choice name="Auto CMD12 End Bit Error"         enum="EndBitError"         value="=ToString(1&lt;&lt;2)" condition="sdhc_ac12err_ac12ebe_present"   />
      <choice name="Auto CMD12 Timeout Error"         enum="TimeoutError"        value="=ToString(1&lt;&lt;1)" condition="sdhc_ac12err_ac12toe_present"   />
      <choice name="Auto CMD12 Cmd Not Executed"      enum="CmdNotExecutedError" value="=ToString(1&lt;&lt;0)" condition="sdhc_ac12err_ac12ne_present"    />
   </bitfieldOption>

   <!-- ____ HTCAPBLT ____ -->

   <binaryOption key="sdhc_htcapblt_vs33" condition="sdhc_htcapblt_vs33_present"
      hidden="true"
      typeName="Sdhc3V3Support"
      baseType="uint32_t"
      toolTip="Indicates availability of 3.3V support"
      description="Voltage Support 3.3 V" >
      <choice name="3.3 V not supported"  value="0" enum="NotSupported" />
      <choice name="3.3 V supported"      value="1" enum="Supported" />
   </binaryOption >

   <binaryOption key="sdhc_htcapblt_srs" condition="sdhc_htcapblt_srs_present"
      hidden="true"
      typeName="SdhcHaltSupport"
      baseType="uint32_t"
      toolTip="This bit indicates whether the SDHC supports suspend / resume functionality.\n
               If this bit is 0, the suspend and resume mechanism, as well as the read wait,\n
               are not supported."
      description="Suspend/Resume Support" >
      <choice name="Not supported"  value="0" enum="NotSupported" />
      <choice name="Supported"      value="1" enum="Supported" />
   </binaryOption >

   <binaryOption key="sdhc_htcapblt_dmas" condition="sdhc_htcapblt_dmas_present"
      hidden="true"
      typeName="SdhcDmaSupport"
      baseType="uint32_t"
      toolTip="This bit indicates whether the SDHC is capable of using the internal DMA\n
               to transfer data between system memory and the data buffer directly."
      description="DMA Support" >
      <choice name="DMA not supported"  value="0" enum="DmaNotSupported" />
      <choice name="DMA supported"      value="1" enum="DmaSupported" />
   </binaryOption >

   <binaryOption key="sdhc_htcapblt_hss" condition="sdhc_htcapblt_hss_present"
      hidden="true"
      typeName="SdhcHighSpeedSupport"
      baseType="uint32_t"
      toolTip="This bit indicates whether the SDHC supports high speed mode and\n
               the host system can supply a SD Clock frequency from 25 MHz to 50 MHz."
      description="High Speed Support" >
      <choice name="High speed not supported"  value="0" enum="HighSpeedNotSupported" />
      <choice name="High speed supported"      value="1" enum="HighSpeedSupported" />
   </binaryOption >

   <binaryOption key="sdhc_htcapblt_admas" condition="sdhc_htcapblt_admas_present"
      hidden="true"
      typeName="SdhcAdmaSupport"
      baseType="uint32_t"
      toolTip="Indicates whether the SDHC supports the ADMA feature."
      description="ADMA Support" >
      <choice name="Advanced DMA not supported"  value="0" enum="AdvancedDmaNotSupported" />
      <choice name="Advanced DMA supported"      value="1" enum="AdvancedDmaSupported" />
   </binaryOption >

   <choiceOption key="sdhc_htcapblt_mbl" condition="sdhc_htcapblt_mbl_present"
      hidden="true"
      typeName="SdhcMaxBlockSize"
      baseType="uint32_t"
      toolTip="This value indicates the maximum block size that the host driver can read and write\n
               to the buffer in the SDHC. The buffer shall transfer block size without wait cycles."
      description="Max Block Length" >
      <choice name="512 bytes"   value="0" enum="512Bytes" />
      <choice name="1024 bytes"  value="1" enum="1024Bytes" />
      <choice name="2048 bytes"  value="2" enum="2048Bytes" />
      <choice name="4096 bytes"  value="3" enum="4096Bytes" />
   </choiceOption >

   <!-- ____ WML ____ -->

   <intOption key="sdhc_wml_wrwml" condition="sdhc_wml_wrwml_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcWriteWaterLevel"
      baseType="uint8_t"
      toolTip="The number of words used as the watermark level (FIFO threshold) in a\n
               DMA write operation. Also the number of words as a sequence of write bursts\n
               in back-to-back mode."
      description="Write Watermark Level"
      value="0b10000"
      min="0" max="128"
   />

   <intOption key="sdhc_wml_rdwml" condition="sdhc_wml_rdwml_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcReadWaterLevel"
      baseType="uint8_t"
      toolTip="The number of words used as the watermark level (FIFO threshold) in a\n
               DMA read operation. Also the number of words as a sequence of read bursts\n
               in back-to-back mode."
      description="Read Watermark Level"
      value="0b10000"
      min="0" max="128"
   />

   <!-- ____ FEVT ____ -->

   <bitfieldOption key="sdhc_fevt"
      valueFormat="%s"
      derived="true"
      description="Force Event"
      toolTip="Bitmask used to force events.\n
               The Force Event (FEVT) register is not a physically implemented register. Rather, \n
               it is an address at which the Interrupt Status register can be written if the\n
               corresponding bit of the Interrupt Status Enable register is set.\n
               Writing 1 to this register sets the corresponding bit of the ISR\n
               Requires SYSCTL[IPGEN] so that bus clock is always active."
      typeName="SdhcForceError"
      enumClass="true"
      baseType="uint32_t" >
      <choice name="Card Interrupt"                         enum="CardInterrupt"         value="=ToString(1&lt;&lt;31)" condition="sdhc_fevt_cint_present"  />
      <choice name="DMA Error"                              enum="DmaError"              value="=ToString(1&lt;&lt;28)" condition="sdhc_fevt_dmae_present"  />
      <choice name="Auto CMD12 Error"                       enum="Acmd12Error"           value="=ToString(1&lt;&lt;24)" condition="sdhc_fevt_ac12e_present" />
      <choice name="Data End Bit Error"                     enum="DataEndBitError"       value="=ToString(1&lt;&lt;22)" condition="sdhc_fevt_debe_present"  />
      <choice name="Data CRC Error"                         enum="DataCrcError"          value="=ToString(1&lt;&lt;21)" condition="sdhc_fevt_dce_present"   />
      <choice name="Data Timeout Error"                     enum="DataTimeoutError"      value="=ToString(1&lt;&lt;20)" condition="sdhc_fevt_dtoe_present"  />
      <choice name="Command Index Error"                    enum="CommandIndexError"     value="=ToString(1&lt;&lt;19)" condition="sdhc_fevt_cie_present"   />
      <choice name="Command End Bit Error"                  enum="CommandEndBitError"    value="=ToString(1&lt;&lt;18)" condition="sdhc_fevt_cebe_present"  />
      <choice name="Command CRC Error"                      enum="CommandCrcError"       value="=ToString(1&lt;&lt;17)" condition="sdhc_fevt_cce_present"   />
      <choice name="Command Timeout Error"                  enum="CommandTimeoutError"   value="=ToString(1&lt;&lt;16)" condition="sdhc_fevt_ctoe_present"  />
      <choice name="Auto CMD12 Cmd Not Issued Error"        enum="Cmd12NotIssuedError"   value="=ToString(1&lt;&lt;7)"  condition="sdhc_fevt_cnibac12e_present" />
      <choice name="Auto CMD12 Index Error"                 enum="Cmd12IndexError"       value="=ToString(1&lt;&lt;4)"  condition="sdhc_fevt_ac12ie_present"    />
      <choice name="Auto CMD12 CRC Error"                   enum="Cmd12CrcError"         value="=ToString(1&lt;&lt;3)"  condition="sdhc_fevt_ac12ce_present"    />
      <choice name="Auto CMD12 End Bit Error"               enum="Cmd12EndBitError"      value="=ToString(1&lt;&lt;2)"  condition="sdhc_fevt_ac12ebe_present"   />
      <choice name="Auto CMD12 Timeout Error"               enum="Cmd12TimeoutError"     value="=ToString(1&lt;&lt;1)"  condition="sdhc_fevt_ac12toe_present"   />
      <choice name="Auto CMD12 Cmd Not Executed"            enum="Cmd12NotExecutedError" value="=ToString(1&lt;&lt;0)"  condition="sdhc_fevt_ac12ne_present"    />
   </bitfieldOption>


   <!-- ____ ADMAES ____ -->

   <binaryOption key="sdhc_admaes_admadce" condition="sdhc_admaes_admadce_present"
      hidden="true"
      typeName="SdhcAdmaDescriptorError"
      baseType="uint32_t"
      toolTip="This error occurs when an invalid descriptor is fetched by ADMA."
      description="ADMA Descriptor Error" >
      <choice name="No error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <binaryOption key="sdhc_admaes_admalme" condition="sdhc_admaes_admalme_present"
      hidden="true"
      typeName="SdhcAdmaLengthError"
      baseType="uint32_t"
      toolTip="This error occurs in the following 2 cases:\n
               - While the block count enable is being set, the total data length specified by the descriptor table is\n
               different from that specified by the block count and block length.\n
               - Total data length can not be divided by the block length."
      description="ADMA Length Mismatch Error" >
      <choice name="No error"    value="0" enum="NoError" />
      <choice name="Error"       value="1" enum="Error" />
   </binaryOption >

   <choiceOption key="sdhc_admaes_admaes" condition="sdhc_admaes_admaes_present"
      hidden="true"
      typeName="SdhcAdmaErrorState"
      baseType="uint32_t"
      toolTip="Indicates the state of the ADMA when an error has occurred during an ADMA data transfer."
      description="ADMA Error State (when ADMA Error has occurred.)" >
      <choice name="Choice 0"  value="0" enum="Choice0" />
      <choice name="Choice 1"  value="1" enum="Choice1" />
      <choice name="Choice 2"  value="2" enum="Choice2" />
      <choice name="Choice 3"  value="3" enum="Choice3" />
   </choiceOption >

   <!-- ____ ADSADDR ____ -->
   <intOption key="sdhc_adsaddr_adsaddr" condition="sdhc_adsaddr_adsaddr_present"
      enabledBy="enablePeripheralSupport"
      typeName="AdmaSystemAddress"
      baseType="uint32_t"
      toolTip=""
      description="ADMA System Address"
      value="0"
      min="0" max="1073741823"
   />

   <!-- ____ VENDOR ____ -->

   <intOption key="sdhc_vendor_intstval" condition="sdhc_vendor_intstval_present"
      hidden="true"
      typeName="uint32_t"
      toolTip="Internal state value, reflecting the corresponding state value selected by Debug Select field."
      description="Internal State Value"
   />

   <binaryOption key="sdhc_vendor_exblknu" condition="sdhc_vendor_exblknu_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcExactBlockNumber"
      baseType="uint32_t"
      toolTip="This bit must be set before S/W issues CMD53 multi-block read with exact block number.\n
               This bit must not be set if the CMD53 multi-block read is not exact block number."
      description="Exact Block Number Block Read Enable For SDIO CMD53" >
      <choice name="No exact block read"              value="0" enum="NoExactBlockRead" />
      <choice name="Exact block read for SDIO CMD53"  value="1" enum="ExactBlockReadForSdioCmd53" />
   </binaryOption >

   <!-- ____ MMCBOOT ____ -->
   <title description="MMC Boot Register" />

   <intOption key="sdhc_mmcboot_bootblkcnt" condition="sdhc_mmcboot_bootblkcnt_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcMmcBootBlockCount"
      baseType="uint16_t"
      toolTip="When received card block cnt is equal to BOOTBLKCNT and AUTOSABGEN is 1, then stop at block gap"
      description="Defines the stop at block gap value of automatic mode."
      value="0"
      min="0" max="65535"
   />

   <binaryOption key="sdhc_mmcboot_autosabgen" condition="sdhc_mmcboot_autosabgen_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcMmcBootStopAtGap"
      baseType="uint32_t"
      toolTip="This function will be triggered, and host will stop at block gap when received card block cnt is equal to BOOTBLKCNT"
      description="Enable auto stop at block gap function." >
      <choice name="Enabled"   value="0" enum="Enabled" />
      <choice name="Disabled"  value="1" enum="Disabled" />
   </binaryOption >

   <binaryOption key="sdhc_mmcboot_booten" condition="sdhc_mmcboot_booten_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcMmcFastBootEnable"
      baseType="uint32_t"
      toolTip="Enable fast boot"
      description="Boot Mode Enable" >
      <choice name="Fast boot disable"  value="0" enum="FastBootDisable" />
      <choice name="Fast boot enable"   value="1" enum="FastBootEnable" />
   </binaryOption >

   <binaryOption key="sdhc_mmcboot_bootmode" condition="sdhc_mmcboot_bootmode_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcMmcBootmode"
      baseType="uint32_t"
      toolTip="Controls boot mode"
      description="Boot Mode Select" >
      <choice name="Normal boot"       value="0" enum="NormalBoot" />
      <choice name="Alternative boot"  value="1" enum="AlternativeBoot" />
   </binaryOption >

   <binaryOption key="sdhc_mmcboot_bootack" condition="sdhc_mmcboot_bootack_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcMmcBootAck"
      baseType="uint32_t"
      toolTip="Controls Boot Ack mode"
      description="Boot Ack Mode Select" >
      <choice name="No ack"      value="0" enum="NoAck" />
      <choice name="Ack"         value="1" enum="Ack" />
   </binaryOption >

   <choiceOption key="sdhc_mmcboot_dtocvack" condition="sdhc_mmcboot_dtocvack_present"
      enabledBy="enablePeripheralSupport"
      typeName="SdhcAckTimeout"
      baseType="uint32_t"
      toolTip="Controls timeout value"
      description="Boot ACK Time Out Counter Value" >
      <choice name="SDCLK x 2^8"   value="0" enum="SdclkBy2_8" />
      <choice name="SDCLK x 2^9"   value="1" enum="SdclkBy2_9" />
      <choice name="SDCLK x 2^10"  value="2" enum="SdclkBy2_10" />
      <choice name="SDCLK x 2^11"  value="3" enum="SdclkBy2_11" />
      <choice name="SDCLK x 2^12"  value="4" enum="SdclkBy2_12" />
      <choice name="SDCLK x 2^13"  value="5" enum="SdclkBy2_13" />
      <choice name="SDCLK x 2^14"  value="6" enum="SdclkBy2_14" />
      <choice name="SDCLK x 2^15"  value="7" enum="SdclkBy2_15" />
      <choice name="SDCLK x 2^22" value="14" enum="SdclkBy2_22" />
   </choiceOption >

   <!-- ____ HOSTVER ____ -->
   <choiceOption key="sdhc_hostver_vvn" condition="sdhc_hostver_vvn_present"
      hidden="true"
      typeName="SdhcSpecificationVersion"
      baseType="uint32_t"
      toolTip="These status bits are reserved for the vendor version number.\n
               The host driver shall not use this status."
      description="Vendor Version Number" >
      <choice name="SDHC version 1.0"  value="0" enum="SdhcVersion10" />
      <choice name="SDHC version 2.0" value="16" enum="SdhcVersion20" />
      <choice name="SDHC version 2.1" value="17" enum="SdhcVersion21" />
      <choice name="SDHC version 2.2" value="18" enum="SdhcVersion22" />
   </choiceOption >

   <choiceOption key="sdhc_hostver_svn" condition="sdhc_hostver_svn_present"
      hidden="true"
      typeName="SdhcHostverSvn"
      baseType="uint32_t"
      toolTip="These status bits indicate the host controller specification version."
      description="Specification Version Number" >
      <choice name="Version 2.0, supports test event register and ADMA"  value="1" enum="Version2" />
   </choiceOption >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field                     : set   : get   : clear : genCode                 : name"
        values="

         sdhc_dsaddr_dsaddr             : true  : true  : false : enableGettersAndSetters : DmaSourceAddress;

         sdhc_blkattr_blkcnt            : true  : true  : false : enablePeripheralSupport : BlockCount;
         sdhc_blkattr_blksize           : true  : true  : false : enablePeripheralSupport : BlockSize;

         sdhc_cmdarg_cmdarg             : true  : true  : false : enablePeripheralSupport : CommandArgument;

         sdhc_xfertyp_cmdinx            : true  : true  : false : enableGettersAndSetters : CommandIndex;
         sdhc_xfertyp_cmdtyp            : true  : true  : false : enableGettersAndSetters : CommandType;
         sdhc_xfertyp_dpsel             : true  : true  : false : enableGettersAndSetters : DataSelect;
         sdhc_xfertyp_cicen             : true  : true  : false : enableGettersAndSetters : IndexCheck;
         sdhc_xfertyp_cccen             : true  : true  : false : enableGettersAndSetters : CommandCRC;
         sdhc_xfertyp_rsptyp            : true  : true  : false : enableGettersAndSetters : ResponseType;
         sdhc_xfertyp_msbsel            : true  : true  : false : enableGettersAndSetters : BlockMode;
         sdhc_xfertyp_dtdsel            : true  : true  : false : enableGettersAndSetters : Direction;
         sdhc_xfertyp_ac12en            : true  : true  : false : enableGettersAndSetters : AutoCmd12Enable;
         sdhc_xfertyp_bcen              : true  : true  : false : enableGettersAndSetters : BlockCountEnable;
         sdhc_xfertyp_dmaen             : true  : true  : false : enableGettersAndSetters : DmaEnable;

         sdhc_datport_datcont           : true  : true  : false : enableGettersAndSetters : DataPort;

         sdhc_prsstat_dlsl              : false : true  : false : enableGettersAndSetters : DatLineLevel;
         sdhc_prsstat_clsl              : false : true  : false : enableGettersAndSetters : CmdSignalLevel;
         sdhc_prsstat_cins              : false : true  : false : enableGettersAndSetters : CardPresent;
         sdhc_prsstat_bren              : false : true  : false : enableGettersAndSetters : BufferReadEnable;
         sdhc_prsstat_bwen              : false : true  : false : enableGettersAndSetters : BufferWriteEnable;
         sdhc_prsstat_rta               : false : true  : false : enableGettersAndSetters : ReadTransferActive;
         sdhc_prsstat_wta               : false : true  : false : enableGettersAndSetters : WriteTransferActive;
         sdhc_prsstat_sdoff             : false : true  : false : enableGettersAndSetters : SdClockStatus;
         sdhc_prsstat_peroff            : false : true  : false : enableGettersAndSetters : SdhcClockStatus;
         sdhc_prsstat_hckoff            : false : true  : false : enableGettersAndSetters : SystemClockStatus;
         sdhc_prsstat_ipgoff            : false : true  : false : enableGettersAndSetters : BusClockStatus;
         sdhc_prsstat_sdstb             : false : true  : false : enableGettersAndSetters : SdClockStable;
         sdhc_prsstat_dla               : false : true  : false : enableGettersAndSetters : DatLineStatus;
         sdhc_prsstat_cdihb             : false : true  : false : enableGettersAndSetters : CommandInhibitDatLine;
         sdhc_prsstat_cihb              : false : true  : false : enableGettersAndSetters : CommandInhibitDatCmdLine;

         sdhc_proctl_wecrm              : true  : true  : false : enableGettersAndSetters : WakeupOnCardRemoval;
         sdhc_proctl_wecins             : true  : true  : false : enableGettersAndSetters : WakeupOnCardInsertion;
         sdhc_proctl_wecint             : true  : true  : false : enableGettersAndSetters : WakeupOnCardInterrupt;
         sdhc_proctl_iabg               : true  : true  : false : enableGettersAndSetters : InterruptAtBlockGap;
         sdhc_proctl_rwctl              : true  : true  : false : enableGettersAndSetters : ReadWaitControl;
         sdhc_proctl_creq               : true  : true  : false : enableGettersAndSetters : ContinueRequest;
         sdhc_proctl_sabgreq            : true  : true  : false : enableGettersAndSetters : StopAtBlockGapRequest;
         sdhc_proctl_dmas               : true  : true  : false : enableGettersAndSetters : DmaMode;
         sdhc_proctl_cdss               : true  : true  : false : enableGettersAndSetters : CardDetectLevelSelect;
         sdhc_proctl_cdtl               : true  : true  : false : enableGettersAndSetters : CardDetectLevel;
         sdhc_proctl_emode              : true  : true  : false : enablePeripheralSupport : EndianMode;
         sdhc_proctl_d3cd               : true  : true  : false : enableGettersAndSetters : CardDetectUsesDat3;
         sdhc_proctl_dtw                : true  : true  : false : enablePeripheralSupport : TransferWidth;
         sdhc_proctl_lctl               : true  : true  : false : enableGettersAndSetters : Led;

         sdhc_sysctl_inita              : true  : true  : false : enableGettersAndSetters : Initialise;
         sdhc_sysctl_rstd               : true  : true  : false : enableGettersAndSetters : DatReset;
         sdhc_sysctl_rstc               : true  : true  : false : enableGettersAndSetters : CmdReset;
         sdhc_sysctl_rsta               : true  : true  : false : enableGettersAndSetters : ResetAll;
         sdhc_sysctl_dtocv              : true  : true  : false : enableGettersAndSetters : DataTimeout;
         sdhc_sysctl_sdclkfs            : true  : true  : false : enableGettersAndSetters : ClockPrescaler;
         sdhc_sysctl_dvs                : true  : true  : false : enableGettersAndSetters : SysctlDvs;
         sdhc_sysctl_sdclken            : true  : true  : false : enableGettersAndSetters : Clock;
         sdhc_sysctl_peren              : true  : true  : false : enableGettersAndSetters : PeripheralClock;
         sdhc_sysctl_hcken              : true  : true  : false : enableGettersAndSetters : SystemClock;
         sdhc_sysctl_ipgen              : true  : true  : false : enableGettersAndSetters : BusClock;

         sdhc_irqstat_dmae              : false : true  : true  : enableGettersAndSetters : IrqStatusDma;
         sdhc_irqstat_ac12e             : false : true  : true  : enableGettersAndSetters : IrqStatusAc12;
         sdhc_irqstat_debe              : false : true  : true  : enableGettersAndSetters : IrqStatusDataBit;
         sdhc_irqstat_dce               : false : true  : true  : enableGettersAndSetters : IrqStatusDataCrc;
         sdhc_irqstat_dtoe              : false : true  : true  : enableGettersAndSetters : IrqStatusTimeout;
         sdhc_irqstat_cie               : false : true  : true  : enableGettersAndSetters : IrqStatusCommandIndex;
         sdhc_irqstat_cebe              : false : true  : true  : enableGettersAndSetters : IrqStatusEndBitIs0;
         sdhc_irqstat_cce               : false : true  : true  : enableGettersAndSetters : IrqStatusCommandCrc;
         sdhc_irqstat_ctoe              : false : true  : true  : enableGettersAndSetters : IrqStatusResponse;
         sdhc_irqstat_cint              : false : true  : true  : enableGettersAndSetters : IrqStatusInterrupt;
         sdhc_irqstat_crm               : false : true  : true  : enableGettersAndSetters : IrqStatusCardInserted;
         sdhc_irqstat_cins              : false : true  : true  : enableGettersAndSetters : IrqStatusCardRemoved;
         sdhc_irqstat_brr               : false : true  : true  : enableGettersAndSetters : IrqStatusBufferRead;
         sdhc_irqstat_bwr               : false : true  : true  : enableGettersAndSetters : IrqStatusBufferWrite;
         sdhc_irqstat_dint              : false : true  : true  : enableGettersAndSetters : IrqStatusDmaCompleted;
         sdhc_irqstat_bge               : false : true  : true  : enableGettersAndSetters : IrqStatusBlockGap;
         sdhc_irqstat_tc                : false : true  : true  : enableGettersAndSetters : IrqStatusTransfer;
         sdhc_irqstat_cc                : false : true  : true  : enableGettersAndSetters : IrqStatusEndBit;

         sdhc_irqstat                   : false : true  : false : enablePeripheralSupport : InterruptStatus;

         sdhc_irqstaten                 : true  : true  : false : enablePeripheralSupport : InterruptStatusEnable;

         sdhc_irqsigen                  : true  : true  : false : enablePeripheralSupport : InterruptEnable;

         sdhc_ac12err                   : false : true  : false : enablePeripheralSupport : Ac12Error;

         sdhc_htcapblt_vs33             : false : true  : false : enableGettersAndSetters : Sdhc3V3Support;
         sdhc_htcapblt_srs              : false : true  : false : enableGettersAndSetters : SdhcHaltSupport;
         sdhc_htcapblt_dmas             : false : true  : false : enableGettersAndSetters : SdhcDmaSupport;
         sdhc_htcapblt_hss              : false : true  : false : enableGettersAndSetters : SdhcHighSpeedSupport;
         sdhc_htcapblt_admas            : false : true  : false : enableGettersAndSetters : SdhcAdmaSupport;
         sdhc_htcapblt_mbl              : false : true  : false : enableGettersAndSetters : SdhcMaxBlockSize;

         sdhc_wml_wrwml                 : true  : true  : false : enableGettersAndSetters : SdhcWriteWaterLevel;
         sdhc_wml_rdwml                 : true  : true  : false : enableGettersAndSetters : SdhcReadWaterLevel;

         sdhc_fevt                      : true  : false : false : enablePeripheralSupport : ForceEvent;

         sdhc_admaes_admadce            : false : true  : false : enableGettersAndSetters : AdmaDescriptorError;
         sdhc_admaes_admalme            : false : true  : false : enableGettersAndSetters : AdmaLengthError;
         sdhc_admaes_admaes             : false : true  : false : enableGettersAndSetters : AdmaErrorState;

         sdhc_adsaddr_adsaddr           : true  : true  : false : enableGettersAndSetters : AdmaSystemAddress;

         sdhc_vendor_intstval           : false : true  : false : enableGettersAndSetters : VendorInternalStatel;
         sdhc_vendor_exblknu            : true  : true  : false : enableGettersAndSetters : VendorExactBlockNumber;

         sdhc_mmcboot_bootblkcnt        : true  : true  : false : enableGettersAndSetters : MmcBootBlockCount;
         sdhc_mmcboot_autosabgen        : true  : true  : false : enableGettersAndSetters : MmcBootStopAtGap;
         sdhc_mmcboot_booten            : true  : true  : false : enableGettersAndSetters : MmcBootEnable;
         sdhc_mmcboot_bootmode          : true  : true  : false : enableGettersAndSetters : MmcBootMode;
         sdhc_mmcboot_bootack           : true  : true  : false : enableGettersAndSetters : MmcBootAck;
         sdhc_mmcboot_dtocvack          : true  : true  : false : enableGettersAndSetters : MmcBootAckTimeout;

         sdhc_hostver_vvn               : false : true  : false : enableGettersAndSetters : HostVersion;
         sdhc_hostver_svn               : false : true  : false : enableGettersAndSetters : HostSpecVersion" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t * (%(field))
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %returnType get%(name)() {
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
         tooltipPadding="x*x"      ><![CDATA[
         \t/**
         \t * Clear %description
         \t * (%(field))
         \t *
         \t * %tooltip
         \t */
         \tstatic void clear%(name)() {
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <for keys="field                     : enable : disable : clear : genCode                 : name"
        values="
         sdhc_irqstat                   : false  : false   : true  : true                    : InterruptStatus;
         sdhc_irqstaten                 : true   : true    : false : true                    : InterruptStatusFlags;
         sdhc_irqsigen                  : true   : true    : false : true                    : InterruptSource" >
      <variableTemplate variables="%(field)" condition="%(enable)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Enable %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void enable%(name)(%params) {
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(disable)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Disable %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void disable%(name)(%params) {
         \t   %register = %register&~%paramExpression;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
         tooltipPadding="x*x"      ><![CDATA[
         \t/**
         \t * Clear %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void clear%(name)(%params) {
         \t   %register = %paramExpression;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <for keys="   field                 : set   : get   : clear : genCode       : context              : name"
        values=" sdhc_cmdrsp_cmdrsp0   : false : true  : false : true          : CMDRSP[index]        : CommandResponse" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t * (%(field))
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(int index, %params) {
         \t   $(_basename)->%(context) = ($(_basename)->%(context) & ~%mask)|%paramExpression;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t * (%(field))
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)(int index) {
         \t   return %paramType($(_basename)->%(context)&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
         tooltipPadding="x*x"      ><![CDATA[
         \t/**
         \t * Clear %description
         \t * (%(field))
         \t *
         \t * %tooltip
         \t */
         \tstatic void clear%(name)(int index) {
         \t   $(_basename)->%(context) = $(_basename)->%(context)|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!-- ________ SDHC Init class ____________________________ -->

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(ErrorCode ec) {
      \t *    ....
      \t * }
      \t *
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
XXXXXXXXXXXXXXXXXXXXXX
      \t *
      \t *   $(_name)Callback,                 // Call-back to execute on event - call-back function name
      \t *   NvicPriority_Low,                 // Priority for interrupt - Low
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ Init class Member variables ________ -->

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <for keys=" type        : variables                                            : init    "
       values="%baseType   : sdhc_dsaddr_dsaddr                                   :   0      ;
               %baseType   : sdhc_blkattr_blkcnt,sdhc_blkattr_blksize             :   0      ;
               %baseType   : sdhc_cmdarg_cmdarg                                   :   0      ;
               %baseType   : sdhc_xfertyp_cmdinx,sdhc_xfertyp_cmdtyp,sdhc_xfertyp_dpsel,
                             sdhc_xfertyp_cicen,sdhc_xfertyp_cccen,sdhc_xfertyp_rsptyp,
                             sdhc_xfertyp_msbsel,sdhc_xfertyp_dtdsel,sdhc_xfertyp_ac12en,
                             sdhc_xfertyp_bcen,sdhc_xfertyp_dmaen                 :   0      ;
               %baseType   : sdhc_datport_datcont                                 :   0      ;
               %baseType   : sdhc_proctl_wecrm,sdhc_proctl_wecins,sdhc_proctl_wecint,
                             sdhc_proctl_iabg,sdhc_proctl_rwctl,sdhc_proctl_creq,
                             sdhc_proctl_sabgreq,sdhc_proctl_dmas,sdhc_proctl_cdss,
                             sdhc_proctl_cdtl,sdhc_proctl_emode,sdhc_proctl_d3cd,
                             sdhc_proctl_dtw,sdhc_proctl_lctl                     :   0      ;
               %baseType   : sdhc_sysctl_inita,sdhc_sysctl_rstd,sdhc_sysctl_rstc,
                             sdhc_sysctl_rsta,sdhc_sysctl_dtocv,sdhc_sysctl_sdclkfs,
                             sdhc_sysctl_dvs,sdhc_sysctl_sdclken,sdhc_sysctl_peren,
                             sdhc_sysctl_hcken,sdhc_sysctl_ipgen                  :   0      ;
               %baseType   : sdhc_irqstat                                         :   0      ;
               %baseType   : sdhc_irqstaten                                       :   0      ;
               %baseType   : sdhc_irqsigen                                        :   0      ;
               %baseType   : sdhc_wml_wrwml,sdhc_wml_rdwml                        :   0      ;
               %baseType   : sdhc_adsaddr_adsaddr                                 :   0      ;
               %baseType   : sdhc_vendor_exblknu                                  :   0      ;
               %baseType   : sdhc_mmcboot_bootblkcnt,sdhc_mmcboot_autosabgen,
                             sdhc_mmcboot_booten,sdhc_mmcboot_bootmode,
                             sdhc_mmcboot_bootack,sdhc_mmcboot_dtocvack           :   0      ;
               %paramType  : /PCR/nvic_irqLevel                                   :   %defaultValue   " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <!-- ____ Init class Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r"
      values="/PCR/nvic_irqLevel;
            sdhc_dsaddr_dsaddr;
            sdhc_blkattr_blkcnt;sdhc_blkattr_blksize;
            sdhc_cmdarg_cmdarg;
            sdhc_xfertyp_cmdinx;sdhc_xfertyp_cmdtyp;
            sdhc_xfertyp_dpsel;sdhc_xfertyp_cicen;sdhc_xfertyp_cccen;
            sdhc_xfertyp_rsptyp;sdhc_xfertyp_msbsel;sdhc_xfertyp_dtdsel;
            sdhc_xfertyp_ac12en;sdhc_xfertyp_bcen;sdhc_xfertyp_dmaen;
            sdhc_datport_datcont;
            sdhc_proctl_wecrm;sdhc_proctl_wecins;sdhc_proctl_wecint;
            sdhc_proctl_iabg;sdhc_proctl_rwctl;sdhc_proctl_creq;
            sdhc_proctl_sabgreq;sdhc_proctl_dmas;sdhc_proctl_cdss;
            sdhc_proctl_cdtl;sdhc_proctl_emode;sdhc_proctl_d3cd;
            sdhc_proctl_dtw;sdhc_proctl_lctl;
            sdhc_sysctl_inita;sdhc_sysctl_rstd;sdhc_sysctl_rstc;
            sdhc_sysctl_rsta;sdhc_sysctl_dtocv;sdhc_sysctl_sdclkfs;
            sdhc_sysctl_dvs;sdhc_sysctl_sdclken;sdhc_sysctl_peren;
            sdhc_sysctl_hcken;sdhc_sysctl_ipgen;
            sdhc_irqstat;
            sdhc_irqstaten;
            sdhc_irqsigen;
            sdhc_wml_wrwml;sdhc_wml_rdwml;
            sdhc_adsaddr_adsaddr;
            sdhc_vendor_exblknu;
            sdhc_mmcboot_bootblkcnt;sdhc_mmcboot_autosabgen;
            sdhc_mmcboot_booten;sdhc_mmcboot_bootmode;
            sdhc_mmcboot_bootack;sdhc_mmcboot_dtocvack
            " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>


   <!-- ____ Init class Configure method ____ -->

   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template codeGenCondition="irqHandlingMethod" condition="irqHandlingMethod" >
   <![CDATA[
      \t   // Configure call-backs
      \t   setCallback(init.callbackFunction);\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values=" irqLevel                                               : enableNvicInterrupts(init.irqlevel) ;
               sdhc_dsaddr_dsaddr                                     : %configRegAssignment  ;
               sdhc_blkattr_blkcnt,sdhc_blkattr_blksize               : %configRegAssignment  ;
               sdhc_cmdarg_cmdarg                                     : %configRegAssignment  ;
               sdhc_xfertyp_cmdinx,sdhc_xfertyp_cmdtyp,sdhc_xfertyp_dpsel,
               sdhc_xfertyp_cicen,sdhc_xfertyp_cccen,sdhc_xfertyp_rsptyp,
               sdhc_xfertyp_msbsel,sdhc_xfertyp_dtdsel,sdhc_xfertyp_ac12en,
               sdhc_xfertyp_bcen,sdhc_xfertyp_dmaen                   : %configRegAssignment  ;
               sdhc_datport_datcont                                   : %configRegAssignment  ;
               sdhc_proctl_wecrm,sdhc_proctl_wecins,sdhc_proctl_wecint,
               sdhc_proctl_iabg,sdhc_proctl_rwctl,sdhc_proctl_creq,
               sdhc_proctl_sabgreq,sdhc_proctl_dmas,sdhc_proctl_cdss,
               sdhc_proctl_cdtl,sdhc_proctl_emode,sdhc_proctl_d3cd,
               sdhc_proctl_dtw,sdhc_proctl_lctl                       : %configRegAssignment  ;
               sdhc_sysctl_inita,sdhc_sysctl_rstd,sdhc_sysctl_rstc,
               sdhc_sysctl_rsta,sdhc_sysctl_dtocv,sdhc_sysctl_sdclkfs,
               sdhc_sysctl_dvs,sdhc_sysctl_sdclken,sdhc_sysctl_peren,
               sdhc_sysctl_hcken,sdhc_sysctl_ipgen                    : %configRegAssignment  ;
               sdhc_irqstat                                           : %configRegAssignment  ;
               sdhc_irqstaten                                         : %configRegAssignment  ;
               sdhc_irqsigen                                          : %register = %baseType(init.%registerName)  ;
               sdhc_wml_wrwml,sdhc_wml_rdwml                          : %configRegAssignment  ;
               sdhc_adsaddr_adsaddr                                   : %configRegAssignment  ;
               sdhc_vendor_exblknu                                    : %configRegAssignment  ;
               sdhc_mmcboot_bootblkcnt,sdhc_mmcboot_autosabgen,
               sdhc_mmcboot_booten,sdhc_mmcboot_bootmode,
               sdhc_mmcboot_bootack,sdhc_mmcboot_dtocvack             : %configRegAssignment " >
      <variableTemplate codeGenCondition="enablePeripheralSupport"
      variables="%(var)"
      linePadding="xxx"
      ><![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            sdhc_dsaddr_dsaddr,
            sdhc_blkattr_blkcnt,sdhc_blkattr_blksize,
            sdhc_cmdarg_cmdarg,
            sdhc_xfertyp_cmdinx,sdhc_xfertyp_cmdtyp,
            sdhc_xfertyp_dpsel,sdhc_xfertyp_cicen,sdhc_xfertyp_cccen,
            sdhc_xfertyp_rsptyp,sdhc_xfertyp_msbsel,sdhc_xfertyp_dtdsel,
            sdhc_xfertyp_ac12en,sdhc_xfertyp_bcen,sdhc_xfertyp_dmaen,
            sdhc_datport_datcont,
            sdhc_proctl_wecrm,sdhc_proctl_wecins,sdhc_proctl_wecint,
            sdhc_proctl_iabg,sdhc_proctl_rwctl,sdhc_proctl_creq,
            sdhc_proctl_sabgreq,sdhc_proctl_dmas,sdhc_proctl_cdss,
            sdhc_proctl_cdtl,sdhc_proctl_emode,sdhc_proctl_d3cd,
            sdhc_proctl_dtw,sdhc_proctl_lctl,
            sdhc_sysctl_inita,sdhc_sysctl_rstd,sdhc_sysctl_rstc,
            sdhc_sysctl_rsta,sdhc_sysctl_dtocv,sdhc_sysctl_sdclkfs,
            sdhc_sysctl_dvs,sdhc_sysctl_sdclken,sdhc_sysctl_peren,
            sdhc_sysctl_hcken,sdhc_sysctl_ipgen,
            sdhc_irqstat,
            sdhc_irqstaten,
            sdhc_irqsigen,
            sdhc_wml_wrwml,sdhc_wml_rdwml,
            sdhc_adsaddr_adsaddr,
            sdhc_vendor_exblknu,
            sdhc_mmcboot_bootblkcnt,sdhc_mmcboot_autosabgen,
            sdhc_mmcboot_booten,sdhc_mmcboot_bootmode,
            sdhc_mmcboot_bootack,sdhc_mmcboot_dtocvack,
            irqLevel" >
    <![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};
      \t\n
   ]]>
   </variableTemplate>

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

   <!-- ____ Common __________________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
   \t/**
   \t * Class representing $(_NAME)
   \t */
   \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Info)> {};\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="sdhc_files">
      <copy source="Project_Headers/sdhc.h"                   target="Project_Headers/sdhc.h"                     overwrite="true"  derived="true" />
      <copy source="Snippets/sdhc-example.cpp"                target="Snippets/sdhc-example.cpp"                  overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ____ Startup __________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration __________________ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping __________________ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</peripheralPage>

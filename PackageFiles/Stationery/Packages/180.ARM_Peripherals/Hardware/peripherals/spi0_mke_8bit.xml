<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- spi0_mke_8bit.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Serial Peripheral Interface">

   <xi:include href="_default_instance.xml"/>

   <xi:include href="_mapPinsOption.xml"/>

   <xi:include href="_irqOption.xml"/>

   <binaryOption key="spi_c1_spie" condition="spi_c1_spie_present"
      enumStem="SpiC1Spie"
      description="Interrupt enable: for SPRF and MODF" >
      <choice name="Interrupts disabled"  value="0" enum="InterruptsDisabled"/>
      <choice name="Interrupts enabled"   value="1" enum="InterruptsEnabled"/>
   </binaryOption>

   <binaryOption key="spi_c1_spe" condition="spi_c1_spe_present"
      enumStem="SpiC1Spe"
      description="System enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption>

   <binaryOption key="spi_c1_sptie" condition="spi_c1_sptie_present"
      enumStem="SpiC1Sptie"
      description="Transmit interrupt enable" >
      <choice name="Interrupts disabled"  value="0" enum="InterruptsDisabled"/>
      <choice name="Interrupts enabled"   value="1" enum="InterruptsEnabled"/>
   </binaryOption>

   <binaryOption key="spi_c1_mstr" condition="spi_c1_mstr_present"
      enumStem="SpiC1Mstr"
      description="Master/slave mode select" >
      <choice name="Slave device"   value="0" enum="SlaveDevice"/>
      <choice name="Master device"  value="1" enum="MasterDevice"/>
   </binaryOption>

   <binaryOption key="spi_c1_cpol" condition="spi_c1_cpol_present"
      enumStem="SpiC1Cpol"
      toolTip="Defines inactive state of the CLK"
      description="Clock polarity" >
      <choice name="Inactive is low"   value="0" enum="InactiveIsLow"/>
      <choice name="Inactive is high"  value="1" enum="InactiveIsHigh"/>
   </binaryOption>

   <binaryOption key="spi_c1_cpha" condition="spi_c1_cpha_present"
      enumStem="SpiC1Cpha"
      toolTip="Determine when output data changes and input data is captured relative to the clock"
      description="Clock phase" >
      <choice name="Data captured on leading edge"     value="0" enum="DataCapturedOnLeadingEdge"/>
      <choice name="Data changes on the leading edge"  value="1" enum="DataChangesOnTheLeadingEdge"/>
   </binaryOption>

   <choiceOption key="spi_c1_mode" condition="spi_c1_mode_present"
      enumStem="SpiC1Mode"
      description="Clock Phase and Polarity" >
      <choice name="Mode 0: CPOL=0, CPHA=0"  value="0" enum="Mode0Cpol0_Cpha0"/>
      <choice name="Mode 1: CPOL=0, CPHA=1"  value="1" enum="Mode1Cpol0_Cpha1"/>
      <choice name="Mode 2: CPOL=1, CPHA=0"  value="2" enum="Mode2Cpol1_Cpha0"/>
      <choice name="Mode 3: CPOL=1, CPHA=1"  value="3" enum="Mode3Cpol1_Cpha1"/>
   </choiceOption>

   <binaryOption key="spi_c1_ssoe" condition="spi_c1_ssoe_present"
      enumStem="SpiC1Ssoe"
      toolTip="This bit only has effect when MODFEN=1 and in master node.\n
               In slave mode, SS pin function is slave select input irrespective of this bit.\n
               In master mode when MODFEN=0 SS pin function is general-purpose I/O\n
               In master mode when MODFEN=1 see below for SS pin usage:"
      description="Slave select output enable" >
      <choice name="Fault mode input"     value="0" enum="FaultModeInput"/>
      <choice name="Automatic SS output"  value="1" enum="AutomaticSsOutput"/>
   </binaryOption>

   <binaryOption key="spi_c1_lsbfe" condition="spi_c1_lsbfe_present"
      enumStem="SpiC1Lsbfe"
      toolTip="Controls whether serial data transfers start with most-significant or least-significant bit"
      description="LSB first (shifter direction)" >
      <choice name="MSB first"   value="0" enum="MsbFirst"/>
      <choice name="LSB first"   value="1" enum="LsbFirst"/>
   </binaryOption>

   <binaryOption key="spi_c2_spmie" condition="spi_c2_spmie_present"
      enumStem="SpiC2Spmie"
      description="Match interrupt enable" >
      <choice name="Interrupts disabled"  value="0" enum="InterruptsDisabled"/>
      <choice name="Interrupts enabled"   value="1" enum="InterruptsEnabled"/>
   </binaryOption>

   <binaryOption key="spi_c2_modfen" condition="spi_c2_modfen_present"
      enumStem="SpiC2Modfen"
      toolTip="Controls operation of SS pin as fault input"
      description="Master mode-fault function enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption>

   <binaryOption key="spi_c2_bidiroe" condition="spi_c2_bidiroe_present"
      enumStem="SpiC2Bidiroe"
      toolTip="Controls output driver enable in bidirectional mode"
      description="Bidirectional mode output enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption>

   <binaryOption key="spi_c2_spiswai" condition="spi_c2_spiswai_present"
      enumStem="SpiC2Spiswai"
      description="Stop in wait mode" >
      <choice name="Operate normally"  value="0" enum="OperateNormally"/>
      <choice name="Clocks stopped"    value="1" enum="ClocksStopped"/>
   </binaryOption>

   <binaryOption key="spi_c2_spc0" condition="spi_c2_spc0_present"
      enumStem="SpiC2Spc0"
      toolTip="This bit enables bidirectional data pin configurations"
      description="Pin control 0" >
      <choice name="Separate input and output"  value="0" enum="SeparateInputAndOutput"/>
      <choice name="Single-wire bidirectional"  value="1" enum="SingleWireBidirectional"/>
   </binaryOption>

   <choiceOption key="spi_br_sppr" condition="spi_br_sppr_present"
      enumStem="SpiBrSppr"
      toolTip="The input to this prescaler is the bus rate clock (BUSCLK).\n
               The output of this prescaler drives the input of the SPI baud rate divider"
      description="Baud rate prescale divisor" >
      <choice name="Divide by 1"  value="0" enum="DivideBy1"/>
      <choice name="Divide by 2"  value="1" enum="DivideBy2"/>
      <choice name="Divide by 3"  value="2" enum="DivideBy3"/>
      <choice name="Divide by 4"  value="3" enum="DivideBy4"/>
      <choice name="Divide by 5"  value="4" enum="DivideBy5"/>
      <choice name="Divide by 6"  value="5" enum="DivideBy6"/>
      <choice name="Divide by 7"  value="6" enum="DivideBy7"/>
      <choice name="Divide by 8"  value="7" enum="DivideBy8"/>
   </choiceOption>

   <choiceOption key="spi_br_spr" condition="spi_br_spr_present"
      enumStem="SpiBrSpr"
      toolTip="Selects one of nine divisors for the SPI baud rate divider.\n
               The input to this divider comes from the SPI baud rate prescaler"
      description="Baud rate divisor select" >
      <choice name="Divide by 2"    value="0" enum="DivideBy2"/>
      <choice name="Divide by 4"    value="1" enum="DivideBy4"/>
      <choice name="Divide by 8"    value="2" enum="DivideBy8"/>
      <choice name="Divide by 16"   value="3" enum="DivideBy16"/>
      <choice name="Divide by 32"   value="4" enum="DivideBy32"/>
      <choice name="Divide by 64"   value="5" enum="DivideBy64"/>
      <choice name="Divide by 128"  value="6" enum="DivideBy128"/>
      <choice name="Divide by 256"  value="7" enum="DivideBy256"/>
      <choice name="Divide by 512"  value="8" enum="DivideBy512"/>
   </choiceOption>

   <intOption key="spi_d_bits" condition="spi_d_bits_present"
      description="Data (low byte)"
   />

   <intOption key="spi_m_bits" condition="spi_m_bits_present"
      description="Hardware compare value"
   />

<!-- Grahic here -->

   <for keys="field:name"
        values="
      spi_c1_spie:C1Spie;
      spi_c1_spe:C1Spe;
      spi_c1_sptie:C1Sptie;
      spi_c1_mstr:C1Mstr;
      spi_c1_cpol:C1Cpol;
      spi_c1_cpha:C1Cpha;
      spi_c1_mode:C1Mode;
      spi_c1_ssoe:C1Ssoe;
      spi_c1_lsbfe:C1Lsbfe;
      spi_c2_spmie:C2Spmie;
      spi_c2_modfen:C2Modfen;
      spi_c2_bidiroe:C2Bidiroe;
      spi_c2_spiswai:C2Spiswai;
      spi_c2_spc0:C2Spc0;
      spi_br_sppr:BrSppr;
      spi_br_spr:BrSpr">
      <setTemplate variables="%(field)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void configure%(name)(%params) {
         \t   %defaultFieldExpression
         \t}\n\n
      ]]></setTemplate>
   </for>

<!--   ========== SPI Init class =============================== -->

   <template key="init_description" namespace="all">
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_class)::Init init {
      \t *
      \t *   // Setup values
      \t *   SpiC1Spie_InterruptsDisabled              // Interrupt enable: for SPRF and MODF,
      \t *   SpiC1Spe_Disabled                         // System enable,
      \t *   SpiC1Sptie_InterruptsDisabled             // Transmit interrupt enable,
      \t *   SpiC1Mstr_SlaveDevice                     // Master/slave mode select,
      \t *   SpiC1Cpol_InactiveIsLow                   // Clock polarity,
      \t *   SpiC1Cpha_DataCapturedOnLeadingEdge       // Clock phase,
      \t *   SpiC1Mode_Mode0Cpol0_Cpha0                // Clock Phase and Polarity,
      \t *   SpiC1Ssoe_FaultModeInput                  // Slave select output enable,
      \t *   SpiC1Lsbfe_MsbFirst                       // LSB first (shifter direction),
      \t *   SpiC2Spmie_InterruptsDisabled             // Match interrupt enable,
      \t *   SpiC2Modfen_Disabled                      // Master mode-fault function enable,
      \t *   SpiC2Bidiroe_Disabled                     // Bidirectional mode output enable,
      \t *   SpiC2Spiswai_OperateNormally              // Stop in wait mode,
      \t *   SpiC2Spc0_SeparateInputAndOutput          // Pin control 0,
      \t *   SpiBrSppr_DivideBy1                       // Baud rate prescale divisor,
      \t *   SpiBrSpr_DivideBy2                        // Baud rate divisor select,
      \t *   0,                                        // Data (low byte),
      \t *   0,                                        // Hardware compare value,
      \t * };
      \t *
      \t * // Initialise $(_class) from values specified above
      \t * $(_class)::configure(init)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm">
   <![CDATA[
      class $(_class)BasicInfo {
      \t
      public:
      \t
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)(const uint32_t &);
      \t\n
   ]]>
   </template>

   <template namespace="usbdm">
   <![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--   Member variables -->

   <setTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="spi_c1_spie,spi_c1_spe,spi_c1_sptie,spi_c1_mstr,spi_c1_cpol,spi_c1_cpha,spi_c1_mode,spi_c1_ssoe,spi_c1_lsbfe"
   ><![CDATA[
      \t   /// Control register 1
      \t   uint8_t c1 = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="spi_c2_spmie,spi_c2_modfen,spi_c2_bidiroe,spi_c2_spiswai,spi_c2_spc0"
   ><![CDATA[
      \t   /// Control register 2
      \t   uint8_t c2 = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="spi_br_sppr,spi_br_spr"
   ><![CDATA[
      \t   /// Baud rate register
      \t   uint8_t br = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="spi_d_bits"
   ><![CDATA[
      \t   /// Data register
      \t   uint8_t d = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="spi_m_bits"
   ><![CDATA[
      \t   /// Match register:
      \t   uint8_t m = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

<!--   Configure methods -->

   <template discardRepeats="true" key="/SPI/InitMethod" namespace="all" ><![CDATA[
      \t/**
      \t * Configure SPI from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled
      \t      setCallback(init.callbackFunction);
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t   enable();
      \t
      \t   spi->C1    = init.c1;
      \t   spi->C2    = init.c2;
      \t   spi->BR    = init.br;
      \t   spi->D    = init.d;
      \t   spi->M    = init.m;
      \t
      \t   calibrate();
      \t}
      \t
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(Info::DefaultInitValue);
      \t}\n
   ]]></template>

<!--   Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%enumParam0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      #if $(irqHandlingMethod)
      \t      %registerName = %paramExpression;
      #else
      \t      (void)%paramExpression;
      #endif
      \t   }\n\n
   ]]></setTemplate>

   <for keys="r"
      values="
            spi_c1_spie;
            spi_c1_spe;
            spi_c1_sptie;
            spi_c1_mstr;
            spi_c1_cpol;
            spi_c1_cpha;
            spi_c1_mode;
            spi_c1_ssoe;
            spi_c1_lsbfe;
            spi_c2_spmie;
            spi_c2_modfen;
            spi_c2_bidiroe;
            spi_c2_spiswai;
            spi_c2_spc0;
            spi_br_sppr;
            spi_br_spr
            ">
      <setTemplate namespace="usbdm"
         variables="%(r)"
         linePadding="xxx">
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>

   <for keys="r"
      values="
            spi_d_bits;
            spi_m_bits
            ">
      <setTemplate namespace="usbdm"
         variables="%(r)"
         linePadding="xxx">
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         \t    * @param value %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(unsigned value, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | value;
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>

<!--   Default Initialisation value -->

   <initialValueTemplate
      separator=","
      terminator=","
      variables="
            spi_c1_spie,
            spi_c1_spe,
            spi_c1_sptie,
            spi_c1_mstr,
            spi_c1_cpol,
            spi_c1_cpha,
            spi_c1_mode,
            spi_c1_ssoe,
            spi_c1_lsbfe,
            spi_c2_spmie,
            spi_c2_modfen,
            spi_c2_bidiroe,
            spi_c2_spiswai,
            spi_c2_spc0,
            spi_br_sppr,
            spi_br_spr,
            irqLevel
         "
   ><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * Default initialisation value for $(_class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <template namespace="usbdm">
      <![CDATA[
      \t}; // $(_class)::BasicInfo::Init\n\n
   ]]>
   </template>

   <template namespace="usbdm">
      <![CDATA[
      }; // $(_class)::BasicInfo\n\n
   ]]>
   </template>

<signals />

</peripheralPage>

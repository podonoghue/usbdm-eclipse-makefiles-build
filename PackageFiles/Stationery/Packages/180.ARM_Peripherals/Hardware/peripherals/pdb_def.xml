<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pdb0_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"  />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"  />
   <constant key="generateDefault"           type="Boolean" value="false"         />
   <constant key="configureInStartupDefault" type="Boolean" value="false"         />
   <xi:include href="enablePeripheral.xml"  />

   <!-- Constants -->

   <!-- Single shared callback -->
   <constant key="IrqInformation" type="String"
      value="&quot;
             irqHandler   : Callback        : Event
             &quot;" />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <!-- Constants -->
   <constant key="NumChannels"            type="Long" value="0" description="Number of channels"            condition="!pdb_ch_dim"     /> <!-- PDB Channels    -->
   <constant key="NumPreTriggers"         type="Long" value="0" description="Number of (ADC) Pre-triggers"  condition="!pdb_dly_dim"    /> <!-- Pretriggers     -->
   <constant key="NumDacIntervalTriggers" type="Long" value="0" description="Number of DAC triggers"        condition="!pdb_dac_dim"    /> <!-- to DAC triggers -->
   <constant key="NumPulseOutputs"        type="Long" value="0" description="Number of Pulse outputs"       condition="!pdb_pondly_dim" /> <!-- to CMP windows  -->

   <constant key="NumChannels"            type="Long" value="pdb_ch_dim"     description="Number of channels"           condition="pdb_ch_dim"     /> <!-- PDB Channels    -->
   <constant key="NumPreTriggers"         type="Long" value="pdb_dly_dim"    description="Number of (ADC) Pre-triggers" condition="pdb_dly_dim"    /> <!-- Pretriggers     -->
   <constant key="NumDacIntervalTriggers" type="Long" value="pdb_dac_dim"    description="Number of DAC triggers"       condition="pdb_dac_dim"    /> <!-- to DAC triggers -->
   <constant key="NumPulseOutputs"        type="Long" value="pdb_pondly_dim" description="Number of Pulse outputs"      condition="pdb_pondly_dim" /> <!-- to CMP windows  -->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Class)BasicInfo&quot;" />

<!--  ============== Masks and Flags ============== -->

   <binaryOption key="pdb_sc_swtrig" condition="pdb_sc_swtrig_present"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="PdbSoftwareTrigger"
      description="Software Trigger"
      toolTip="When software trigger is selected, writing 1 to this field resets and restarts the counter. \n
               Writing 0 to this field has no effect. Reading this field yields 0" >
      <choice name="No Action"       value="0" enum="NoAction"/>
      <choice name="Load registers"  value="1" enum="RestartCounter"/>
   </binaryOption >

   <binaryOption key="pdb_sc_pdbif" condition="pdb_sc_pdbif_present"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="PdbInterruptFlag"
      toolTip="This field is set when the counter value is equal to the IDLY register. Writing zero clears this field"
      description="PDB Interrupt Flag" >
      <choice name="No event"         value="0" enum="NoEvent"        />
      <choice name="Request Pending"  value="1" enum="RequestPending" />
   </binaryOption >

   <binaryOption key="pdb_sc_ldok" condition="pdb_sc_ldok_present"
      hidden="true"
      typeName="PdbLoad"
      toolTip="Writing 1 to this bit updates the internal registers MOD, IDLY, CHnDLYm, DACINTx,and POyDLY from their buffers. \n
               The new values will take effect according to the LDMOD"
      description="PDB Load" >
      <choice name="No Action"       value="0" enum="NoAction"/>
      <choice name="Load registers"  value="1" enum="LoadRegisters"/>
   </binaryOption >

<!--  ============== PDB_SC Trigger ============== -->

   <title description="Triggers and sequence" />

   <choiceOption key="pdb_sc_trgsel" condition="pdb_sc_trgsel_present"
      enabledBy="enablePeripheralSupport"
      typeName="PdbTrigger"
      valueFormat="PDB_SC_PDBEN(%s),PDB_SC_TRGSEL(%s)"
      description="Trigger Input Source Select"
      toolTip="Selects the trigger input source for the PDB.\n
         The trigger input source can be internal or external (EXTRG pin),\n
         or the software trigger" >
      <choice value="0,0"  name="PDB Disabled"                      enum="PdbDisabled"   />
      <choice value="1,0"  name="External Trigger (PDB0_EXTRG)"     enum="External"      />
      <choice value="1,1"  name="CMP 0"                             enum="Cmp0"       condition="/CMP0/_present"   />
      <choice value="1,2"  name="CMP 1"                             enum="Cmp1"       condition="/CMP1/_present"   />
      <choice value="1,3"  name="CMP 3"                             enum="Cmp2"       condition="/CMP2/_present"   />
      <choice value="1,4"  name="PIT Ch 0 Output"                   enum="PitCh0"     condition="/PIT/_present"    />
      <choice value="1,5"  name="PIT Ch 1 Output"                   enum="PitCh1"     condition="/PIT/_present"    />
      <choice value="1,6"  name="PIT Ch 2 Output"                   enum="PitCh2"     condition="/PIT/_present"    />
      <choice value="1,7"  name="PIT Ch 3 Output"                   enum="PitCh3"     condition="/PIT/_present"    />
      <choice value="1,8"  name="FTM0 Init and Ext Trigger Outputs" enum="Ftm0"       condition="/FTM0/_present"   />
      <choice value="1,9"  name="FTM1 Init and Ext Trigger Outputs" enum="Ftm1"       condition="/FTM1/_present"   />
      <choice value="1,10" name="FTM2 Init and Ext Trigger Outputs" enum="Ftm2"       condition="/FTM2/_present"   />
      <choice value="1,11" name="FTM3 Init and Ext Trigger Outputs" enum="Ftm3"       condition="/FTM3/_present"   />
      <choice value="1,12" name="RTC Alarm"                         enum="RtcAlarm"   condition="/RTC/_present"    />
      <choice value="1,13" name="RTC Seconds"                       enum="RtcSeconds" condition="/RTC/_present"    />
      <choice value="1,14" name="LPTMR"                             enum="Lptmr"      condition="/LPTMR0/_present" />
      <choice value="1,15" name="Software trigger is selected"      enum="Software"   />
   </choiceOption>

   <binaryOption key="secondsSupport"
      enabledBy="pdb_sc_trgsel>0"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point is necessary to support specifing PDB times in seconds in runtime code.\n
               If not needed, the overhead can be avoided by disabling this option" >
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <intOption key="Minimum_resolution"
      enabledBy="secondsSupport"
      valueFormat="%s"
      typeName="const Ticks &amp;"
      units="ticks"
      description="Minumum value for counter modulus"
      toolTip="This can be used to ensure that a reasonable resolution is available when using Seconds\n
               Attempting to set too small a modulo will result in an error"
      value="1000" min="0" max="65535"/>

   <choiceOption key="pdb_sc_ldmod" condition="pdb_sc_ldmod_present"
      typeName="PdbLoadMode"
      enabledBy="pdb_sc_trgsel>0"
      description="Register Load Select"
      toolTip="Selects when to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,\n
         after 1 is written to LDOK" >
      <choice value="0" name="Registers loaded immediately on LDOK=1"                                  enum="Immediate"     />
      <choice value="1" name="Registers loaded when PDB counter reaches MOD"                           enum="Modulo"        />
      <choice value="2" name="Registers loaded on trigger input event"                                 enum="Event"         />
      <choice value="3" name="Registers loaded when PDB counter reaches MOD or on trigger input event" enum="EventOrModulo" />
   </choiceOption>

   <binaryOption key="pdb_sc_pdbeie" condition="pdb_sc_pdbeie_present"
      typeName="PdbErrorAction"
      enabledBy="pdb_sc_trgsel>0"
      description="Sequence Error Interrupt Enable"
      toolTip="This bit enables the sequence error interrupt\n
         When this bit is set, any of the channel sequence error flags generates a sequence error interrupt" >
      <choice value="0" name="No interrupt on error"  enum="None"      />
      <choice value="1" name="Interrupt on error"     enum="Interrupt" />
   </binaryOption>

   <binaryOption key="pdb_sc_cont" condition="pdb_sc_cont_present"
      enabledBy="pdb_sc_trgsel>0"
      typeName="PdbMode"
      description="PDB operation mode"
      toolTip="Select continuous or one-shot mode" >
      <choice value="0" name="Sequence runs once only"                    enum="OneShot"      />
      <choice value="1" name="Sequence runs continuously once triggered"  enum="Continuous" />
   </binaryOption>

<!--  ============== PDB_SC related ============== -->

   <title description="Clocking" />

   <choiceOption key="pdbClockConfig"
      target="input_clock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for ticks and time calculations" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="input_clock"
      locked="true"
      derived="true"
      units="Hz"
      description="Frequency of PDB input Clock" />

   <choiceOption key="pdb_channel"
      typeName="PdbChannel"
      valueFormat="%s"
      hidden="true"
      description="PDB Channel select"
      toolTip="Selects a PDB channel" >
      <choice value="0" name="Channel 0"   enum="0" condition="=NumChannels>0"/>
      <choice value="1" name="Channel 1"   enum="1" condition="=NumChannels>1"/>
      <choice value="2" name="Channel 2"   enum="2" condition="=NumChannels>2"/>
      <choice value="3" name="Channel 3"   enum="3" condition="=NumChannels>3"/>
      <choice value="4" name="Channel 4"   enum="4" condition="=NumChannels>4"/>
      <choice value="5" name="Channel 5"   enum="5" condition="=NumChannels>5"/>
      <choice value="6" name="Channel 6"   enum="6" condition="=NumChannels>6"/>
      <choice value="7" name="Channel 7"   enum="7" condition="=NumChannels>7"/>
   </choiceOption>

   <choiceOption key="pdb_sc_divider"
      target="pdb_clock_frequency"
      valueFormat="PDB_SC_MULT(%s),PDB_SC_PRESCALER(%s)"
      enabledBy="pdb_sc_trgsel>0"
      typeName="PdbPrescale"
      description="Clock Prescaler Divider Select"
      toolTip="The PDB input clock is divided by this factor" >
      <choice value="0,0"   name="Divide by 1"      enum="DivBy_1"      ref="(input_clock)/1"    />
      <choice value="0,1"   name="Divide by 2"      enum="DivBy_2"      ref="(input_clock)/2"    />
      <choice value="0,2"   name="Divide by 4"      enum="DivBy_4"      ref="(input_clock)/4"    />
      <choice value="0,3"   name="Divide by 8"      enum="DivBy_8"      ref="(input_clock)/8"    />
      <choice value="1,0"   name="Divide by 10"     enum="DivBy_10"     ref="(input_clock)/10"   />
      <choice value="0,4"   name="Divide by 16"     enum="DivBy_16"     ref="(input_clock)/16"   />
      <choice value="1,1"   name="Divide by 20"     enum="DivBy_20"     ref="(input_clock)/20"   />
      <choice value="0,5"   name="Divide by 32"     enum="DivBy_32"     ref="(input_clock)/32"   />
      <choice value="1,2"   name="Divide by 40"     enum="DivBy_40"     ref="(input_clock)/40"   />
      <choice value="0,6"   name="Divide by 64"     enum="DivBy_64"     ref="(input_clock)/64"   />
      <choice value="1,3"   name="Divide by 80"     enum="DivBy_80"     ref="(input_clock)/80"   />
      <choice value="0,7"   name="Divide by 128"    enum="DivBy_128"    ref="(input_clock)/128"  />
      <choice value="1,4"   name="Divide by 160"    enum="DivBy_160"    ref="(input_clock)/160"  />
      <choice value="1,5"   name="Divide by 320"    enum="DivBy_320"    ref="(input_clock)/320"  />
      <choice value="1,6"   name="Divide by 640"    enum="DivBy_640"    ref="(input_clock)/640"  />
      <choice value="1,7"   name="Divide by 1280"   enum="DivBy_1280"   ref="(input_clock)/1280" />
      <choice value="2,7"   name="Divide by 2560"   enum="DivBy_2560"   ref="(input_clock)/2560" />
      <choice value="3,7"   name="Divide by 5120"   enum="DivBy_5120"   ref="(input_clock)/5120" />
   </choiceOption>

   <choiceOption key="pdb_sc_autoDivider"
      hidden="true"
      valueFormat="PDB_SC_MULT(%s),PDB_SC_PRESCALER(%s)"
      description="Clock prescaler is calculated from given period"
      typeName="PdbPrescale_Auto" >
      <choice value="3,0"   name="Auto select"      enum="Calculated" />
   </choiceOption>

   <floatOption key="pdb_clock_frequency"
      enabledBy="pdb_sc_trgsel>0"
      description="Frequency of PDB clock"
      toolTip="PDB clock frequency (Tick rate of PDB)"
      derived="true"
      locked="true"
      min="0" units="Hz" />

   <floatOption key="pdb_clock_period"
      enabledBy="pdb_sc_trgsel>0"
      ref="1.0/pdb_clock_frequency"
      description="Period of PDB clock"
      toolTip="PDB clock period (Tick period of PDB)"
      derived="true"
      locked="true"
      value="1k" min="0" units="s" />

<!--  ============== PDB_MOD ============== -->

   <title description="Main counter" />

   <intOption key="pdb_mod" condition="pdb_mod_mod_present"
      valueFormat="%s"
      typeName="const Ticks &amp;"
      units="ticks"
      enabledBy="pdb_sc_trgsel>0"
      description="Counter modulo value"
      toolTip="Controls the period of the main PDB counter [0..mod]\n
         When the counter reaches this value, it will be reset back to zero.\n
         If the PDB is in Continuous mode, the count begins anew\n
         Counter modulus is (mod+1)"
      value="65535" min="0" max="65535"/>

   <floatOption key="pdb_mod_period" condition="pdb_mod_mod_present"
      enabledBy="pdb_sc_trgsel>0"
      ref="(pdb_mod+1)*pdb_clock_period"
      typeName="const Seconds &amp;"
      description="Counter period in seconds"
      derivedFrom="pdb_mod"
      derived="true"
      min="0" units="s" />

<!--  ============== PDB_IDLY ============== -->

   <choiceOption key="pdb_sc_action" condition="pdb_sc_dmaen_present&amp;&amp;pdb_sc_pdbie_present"
      enabledBy="pdb_sc_trgsel>0"
      typeName="PdbAction"
      valueFormat="PDB_SC_DMAEN(%s),PDB_SC_PDBIE(%s)"
      description="Timer event action"
      toolTip="Selects the action taken when the timer reaches the interrupt delay value" >
      <choice value="0,0" name="No action on event"   enum="None"      />
      <choice value="0,1" name="Interrupt on event"   enum="Interrupt" />
      <choice value="1,1" name="DMA request on event" enum="Dma"       />
   </choiceOption>

   <intOption key="pdb_idly" condition="pdb_idly_idly_present"
      enabledBy="pdb_sc_trgsel>0"
      valueFormat="%s"
      typeName="const Ticks &amp;"
      units="ticks"
      description="Interrupt delay"
      toolTip="Specifies the delay value to schedule the PDB event.\n
         It can be used to schedule an independent interrupt or DMA at some point in the PDB cycle"
      value="0" min="0" max="65535" />

   <floatOption key="pdb_idly_delay" condition="pdb_idly_idly_present"
      enabledBy="pdb_sc_trgsel>0"
      ref="(pdb_idly+1)*pdb_clock_period"
      typeName="const Seconds &amp;"
      description="Interrupt delay in seconds"
      derived="true"
      derivedFrom="pdb_idly"
      value="0" min="0" units="s" />

<!--  ============== PDB Channels ============== -->

   <for keys="n" dim="=NumChannels" >
      <category description="ADC%(n) pretriggers" >
         <for keys="m" dim="=NumPreTriggers" >
            <title description="Pre-trigger %(m)"
               toolTip="Each channel has a number of pre-trigger outputs that are usually associated with an ADC\n
                        Each pre-trigger is asserted once during a PDB cycle."
            />
            <choiceOption key="pdb_ch%(n)_c1_pt%(m)" condition="pdb_c1_en_present&amp;&amp;pdb_c1_tos_present&amp;&amp;pdb_c1_bb_present"
               valueFormat="PDB_C1_EN(%s&lt;&lt;%(m)),PDB_C1_TOS(%s&lt;&lt;%(m)),PDB_C1_BB(%s&lt;&lt;%(m))"
               enabledBy="pdb_sc_trgsel>0"
               typeName="PdbPretrigger%(m)"
               description="Channel Pretrigger ADC%(n).SC1[%(m)]"
               toolTip="Select pre-trigger mode" >
               <choice value="0,0,0" name="Pretrigger disabled"                                                  enum="Disabled"   />
               <choice value="1,0,0" name="Pretrigger asserts 1 clock after trigger"                             enum="Bypassed"   />
               <choice value="1,1,0" name="Pretrigger asserts 1 clock + delay after trigger"                     enum="Delayed"    />
               <choice value="1,0,1" name="Back-to-back, pretrigger asserts 2 clocks after previous acknowledge" enum="BackToBack" />
            </choiceOption>

            <intOption key="pdb_ch%(n)_dly%(m)"
               valueFormat="%s"
               typeName="const Ticks &amp;"
               units="ticks"
               enabledBy="pdb_ch%(n)_c1_pt%(m) == 2"
               description="Delay"
               toolTip="Specifies the delay value for the pre-trigger of corresponding channel"
               min="0" max="65535" />

            <floatOption key="pdb_ch%(n)_dly%(m)_delay"
               ref="(pdb_ch%(n)_dly%(m)+1)*pdb_clock_period"
               typeName="const Seconds &amp;"
               enabledBy="pdb_ch%(n)_c1_pt%(m) == 2"
               description="Delay in seconds"
               derivedFrom="pdb_ch%(n)_dly%(m)"
               derived="true"
               min="0" units="s" />
         </for>
      </category>
   </for>

<!--  ============== DAC Triggers ============== -->

   <for keys="x" dim="=NumDacIntervalTriggers" >
      <category
         description="Trigger to DAC%(x)"
         toolTip="Each DAC trigger is associated with a DAC\n
                  Each DAC trigger has an independent counter so may be asserted multiple times within a PDB cycle\n
                  This may, for example, be used with the DAC FIFO to produce multiple levels synchronized to the PDB cycle."
      >
         <choiceOption key="pdb_intc%(x)_triggerMode" condition="pdb_intc_toe_present&amp;&amp;pdb_intc_ext_present"
            valueFormat="PDB_INTC_TOE(%s),PDB_INTC_EXT(%s)"
            typeName="PdbDac%(x)TriggerMode"
            enabledBy="pdb_sc_trgsel>0"
            description="DAC trigger control"
            toolTip="_Disabled\n
                  No DAC trigger is generated\n
              _Periodic\n
                  DAC interval counter is reset and counting starts when a rising edge is detected on\n
                  selected trigger input source or software trigger is selected and SWTRIG is written with 1\n
              _External\n
                  DAC interval counter is bypassed and DAC external trigger input triggers the DAC interval trigger" >
            <choice value="0,0" name="No DAC trigger"                               enum="Disabled"   />
            <choice value="1,0" name="DAC periodic trigger using interval counter"  enum="Periodic"    />
            <choice value="1,1" name="DAC trigger is connected to external trigger" enum="External"   />
         </choiceOption>

         <intOption key="pdb_int%(x)"
            enabledBy="pdb_intc%(x)_triggerMode==1"
            valueFormat="%s"
            units="ticks"
            typeName="const Ticks &amp;"
            description="DAC interval"
            toolTip="Specifies the interval value for DAC interval counter.\n
                     When the DAC interval counter is equal to this value, the DAC is triggered and\n
                     the interval counter is reset and may continue counting.\n
                     Note that the DAC interval counter is separate to the PDB counter.\n
                     This allows multiple DAC events in a PDB cycle."
            value="0" min="0" max="65535" />

         <floatOption key="pdb_int%(x)_delay"
            ref="(pdb_int%(x)+1)*pdb_clock_period"
            typeName="const Seconds &amp;"
            enabledBy="pdb_intc%(x)_triggerMode==1"
            description="DAC interval in seconds"
            derivedFrom="pdb_int%(x)"
            derived="true"
            min="0" units="s" />
      </category>
   </for>

<!--  ============== Pulse Outputs ============== -->

   <for keys="y" dim="=NumPulseOutputs" >
      <category
         description="Pulse output %(y) to CMP%(y)"
         toolTip="The pulse output is usually used to control the sample window for an associated CMP.\n
                  The pulse is generated once per PDB cycle and has adjustable start and end times."
      >
         <binaryOption key="pdb_poen_en%(y)"
            typeName="PdbPulseOutput%(y)"
            valueFormat="PDB_POEN_POEN(%s&lt;&lt;%(y))"
            enabledBy="pdb_sc_trgsel>0"
            description="Pulse output trigger enable"
            toolTip="Enable the trigger to DAC %(y)" >
            <choice value="0" name="Pulse output disabled"        enum="Disabled" />
            <choice value="1" name="Pulse output %(y) is enabled" enum="Enabled"  />
         </binaryOption>

         <intOption key="pdb_po%(y)_dly1"
            enabledBy="pdb_poen_en%(y)"
            valueFormat="%s"
            units="ticks"
            typeName="const Ticks &amp;"
            description="Pulse-Output Delay 1 - rising edge"
            toolTip="This specifies the delay 1 value for the Pulse-Out\n
               Pulse-Output goes high when the counter is equal to the dly1"
            value="0" min="0" max="65535" />

         <floatOption key="pdb_po%(y)_dly1_delay"
            enabledBy="pdb_poen_en%(y)"
            ref="(pdb_po%(y)_dly1+1)*pdb_clock_period"
            typeName="const Seconds &amp;"
            description="Pulse-Output Delay 1 - rising edge in seconds"
            derived="true"
            derivedFrom="pdb_po%(y)_dly1"
            value="1" min="0" units="s" />

         <intOption key="pdb_po%(y)_dly2"
            enabledBy="pdb_poen_en%(y)"
            valueFormat="%s"
            units="ticks"
            typeName="const Ticks &amp;"
            description="Pulse-Output Delay 2 - falling edge"
            toolTip="These bits specify the delay 2 value for the Pulse-Out\n
               Pulse-Output goes low when the counter is equal to the dly2"
            value="0" min="0" max="65535" />

         <floatOption key="pdb_po%(y)_dly2_delay"
            enabledBy="pdb_poen_en%(y)"
            ref="(pdb_po%(y)_dly2+1)*pdb_clock_period"
            typeName="const Seconds &amp;"
            description="Pulse-Output Delay 2 - falling edge in seconds"
            derived="true"
            derivedFrom="pdb_po%(y)_dly2"
            value="1" min="0" units="s" />
      </category>
   </for>

<!-- Graphic here -->

   <for keys="field:name"
        values="
         pdb_sc_ldmod         : LoadMode;
         pdb_sc_pdbeie        : SequenceError;
         pdb_sc_swtrig        : SofwtareTrigger;
         pdb_sc_dmaen         : DmaEnable;
         pdb_sc_prescaler     : ClockPrescaler;
         pdb_sc_trgsel        : TriggerSelect;
         pdb_sc_pdben         : Enable;
         pdb_sc_pdbif         : InterruptFlag;
         pdb_sc_pdbie         : InterruptEnable;
         pdb_sc_mult          : Prescaler;
         pdb_sc_cont          : Continuous;
         pdb_sc_ldok          : Load;
         pdb_mod_mod          : Modulo;
         pdb_cnt_cnt          : Counter;
         pdb_idly_idly        : IrqDelay;
         pdb_c1_bb            : C1Bb;
         pdb_c1_tos           : C1Tos;
         pdb_c1_en            : C1En;
         pdb_s_cf             : SCf;
         pdb_s_err            : SErr;
         pdb_dly_dly          : DlyDly;
         pdb_poen_poen        : PulseOutput;
         pdb_dly_dly          : Delay;
         pdb_podly_dly1       : PulseOutput1Delay;
         pdb_podly_dly2       : PulseOutput2Delay" >
      <variableTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!--   ========== class $(_Class)BasicInfo =============================== -->

   <template namespace="usbdm" ><![CDATA[
      class $(_Class)BasicInfo {

      public:\n
   ]]></template>

   <!--   ========== Interrupt handling =============================== -->

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></variableTemplate>

   <template namespace="usbdm" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Type definition for $(_Baseclass) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]></template>

   <for keys="irqHandler   : Callback        : Description"
      values="=IrqInformation"
   >
      <template codeGenCondition="irqHandlingMethod" ><![CDATA[
         \t/** Callback functions for %(Description) ISR */
         \tstatic CallbackFunction s%(Callback);
         \t
         \t/**
         \t * Set %(Description) callback function.
         \t *
         \t * @param[in]  $(_basename)Callback Callback function to execute on interrupt
         \t *                             Use nullptr to remove callback.
         \t */
         \tstatic void set%(Callback)(CallbackFunction $(_basename)%(Callback)) {
         \t   if ($(_basename)%(Callback) == nullptr) {
         \t      $(_basename)%(Callback) = unhandledCallback;
         \t   }
         \t   // Allow either no handler set yet or removing handler
         \t   usbdm_assert(
         \t         (s%(Callback) == unhandledCallback) || ($(_basename)%(Callback) == unhandledCallback),
         \t         "Handler already set");
         \t   s%(Callback) = $(_basename)%(Callback);
         \t}
         \t
         \t/**
         \t * $(_BASENAME) %(Description) callback handler
         \t */
         \tstatic void %(irqHandler)() {
         \t
         \t   // Execute call-back
         \t   sCallback($(irq_call));
         \t}
         \t\n
      ]]></template>

      <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
         \t
         \t/**
         \t * Callback for programmatically set %(Description) callback for $(_Class)
         \t */
         \t$(_Class)Info::CallbackFunction $(_Class)Info::s%(Callback)  = $(_Class)Info::unhandledCallback;
         \t\n
      ]]></template>

   </for>

   <!--   ========== PDB Init class =============================== -->

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Class used to do main initialisation of a $(_Class)
      \t *
      \t * This class has a templated constructor that accepts various values.  <br>
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.  <br>
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.  <br>
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * // Example initialisation values for $(_Class)
      \t *
      \t * // This example uses 'ticks'
      \t * static const Pdb::Init pdbInit_ticks {
      \t *
      \t *    PdbTrigger_Software ,      // Trigger Input Source Select - Software trigger is selected
      \t *    PdbMode_OneShot ,          // PDB operation mode - Sequence runs once only
      \t *    PdbLoadMode_Immediate ,    // Register Load Select - Register loaded immediately
      \t *
      \t *    PdbPrescale_DivBy_4 ,      // Clock Prescaler Divider Select - Divide by 4
      \t *    0x1000_ticks ,             // Counter modulus
      \t *
      \t *    NvicPriority_VeryHigh,     // IRQ level for this peripheral - VeryHigh
      \t *
      \t *    PdbAction_Interrupt ,      // Action done on event - Interrupt req on event
      \t *    0x900_ticks ,              // Interrupt delay
      \t *    pdbCallback,               // Action call-back
      \t *
      \t *    PdbErrorAction_None ,      // Sequence Error Interrupt Enable - No interrupt on error
      \t *
      \t *    // ADC Pretriggers
      \t *    PdbChannel_0, PdbPretrigger0_Delayed, 0x111_ticks, // Channel 0 Pretrigger 0
      \t *    PdbChannel_0, PdbPretrigger1_Disabled,             // Channel 0 Pretrigger 1
      \t *    PdbChannel_1, PdbPretrigger0_Delayed, 0x222_ticks, // Channel 1 Pretrigger 0
      \t *    PdbChannel_1, PdbPretrigger1_Bypassed,             // Channel 1 Pretrigger 1
      \t *
      \t *    // DAC triggers
      \t *    PdbDac0TriggerMode_Periodic, 0x333_ticks, // DAC0 Trigger
      \t *    PdbDac1TriggerMode_External,              // DAC1 Trigger
      \t *
      \t *    // Pulse outputs
      \t *    PdbPulseOutput0_Enabled, 0x444_ticks, 0x555_ticks,  // Pulse output 0 (CMP0)
      \t *    PdbPulseOutput1_Enabled, 0x666_ticks, 0x777_ticks,  // Pulse output 0 (CMP1)
      \t *
      \t *    Pdb0::DefaultInitValue,  // Optional initial value.  Above parameters modify this
      \t * };
      \t *
      \t * // Initialise PDB channel from values specified above
      \t * Pdb::configure(pdbInit_ticks)
      \t *
      \t * // Example initialisation values for $(_Class)
      \t * // This example uses 'seconds'
      \t * static const Pdb::Init pdbInit_seconds {
      \t *
      \t *    PdbTrigger_Software ,      // Trigger Input Source Select - Software trigger is selected
      \t *    PdbMode_OneShot ,          // PDB operation mode - Sequence runs once only
      \t *    PdbLoadMode_Immediate ,    // Register Load Select - Register loaded immediately
      \t *
      \t *    PdbPrescale_Auto_Calculated ,  // Clock Prescaler auto-selected by PDB period
      \t *    200_ms ,                   // Counter period
      \t *
      \t *    NvicPriority_VeryHigh,     // IRQ level for this peripheral - VeryHigh
      \t *
      \t *    PdbAction_None ,           // Action done on event - No action on event
      \t *    190_ms ,                   // Interrupt delay
      \t *
      \t *    PdbErrorAction_Interrupt , // Sequence Error Interrupt Enable - Interrupt on error
      \t *    pdbCallback,               // Error action call-back
      \t *
      \t *    // ADC Pretriggers
      \t *    PdbChannel_0, PdbPretrigger0_Delayed, 100_ms, // Channel 0 Pretrigger 0 @ 100 ms
      \t *    PdbChannel_0, PdbPretrigger1_Disabled,        // Channel 0 Pretrigger 1 disabled
      \t *    PdbChannel_1, PdbPretrigger0_Delayed, 150_ms, // Channel 1 Pretrigger 0 @ 150 ms
      \t *    PdbChannel_1, PdbPretrigger1_Bypassed,        // Channel 1 Pretrigger 1 disabled
      \t *
      \t *    // DAC triggers
      \t *    PdbDac0TriggerMode_Periodic, 50_ms, // DAC0 Trigger @ 50 ms
      \t *    PdbDac1TriggerMode_External,        // DAC1 Trigger directly triggered by external input
      \t *
      \t *    // Pulse outputs
      \t *    PdbPulseOutput0_Enabled, 120_ms, 130_ms,  // Pulse output 0 (CMP0 window) @ 120-130 ms
      \t *    PdbPulseOutput1_Enabled, 220_ms, 230_ms,  // Pulse output 0 (CMP1 window) @ 220-230 ms
      \t * };
      \t *
      \t * // Initialise PDB channel from values specified above
      \t * Pdb::configure(pdbInit_seconds)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="!secondsSupport&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t   // Shadow larger definition to save space when not using float
      \t   struct Seconds_Ticks {
      \t
      \t      ///  Time in Ticks
      \t      uint32_t value;
      \t
      \t      constexpr Seconds_Ticks() : value(0) {}
      \t
      \t      constexpr Ticks   toTicks() const { return Ticks(value); }
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t   using Seconds_Ticks = USBDM::Seconds_Ticks;
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="!secondsSupport&amp;&amp;enablePeripheralSupport
               &amp;&amp;/HARDWARE/useTypeSystemForTimers" ><![CDATA[
      \t      constexpr void fromTicks(Ticks ticks) { value = ticks.getValue(); }\n
   ]]></template>
   <template namespace="usbdm" codeGenCondition="!secondsSupport&amp;&amp; enablePeripheralSupport
               &amp;&amp;!/HARDWARE/useTypeSystemForTimers" ><![CDATA[
      \t      constexpr void fromTicks(Ticks ticks) { value = ticks; }\n
   ]]></template>
   <template namespace="usbdm" codeGenCondition="!secondsSupport&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t   };
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <for keys="irqHandler   : Callback        : Description"
      values="=IrqInformation"
   >
      <template namespace="usbdm" codeGenCondition="irqHandlingMethod"
       ><![CDATA[
         \t   /// %(Description) callback
         \t   CallbackFunction %(irqHandler) = nullptr;\n\n
      ]]></template>
   </for>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_poen_en0"
   ><![CDATA[
      \t   /// Pulse-Out Enable register
      \t   uint8_t poen = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_po0_dly1"
   ><![CDATA[
      \t   /// Pulse-Out[Y] Delay 1 - rising edge
      \t   Seconds_Ticks dly1[$(NumPulseOutputs)];\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_po0_dly2"
   ><![CDATA[
      \t   /// Pulse-Out[Y] Delay 1 - falling edge
      \t   Seconds_Ticks dly2[$(NumPulseOutputs)];\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_intc0_triggerMode"
   ><![CDATA[
      \t   /// DAC Interval Trigger[X] Control Register
      \t   uint8_t intc[$(NumDacIntervalTriggers)] = {0};\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_int0"
   ><![CDATA[
      \t   /// DAC Interval[X] Interval Register
      \t   Seconds_Ticks interval[$(NumDacIntervalTriggers)];\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_sc_divider, pdb_sc_trgsel, pdb_sc_action, pdb_sc_pdbeie, pdb_sc_cont, pdb_sc_ldmod"
   ><![CDATA[
      \t   /// Status and Control register
      \t   uint32_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <for keys="r" values="pdb_mod;pdb_idly" >
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
      ><![CDATA[
         \t   /// %description
         \t   Seconds_Ticks %registerName;\n\n
      ]]></variableTemplate>
   </for>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_ch0_c1_pt0"
   ><![CDATA[
      \t   /// Channel[N] Pretrigger control
      \t   uint32_t c1[$(NumChannels)] = {0};\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_ch0_dly0"
   ><![CDATA[
      \t   /// Channel[N] PretriggerDelay[M]
      \t   Seconds_Ticks dly[$(NumChannels)][$(NumPreTriggers)];\n\n
   ]]></variableTemplate>

<!--   Constructors -->

   <for keys="r" values="
         pdb_sc_trgsel;
         pdb_sc_cont;
         pdb_sc_ldmod" >
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName & ~%mask) | %paramExpression;
         \t   }\n\n
      ]]></variableTemplate>
   </for>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_sc_action, pdb_idly"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromTicks(%paramName1);
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm"  codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport"
      variables="pdb_sc_action, pdb_idly_delay"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromSeconds(%paramName1);
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm"  codeGenCondition="irqHandlingMethod"
      variables="pdb_sc_action, pdb_idly, irqHandlingMethod"
      nonDefaultParams="3"
      defaultParamValue=",,nullptr"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromTicks(%paramName1);
      \t      irqHandler = %paramName2;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm"  codeGenCondition="secondsSupport &amp;&amp; irqHandlingMethod"
      variables="pdb_sc_action, pdb_idly_delay, irqHandlingMethod"
      nonDefaultParams="3"
      defaultParamValue=",,nullptr"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromSeconds(%paramName1);
      \t      irqHandler = %paramName2;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_sc_pdbeie"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm"  codeGenCondition="irqHandlingMethod&amp;&amp;(_irqCount>1)"
      variables="pdb_sc_pdbeie, irqHandlingMethod"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %paramName0;
      \t      errorHandler = %paramName1;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="pdb_sc_divider, pdb_mod"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description0 and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0        = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromTicks(%paramName1);
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="usbdm"
      codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport"
      variables="pdb_sc_autoDivider, pdb_mod_period"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description0 and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0          = (%registerName0 & ~%mask0) | %paramName0;
      \t      %registerName1.fromSeconds(%paramName1);
      \t   }\n\n
   ]]></variableTemplate>

   <!--  Pre-triggers -->
   <for keys="m" dim="=NumPreTriggers" >
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="pdb_channel, pdb_ch0_c1_pt%(m), pdb_ch0_dly%(m)"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m) with delay
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%paramName0] |= %paramName1;
         \t      dly[%paramName0][%(m)].fromTicks(%paramName2);
         \t   }\n\n
      ]]></variableTemplate>
      <variableTemplate namespace="usbdm"
         codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport"
         variables="pdb_channel, pdb_ch0_c1_pt%(m), pdb_ch0_dly%(m)_delay"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m) with delay
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%paramName0] |= %paramName1;
         \t      dly[%paramName0][%(m)].fromSeconds(%paramName2);
         \t   }\n\n
      ]]></variableTemplate>
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="pdb_channel, pdb_ch0_c1_pt%(m)"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%paramName0] |= %paramName1;
         \t      dly[%paramName0][%(m)].fromTicks(0_ticks);
         \t   }\n\n
      ]]></variableTemplate>
   </for>

   <!--   DAC triggers -->
   <for keys="x" dim="=NumDacIntervalTriggers" >
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="pdb_intc%(x)_triggerMode, pdb_int%(x)"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 with %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)] = %paramName0;
         \t      interval[%(x)].fromTicks(%paramName1);
         \t   }\n\n
      ]]></variableTemplate>
      <variableTemplate namespace="usbdm"
         codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport"
         variables="pdb_intc%(x)_triggerMode, pdb_int%(x)_delay"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 with %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)]             = %paramName0;
         \t      interval[%(x)].fromSeconds(%paramName1);
         \t   }\n\n
      ]]></variableTemplate>
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="pdb_intc%(x)_triggerMode"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)] = %paramName0;
         \t      interval[%(x)].fromTicks(0_ticks);
         \t   }\n\n
      ]]></variableTemplate>
   </for>

   <!--  Pulse outputs -->
   <for keys="y" dim="=NumPulseOutputs" >
      <variableTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="pdb_poen_en%(y), pdb_po%(y)_dly1, pdb_po%(y)_dly2"
         nonDefaultParams="3"
         params=", rising, falling"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 %(y) with
         \t    *         %description1,
         \t    *         %description2
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      poen          |= %paramName0;
         \t      dly1[%(y)].fromTicks(%paramName1);
         \t      dly2[%(y)].fromTicks(%paramName2);
         \t   }\n\n
      ]]></variableTemplate>
      <variableTemplate namespace="usbdm"
         codeGenCondition="secondsSupport&amp;&amp;enablePeripheralSupport"
         variables="pdb_poen_en%(y), pdb_po%(y)_dly1_delay, pdb_po%(y)_dly2_delay"
         nonDefaultParams="3"
         params=", rising, falling"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 %(y) with
         \t    *         %description1,
         \t    *         %description2
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      poen            |= %paramName0;
         \t      dly1[%(y)].fromSeconds(%paramName1);
         \t      dly2[%(y)].fromSeconds(%paramName2);
         \t   }\n\n
      ]]></variableTemplate>
   </for>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}; // class $(_Class)BasicInfo::Init\n\n
   ]]></template>

<!--   Default Initialisation value -->

   <variableTemplate  codeGenCondition="enablePeripheralSupport"
      variables="
         pdb_sc_trgsel,
         pdb_sc_cont,
         pdb_sc_ldmod,
         pdb_sc_divider, pdb_mod,
         irqLevel,
         pdb_sc_pdbeie,
         pdb_sc_action, pdb_idly"
      separator=","
      terminator=","
    ><![CDATA[
      \t/**
      \t * Default initialisation values for PDB
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {
       %initExpression
       \t
   ]]></variableTemplate>

   <for keys="n" dim="=NumChannels" >
      <for keys="m" dim="=NumPreTriggers" >
         <variableTemplate variables="pdb_ch%(n)_c1_pt%(m), pdb_ch%(n)_dly%(m)" codeGenCondition="enablePeripheralSupport"
            separator=","
            terminator=","
          ><![CDATA[
               \t
               \t   // Pre-trigger %(n) configuration
               \t   PdbChannel_%(n), %initExpression
               \t
         ]]></variableTemplate>
      </for>
   </for>

   <for keys="x" dim="=NumDacIntervalTriggers" >
      <variableTemplate variables="pdb_intc%(x)_triggerMode, pdb_int%(x)" codeGenCondition="enablePeripheralSupport"
         separator=","
         terminator=","
         initExpressionOnSameLine="true"
       ><![CDATA[
         \t
         \t   // DAC %(x) trigger configuration
         \t\t%initExpression
         \t
      ]]></variableTemplate>
   </for>

   <for keys="y" dim="=NumPulseOutputs" >
      <variableTemplate variables="pdb_poen_en%(y), pdb_po%(y)_dly1, pdb_po%(y)_dly2" codeGenCondition="enablePeripheralSupport"
         separator=","
         terminator=","
         initExpressionOnSameLine="true"
       ><![CDATA[
         \t
         \t   // Pulse output %(y) (CMP%(y)) configuration
         \t\t%initExpression \n
      ]]></variableTemplate>
   </for>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t};\n\n
   ]]></template>

<!--  Configure method -->

   <template discardRepeats="true" key="/PDB/InitMethod" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
      \t/**
      \t * Configure PDB from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @return E_NO_ERROR
      \t */
      \tstatic ErrorCode configure(const typename Info::Init &init) {
      \t   return Info::template configure<PdbBase_T<Info>>(init);
      \t}
      \t
      \t/**
      \t * Set PDB to default configuration.
      \t *
      \t * Includes enabling clock and any pins used.\n
      \t * Sets PDB registers to default configuration from Configure.usbdmProject
      \t */
      \tstatic ErrorCode defaultConfigure() {
      \t
      \t   return configure(Info::DefaultInitValue);
      \t};
      \t\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \tprotected:
      \t/**
      \t * Configure PDB from values specified in init
      \t *
      \t * @tparam Pdb  Type of originating PDB
      \t * @param  init Class containing initialisation values
      \t *
      \t * @return E_NO_ERROR
      \t */
      \ttemplate<class Pdb>
      \tstatic ErrorCode configure(const Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   // Configure pins as required
      \t   configureAllPins();
      \t
      \t   // Initially assume working with Ticks
      \t   uint32_t scValue  = init.sc;
      \t   uint16_t modValue = init.mod.toTicks();
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;secondsSupport" ><![CDATA[
      \t   const bool useSeconds = ((init.sc&(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK)) == PdbPrescale_Auto_Calculated);
      \t
      \t   if (useSeconds) {
      \t      // Calculate new SC and modulo value
      \t      ErrorCode rc = Pdb::calculateCounterParameters(init.mod.toSeconds(), scValue, modValue);
      \t      if (rc != E_NO_ERROR) {
      \t          return rc;
      \t      }
      \t      scValue |= (init.sc & ~(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK));
      \t   }
      \t
      \t   const auto convertIfNeeded = [useSeconds, scValue](const Init::Seconds_Ticks &value) {
      \t      uint16_t temp = value.toTicks();
      \t      if (useSeconds) {
      \t         // This uses the SC value calculated for the modulo above
      \t         temp = Pdb::convertSecondsToTicks(value.toSeconds(), scValue)-1;
      \t      }
      \t      return temp;
      \t   };
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;!secondsSupport" ><![CDATA[
      \t   const auto convertIfNeeded = [](const Init::Seconds_Ticks &value) {
      \t      return value.toTicks();
      \t   };
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   pdb->MOD  = modValue;
      \t   pdb->IDLY = convertIfNeeded(init.idly);
      \t
      \t   // Configure pre-triggers (to ADCs usually)
      \t   for (size_t n=0; n<numChannels; n++) {
      \t      pdb->CH[n].C1 = init.c1[n];
      \t      for (size_t m=0; m<numPreTriggers; m++) {
      \t         pdb->CH[n].DLY[m] = convertIfNeeded(init.dly[n][m]);
      \t      }
      \t   }
      \t\n
   ]]></template>
   <variableTemplate variables="pdb_intc0_triggerMode" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Configure DAC triggers
      \t   for (size_t x=0; x<numDacIntervalTriggers; x++) {
      \t      pdb->DAC[x].INTC = init.intc[x];
      \t      pdb->DAC[x].INT  = convertIfNeeded(init.interval[x]);
      \t   }
      \t\n
   ]]></variableTemplate>
   <variableTemplate variables="pdb_sc_divider" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Configure Pulse outputs (to CMPs)
      \t   pdb->POEN = init.poen;
      \t   for (size_t x=0; x<numPulseOutputs; x++) {
      \t      pdb->POnDLY[x].DLY1 = convertIfNeeded(init.dly1[x]);
      \t      pdb->POnDLY[x].DLY2 = convertIfNeeded(init.dly2[x]);
      \t   }
      \t\n
   ]]></variableTemplate>
   <template codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t   // Set callbacks
      \t   setCallback(init.irqHandler);
      \t   NVIC_SetPriority(irqNums[0], init.irqlevel);
      \t   NVIC_EnableIRQ(irqNums[0]);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   // Final setting and enable load registers
      \t   pdb->SC = scValue|PDB_SC_LDOK_MASK;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \tpublic:\n\n
   ]]></template>

<!-- End of class $(_Class)BasicInfo -->

   <template namespace="usbdm" ><![CDATA[
      }; // class $(_Class)BasicInfo\n\n
   ]]></template>

<!--  ============== Templates ============== -->

   <template><![CDATA[
      \t// Number of PDB channels
      \tstatic constexpr size_t numChannels = $(NumChannels);
      \t
      \t// Number of PDB Triggers (to DACs)
      \tstatic constexpr size_t numDacIntervalTriggers = $(NumDacIntervalTriggers);
      \t
      \t// Number of PDB pulse outputs (to CMPs)
      \tstatic constexpr size_t numPulseOutputs = $(NumPulseOutputs);
      \t
      \t// Number of PDB pre-trigger outputs (to ADCs)
      \tstatic constexpr size_t numPreTriggers = $(NumPreTriggers);\n\n
      \t
      \t// Minimum resolution in ticks
      \tstatic constexpr Ticks MinimumResolution = $(Minimum_resolution)_ticks;\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t  * Get PDB clock frequency
      \t  *
      \t  * @return Frequency as a uint32_t in Hz
      \t  */
      \tstatic __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PdbValidate" >
   </validate>

   <projectActionList id="pdb_files" >
      <copy source="Project_Headers/pdb.h"         target="Project_Headers/pdb.h"        overwrite="true"  derived="true" />
      <copy source="Snippets/pdb-adc-example.cpp"  target="Snippets/pdb-adc-example.cpp" overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* SIM configuration ****************** -->
   <category name="Advanced" description="SIM configuration">
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>
   <deleteVariables variables="_scgc_clock"  mustExist="false" />

   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />
</fragment>

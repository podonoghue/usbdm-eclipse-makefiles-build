<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- pdb0_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <xi:include href="_default_instance.xml"/>

   <xi:include href="_mapPinsOption.xml"/>

   <xi:include href="_irqOption.xml"/>

   <xi:include href="_clockOption.xml"/>

<!--  ============== PDB_SC Trigger ============== -->

   <stringOption key="Triggers and Sequence" value="------- Triggers -------" constant="true" description="Triggers and sequence" />

   <choiceOption key="pdb_sc_trgsel"
      enumStem="PdbTrigger"
      valueFormat="PDB_SC_PDBEN(%s),PDB_SC_TRGSEL(%s)"
      description="Trigger Input Source Select"
      toolTip="Selects the trigger input source for the PDB.\n
         The trigger input source can be internal or external (EXTRG pin),\n
         or the software trigger" >
      <choice value="0,0"  name="PDB Disabled"                      enum="PdbDisabled"   />
      <choice value="1,0"  name="External Trigger (PDB0_EXTRG)"     enum="External"      />
      <choice value="1,1"  name="CMP 0"                             enum="Cmp0"       condition="/CMP0/$present"   />
      <choice value="1,2"  name="CMP 1"                             enum="Cmp1"       condition="/CMP1/$present"   />
      <choice value="1,3"  name="CMP 3"                             enum="Cmp2"       condition="/CMP2/$present"   />
      <choice value="1,4"  name="PIT Ch 0 Output"                   enum="PitCh0"     condition="/PIT/$present"    />
      <choice value="1,5"  name="PIT Ch 1 Output"                   enum="PitCh1"     condition="/PIT/$present"    />
      <choice value="1,6"  name="PIT Ch 2 Output"                   enum="PitCh2"     condition="/PIT/$present"    />
      <choice value="1,7"  name="PIT Ch 3 Output"                   enum="PitCh3"     condition="/PIT/$present"    />
      <choice value="1,8"  name="FTM0 Init and Ext Trigger Outputs" enum="Ftm0"       condition="/FTM0/$present"   />
      <choice value="1,9"  name="FTM1 Init and Ext Trigger Outputs" enum="Ftm1"       condition="/FTM1/$present"   />
      <choice value="1,10" name="FTM2 Init and Ext Trigger Outputs" enum="Ftm2"       condition="/FTM2/$present"   />
      <choice value="1,11" name="FTM3 Init and Ext Trigger Outputs" enum="Ftm3"       condition="/FTM3/$present"   />
      <choice value="1,12" name="RTC Alarm"                         enum="RtcAlarm"   condition="/RTC/$present"    />
      <choice value="1,13" name="RTC Seconds"                       enum="RtcSeconds" condition="/RTC/$present"    />
      <choice value="1,14" name="LPTMR"                             enum="Lptmr"      condition="/LPTMR0/$present" />
      <choice value="1,15" name="Software trigger is selected"      enum="Software"   />
   </choiceOption>

   <binaryOption key="secondsSupport"
      enabledBy="pdb_sc_trgsel>0"
      description="Enable use of Seconds for time"
      toolTip="Use of floating point is necessary to support specifing PDB times in seconds in runtime code.\n
               If not needed, the overhead can be avoided by disabling this option">
      <choice value="false" enum="Disabled" name="Seconds support disabled" isDefault="true" />
      <choice value="true"  enum="Enabled"  name="Seconds support enabled" />
   </binaryOption>

   <intOption key="Minimum_resolution"
      enabledBy="secondsSupport"
      valueFormat="%s_ticks"
      typeName="const Ticks &amp;"
      description="Minumum value for counter modulus"
      toolTip="This can be used to ensure that a reasonable resolution is available when using Seconds\n
               Attempting to set too small a modulo will result in an error"
      value="1000" min="0" max="65535"/>

   <binaryOption key="pdb_sc_pdbeie" condition="pdb_sc_pdbeie_present"
      enumStem="PdbErrorAction"
      enabledBy="pdb_sc_trgsel>0"
      description="Sequence Error Interrupt Enable"
      toolTip="This bit enables the sequence error interrupt\n
         When this bit is set, any of the channel sequence error flags generates a sequence error interrupt" >
      <choice value="0" name="No interrupt on error"  enum="None"      />
      <choice value="1" name="Interrupt on error"     enum="Interrupt" />
   </binaryOption>

   <binaryOption key="pdb_sc_cont" condition="pdb_sc_cont_present"
      enumStem="PdbMode"
      enabledBy="pdb_sc_trgsel>0"
      description="PDB operation mode"
      toolTip="Select continuous or one-shot mode" >
      <choice value="0" name="Sequence runs once only"                    enum="OneShot"      />
      <choice value="1" name="Sequence runs continuously once triggered"  enum="Continuous" />
   </binaryOption>

   <choiceOption key="pdb_sc_ldmod" condition="pdb_sc_ldmod_present"
      enumStem="PdbLoadMode"
      enabledBy="pdb_sc_trgsel>0"
      description="Register Load Select"
      toolTip="Selects when to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,\n
         after 1 is written to LDOK">
      <choice value="0" name="Registers loaded immediately on LDOK=1"                                  enum="Immediate"     />
      <choice value="1" name="Registers loaded when PDB counter reaches MOD"                           enum="Modulo"        />
      <choice value="2" name="Registers loaded on trigger input event"                                 enum="Event"         />
      <choice value="3" name="Registers loaded when PDB counter reaches MOD or on trigger input event" enum="EventOrModulo" />
   </choiceOption>

<!--  ============== PDB_SC related ============== -->

   <stringOption key="Clocking" value="------- Clocking -------" constant="true" description="Clocking" />

   <choiceOption key="pdbClockConfig"
      target="input_clock"
      description="Clock configuration"
      toolTip="Selects the clock configuration used for ticks and time calculations" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="input_clock"
      ref="/SIM/system_bus_clock[]"
      constant="true"
      derived="true"
      units="Hz"
      description="Frequency of PDB input Clock" />

   <choiceOption key="pdb_channel"
      enumStem="PdbChannel"
      valueFormat="%s"
      hidden="true"
      description="PDB Channel select"
      toolTip="Selects a PDB channel">
      <choice value="0" name="Channel 0"   enum="0" condition="@NumChannels>0"/>
      <choice value="1" name="Channel 1"   enum="1" condition="@NumChannels>1"/>
      <choice value="2" name="Channel 2"   enum="2" condition="@NumChannels>2"/>
      <choice value="3" name="Channel 3"   enum="3" condition="@NumChannels>3"/>
      <choice value="4" name="Channel 4"   enum="4" condition="@NumChannels>4"/>
      <choice value="5" name="Channel 5"   enum="5" condition="@NumChannels>5"/>
      <choice value="6" name="Channel 6"   enum="6" condition="@NumChannels>6"/>
      <choice value="7" name="Channel 7"   enum="7" condition="@NumChannels>7"/>
   </choiceOption>

   <choiceOption key="pdb_sc_divider"
      target="pdb_clock_frequency"
      valueFormat="PDB_SC_MULT(%s),PDB_SC_PRESCALER(%s)"
      enabledBy="pdb_sc_trgsel>0"
      enumStem="PdbPrescale"
      description="Clock Prescaler Divider Select"
      toolTip="The PDB input clock is divided by this factor">
      <choice value="0,0"   name="Divide by 1"      enum="DivBy_1"      ref="(input_clock)/1"    />
      <choice value="0,1"   name="Divide by 2"      enum="DivBy_2"      ref="(input_clock)/2"    />
      <choice value="0,2"   name="Divide by 4"      enum="DivBy_4"      ref="(input_clock)/4"    />
      <choice value="0,3"   name="Divide by 8"      enum="DivBy_8"      ref="(input_clock)/8"    />
      <choice value="1,0"   name="Divide by 10"     enum="DivBy_10"     ref="(input_clock)/10"   />
      <choice value="0,4"   name="Divide by 16"     enum="DivBy_16"     ref="(input_clock)/16"   />
      <choice value="1,1"   name="Divide by 20"     enum="DivBy_20"     ref="(input_clock)/20"   />
      <choice value="0,5"   name="Divide by 32"     enum="DivBy_32"     ref="(input_clock)/32"   />
      <choice value="1,2"   name="Divide by 40"     enum="DivBy_40"     ref="(input_clock)/40"   />
      <choice value="0,6"   name="Divide by 64"     enum="DivBy_64"     ref="(input_clock)/64"   />
      <choice value="1,3"   name="Divide by 80"     enum="DivBy_80"     ref="(input_clock)/80"   />
      <choice value="0,7"   name="Divide by 128"    enum="DivBy_128"    ref="(input_clock)/128"  />
      <choice value="1,4"   name="Divide by 160"    enum="DivBy_160"    ref="(input_clock)/160"  />
      <choice value="1,5"   name="Divide by 320"    enum="DivBy_320"    ref="(input_clock)/320"  />
      <choice value="1,6"   name="Divide by 640"    enum="DivBy_640"    ref="(input_clock)/640"  />
      <choice value="1,7"   name="Divide by 1280"   enum="DivBy_1280"   ref="(input_clock)/1280" />
      <choice value="2,7"   name="Divide by 2560"   enum="DivBy_2560"   ref="(input_clock)/2560" />
      <choice value="3,7"   name="Divide by 5120"   enum="DivBy_5120"   ref="(input_clock)/5120" />
   </choiceOption>

   <choiceOption key="pdb_sc_auto_divider"
      valueFormat="PDB_SC_MULT(%s),PDB_SC_PRESCALER(%s)"
      enumStem="PdbPrescale_Auto"
      hidden="true"
      description="Auto select divider from period in seconds"
      toolTip="Auto select divider from period in seconds">
      <choice value="3,0"   name="Auto select divider"      enum="Select" />
   </choiceOption>

   <floatOption key="pdb_clock_frequency"
      enabledBy="pdb_sc_trgsel>0"
      description="Frequency of PDB clock"
      toolTip="PDB clock frequency (Tick rate of PDB)"
      derived="true"
      constant="true"
      min="0" units="Hz" />

   <floatOption key="pdb_clock_period"
      enabledBy="pdb_sc_trgsel>0"
      ref="1.0/pdb_clock_frequency"
      description="Period of PDB clock"
      toolTip="PDB clock period (Tick period of PDB)"
      derived="true"
      constant="true"
      value="1k" min="0" units="s" />

<!--  ============== PDB_MOD ============== -->

   <stringOption key="MainCounter" value="------- Counter -------" constant="true" description="Main counter" />

   <intOption key="pdb_mod" condition="pdb_mod_mod_present"
      valueFormat="%s_ticks"
      typeName="const Ticks &amp;"
      enabledBy="pdb_sc_trgsel>0"
      description="Counter mod register value"
      toolTip="Controls the period of the main PDB counter [0..mod]\n
         When the counter reaches this value, it will be reset back to zero.\n
         If the PDB is in Continuous mode, the count begins anew\n
         Counter modulus is (mod+1)"
      value="65535" min="0" max="65535"/>

   <floatOption key="pdb_mod_period" condition="pdb_mod_mod_present"
      enabledBy="pdb_sc_trgsel>0"
      ref="(pdb_mod+1)*pdb_clock_period"
      typeName="const Seconds &amp;"
      description="Counter period in seconds"
      derivedFrom="pdb_mod"
      derived="true"
      min="0" units="s" />

<!--  ============== PDB_IDLY ============== -->

   <choiceOption key="pdb_sc_action" condition="pdb_sc_dmaen_present&amp;&amp;pdb_sc_pdbie_present"
      enabledBy="pdb_sc_trgsel>0"
      enumStem="PdbAction"
      valueFormat="PDB_SC_DMAEN(%s),PDB_SC_PDBIE(%s)"
      description="Interrupt action"
      toolTip="Selects the action when timer reached interrupt delay value" >
      <choice value="0,0" name="No action on event"   enum="None"      />
      <choice value="0,1" name="Interrupt on event"   enum="Interrupt" />
      <choice value="1,1" name="DMA request on event" enum="Dma"       />
   </choiceOption>

   <intOption key="pdb_idly" condition="pdb_idly_idly_present"
      enabledBy="pdb_sc_trgsel>0"
      valueFormat="%s_ticks"
      typeName="const Ticks &amp;"
      description="Interrupt delay"
      toolTip="Specifies the delay value to schedule the PDB event.\n
         It can be used to schedule an independent interrupt or DMA at some point in the PDB cycle"
      value="0" min="0" max="65535" />

   <floatOption key="pdb_idly_delay" condition="pdb_idly_idly_present"
      enabledBy="pdb_sc_trgsel>0"
      ref="(pdb_idly+1)*pdb_clock_period"
      typeName="const Seconds &amp;"
      description="Interrupt delay in seconds"
      derived="true"
      derivedFrom="pdb_idly"
      value="0" min="0" units="s" />

<!--  ============== PDB Channels ============== -->

   <for keys="n" dim="NumChannels" >
      <stringOption key="Channel %(n)" value="------- Channel %(n) -------" constant="true"
         description="PDB Channel %(n) (usually associated with ADC%(n))"
         toolTip="Each channel has a number of pre-trigger outputs that are usually associated with an ADC\n
                  Each pre-trigger is asserted once during a PDB cycle."
      />
      <for keys="m" dim="NumPreTriggers" >

         <choiceOption key="pdb_ch%(n)_c1_pt%(m)" condition="pdb_c1_en_present&amp;&amp;pdb_c1_tos_present&amp;&amp;pdb_c1_bb_present"
            valueFormat="PDB_C1_EN(%s&lt;&lt;%(m)),PDB_C1_TOS(%s&lt;&lt;%(m)),PDB_C1_BB(%s&lt;&lt;%(m))"
            enabledBy="pdb_sc_trgsel>0"
            enumStem="PdbPretrigger%(m)"
            description="Channel Pretrigger control (usually ADC%(n).SC1[%(m)])"
            toolTip="Select pre-trigger mode" >
            <choice value="0,0,0" name="Pretrigger disabled"                                                  enum="Disabled"   />
            <choice value="1,0,0" name="Pretrigger asserts 1 clock after trigger"                             enum="Bypassed"   />
            <choice value="1,1,0" name="Pretrigger asserts 1 clock + delay after trigger"                     enum="Delayed"    />
            <choice value="1,0,1" name="Back-to-back, pretrigger asserts 2 clocks after previous acknowledge" enum="BackToBack" />
         </choiceOption>

         <intOption key="pdb_ch%(n)_dly%(m)"
            valueFormat="%s_ticks"
            typeName="const Ticks &amp;"
            enabledBy="pdb_ch%(n)_c1_pt%(m) == 2"
            description="Delay"
            toolTip="Specifies the delay value for the pre-trigger of corresponding channel"
            min="0" max="65535" />

         <floatOption key="pdb_ch%(n)_dly%(m)_delay"
            ref="(pdb_ch%(n)_dly%(m)+1)*pdb_clock_period"
            typeName="const Seconds &amp;"
            enabledBy="pdb_ch%(n)_c1_pt%(m) == 2"
            description="Delay in seconds"
            derivedFrom="pdb_ch%(n)_dly%(m)"
            derived="true"
            min="0" units="s" />
      </for>
   </for>

<!--  ============== DAC Triggers ============== -->

   <for keys="x" dim="NumDacIntervalTriggers" >
      <stringOption key="DAC %(x)" value="------- DAC %(x) -------" constant="true"
         description="Trigger to DAC%(x)"
         toolTip="Each DAC trigger is associated with a DAC\n
                  Each DAC trigger has an independent counter so may be asserted multiple times within a PDB cycle\n
                  This may, for example, be used with the DAC FIFO to produce multiple levels synchronized to the PDB cycle."
      />

      <choiceOption key="pdb_intc%(x)_triggerMode" condition="pdb_intc_toe_present&amp;&amp;pdb_intc_ext_present"
         valueFormat="PDB_INTC_TOE(%s),PDB_INTC_EXT(%s)"
         enumStem="PdbDac%(x)TriggerMode"
         enabledBy="pdb_sc_trgsel>0"
         description="DAC trigger control"
         toolTip="_Disabled\n
               No DAC trigger is generated\n
           _Periodic\n
               DAC interval counter is reset and counting starts when a rising edge is detected on\n
               selected trigger input source or software trigger is selected and SWTRIG is written with 1\n
           _External\n
               DAC interval counter is bypassed and DAC external trigger input triggers the DAC interval trigger" >
         <choice value="0,0" name="No DAC trigger"                               enum="Disabled"   />
         <choice value="1,0" name="DAC periodic trigger using interval counter"  enum="Periodic"    />
         <choice value="1,1" name="DAC trigger is connected to external trigger" enum="External"   />
      </choiceOption>

      <intOption key="pdb_int%(x)"
         enabledBy="pdb_intc%(x)_triggerMode==1"
         valueFormat="%s_ticks"
         typeName="const Ticks &amp;"
         description="DAC interval"
         toolTip="Specifies the interval value for DAC interval counter.\n
                  When the DAC interval counter is equal to this value, the DAC is triggered and\n
                  the interval counter is reset and may continue counting.\n
                  Note that the DAC interval counter is separate to the PDB counter.\n
                  This allows multiple DAC events in a PDB cycle."
         value="0" min="0" max="65535" />

      <floatOption key="pdb_int%(x)_delay"
         ref="(pdb_int%(x)+1)*pdb_clock_period"
         typeName="const Seconds &amp;"
         enabledBy="pdb_intc%(x)_triggerMode==1"
         description="DAC interval in seconds"
         derivedFrom="pdb_int%(x)"
         derived="true"
         min="0" units="s" />
   </for>

<!--  ============== Pulse Outputs ============== -->

   <for keys="y" dim="NumPulseOutputs" >
      <stringOption key="Pulse Output %(y)" value="------- PULSE %(y) -------" constant="true"
         description="Pulse output %(y) to CMP%(y)"
         toolTip="The pulse output is usually used to control the sample window for an associated CMP.\n
                  The pulse is generated once per PDB cycle and has adjustable start and end times."
      />
      <binaryOption key="pdb_poen_en%(y)"
         enumStem="PdbPulseOutput%(y)"
         valueFormat="PDB_POEN_POEN(%s&lt;&lt;%(y))"
         enabledBy="pdb_sc_trgsel>0"
         description="Pulse output trigger enable"
         toolTip="Enable the trigger to DAC %(y)" >
         <choice value="0" name="Pulse output disabled"        enum="Disabled" />
         <choice value="1" name="Pulse output %(y) is enabled" enum="Enabled"  />
      </binaryOption>

      <intOption key="pdb_po%(y)_dly1"
         enabledBy="pdb_poen_en%(y)"
         valueFormat="%s_ticks"
         typeName="const Ticks &amp;"
         description="Pulse-Output Delay 1 - rising edge"
         toolTip="This specifies the delay 1 value for the Pulse-Out\n
            Pulse-Output goes high when the counter is equal to the dly1"
         value="0" min="0" max="65535" />

      <floatOption key="pdb_po%(y)_dly1_delay"
         enabledBy="pdb_poen_en%(y)"
         ref="(pdb_po%(y)_dly1+1)*pdb_clock_period"
         typeName="const Seconds &amp;"
         description="Pulse-Output Delay 1 - rising edge in seconds"
         derived="true"
         derivedFrom="pdb_po%(y)_dly1"
         value="1" min="0" units="s" />

      <intOption key="pdb_po%(y)_dly2"
         enabledBy="pdb_poen_en%(y)"
         valueFormat="%s_ticks"
         typeName="const Ticks &amp;"
         description="Pulse-Output Delay 2 - falling edge"
         toolTip="These bits specify the delay 2 value for the Pulse-Out\n
            Pulse-Output goes low when the counter is equal to the dly2"
         value="0" min="0" max="65535" />

      <floatOption key="pdb_po%(y)_dly2_delay"
         enabledBy="pdb_poen_en%(y)"
         ref="(pdb_po%(y)_dly2+1)*pdb_clock_period"
         typeName="const Seconds &amp;"
         description="Pulse-Output Delay 2 - falling edge in seconds"
         derived="true"
         derivedFrom="pdb_po%(y)_dly2"
         value="1" min="0" units="s" />
   </for>

   <!--   ========== PDB Init class =============================== -->

   <template key="init_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do main initialisation of a $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values.  <br>
      \t * Parameters available may vary with device - see $(_class)::DefaultInitValue for relevant example.  <br>
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.  <br>
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * // Example initialisation values for $(_class)
      \t *
      \t * // This example uses 'ticks'
      \t * static const Pdb::Init pdbInit_ticks {
      \t *
      \t *    PdbTrigger_Software ,      // Trigger Input Source Select - Software trigger is selected
      \t *    PdbMode_OneShot ,          // PDB operation mode - Sequence runs once only
      \t *    PdbLoadMode_Immediate ,    // Register Load Select - Register loaded immediately
      \t *
      \t *    PdbPrescale_DivBy_4 ,      // Clock Prescaler Divider Select - Divide by 4
      \t *    0x1000_ticks ,             // Counter modulus
      \t *
      \t *    NvicPriority_VeryHigh,     // IRQ level for this peripheral - VeryHigh
      \t *
      \t *    PdbAction_Interrupt ,      // Action done on event - Interrupt req on event
      \t *    0x900_ticks ,              // Interrupt delay
      \t *    pdbCallback,               // Action call-back
      \t *
      \t *    PdbErrorAction_None ,      // Sequence Error Interrupt Enable - No interrupt on error
      \t *
      \t *    // ADC Pretriggers
      \t *    PdbChannel_0, PdbPretrigger0_Delayed, 0x111_ticks, // Channel 0 Pretrigger 0
      \t *    PdbChannel_0, PdbPretrigger1_Disabled,             // Channel 0 Pretrigger 1
      \t *    PdbChannel_1, PdbPretrigger0_Delayed, 0x222_ticks, // Channel 1 Pretrigger 0
      \t *    PdbChannel_1, PdbPretrigger1_Bypassed,             // Channel 1 Pretrigger 1
      \t *
      \t *    // DAC triggers
      \t *    PdbDac0TriggerMode_Periodic, 0x333_ticks, // DAC0 Trigger
      \t *    PdbDac1TriggerMode_External,              // DAC1 Trigger
      \t *
      \t *    // Pulse outputs
      \t *    PdbPulseOutput0_Enabled, 0x444_ticks, 0x555_ticks,  // Pulse output 0 (CMP0)
      \t *    PdbPulseOutput1_Enabled, 0x666_ticks, 0x777_ticks,  // Pulse output 0 (CMP1)
      \t *
      \t *    Pdb0::DefaultInitValue,  // Optional initial value.  Above parameters modify this
      \t * };
      \t *
      \t * // Initialise PDB channel from values specified above
      \t * Pdb::configure(pdbInit_ticks)
      \t *
      \t * // Example initialisation values for $(_class)
      \t * // This example uses 'seconds'
      \t * static const Pdb::Init pdbInit_seconds {
      \t *
      \t *    PdbTrigger_Software ,      // Trigger Input Source Select - Software trigger is selected
      \t *    PdbMode_OneShot ,          // PDB operation mode - Sequence runs once only
      \t *    PdbLoadMode_Immediate ,    // Register Load Select - Register loaded immediately
      \t *
      \t *    PdbPrescale_Auto_Select ,  // Clock Prescaler auto-selected by PDB period
      \t *    200_ms ,                   // Counter period
      \t *
      \t *    NvicPriority_VeryHigh,     // IRQ level for this peripheral - VeryHigh
      \t *
      \t *    PdbAction_None ,           // Action done on event - No action on event
      \t *    190_ms ,                   // Interrupt delay
      \t *
      \t *    PdbErrorAction_Interrupt , // Sequence Error Interrupt Enable - Interrupt on error
      \t *    pdbCallback,               // Error action call-back
      \t *
      \t *    // ADC Pretriggers
      \t *    PdbChannel_0, PdbPretrigger0_Delayed, 100_ms, // Channel 0 Pretrigger 0 @ 100 ms
      \t *    PdbChannel_0, PdbPretrigger1_Disabled,        // Channel 0 Pretrigger 1 disabled
      \t *    PdbChannel_1, PdbPretrigger0_Delayed, 150_ms, // Channel 1 Pretrigger 0 @ 150 ms
      \t *    PdbChannel_1, PdbPretrigger1_Bypassed,        // Channel 1 Pretrigger 1 disabled
      \t *
      \t *    // DAC triggers
      \t *    PdbDac0TriggerMode_Periodic, 50_ms, // DAC0 Trigger @ 50 ms
      \t *    PdbDac1TriggerMode_External,        // DAC1 Trigger directly triggered by external input
      \t *
      \t *    // Pulse outputs
      \t *    PdbPulseOutput0_Enabled, 120_ms, 130_ms,  // Pulse output 0 (CMP0 window) @ 120-130 ms
      \t *    PdbPulseOutput1_Enabled, 220_ms, 230_ms,  // Pulse output 0 (CMP1 window) @ 220-230 ms
      \t * };
      \t *
      \t * // Initialise PDB channel from values specified above
      \t * Pdb::configure(pdbInit_seconds)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" ><![CDATA[
      class $(_class)BasicInfo {
      \t
      public:
      \t/**
      \t * Type definition for $(_class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)();
      \t\n
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="!secondsSupport" ><![CDATA[
      \t   // Shadow larger definition to save space when not using float
      \t   struct Seconds_Ticks {
      \t
      \t      ///  Time in Ticks
      \t      uint32_t value;
      \t
      \t      constexpr Seconds_Ticks() : value(0) {}
      \t
      \t      constexpr Ticks   toTicks()   const { return value; }
      \t
#if ($(/HARDWARE/useTypeSystemForTimers))
      \t      constexpr void fromTicks(Ticks ticks)       { value = ticks.getValue(); }
#else
      \t      constexpr void fromTicks(Ticks ticks)       { value = ticks; }
#endif
      \t   };
      \t\n
   ]]></template>

   <template namespace="usbdm"><![CDATA[
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--  Member variables -->

   <initialValueTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   CallbackFunction callback = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   CallbackFunction errorCallback = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_poen_en0"
   ><![CDATA[
      \t   /// Pulse-Out Enable register
      \t   uint8_t poen = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_po0_dly1"
   ><![CDATA[
      \t   /// Pulse-Out[Y] Delay 1 - rising edge
      \t   Seconds_Ticks dly1[$(NumPulseOutputs)];\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_po0_dly2"
   ><![CDATA[
      \t   /// Pulse-Out[Y] Delay 1 - falling edge
      \t   Seconds_Ticks dly2[$(NumPulseOutputs)];\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_intc0_triggerMode"
   ><![CDATA[
      \t   /// DAC Interval Trigger[X] Control Register
      \t   uint8_t intc[$(NumDacIntervalTriggers)] = {0};\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_int0"
   ><![CDATA[
      \t   /// DAC Interval[X] Interval Register
      \t   Seconds_Ticks interval[$(NumDacIntervalTriggers)];\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_sc_divider, pdb_sc_trgsel, pdb_sc_action, pdb_sc_pdbeie, pdb_sc_cont, pdb_sc_ldmod"
   ><![CDATA[
      \t   /// Status and Control register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <for keys="r" values="pdb_mod;pdb_idly">
      <initialValueTemplate namespace="usbdm"
         variables="%(r)"
      ><![CDATA[
         \t   /// %description
         \t   Seconds_Ticks %registerName;\n\n
      ]]></initialValueTemplate>
   </for>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_ch0_c1_pt0"
   ><![CDATA[
      \t   /// Channel[N] Pretrigger control
      \t   uint32_t c1[$(NumChannels)] = {0};\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"
      variables="pdb_ch0_dly0"
   ><![CDATA[
      \t   /// Channel[N] PretriggerDelay[M]
      \t   Seconds_Ticks dly[$(NumChannels)][$(NumPreTriggers)];\n\n
   ]]></initialValueTemplate>

<!--  Configure method -->

   <setTemplate variables="pdb_sc_divider" discardRepeats="true" key="/PDB/InitMethod" namespace="all" ><![CDATA[
      \t/**
      \t * Configure a PDB from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @return E_NO_ERROR
      \t */
      \tstatic ErrorCode configure(const typename Info::Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   // Initially assume working with Ticks
      \t   uint32_t scValue  = init.sc;
      \t   uint16_t modValue = init.mod.toTicks();
      \t\n
   ]]></setTemplate>
   <setTemplate variables="pdb_sc_divider" discardRepeats="true" key="/PDB/InitMethod" namespace="all"
        codeGenCondition="secondsSupport"
   ><![CDATA[
      \t   const bool useSeconds = ((init.sc&(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK)) == PdbPrescale_Auto_Select);
      \t
      \t   if (useSeconds) {
      \t      // Calculate new SC and modulo value
      \t      ErrorCode rc = calculateCounterParameters(init.mod.toSeconds(), scValue, modValue);
      \t      if (rc != E_NO_ERROR) {
      \t          return rc;
      \t      }
      \t      scValue |= (init.sc & ~(PDB_SC_MULT_MASK|PDB_SC_PRESCALER_MASK));
      \t   }
      \t
      \t   const auto convertIfNeeded = [useSeconds, scValue](const Seconds_Ticks &value) {
      \t      uint16_t temp = value.toTicks();
      \t      if (useSeconds) {
      \t         // This uses the SC value calculated for the modulo above
      \t         temp = convertSecondsToTicks(value.toSeconds(), scValue)-1;
      \t      }
      \t      return temp;
      \t   };
      \t\n
   ]]></setTemplate>
   <setTemplate variables="pdb_sc_divider" discardRepeats="true" key="/PDB/InitMethod" namespace="all"
        codeGenCondition="!secondsSupport"
   ><![CDATA[
      \t   const auto convertIfNeeded = [](const typename Info::Seconds_Ticks &value) {
      \t      return value.toTicks();
      \t   };
      \t\n
   ]]></setTemplate>
   <setTemplate variables="pdb_sc_divider" discardRepeats="true" key="/PDB/InitMethod" namespace="all" ><![CDATA[
      \t   pdb->MOD  = modValue;
      \t   pdb->IDLY = convertIfNeeded(init.idly);
      \t
      \t   // Configure pre-triggers (to ADCs usually)
      \t   for (size_t n=0; n<Info::numChannels; n++) {
      \t      pdb->CH[n].C1 = init.c1[n];
      \t      for (size_t m=0; m<Info::numPreTriggers; m++) {
      \t         pdb->CH[n].DLY[m] = convertIfNeeded(init.dly[n][m]);
      \t      }
      \t   }
      \t\n
   ]]></setTemplate>
   <setTemplate variables="pdb_intc0_triggerMode" discardRepeats="true" key="/PDB/InitMethod" namespace="all" ><![CDATA[
      \t   // Configure DAC triggers
      \t   for (size_t x=0; x<Pdb0Info::numDacIntervalTriggers; x++) {
      \t      pdb->DAC[x].INTC = init.intc[x];
      \t      pdb->DAC[x].INT  = convertIfNeeded(init.interval[x]);
      \t   }
      \t\n
   ]]></setTemplate>
   <setTemplate variables="pdb_sc_divider" discardRepeats="true" key="/PDB/InitMethod" namespace="all" ><![CDATA[
      \t   // Configure Pulse outputs (to CMPs)
      \t   pdb->POEN = init.poen;
      \t   for (size_t x=0; x<Info::numPulseOutputs; x++) {
      \t      pdb->POnDLY[x].DLY1 = convertIfNeeded(init.dly1[x]);
      \t      pdb->POnDLY[x].DLY2 = convertIfNeeded(init.dly2[x]);
      \t   }
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-backs if feature enabled
      \t      setCallback(init.callback);
      \t      setErrorCallback(init.errorCallback);
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t
      \t   // Final setting and enable load registers
      \t   pdb->SC = scValue|PDB_SC_LDOK_MASK;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set PDB to default configuration.
      \t *
      \t * Includes enabling clock and any pins used.\n
      \t * Sets PDB registers to default configuration from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t
      \t   configure(Info::DefaultInitValue);
      \t}\n\n
   ]]></setTemplate>

<!--   Constructors -->

   <for keys="r" values="
         pdb_sc_trgsel;
         pdb_sc_cont;
         pdb_sc_ldmod">
      <constructorTemplate namespace="usbdm"
         variables="%(r)"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName & ~%mask) | %paramExpression;
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"
      variables="pdb_sc_action, pdb_idly"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromTicks(%enumParam1);
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"  codeGenCondition="secondsSupport"
      variables="pdb_sc_action, pdb_idly_delay"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromSeconds(%enumParam1);
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"  codeGenCondition="irqHandlingMethod"
      variables="pdb_sc_action, pdb_idly, irqHandlingMethod"
      nonDefaultParams="3"
      defaultParamValue=",,nullptr"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromTicks(%enumParam1);
      \t      callback = %enumParam2;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"  codeGenCondition="secondsSupport &amp;&amp; irqHandlingMethod"
      variables="pdb_sc_action, pdb_idly_delay, irqHandlingMethod"
      nonDefaultParams="3"
      defaultParamValue=",,nullptr"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromSeconds(%enumParam1);
      \t      callback = %enumParam2;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"
      variables="pdb_sc_pdbeie"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"  codeGenCondition="irqHandlingMethod"
      variables="pdb_sc_pdbeie, irqHandlingMethod"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0 = (%registerName0 & ~%mask0) | %enumParam0;
      \t      errorCallback = %enumParam1;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"
      variables="pdb_sc_divider, pdb_mod"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description0 and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0        = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromTicks(%enumParam1);
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm"
      codeGenCondition="secondsSupport"
      variables="pdb_sc_auto_divider, pdb_mod_period"
      nonDefaultParams="2"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description0 and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0          = (%registerName0 & ~%mask0) | %enumParam0;
      \t      %registerName1.fromSeconds(%enumParam1);
      \t   }\n\n
   ]]></constructorTemplate>

   <!--  Pre-triggers -->
   <for keys="m" dim="NumPreTriggers">
      <constructorTemplate namespace="usbdm"
         variables="pdb_channel, pdb_ch0_c1_pt%(m), pdb_ch0_dly%(m)"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m) with delay
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%enumParam0] |= %enumParam1;
         \t      dly[%enumParam0][%(m)].fromTicks(%enumParam2);
         \t   }\n\n
      ]]></constructorTemplate>
      <constructorTemplate namespace="usbdm"
         codeGenCondition="secondsSupport"
         variables="pdb_channel, pdb_ch0_c1_pt%(m), pdb_ch0_dly%(m)_delay"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m) with delay
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%enumParam0] |= %enumParam1;
         \t      dly[%enumParam0][%(m)].fromSeconds(%enumParam2);
         \t   }\n\n
      ]]></constructorTemplate>
      <constructorTemplate namespace="usbdm"
         variables="pdb_channel, pdb_ch0_c1_pt%(m)"
         nonDefaultParams="3"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for Channel Pretrigger %(m)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      c1[%enumParam0] |= %enumParam1;
         \t      dly[%enumParam0][%(m)].fromTicks(0_ticks);
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <!--   DAC triggers -->
   <for keys="x" dim="NumDacIntervalTriggers">
      <constructorTemplate namespace="usbdm"
         variables="pdb_intc%(x)_triggerMode, pdb_int%(x)"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 with %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)] = %enumParam0;
         \t      interval[%(x)].fromTicks(%enumParam1);
         \t   }\n\n
      ]]></constructorTemplate>
      <constructorTemplate namespace="usbdm"
         codeGenCondition="secondsSupport"
         variables="pdb_intc%(x)_triggerMode, pdb_int%(x)_delay"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 with %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)]             = %enumParam0;
         \t      interval[%(x)].fromSeconds(%enumParam1);
         \t   }\n\n
      ]]></constructorTemplate>
      <constructorTemplate namespace="usbdm"
         variables="pdb_intc%(x)_triggerMode"
         nonDefaultParams="2"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      intc[%(x)] = %enumParam0;
         \t      interval[%(x)].fromTicks(0_ticks);
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <!--  Pulse outputs -->
   <for keys="y" dim="NumPulseOutputs">
      <constructorTemplate namespace="usbdm"
         variables="pdb_poen_en%(y), pdb_po%(y)_dly1, pdb_po%(y)_dly2"
         nonDefaultParams="3"
         params=", rising, falling"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 %(y) with
         \t    *         %description1,
         \t    *         %description2
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      poen          |= %enumParam0;
         \t      dly1[%(y)].fromTicks(%enumParam1);
         \t      dly2[%(y)].fromTicks(%enumParam2);
         \t   }\n\n
      ]]></constructorTemplate>
      <constructorTemplate namespace="usbdm"
         codeGenCondition="secondsSupport"
         variables="pdb_poen_en%(y), pdb_po%(y)_dly1_delay, pdb_po%(y)_dly2_delay"
         nonDefaultParams="3"
         params=", rising, falling"
         linePadding="xxx"
       ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 %(y) with
         \t    *         %description1,
         \t    *         %description2
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      poen            |= %enumParam0;
         \t      dly1[%(y)].fromSeconds(%enumParam1);
         \t      dly2[%(y)].fromSeconds(%enumParam2);
         \t   }\n\n
      ]]></constructorTemplate>
   </for>

   <template namespace="usbdm" ><![CDATA[
      \t};\n\n
   ]]></template>

   <template namespace="usbdm" ><![CDATA[
      };\n\n
   ]]></template>

<!--   Default Values -->

   <template><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * $(_class) interrupt call back
      \t */
      \ttypedef $(_class)BasicInfo::CallbackFunction CallbackFunction;
      \t\n
   ]]></template>

   <template codeGenCondition="!secondsSupport" ><![CDATA[
      \t
      \t/**
      \t * Shadow larger definition to save space when not using float
      \t */
      \ttypedef Pdb0BasicInfo::Init::Seconds_Ticks Seconds_Ticks;\n\n
   ]]></template>

   <initialValueTemplate variables="
         pdb_sc_trgsel,
         pdb_sc_cont,
         pdb_sc_ldmod,
         pdb_sc_divider, pdb_mod,
         irqLevel,
         pdb_sc_action, pdb_idly,
         pdb_sc_pdbeie"
      separator=","
      terminator=","
    ><![CDATA[
      \t/**
      \t * Default initialisation values for PDB
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {
       %initExpression
       \t
   ]]></initialValueTemplate>

   <for keys="n" dim="NumChannels">
      <for keys="m" dim="NumPreTriggers">
         <initialValueTemplate variables="pdb_ch%(n)_c1_pt%(m), pdb_ch%(n)_dly%(m)"
            separator=","
            terminator=","
          ><![CDATA[
               \t
               \t   // Pre-trigger %(n) configuration
               \t   PdbChannel_%(n), %initExpression
               \t
         ]]></initialValueTemplate>
      </for>
   </for>

   <for keys="x" dim="NumDacIntervalTriggers">
      <initialValueTemplate variables="pdb_intc%(x)_triggerMode, pdb_int%(x)"
         separator=","
         terminator=","
         initExpressionOnSameLine="true"
       ><![CDATA[
         \t
         \t   // DAC %(x) trigger configuration
         \t\t%initExpression
         \t
      ]]></initialValueTemplate>
   </for>

   <for keys="y" dim="NumPulseOutputs">
      <initialValueTemplate variables="pdb_poen_en%(y), pdb_po%(y)_dly1, pdb_po%(y)_dly2"
         separator=","
         terminator=","
         initExpressionOnSameLine="true"
       ><![CDATA[
         \t
         \t   // Pulse output %(y) (CMP%(y)) configuration
         \t\t%initExpression \n
      ]]></initialValueTemplate>
   </for>

   <template><![CDATA[
      \t};\n\n
   ]]></template>

<!--  ============== Templates ============== -->

   <template><![CDATA[
      \t// Number of PDB channels
      \tstatic constexpr size_t numChannels = $(NumChannels);
      \t
      \t// Number of PDB Triggers (to DACs)
      \tstatic constexpr size_t numDacIntervalTriggers = $(NumDacIntervalTriggers);
      \t
      \t// Number of PDB pulse outputs (to CMPs)
      \tstatic constexpr size_t numPulseOutputs = $(NumPulseOutputs);
      \t
      \t// Number of PDB pre-trigger outputs (to ADCs)
      \tstatic constexpr size_t numPreTriggers = $(NumPreTriggers);\n\n
      \t
      \t// Minimum resolution in ticks
      \tstatic constexpr Ticks MinimumResolution = $(Minimum_resolution)_ticks;\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t  * Get PDB clock frequency
      \t  *
      \t  * @return Frequency as a uint32_t in Hz
      \t  */
      \tstatic __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      \t   return SystemBusClock;
      \t}\n\n
   ]]></template>

   <template key="/PDB/declarations" namespace="all"  ><![CDATA[
      \t/**
      \t * Class representing $(_name)
      \t */
      \tclass $(_class) : public $(_base_class)Base_T<$(_class)Info> {};\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PdbValidate">
   </validate>

   <projectActionList id = "pdb_files">
      <copy source="Project_Headers/pdb.h"         target="Project_Headers/pdb.h"        overwrite="true"  derived="true" />
      <copy source="Snippets/pdb-adc-example.cpp"  target="Snippets/pdb-adc-example.cpp" overwrite="true"  derived="true" />
   </projectActionList>

   <signals/>
</fragment>

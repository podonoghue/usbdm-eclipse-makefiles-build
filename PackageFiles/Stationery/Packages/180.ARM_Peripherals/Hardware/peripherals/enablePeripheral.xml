<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- mapPinsOption.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A

   Template Rules based on attributes  info|usbdm|class|all)  "info"

   - namespace="info" (default if blank)
     Placed in Info class in pin_mapping.h

   - namespace="usbdm"
     Placed before Info class in pin_mapping.h i.e. in USBDM namespace

   - key="keyValue"
     Substituted anywhere for $(keyValue)
 -->

<!-- GENERAL SETTINGS -->

   <constant key="_debugcode" type="Boolean" value="false" />

   <title description="General Settings" toolTip="" />

   <!--
      Generates:
         enablePeripheralSupport
         /$(_STRUCTNAME)/generateSharedInfo    = OR of enablePeripheralSupport's' using _STRUCTNAME
         /$(_BASENAME)/enablePeripheralSupport = OR of all enablePeripheralSupport's'
   -->

   <!-- Enable for this peripheral -->
   <binaryOption key="enablePeripheralSupport" condition="!enablePeripheralSupport"
      hidden="true"
      description="Enable peripheral support"
      toolTip="Even if disabled, some code may still be generated but will \n
               be removed by linker if not used">
      <choice value="false" name="Minimal code for $(_NAME)"  />
      <choice value="true"  name="Generate code for $(_NAME)" isDefault="=generateDefault" />
   </binaryOption>

   <!-- If not already generated -->
   <if condition="!/$(_STRUCTNAME)/generateSharedInfo">

      <!-- Construct equation to check if any instance sharing the same struct is enabled -->
      <equation key="_enable" value="=&quot;false&quot;" />
      <for keys="instance" values="=_instanceList" >
         <equation
            key="_enable"
            condition="=&quot;$(_STRUCTNAME)&quot;==/%(instance)/structName"
            value="=_enable+&quot;||/&quot;+&quot;%(instance)&quot;+&quot;/enablePeripheralSupport&quot;"
         />
      </for>
      <!-- stringOption key="yyy" value="=_enable"/ -->

      <!-- Enable for shared code needed by all instances of peripheral -->
      <binaryOption key="/$(_STRUCTNAME)/generateSharedInfo"
         ref="=_enable"
         description="=_enable"
         hidden="true"
         locked="true"
         derived="true">
         <choice value="false" name="Minimal shared code for structName=$(_STRUCTNAME)"  />
         <choice value="true"  name="All shared code for structName=$(_STRUCTNAME)"      />
      </binaryOption>
      <deleteVariables variables="_enable" />
   </if>

   <!-- If not already generated -->
   <if condition="!/$(_BASENAME)/enablePeripheralSupport">

      <!-- Construct equation to check if any instance sharing the same struct is enabled -->
      <equation key="_enable" value="=&quot;false&quot;" />
      <for keys="instance" values="=_instanceList" >
         <equation
            key="_enable"
            value="=_enable+&quot;||/&quot;+&quot;%(instance)&quot;+&quot;/enablePeripheralSupport&quot;"
         />
      </for>
      <!-- stringOption key="yyy" value="=_enable"/ -->

      <!-- Enable for shared code needed by all instances of peripheral -->
      <binaryOption key="/$(_BASENAME)/enablePeripheralSupport"
         ref="=_enable"
         description="=_enable"
         hidden="true"
         locked="true"
         derived="true">
         <choice value="false" name="Minimal shared code for basename=$(_BASENAME)"  />
         <choice value="true"  name="All shared code for basename=$(_BASENAME)"      />
      </binaryOption>
      <deleteVariables variables="_enable" />
   </if>

   <aliasOption key="enablePeripheralSupport" locked="false" />
   <aliasOption name="/$(_BASENAME)/enablePeripheralSupport" key="/$(_BASENAME)/enablePeripheralSupport" optional="true"  condition="=_debugcode" />
   <aliasOption name="/$(_STRUCTNAME)/generateSharedInfo"    key="/$(_STRUCTNAME)/generateSharedInfo"    optional="true"  condition="=_debugcode" />

   <!-- =======================================================================================================================  -->


   <!-- Enable for generation of getters and setters -->
   <binaryOption key="enableGettersAndSetters" condition="!enableGettersAndSetters"
      enabledBy="enablePeripheralSupport"
      description="Enable Getters and Setters"
      toolTip="Even if disabled, some code may still be generated">
      <choice value="false" name="Minimal Get and Set methods"        isDefault="true" />
      <choice value="true"  name="All Get and Set methods"  />
   </binaryOption>

    <!-- Configure peripheral instance in startup -->
   <binaryOption key="configurePeripheralInStartUp" condition="!configurePeripheralInStartUp&amp;&amp;configureInStartupDefault"
      enabledBy="enablePeripheralSupport"
      description="Configure this peripheral"
      toolTip="Configure this peripheral in startup code before main() is entered\n
               Even if disabled, some minimal code may still be executed" >
      <choice value="false" name="Not Configured"              />
      <choice value="true"  name="Configured in startup code"  isDefault="=configureInStartupDefault" />
   </binaryOption>

   <!-- Pin mapping and enables -->

   <if condition="/PCR/mux_present&amp;&amp;_hasPcrTable">

      <binaryOption key="mapPinsOnEnable"
         enabledBy="enablePeripheralSupport"
         description="Map pins when configured"
         toolTip="Map all allocated pins on a peripheral when the\n
                  peripheral is enabled by configure() method etc">
         <choice value="false" name="Don't map pins"  />
         <choice value="true"  name="Map pins when configured"  isDefault="true"/>
      </binaryOption>

      <template><![CDATA[
         \t//! Map all allocated pins on a peripheral when enabled
         \tstatic constexpr bool mapPinsOnEnable = $(mapPinsOnEnable);\n\n
         \t
         \t/**
         \t * Configures all mapped pins associated with $(_BASENAME)
         \t *
         \t * @note Locked pins will be unaffected
         \t */
         \tstatic void configureAllPins() {
         \t
         \t   // Configure pins if selected and not already locked
         \t   if constexpr (mapPinsOnEnable) {
         \t      initPCRs();
         \t   }
         \t}
         \t
         \t/**
         \t * Disabled all mapped pins associated with $(_BASENAME)
         \t *
         \t * @note Only the lower 16-bits of the PCR registers are modified
         \t *
         \t * @note Locked pins will be unaffected
         \t */
         \tstatic void disableAllPins() {
         \t
         \t   // Disable pins if selected and not already locked
         \t   if constexpr (mapPinsOnEnable) {
         \t      clearPCRs();
         \t   }
         \t}
         \t\n
      ]]></template>
   </if>

<!-- ================== INTERRUPTS ==================== -->

   <!-- Only create if device has interrupts -->
   <if condition="_irqCount" >

      <title description="Interrupts" />

      <!--
      Patterns for pattern and classHandler
        -  %i replaced with peripheral instance e.g. FTM1 => 1, PTA => A          Use $(_instance) instead
        -  %b replaced with peripheral base name e.g. FTM1 => FTM                 Use $(_BASENAME) instead
        -  %c replaced with peripheral C++ base class name e.g. FTM1 => Ftm       Use $(_Baseclass) instead
        -  _IRQHandler is appended to the pattern (only)
      Multiple patterns and classsHandlers may be used separated by ';'
      -->

      <!--
         Generates:
            irqHandlingMethod
            /$(_STRUCTNAME)/generateSharedIrqInfo = OR of irqHandlingMethod' using _STRUCTNAME
            /$(_BASENAME)/irqHandlingMethod       = OR of all irqHandlingMethod'
      -->

      <!-- If not explicitly controlled, IRQ options are always enabled -->
      <constant key="irqEnable"        type="Boolean" value="true"  condition="!irqEnable"/>

      <!-- Default IRQ vector patterns if none specified -->
      <constant key="irq_pattern"      type="String"  value="&quot;^$(_NAME)$&quot;" condition="!irq_pattern" />
      <constant key="irq_ClassHandler" type="String"  value="&quot;$(_Class)::irqHandler&quot;" condition="!irq_ClassHandler" />

      <!-- Create only if needed -->
      <if condition="!irqHandlingMethod">

         <!-- Interrupt control for this peripheral -->
         <irqOption key="irqHandlingMethod"
            hidden="true"
            valueFormat="%s"
            enabledBy="enablePeripheralSupport&amp;&amp;irqEnable"
            typeName="CallbackFunction"
            description="Peripheral interrupt handling"
            toolTip="If enabled, the handler may be set using the setCallback() function or\n
                     by overriding the interrupt handler method in the peripheral class\n
                     If not enabled, then interrupt handlers may be installed by naming them \n
                     (see weak names used in vector table)."
            pattern="=irq_pattern"
            classHandler="=irq_ClassHandler" />

         <!-- If not already generated -->
         <if condition="!/$(_STRUCTNAME)/generateSharedIrqInfo">

            <!-- Construct equation to check if interrupts are enabled on any instance sharing the same struct -->
            <equation key="_enable" value="=&quot;false&quot;" />
            <for keys="instance" values="=_instanceList" >
               <if condition="/%(instance)/_irqCount" >
                  <equation
                     key="_enable"
                     condition="=&quot;$(_STRUCTNAME)&quot;==/%(instance)/structName"
                     value="=_enable+&quot;||/&quot;+&quot;%(instance)&quot;+&quot;/irqHandlingMethod&quot;"
                  />
               </if>
            </for>
            <!--  printVar key="_enable"/ -->

            <!-- Enable for shared code needed by all instances of peripheral -->
            <binaryOption key="/$(_STRUCTNAME)/generateSharedIrqInfo" name="/$(_STRUCTNAME)/generateSharedIrqInfo"
               ref="=_enable"
               description="=_enable"
               hidden="true"
               locked="true"
               derived="true">
               <choice value="false" name="No shared interrupt code for $(_STRUCTNAME)"  />
               <choice value="true"  name="Shared interrupt code for $(_STRUCTNAME)"      />
            </binaryOption>
            <deleteVariables variables="_enable" />
         </if>

         <!-- If not already generated -->
         <if condition="!/$(_BASENAME)/irqHandlingMethod">

            <!-- Construct equation to check if interrupts are enabled on any instance -->
            <equation key="_enable" value="=&quot;false&quot;" />
            <for keys="instance" values="=_instanceList" >
               <if condition="/%(instance)/_irqCount" >
                  <equation
                     key="_enable"
                     value="=_enable+&quot;||/&quot;+&quot;%(instance)&quot;+&quot;/irqHandlingMethod&quot;"
                  />
               </if>
            </for>
            <!-- stringOption key="yyy" value="=_enable"/ -->

            <!-- Enable for shared code needed by all instances of peripheral -->
            <binaryOption key="/$(_BASENAME)/irqHandlingMethod"  name="/$(_BASENAME)/irqHandlingMethod"
               ref="=_enable"
               description="=_enable"
               hidden="true"
               locked="true"
               derived="true">
               <choice value="false" name="No shared interrupt code for $(_BASENAME)"  />
               <choice value="true"  name="Shared interrupt code for $(_BASENAME)"      />
            </binaryOption>
            <deleteVariables variables="_enable" />
         </if>

      </if>

      <!-- Display here -->
      <aliasOption key="irqHandlingMethod" locked="false" optional="true"  />

      <aliasOption key="/$(_STRUCTNAME)/generateSharedIrqInfo" optional="true"  condition="=_debugcode" />
      <aliasOption key="/$(_BASENAME)/irqHandlingMethod"       optional="true"  condition="=_debugcode"/>

      <!-- Create only if needed -->
      <choiceOption key="irqLevel" condition="!irqLevel"
         hidden="true"
         modify="true"
         enabledBy="irqHandlingMethod"
         description="IRQ level for this peripheral"
         toolTip="Priority level used to configure the NVIC"
         valueFormat="%s"
         disabledValue="Not Installed"
         derivedFrom="/PCR/nvic_irqLevel" >
      </choiceOption>

      <!-- Display here (wherever the original) -->
      <aliasOption key="irqLevel" locked="false" />

      <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="irqHandlingMethod"
      ><![CDATA[
          \t//! Class based callback handler has been installed in vector table for this instance
          \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
          \t\n
      ]]></variableTemplate>

      <variableTemplate condition="!suppressIrqArray"  codeGenCondition="irqHandlingMethod"
         variables="/$(_BASENAME)/irqHandlingMethod,irqLevel"
      ><![CDATA[
         \t//! IRQ numbers for hardware
         \tstatic constexpr IRQn_Type irqNums[]  = $(_NAME)_IRQS;
         \t
         \t//! Number of IRQs for hardware
         \tstatic constexpr uint32_t irqCount  = sizeofArray(irqNums);
         \t\n
      ]]></variableTemplate>

      <variableTemplate variables="irqLevel"   codeGenCondition="irqHandlingMethod"
      ><![CDATA[
         \t//! Default IRQ level
         \tstatic constexpr NvicPriority irqLevel =  %symbolicExpression;
         \t\n
      ]]></variableTemplate>

      <choiceOption key="irq_enum" condition="(@_irqCount>1)&amp;&amp;!irq_enum"
         hidden="true"
         description="IRQ entry"
         toolTip="Select amongst interrupts associated with the peripheral"
         typeName="$(_Class)IrqNum"
         valueFormat="%s"
         >
         <choiceExpansion keys="irq" dim="=_irqCount" value="%(irq)" name="Irq%(irq)" enum="%(irq)" />
      </choiceOption>

      <if condition="(@_irqCount>1)" >
         <variableTemplate condition="irqHandlingMethod&amp;&amp;!suppressIrqArray" codeGenCondition="irqHandlingMethod"
            variables="irq_enum"
         ><![CDATA[
            \t/**
            \t * Enable interrupts in NVIC
            %paramDescription
            \t */
            \tstatic void enableNvicInterrupts(%params) {
            \t   NVIC_EnableIRQ(irqNums[%paramName0]);
            \t}
            \t
            \t/**
            \t * Enable and set priority of interrupts in NVIC
            \t * Any pending NVIC interrupts are first cleared.
            \t *
            \t * @param[in]  nvicPriority  Interrupt priority
            %paramDescription
            \t */
            \tstatic void enableNvicInterrupts(%params, NvicPriority nvicPriority) {
            \t   enableNvicInterrupt(irqNums[%paramName0], nvicPriority);
            \t}
            \t
            \t/**
            \t * Disable interrupts in NVIC
            %paramDescription
            \t */
            \tstatic void disableNvicInterrupts(%params) {
            \t   NVIC_DisableIRQ(irqNums[%paramName0]);
            \t}
            \t\n
         ]]></variableTemplate>
      <else />
         <template condition="irqHandlingMethod&amp;&amp;!suppressIrqArray" codeGenCondition="irqHandlingMethod" ><![CDATA[
            \t/**
            \t * Enable interrupts in NVIC
            \t */
            \tstatic void enableNvicInterrupts() {
            \t   NVIC_EnableIRQ(irqNums[0]);
            \t}
            \t
            \t/**
            \t * Enable and set priority of interrupts in NVIC
            \t * Any pending NVIC interrupts are first cleared.
            \t *
            \t * @param[in]  nvicPriority  Interrupt priority
            \t */
            \tstatic void enableNvicInterrupts(NvicPriority nvicPriority) {
            \t   enableNvicInterrupt(irqNums[0], nvicPriority);
            \t}
            \t
            \t/**
            \t * Disable interrupts in NVIC
            \t */
            \tstatic void disableNvicInterrupts() {
            \t   NVIC_DisableIRQ(irqNums[0]);
            \t}
            \t\n
         ]]></template>
      </if>
   </if> <!-- condition="_irqCount" -->

   <constant key="_clockInfo"  value="=/$(_BASENAME)/_clockMask"   type="String"  condition="/$(_BASENAME)/_clockMask"           />
   <constant key="_clockInfo"  value="=_clockMask"                 type="String"  condition="_clockMask&amp;&amp;!_clockInfo[]"  />
   <constant key="_scgc_clock" value="&quot;/SIM/&quot;+ToLowerCase(&quot;sim_&quot;+@_clockInfo[0]+&quot;_&quot;+@_clockInfo[1])"
             type="String" condition="_clockInfo[]" />

   <template condition="_clockInfo[]" codeGenCondition="enablePeripheralSupport"
      immediateVariables="_clockInfo[0],_clockInfo[1]"
   ><![CDATA[
      \t/**
      \t *  Enable clock to $(_Class)
      \t */
      \tstatic void enableClock() {
      \t   SIM->$(_clockInfo[0]) = SIM->$(_clockInfo[0]) | SIM_$(_clockInfo[0])_$(_clockInfo[1])_MASK;
      \t}
      \t
      \t/**
      \t *  Disable clock to $(_Class)
      \t */
      \tstatic void disableClock() {
      \t   SIM->$(_clockInfo[0]) = SIM->$(_clockInfo[0]) & ~SIM_$(_clockInfo[0])_$(_clockInfo[1])_MASK;
      \t}
      \t\n
   ]]></template>

   <!-- ************* SIM configuration ****************** -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Basic enable of $(_Class)
      \t * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
      \t */
      \tstatic void enable() {\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="_clockInfo[]" ><![CDATA[
      \t   enableClock();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="/PCR/mux_present&amp;&amp;_hasPcrTable" ><![CDATA[
      \t   configureAllPins();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t
      \t/**
      \t * Disables the clock to $(_Class) and all mapped pins
      \t */
      \tstatic void disable() {
      \t   $(disable_peripheral: )\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="_irqCount&amp;&amp;!suppressIrqArray" ><![CDATA[
      \t   NVIC_DisableIRQ(irqNums[0]);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="/PCR/mux_present&amp;&amp;_hasPcrTable" ><![CDATA[
      \t   disableAllPins();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="_clockInfo[]" ><![CDATA[
      \t   disableClock();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t\n
   ]]></template>

   <deleteVariables variables="_clockInfo[0],_clockInfo[1]" mustExist="false" />

   <!-- template key="/$(_BASENAME)/publicMethods" condition="/$(_BASENAME)/irqHandlingMethod" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" discardRepeats="true" >
   <![CDATA[
      \t/**
      \t * Wrapper to allow the use of a class member as a callback function
      \t * @note Only usable with static objects.
      \t *
      \t * @tparam T         Type of the object containing the callback member function
      \t * @tparam callback  Member function pointer
      \t * @tparam object    Object containing the member function
      \t *
      \t * @return  Pointer to a function suitable for the use as a callback
      \t *
      \t * @code
      \t * class $(_Baseclass)CallbackClass {
      \t * public:
      \t *    int y;
      \t *
      \t *    // Member function used as callback
      \t *    // This function must match $(_Baseclass)::CallbackFunction
      \t *    void callback($(irq_parameters)) {
      \t *       ...;
      \t *    }
      \t * };
      \t * ...
      \t * // Instance of class containing callback member function
      \t * static $(_Baseclass)CallbackClass $(_Baseclass)CallbackClassInstance;
      \t * ...
      \t * // Wrap member function
      \t * auto $(_Baseclass)cbfn = $(_Baseclass)::wrapCallback<$(_Baseclass)CallbackClass, &$(_Baseclass)CallbackClass::callback, $(_Baseclass)CallbackClassInstance>();
      \t *
      \t * // Use as callback
      \t * $(_Baseclass)::Channel<0>::setCallback($(_Baseclass)cbfn);
      \t * @endcode
      \t */
      \ttemplate<class T, void(T::*callback)($(irq_parameters)), T &object>
      \tstatic CallbackFunction wrapCallback() {
      \t   static CallbackFunction fn = []($(irq_parameters)) {
      \t      (object.*callback)($(irq_call));
      \t   };
      \t   return fn;
      \t}
      \t
      \t/**
      \t * Wrapper to allow the use of a class member as a callback function
      \t * @note There is a considerable space and time overhead to using this method
      \t *
      \t * @tparam T         Type of the object containing the callback member function
      \t * @tparam callback  Member function pointer
      \t * @tparam object    Object containing the member function
      \t *
      \t * @return  Pointer to a function suitable for the use as a callback
      \t *
      \t * @code
      \t * class $(_Baseclass)CallbackClass {
      \t * public:
      \t *    int y;
      \t *
      \t *    // Member function used as callback
      \t *    // This function must match $(_Baseclass)::CallbackFunction
      \t *    void callback($(irq_parameters)) {
      \t *       ...;
      \t *    }
      \t * };
      \t * ...
      \t * // Instance of class containing callback member function
      \t * $(_Baseclass)CallbackClass $(_Baseclass)CallbackClassInstance;
      \t * ...
      \t * // Wrap member function
      \t * auto $(_Baseclass)cbfn = $(_Baseclass)::wrapCallback<$(_Baseclass)CallbackClass, &$(_Baseclass)CallbackClass::callback>($(_Baseclass)CallbackClassInstance);
      \t *
      \t * // Use as callback
      \t * $(_Baseclass)::Channel<0>::setCallback($(_Baseclass)cbfn);
      \t * @endcode
      \t */
      \ttemplate<class T, void(T::*callback)($(irq_parameters))>
      \tstatic CallbackFunction wrapCallback(T &object) {
      \t   static T &obj = object;
      \t   static CallbackFunction fn = []($(irq_parameters)) {
      \t      (obj.*callback)($(irq_call));
      \t   };
      \t   return fn;
      \t}
      \t\n
   ]]>
   </template -->

   <template><![CDATA[
      \t//! Hardware base address as uint32_t
      \tstatic constexpr uint32_t baseAddress = $(_NAME)_BasePtr;
      \t
      \t//! Hardware base pointer
      \tstatic constexpr HardwarePtr<$(structName)_Type> $(_basename) = baseAddress;
      \t\n
   ]]></template>

   <!-- Don't generate instance if suppressed or empty -->
   <template condition="!suppressInstance&amp;&amp;&quot;$(_instance)&quot;!=&quot;&quot;" ><![CDATA[
      \t//! Peripheral instance number
      \tstatic constexpr unsigned instance = $(_instance);
      \t\n
   ]]></template>

   <constant key="class_present" type="Boolean"  value = "true"   />

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport&amp;&amp;/HARDWARE/generateDebugDefinitions" ><![CDATA[
      \t//! Indicates $(_NAME) is available
      \t#define USBDM_$(_NAME)_AVAILABLE
      \t\n
   ]]></template>

   <!-- ************* Base pin mapping ****************** -->
   <binaryOption key="$(_name)_pin_map" condition="pinMap"
      description="$(_NAME) Pin mapping"
      toolTip="Pin mapping used when $(_NAME) enabled"
      disabledPinMap="#enablePeripheralSupport"
      locked="true"
      derived="true" >
      <choice name="Pin mapping" value="0" pinMap="=pinMap" />
   </binaryOption>

</fragment>

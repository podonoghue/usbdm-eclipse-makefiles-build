<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- enablePeripheral.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

<!--====================================================================================================== -->
<!-- GENERAL SETTINGS -->
<!-- Generates: -->
<!--  $(_InfoGuard)       = enablePeripheralSupport           = Per instance - peripheral enabled -->
<!--  $(_BasicInfoGuard)  = /STRUCTNAME/generateSharedInfo    = OR of enablePeripheralSupport for instances using same STRUCTNAME -->
<!--  $(_CommonInfoGuard) = /BASENAME/enablePeripheralSupport = OR of enablePeripheralSupport for all instances of peripheral -->
<!--====================================================================================================== -->

   <!--  Debug defaults to off -->
   <equation key="_debugcode" value="false" condition="!_debugcode" />

   <title description="General Settings" toolTip="" />

   <!-- _________ Peripheral support _________________  -->


   <!-- Enable for this peripheral -->
   <binaryOption key="enablePeripheralSupport" condition="!enablePeripheralSupport"
      hidden="true"
      description="Enable peripheral support"
      toolTip="Even if disabled, some code may still be generated but will \n
               be removed by linker if not used" >
      <choice value="false" name="Minimal code for $(_NAME)"  />
      <choice value="true"  name="Generate code for $(_NAME)" isDefault="=generateDefault" />
   </binaryOption>

   <!-- printVar key="$(_BasicInfoGuard)" condition="$(_BasicInfoGuard)" / -->

   <if condition="!$(_BasicInfoGuard)" >  <!-- Only generate once -->

      <equation key="_enable" value='="false"' />
      <for keys="instance" values="=_instanceList" >

      <!-- Construct $(_BasicInfoGuard) equation to check if any instance sharing the same struct is enabled -->
         <equation
            key="_enable"
            condition='="$(_STRUCTNAME)"==/%(instance)/structName'
            value='=_enable+"||/%(instance)/enablePeripheralSupport"'
         />
      </for>

      <!-- Enable for shared code needed by all instances of peripheral -->
      <binaryOption key="$(_BasicInfoGuard)"
         ref="=_enable"
         description="=_enable"
         hidden="true"
         locked="true"
         derived="true" >
         <choice value="false" name="Minimal shared code for structName=$(_STRUCTNAME)"  />
         <choice value="true"  name="All shared code for structName=$(_STRUCTNAME)"      />
      </binaryOption>
   </if>

   <if condition="!$(_CommonInfoGuard)" > <!-- Only generate once -->
      <!-- Construct $(_BasicInfoGuard) equation to check if any instance sharing the same struct is enabled -->

      <!-- Construct equation to check if any instance of the same peripheral type is enabled -->
      <equation key="_enable" value='="false"' />
      <for keys="instance" values="=_instanceList" >
         <equation
            key="_enable"
            value='=_enable+"||/%(instance)/enablePeripheralSupport"'
         />
      </for>
      <!-- stringOption key="yyy" value="=_enable"/ -->

      <!-- Enable for shared code needed by all instances of peripheral -->
      <binaryOption key="$(_CommonInfoGuard)"
         ref="=_enable"
         description="=_enable"
         hidden="true"
         locked="true"
         derived="true" >
         <choice value="false" name="Minimal shared code for basename=$(_BASENAME)"  />
         <choice value="true"  name="All shared code for basename=$(_BASENAME)"      />
      </binaryOption>
   </if>

   <aliasOption key="enablePeripheralSupport" locked="false" />
   <aliasOption name='"$(_BasicInfoGuard)"'  key="$(_BasicInfoGuard)"  optional="true"  condition="=_debugcode" />
   <aliasOption name='"$(_CommonInfoGuard)"' key="$(_CommonInfoGuard)" optional="true"  condition="=_debugcode" />

   <!-- _______ Getters and Setters __________  -->

   <!-- Enable for generation of getters and setters -->
   <binaryOption key="enableGettersAndSetters" condition="!enableGettersAndSetters"
      enabledBy="enablePeripheralSupport"
      description="Enable Getters and Setters"
      toolTip="Even if disabled, some code may still be generated" >
      <choice value="false" name="Minimal Get and Set methods"        isDefault="true" />
      <choice value="true"  name="All Get and Set methods"  />
   </binaryOption>

    <!-- Configure peripheral instance in startup -->
   <binaryOption key="configurePeripheralInStartUp" condition="!configurePeripheralInStartUp&amp;&amp;configureInStartupDefault"
      enabledBy="enablePeripheralSupport"
      description="Configure this peripheral"
      toolTip="Configure this peripheral in startup code before main() is entered\n
               Even if disabled, some minimal code may still be executed"
      disabledValue="false" >
      <choice value="false" name="Not Configured"              />
      <choice value="true"  name="Configured in startup code"  isDefault="=configureInStartupDefault" />
   </binaryOption>

   <!-- Pin mapping and enables -->

   <if condition="/PCR/mux_present&amp;&amp;_hasPcrTable" >

      <binaryOption key="mapPinsOnEnable"
         enabledBy="enablePeripheralSupport"
         description="Map pins when configured"
         toolTip="Map all allocated pins on a peripheral when the\n
                  peripheral is enabled by configure() method etc"
         disabledValue="false" >
         <choice value="false" name="Don't map pins"  />
         <choice value="true"  name="Map pins when configured"  isDefault="true"/>
      </binaryOption>

      <template><![CDATA[
         \t//! Map all allocated pins on a peripheral when enabled
         \tstatic constexpr bool mapPinsOnEnable = $(mapPinsOnEnable);\n\n
         \t
         \t/**
         \t * Configures all mapped pins associated with $(_NAME)
         \t *
         \t * @note Locked pins will be unaffected
         \t */
         \tstatic void configureAllPins() {
         \t
         \t   // Configure pins if selected and not already locked
         \t   if constexpr (mapPinsOnEnable) {
         \t      initPCRs();
         \t   }
         \t}
         \t
         \t/**
         \t * Disabled all mapped pins associated with $(_NAME)
         \t *
         \t * @note Only the lower 16-bits of the PCR registers are modified
         \t *
         \t * @note Locked pins will be unaffected
         \t */
         \tstatic void disableAllPins() {
         \t
         \t   // Disable pins if selected and not already locked
         \t   if constexpr (mapPinsOnEnable) {
         \t      clearPCRs();
         \t   }
         \t}
         \t\n
      ]]></template>
   </if>

<!--====================================================================================================== -->
<!--  INTERRUPTS -->
<!--====================================================================================================== -->

   <!-- Only create if device has interrupts -->
   <if condition="_hardwareIrqCount" >

      <!--
      Patterns for pattern and classHandler
        -  %i replaced with peripheral instance e.g. FTM1 => 1, PTA => A          Use $(_instance) instead
        -  %b replaced with peripheral base name e.g. FTM1 => FTM                 Use $(_BASENAME) instead
        -  %c replaced with peripheral C++ base class name e.g. FTM1 => Ftm       Use $(_Baseclass) instead
        -  _IRQHandler is appended to the pattern (only)
      Multiple patterns and classsHandlers may be used separated by ';'
      -->

      <!--
         Generates:
            irqHandlingMethod       = Interrupts enabled for this instance
            $(_BasicInfoIrqGuard)   = OR of irqHandlingMethod using same _STRUCTNAME
            $(_CommonInfoIrqGuard)  = OR of all irqHandlingMethod
      -->
      <title description="Interrupts" />

      <!-- These control the IRQ number available to used (which may differ from actual hardware) -->
      <equation key="_userIrqCount" value="=_hardwareIrqCount" condition="!_userIrqCount" />
      <equation key="_userIrqNums"  value="=_hardwareIrqNums"  condition="!_userIrqNums" />

      <!-- If not explicitly controlled, IRQ options are always enabled -->
      <constant key="irqEnable"        type="Boolean" value="true"  condition="!irqEnable"/>

      <if condition='!irq_pattern' >
         <if condition='=(_hardwareIrqCount==1)' >
            <equation key="irq_pattern"       value='=ReplaceAll(_hardwareIrqNums, "^(.*)_IRQn$", "$1")'      />
            <equation key="irq_ClassHandler"  value='=ReplaceAll(_hardwareIrqNums, "^(.*)_IRQn$", "$(_Class)::irqHandler")'  />
         <else/>
            <for keys="irqName" values="=_hardwareIrqNums" delimiter=";" >
               <equation key="irq_p" value='=ReplaceAll("%(irqName)", "^(.*)_IRQn$", "$1")'  />
               <if condition="!irq_pattern" >
                  <equation key="irq_pattern"  value='=irq_p'                 />
               <else/>
                  <equation key="irq_pattern"  value='=irq_pattern+";"+irq_p' />
               </if>

               <equation key="irq_c" value='=ReplaceAll("%(irqName)", "^(.*?)_(.*)_IRQn$", "$(_Class)::irqHandler&lt;$(_Class)::IrqNum_$2&gt;")' />
               <if condition="!irq_ClassHandler" >
                  <equation key="irq_ClassHandler"  value='=irq_c'                  />
               <else/>
                  <equation key="irq_ClassHandler"  value='=irq_ClassHandler+";"+irq_c' />
               </if>
            </for>
         </if>
      </if>
      <!--
      <printVar key="irq_pattern"/>
      <printVar key="irq_ClassHandler"/>
      <printVar key="_hardwareIrqCount"/>
      <printVar key="_hardwareIrqNums"/>
      <printVar key="_userIrqNums"/>
      <printVar key="_userIrqCount"/>
       -->


      <!-- Interrupt control for this peripheral -->
      <irqOption key="irqHandlingMethod" condition="!irqHandlingMethod"
         hidden="true"
         valueFormat="%s"
         enabledBy="enablePeripheralSupport&amp;&amp;irqEnable"
         typeName="CallbackFunction"
         description="Peripheral interrupt handling"
         toolTip="If enabled, the handler may be set using the setCallback() function or\n
                  by overriding the interrupt handler method in the peripheral class\n
                  If not enabled, then interrupt handlers may be installed by naming them \n
                  (see weak names used in vector table)."
         pattern="=irq_pattern"
         classHandler="=irq_ClassHandler" />

      <if condition="!$(_BasicInfoIrqGuard)" >

         <!-- Construct equation to check if interrupts are enabled on any instance sharing the same struct -->
         <equation key="_enable" value='="false"' />
         <for keys="instance" values="=_instanceList" >
            <if condition="/%(instance)/_hardwareIrqCount" >
               <equation
                  key="_enable"
                  condition='="$(_STRUCTNAME)"==/%(instance)/structName'
                  value='=_enable+"||/%(instance)/irqHandlingMethod"'
               />
            </if>
         </for>
         <!-- printVar key="_enable"/ -->

         <!-- Enable for shared code needed by all instances of peripheral using same _STRUCTNAME -->
         <binaryOption key="$(_BasicInfoIrqGuard)" name="$(_BasicInfoIrqGuard)"
            ref="=_enable"
            description="=_enable"
            hidden="true"
            locked="true"
            derived="true" >
            <choice value="false" name="No shared interrupt code for structName=$(_STRUCTNAME)"  />
            <choice value="true"  name="Shared interrupt code for structName=$(_STRUCTNAME)"     />
         </binaryOption>
      </if>

      <if condition="!$(_CommonInfoIrqGuard)" >

         <!-- Construct equation to check if interrupts are enabled on any instance -->
         <equation key="_enable" value='="false"' />
         <for keys="instance" values="=_instanceList" >
            <if condition="/%(instance)/_hardwareIrqCount" >
               <equation
                  key="_enable"
                  value='=_enable+"||/%(instance)/irqHandlingMethod"'
               />
            </if>
         </for>
         <!-- stringOption key="yyy" value="=_enable"/ -->

         <!-- Enable for shared code needed by all instances of peripheral -->
         <binaryOption key="$(_CommonInfoIrqGuard)"  name="$(_CommonInfoIrqGuard)"
            ref="=_enable"
            description="=_enable"
            hidden="true"
            locked="true"
            derived="true" >
            <choice value="false" name="No shared interrupt code for basename=$(_BASENAME)"  />
            <choice value="true"  name="Shared interrupt code for basename=$(_BASENAME)"     />
         </binaryOption>
      </if>

      <!-- Display here -->
      <aliasOption key="irqHandlingMethod" locked="false" optional="true"  />
      <aliasOption name='"$(_BasicInfoIrqGuard)"'  key="$(_BasicInfoIrqGuard)"  optional="true"  condition="=_debugcode" />
      <aliasOption name='"$(_CommonInfoIrqGuard)"' key="$(_CommonInfoIrqGuard)" optional="true"  condition="=_debugcode" />

   </if>

   <if condition="_hardwareIrqCount&amp;&amp;!suppressIrqArray" >

      <!-- Create only if needed -->

      <for keys="irqNum" values="=_hardwareIrqNums" iterationVar="ch" >
         <if condition='=(_hardwareIrqCount>1)' >

            <!-- Extract IRQ 'name' RTC_Alarm_IRQn => Alarm, Ch0 etc  -->
            <immediateValue keys="irqmodifier" values='=ReplaceAll("%(irqNum)","^(.+)_(.+)_IRQn$","$2")'>
               <clipboard key='irqHandlerTemplate_%(irqmodifier)' condition='!irqHandlerTemplate_%(irqmodifier)'
                  hiddenBy="irqHandlingMethod||!enablePeripheralSupport"
                  description='Interrupt handler template for %(irqmodifier)'
                  toolTip='Interrupt handler example' >
                  <![CDATA[="
                     \t/**
                     \t * Handler for $(_NAME) %(irqmodifier) interrupt (Multiple entries)
                     \t */
                     \tvoid "+"$(_NAME)_%(irqmodifier)_IRQHandler() {
                     \t   ...
                     \t};
                     \t"
                  ]]>
               </clipboard>
      
               <choiceOption key='irqLevel_%(irqmodifier)' condition='!irqLevel_%(irqmodifier)'
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  description='IRQ priority level for %(irqmodifier)'
                  toolTip='="Priority level used to configure the NVIC for %(irqmodifier)\n
                           Selecting -Interrupts Disabled- will disable interrupts in the NVIC when configured"'
                  valueFormat="%s"
                  disabledValue="Interrupts disabled"
                  derivedFrom="/PCR/nvic_irqLevel"
                  >
               </choiceOption>
            </immediateValue>
         <else/>
            <clipboard key='irqHandlerTemplate' condition='!irqHandlerTemplate'
               hiddenBy="irqHandlingMethod||!enablePeripheralSupport"
               description='Interrupt handler template'
               toolTip='Interrupt handler example'>
               <![CDATA[="
                  \t/**
                  \t * Handler for $(_NAME) interrupt (Single entry)
                  \t */
                  \tvoid "+"$(_NAME)_IRQHandler() {
                  \t   ...
                  \t};
                  \t"
               ]]>
            </clipboard>
   
            <choiceOption key='irqLevel' condition='!irqLevel'
               hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
               derived="true"
               description='IRQ priority level'
               toolTip='Priority level used to configure the NVIC\n
                        Selecting -Interrupts Disabled- will disable interrupts in the NVIC when configured'
               valueFormat="%s"
               disabledValue="Interrupts disabled"
               derivedFrom="/PCR/nvic_irqLevel"
               >
            </choiceOption>
         </if>

      </for>

      <for keys="irqNum" values="=_userIrqNums" iterationVar="ch" >
         <if condition='=(_userIrqCount>1)' >
            <!-- Extract IRQ 'name' RTC_Alarm_IRQn => Alarm, Ch0 etc  -->
            <immediateValue keys="irqmodifier,irq_parameters" values='=ReplaceAll("%(irqNum)","^(.+)_(.+)_IRQn$","$2"),irq_parameters'>
               <!-- irqmodifier = Alarm, Ch0 etc -->
               <stringOption key='irqHandlerName_%(irqmodifier)'
                  valueFormat="%s"
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  description="Name of %(irqmodifier) event handler"
                  toolTip="Name of interrupt handler to be used in default settings object.\n
                           This must be a global function matching the expected interrupt handler signature"
                  value=""  />
                  
               <variable key='handlerName_%(irqmodifier)' type="String" 
                  description="User declared event handler"
                  expression='isBlank(irqHandlerName_%(irqmodifier))?"unhandledCallback":irqHandlerName_%(irqmodifier)' />
                  
               <template key="/$(_BASENAME)/prototypes" >
                  <![CDATA[
                  $(/$(_NAME)/handlerPrototype_%(irqmodifier):// No handler defined for $(_NAME) %(irqmodifier))\n
                  ]]>
               </template>

               <!-- For debug - displays handler information 
               <stringOption key='_handlerName_%(irqmodifier)' 
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  locked="true"
                  derived="true" 
                  ref='="handlerName_%(irqmodifier)"' />
               -->        
               <stringOption key='handlerPrototype_%(irqmodifier)'
                  description="Handler prototype" 
                  toolTip="Prototype for user callback"
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  locked="true"
                  derived="true" 
                  ref='isBlank(irqHandlerName_%(irqmodifier))?"// No handler defined for $(_NAME) %(irqmodifier)":"extern void "+irqHandlerName_%(irqmodifier)+"(%(irq_parameters));"' />
            </immediateValue>
         <else/> <!-- !(_userIrqCount>1) -->
            <immediateValue keys="irq_parameters" values='=irq_parameters'>
               <stringOption key="irqHandlerName"
                  valueFormat="%s"
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  description="Name of interrupt handler"
                  toolTip="Name of interrupt handler to be used in default settings object.\n
                           This must be a global function matching the expected interrupt handler signature"
                  value=""  />
               <variable key='handlerName' type="String" 
                  description="User declared event handler"
                  expression='isBlank(irqHandlerName)?"unhandledCallback":irqHandlerName' />
               
               <template key="/$(_BASENAME)/prototypes" >
                  <![CDATA[
                  $(/$(_NAME)/handlerPrototype:// No handler defined for $(_NAME))\n
                  ]]>
               </template>
               <!-- For debug - displays handler information 
               <stringOption key='_handlerName' 
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  locked="true"
                  derived="true" 
                  ref='handlerName' />
               -->        
               <stringOption key='handlerPrototype' 
                  description="Handler prototype" 
                  toolTip="Prototype for user callback"
                  hiddenBy="!irqHandlingMethod||!enablePeripheralSupport"
                  locked="true"
                  derived="true" 
                  ref='isBlank(irqHandlerName)?"// No handler defined for $(_NAME) ":"extern void "+irqHandlerName+"(%(irq_parameters));"' />        
            </immediateValue>
         </if>
      </for>

      <!-- Display here (wherever the original) -->
      <!-- aliasOption key="irqLevel"       locked="false" optional="true" / -->
      <!--  aliasOption key="irqHandlerName" locked="false" / -->

      <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
         variables="$(_BasicInfoIrqGuard)"
      ><![CDATA[
          \t//! Class based interrupt code has been generated for this class of peripheral
          \t// (%variables)
          \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
          \t\n
      ]]></variableTemplate>

      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="!suppressIrqArray"
         variables="$(_BasicInfoIrqGuard)"
      ><![CDATA[
          \t//! Common class based callback code has been generated for this class of peripheral
          \t// (%variables)
          \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
          \t\n
      ]]></variableTemplate>

      <template where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"  condition="!suppressIrqArray"
         immediateVariables="irq_parameters,irq_dummy_parameters" >
      <![CDATA[
         \t/**
         \t * Type definition for $(_Baseclass) interrupt call back.
         \t */
         \ttypedef void (*CallbackFunction)($(irq_parameters));
         \t
         \t/**
         \t * Callback to catch unhandled interrupt
         \t */
         \tstatic void unhandledCallback($(irq_dummy_parameters)) {
         \t   setAndCheckErrorCode(E_NO_HANDLER);
         \t}
         \t\n
      ]]>
      </template>

      <variableTemplate
         variables="$(_CommonInfoIrqGuard),irqLevel" condition="!suppressIrqArray"
      ><![CDATA[
         \t//! IRQ numbers for hardware
         \tstatic constexpr IRQn_Type irqNums[]  = $(_NAME)_IRQS;
         \t
         \t//! Number of IRQs for hardware
         \tstatic constexpr uint32_t irqCount  = sizeofArray(irqNums);
         \t\n
      ]]></variableTemplate>

<!--
      <variableTemplate variables="irqLevel" codeGenCondition="enablePeripheralSupport"
      ><![CDATA[
         \t//! Default IRQ level
         \tstatic constexpr NvicPriority irqLevel =  %symbolicExpression;
         \t\n
      ]]></variableTemplate>
 -->

      <!-- enum for IRQ indices into irqNums[]  -->
      <choiceOption where="info" key="irq_enum" condition="!irq_enum&amp;&amp;(@_hardwareIrqCount>1)"
         hidden="true"
         description="IRQ entry"
         toolTip="Select amongst interrupts associated with the peripheral"
         typeName="IrqNum"
         valueFormat="%s"
         >
         <choiceExpansion keys="irq" values="=_hardwareIrqNums"
            value="%(i)" name="Maps to %(irq)" enum='=Prettify(ReplaceAll("%(irq)", "$(_NAME)_([a-z|A-Z|0-9_]+)_IRQn", "$1"))' />
      </choiceOption>

      <choiceOption where="info" key="irq_enum" condition="!irq_enum&amp;&amp;(@_userIrqCount>1)"
         hidden="true"
         description="IRQ entry"
         toolTip="Select amongst interrupts associated with the peripheral"
         typeName="IrqNum"
         valueFormat="%s"
         >
         <choiceExpansion keys="irq" values="=_userIrqNums"
            value="%(i)" name="Maps to %(irq)" enum='=Prettify(ReplaceAll("%(irq)", "$(_NAME)_([a-z|A-Z|0-9_]+)_IRQn", "$1"))' />
      </choiceOption>

      <!-- IRQ enable/disable when single hardware IRQ is available  -->
      <template condition="=(_hardwareIrqCount==1)" ><![CDATA[
         \t/**
         \t * Enable interrupts in NVIC
         \t */
         \tstatic void enableNvicInterrupts() {
         \t   NVIC_EnableIRQ(irqNums[0]);
         \t}
         \t
         \t/**
         \t * Enable and set priority of interrupts in NVIC
         \t * Any pending NVIC interrupts are first cleared.
         \t *
         \t * @param[in]  nvicPriority  Interrupt priority
         \t */
         \tstatic void enableNvicInterrupts(NvicPriority nvicPriority) {
         \t   enableNvicInterrupt(irqNums[0], nvicPriority);
         \t}
         \t
         \t/**
         \t * Disable interrupts in NVIC
         \t */
         \tstatic void disableNvicInterrupts() {
         \t   NVIC_DisableIRQ(irqNums[0]);
         \t}
         \t\n
      ]]></template>

      <!-- IRQ enable/disable when multiple hardware IRQs available  -->
      <variableTemplate condition="=(_hardwareIrqCount>1)"
         variables="irq_enum"
      ><![CDATA[
         \t/**
         \t * Enable interrupts in NVIC
         %paramDescription
         \t */
         \tstatic void enableNvicInterrupts(%params) {
         \t   NVIC_EnableIRQ(irqNums[%paramName0]);
         \t}
         \t
         \t/**
         \t * Enable and set priority of interrupts in NVIC
         \t * Any pending NVIC interrupts are first cleared.
         \t *
         \t * @param[in]  nvicPriority  Interrupt priority
         %paramDescription
         \t */
         \tstatic void enableNvicInterrupts(%params, NvicPriority nvicPriority) {
         \t   enableNvicInterrupt(irqNums[%paramName0], nvicPriority);
         \t}
         \t
         \t/**
         \t * Disable interrupts in NVIC
         %paramDescription
         \t */
         \tstatic void disableNvicInterrupts(%params) {
         \t   NVIC_DisableIRQ(irqNums[%paramName0]);
         \t}
         \t\n
      ]]></variableTemplate>

      <!-- ____ Single user/hardware handler _____________ -->

      <equation key="wrapped_irq_dummy_parameters" value='=(irq_dummy_parameters=="")?"":", "+irq_dummy_parameters' />
      <!-- printVar key="wrapped_irq_dummy_parameters"/ -->
      <!-- printVar key="suppressIrqHandler"/ -->

      <!--  Wrappers for interrupt handlers -->
      <template codeGenCondition="irqHandlingMethod"
         immediateVariables="wrapped_irq_dummy_parameters,irq_parameters"
      >
      <![CDATA[
         \ttemplate<typename T>
         \tusing CallbackWrapper = USBDM::CallbackWrapper<T, $(_Info)$(wrapped_irq_dummy_parameters)>;
         \t
         \t/**
         \t * Function to wrap a member function as a static callback function
         \t * Example:
         \t * @code
         \t * class AClass {
         \t * public:
         \t *    int y;
         \t *
         \t *    // Member function used as callback
         \t *    // This function must match CallbackFunction
         \t *    void callbackFuction($(irq_parameters)) {
         \t *       ...;
         \t *    }
         \t * };
         \t * ...
         \t *    AClass *tester = new AClass{};
         \t *
         \t *    auto cb = $(_Class)::wrapCallback(tester, &AClass::callbackFuction);
         \t *    $(_Class)::setCallback(cb);
         \t *   @endcode
         \t *
         \t * @tparam T               Type of class containing callback (inferred)
         \t *
         \t * @param classInstance    Pointer to instance of class
         \t * @param memberFunction   Pointer to the member function
         \t *
         \t * @return  Wrapper
         \t */
         \ttemplate<typename T>
         \tstatic auto wrapCallback(T *classInstance, void (T::*memberFunction)($(irq_parameters))) {
         \t   static CallbackWrapper<T> sClass(classInstance, memberFunction);
         \t   return sClass.callback;
         \t}
         \t\n
      ]]>
      </template>

      <equation key="irq_call" value="sCallback($(irq_call_parameters))" condition="!irq_call" />

      <!--  Interrupt handler -->
      <template codeGenCondition="irqHandlingMethod" condition="!irq_enum&amp;&amp;!suppressIrqHandler"
         immediateVariables="irq_call" >
      <![CDATA[
         \t/**
         \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
         \t */
         \tstatic void irqHandler() {
         \t
         \t   // Execute call-back
         \t   $(irq_call);
         \t}
         \t\n
      ]]>
      </template>

      <!--  Set callback -->
      <template codeGenCondition="irqHandlingMethod" condition="!irq_enum||irq_single_handler" >
      <![CDATA[
         \t/** Callback function for $(_Class) */
         \tstatic inline CallbackFunction sCallback = $(_Info)::unhandledCallback; // $(_hardwareIrqNums);
         \t
         \t/**
         \t * Set interrupt callback function.
         \t *
         \t * @param  $(_basename)Callback Callback function to execute on interrupt
         \t *                             Use nullptr to remove callback.
         \t */
         \tstatic void setCallback(CallbackFunction $(_basename)Callback) {
         \t   if ($(_basename)Callback == nullptr) {
         \t      $(_basename)Callback = unhandledCallback;
         \t   }
         \t   // Allow either no handler set yet, setting same handler or removing handler
         \t   usbdm_assert(
         \t         (sCallback == unhandledCallback) ||
         \t         (sCallback == $(_basename)Callback) ||
         \t         ($(_basename)Callback == unhandledCallback),
         \t         "Handler already set");
         \t   sCallback = $(_basename)Callback;
         \t}
         \t\n
      ]]>
      </template>

      <!-- ____ Multiple user/hardware handlers _____________ -->

      <!--  Interrupt handler -->
      <variableTemplate codeGenCondition="irqHandlingMethod" variables="irq_enum" condition="!suppressIrqHandler&amp;&amp;!irq_single_handler" >
      <![CDATA[
         \t/**
         \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
         \t * (Multiple handlers)
         \t *
         \t * @tparam %paramName0 %tooltip
         \t */
         \ttemplate<%params>
         \tstatic void irqHandler() {
         \t
         \t   // Execute call-back
         \t   sCallbacks[%paramName0]($(irq_call_parameters));
         \t}
         \t\n
      ]]>
      </variableTemplate>

      <variableTemplate codeGenCondition="irqHandlingMethod" variables="irq_enum" condition="!suppressIrqHandler&amp;&amp;irq_single_handler" >
      <![CDATA[
         \t/**
         \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
         \t * (Multiple vectors mapped to single handler)
         \t *
         \t * @tparam %paramName0 %tooltip
         \t */
         \ttemplate<%params>
         \tstatic void irqHandler() {
         \t
         \t   // Execute call-back
         \t   $(irq_call);
         \t}
         \t\n
      ]]>
      </variableTemplate>

      <!--  Set callback -->
      <variableTemplate codeGenCondition="irqHandlingMethod" variables="irq_enum" condition="!irq_single_handler"
         immediateVariables="_userIrqCount" >
      <![CDATA[
         \t/** Callback function for $(_Class) */
         \tstatic inline CallbackFunction sCallbacks[$(_userIrqCount)] = {\n
      ]]></variableTemplate>
      <for keys="irqName" values="=_userIrqNums" condition="=_userIrqCount>1" >
         <template codeGenCondition="irqHandlingMethod" condition="irq_enum&amp;&amp;!irq_single_handler" ><![CDATA[
            \t   $(_Info)::unhandledCallback,  // %(irqName) \n
         ]]></template>
      </for>
      <variableTemplate codeGenCondition="irqHandlingMethod" variables="irq_enum" condition="!irq_single_handler" >
      <![CDATA[
         \t};
         \t
         \t/**
         \t * Set interrupt callback function.
         \t *
         %paramDescription0
         \t * @param  $(_basename)Callback Callback function to execute on interrupt
         \t *                             Use nullptr to remove callback.
         \t */
         \tstatic void setCallback(%param0, CallbackFunction $(_basename)Callback) {
         \t   if ($(_basename)Callback == nullptr) {
         \t      $(_basename)Callback = unhandledCallback;
         \t   }
         \t   // Allow either no handler set yet, setting same handler or removing handler
         \t   usbdm_assert(
         \t         (sCallbacks[%paramName0] == unhandledCallback) ||
         \t         (sCallbacks[%paramName0] == $(_basename)Callback) ||
         \t         ($(_basename)Callback == unhandledCallback),
         \t         "Handler already set");
         \t   sCallbacks[%paramName0] = $(_basename)Callback;
         \t}
         \t\n
      ]]>
      </variableTemplate>

   </if> <!-- condition="_hardwareIrqCount&amp;&amp;!suppressHardwareIrq" -->

<!--====================================================================================================== -->
<!--  Peripheral clock  -->
<!--====================================================================================================== -->

   <!-- Try both e.g. /CMP/_clockMask and /CMP1/_clockMask - prefer latter -->
   <equation key="clock_data"  value="=/$(_BASENAME)/_clockInfo" condition="/$(_BASENAME)/_clockInfo" />
   <equation key="clock_data"  value="=_clockInfo"               condition="_clockInfo" />

   <!-- SIM clock control register e.g. SCGC3 -->
   <equation key="clock_reg"   value='=ReplaceAll(clock_data, "^(.+?),(.+?)$", "$1")' condition="clock_data" />

   <!-- SIM clock control register mask (partial) e.g. CMP3 -->
   <equation key="clock_mask"  value='=ReplaceAll(clock_data, "^(.+?),(.+?)$", "$2")' condition="clock_data" />

   <!-- SIM clock control in GUI -->
   <equation key="_scgc_clock" value='="/SIM/"+ToLowerCase("sim_"+clock_reg+"_"+clock_mask)' condition="clock_data" />

   <template condition="clock_data"
      immediateVariables="clock_reg,clock_mask"
   ><![CDATA[
      \t/**
      \t *  Enable clock to $(_Class)
      \t */
      \tstatic void enableClock() {
      \t   SIM->$(clock_reg) = SIM->$(clock_reg) | SIM_$(clock_reg)_$(clock_mask)_MASK;
      \t}
      \t
      \t/**
      \t *  Disable clock to $(_Class)
      \t */
      \tstatic void disableClock() {
      \t   SIM->$(clock_reg) = SIM->$(clock_reg) & ~SIM_$(clock_reg)_$(clock_mask)_MASK;
      \t}
      \t\n
   ]]></template>

<!--====================================================================================================== -->
<!--     START enable/disable methods -->
<!--====================================================================================================== -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Basic enable of $(_Class)
      \t * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
      \t */
      \tstatic void enable() {\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="clock_data" ><![CDATA[
      \t   enableClock();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="/PCR/mux_present&amp;&amp;_hasPcrTable" ><![CDATA[
      \t   configureAllPins();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t
      \t/**
      \t * Disables $(_Class)
      \t */
      \tstatic void disable() {
      \t
      \t   $(disable_peripheral: )\n
   ]]></template>
   <if condition="_hardwareIrqCount&amp;&amp;!suppressIrqArray" >

      <for keys="irqName" values="=_hardwareIrqNums" condition="!suppressHardwareIrq&amp;&amp;(@_hardwareIrqCount>1)" >
         <equation key="prettyIrqNum" value='=Prettify(ReplaceAll("%(irqName)", "$(_NAME)_([a-z|A-Z|0-9_]+)_IRQn", "$1"))' />
         <!--
         <printVar key="prettyIrqNum" />
          -->

         <template codeGenCondition="enablePeripheralSupport"
            immediateVariables="prettyIrqNum" >
         <![CDATA[
            \t   disableNvicInterrupts(IrqNum_$(prettyIrqNum));\n
         ]]></template>
      </for>

      <template codeGenCondition="enablePeripheralSupport" condition="!suppressHardwareIrq&amp;&amp;(@_hardwareIrqCount==1)" >
      <![CDATA[
         \t   disableNvicInterrupts();\n
      ]]></template>
   </if>
   <template codeGenCondition="enablePeripheralSupport" condition="/PCR/mux_present&amp;&amp;_hasPcrTable" ><![CDATA[
      \t   disableAllPins();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="clock_data" ><![CDATA[
      \t   disableClock();\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t\n
   ]]></template>

   <template><![CDATA[
      \t//! Hardware base address as uint32_t
      \tstatic constexpr uint32_t baseAddress = $(_NAME)_BasePtr;
      \t
      \t//! Hardware base pointer
      \tstatic constexpr HardwarePtr<$(structName)_Type> $(_basename) = baseAddress;
      \t\n
   ]]></template>

   <!-- Don't generate instance if suppressed or empty -->
   <template condition='!suppressInstance&amp;&amp;"$(_instance)"!=""' ><![CDATA[
      \t//! Peripheral instance number
      \tstatic constexpr unsigned instance = $(_instance);
      \t\n
   ]]></template>

   <constant key="class_present" type="Boolean"  value = "true"   />

   <template where="definitions" codeGenCondition="enablePeripheralSupport&amp;&amp;/HARDWARE/generateDebugDefinitions" ><![CDATA[
      \t//! Indicates $(_NAME) is available
      \t#define USBDM_$(_NAME)_AVAILABLE
      \t\n
   ]]></template>

   <!-- _____________ Base pin mapping __________________ -->

   <binaryOption key="$(_name)_pin_map" condition="pinMap"
      description="$(_NAME) Pin mapping"
      toolTip="Pin mapping used when $(_NAME) enabled"
      disabledPinMap="#enablePeripheralSupport"
      locked="true"
      derived="true" >
      <choice name="Pin mapping" value="0" pinMap="=pinMap" />
   </binaryOption>

<!--====================================================================================================== -->
<!--     START BasicInfo::InitVectors class and Init typedef -->
<!--====================================================================================================== -->
   <if condition="_hardwareIrqCount&amp;&amp;!suppressIrqArray&amp;&amp;!no_initvectors" >
   
      <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount>1)"
         variables="irq_enum"
         immediateVariables="_hardwareIrqCount"
         linePadding="xxx" >
      <![CDATA[
         \t/**
         \t * Information describing the priority and callback function for each interrupt
         \t */
         \ttypedef InitVectors<Init, CallbackFunction, %returnType0, $(_hardwareIrqCount)> Init;
         \t\n
      ]]></variableTemplate>

      <template where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount==1)"
         linePadding="xxx" >
      <![CDATA[
         \t/**
         \t * Information describing the priority and callback function for each interrupt
         \t */
         \ttypedef InitVectors<Init, CallbackFunction, int, 1> Init;
         \t\n
      ]]></template>
   </if>

</fragment>

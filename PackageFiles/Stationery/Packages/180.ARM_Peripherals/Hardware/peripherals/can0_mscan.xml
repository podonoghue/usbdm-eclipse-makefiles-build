<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- can0_mscan.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Scalable Controller Area Network" >

   <option key="debugGuards" value="true" />

   <equation key="individual_clock_source" value='=Exists("/SIM/system_$(_name)_clock[]")'     />
   <equation key="shared_clock_source"     value='=Exists("/SIM/system_$(_basename)_clock[]")' />

   <!-- ____ Class Declarations ________ -->
   <constant key="_basicInfo_declaration" type="String" value='"$(_BasicInfo)"' />
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <!-- ____ Instance control ________ -->
   <constant key="_can_create_instance" value="true" type="Boolean" />

   <equation key="irq_parameters"             value=""          />
   <equation key="irq_dummy_parameters"       value=""          />
   <equation key="irq_call_parameters"        value=""          />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <!-- ____ CANCTL0 ____ -->
   <title description="Control Register 0" />

   <binaryOption key="can_canctl0_rxfrm" condition="can_canctl0_rxfrm_present"
      enabledBy="$(_BasicInfoGuard)"
      typeName="CanRxFrameFlag"
      hidden="true"
      derived="true"
      toolTip="This bit is read and clear only.\n
               It is set when a receiver has received a valid message correctly,"
      description="Received Frame Flag" >
      <choice name="No new message"         value="0" enum="NoNewMessage" />
      <choice name="New message available"  value="1" enum="NewMessageAvailable" />
   </binaryOption >

   <binaryOption key="can_canctl0_rxact" condition="can_canctl0_rxact_present"
      hidden="true"
      derived="true"
      typeName="CanReceiverActiveStatus"
      baseType="uint8_t"
      toolTip="This read-only flag indicates the MSCAN is receiving a message or has lost arbitration"
      description="Receiver Active Status" >
      <choice name="Transmitting or idle"  value="0" enum="TransmittingOrIdle" />
      <choice name="Receiving message"     value="1" enum="ReceivingMessage" />
   </binaryOption >

   <binaryOption key="can_canctl0_cswai" condition="can_canctl0_cswai_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanStopInWait"
      baseType="uint8_t"
      toolTip="This bit allows for lower power consumption in wait mode"
      description="CAN Stops in Wait Mode" >
      <choice name="Ignore wait mode"      value="0" enum="IgnoreWaitMode"/>
      <choice name="Suspend in wait mode"  value="1" enum="SuspendInWaitMode"/>
   </binaryOption >

   <binaryOption key="can_canctl0_synch" condition="can_canctl0_synch_present"
      hidden="true"
      derived="true"
      typeName="CanSynchronizedStatus"
      baseType="uint8_t"
      toolTip="This read-only flag indicates whether the MSCAN is synchronized to the CAN bus"
      description="Synchronized Status" >
      <choice name="MSCAN not synchronized"  value="0" enum="MscanNotSynchronized" />
      <choice name="MSCAN synchronized"      value="1" enum="MscanSynchronized" />
   </binaryOption >

   <binaryOption key="can_canctl0_time" condition="can_canctl0_time_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTimerEnable"
      baseType="uint8_t"
      toolTip="Enables an internal 16-bit wide free running timer which is clocked by the bit clock rate"
      description="Timer Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canctl0_wupe" condition="can_canctl0_wupe_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanWakeupEnable"
      baseType="uint8_t"
      toolTip="Allows the MSCAN to restart from sleep mode or from power down mode when traffic detected on CAN"
      description="WakeUp Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canctl0_slprq" condition="can_canctl0_slprq_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanSleepModeRequest"
      baseType="uint8_t"
      toolTip="This bit requests the MSCAN to enter sleep mode"
      description="Sleep Mode Request" >
      <choice name="Normal mode"          value="0" enum="NormalMode" />
      <choice name="Initialisation mode"  value="1" enum="InitialisationMode" />
   </binaryOption >

   <binaryOption key="can_canctl0_initrq" condition="can_canctl0_initrq_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanInitializationModeRequest"
      baseType="uint8_t"
      toolTip="When this bit is set by the CPU, the MSCAN skips to initialization mode.\n
               Any ongoing transmission or reception is aborted and synchronization to the CAN bus is lost.\n
               The module indicates entry to initialization mode by setting INITAK = 1"
      description="Initialization Mode Request" >
      <choice name="Normal mode"          value="0" enum="NormalMode" />
      <choice name="Initialisation mode"  value="1" enum="InitialisationMode" />
   </binaryOption >

   <!-- ____ CANCTL1 ____ -->
   <title description="Control Register 1" />

   <binaryOption key="can_canctl1_cane" condition="can_canctl1_cane_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanMscanEnable"
      baseType="uint8_t"
      toolTip="Module enable"
      description="MSCAN Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canctl1_clksrc" condition="can_canctl1_clksrc_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanMscanClockSource"
      baseType="uint8_t"
      toolTip="This bit defines the clock source for the MSCAN module"
      description="MSCAN Clock Source" >
      <choice name="Oscillator clock"  value="0" enum="OscillatorClock" />
      <choice name="Bus clock"         value="1" enum="BusClock" />
   </binaryOption >

   <binaryOption key="can_canctl1_loopb" condition="can_canctl1_loopb_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanLoopbackSelfTestMode"
      baseType="uint8_t"
      toolTip="Allows the MSCAN to perform an internal loopback test"
      description="Loopback Self Test Mode" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canctl1_listen" condition="can_canctl1_listen_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanListenOnlyMode"
      baseType="uint8_t"
      toolTip="This bit configures the MSCAN as a CAN bus monitor"
      description="Listen Only Mode" >
      <choice name="Normal"            value="0" enum="Normal" />
      <choice name="Listen only mode"  value="1" enum="ListenOnlyMode" />
   </binaryOption >

   <binaryOption key="can_canctl1_borm" condition="can_canctl1_borm_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanBusOffRecoveryMode"
      baseType="uint8_t"
      toolTip="This bit configures the bus-off state recovery mode of the MSCAN\n
               See Bosch CAN 2.0A/B protocol specification"
      description="Bus-Off Recovery Mode" >
      <choice name="Automatic"     value="0" enum="Automatic" />
      <choice name="User request"  value="1" enum="UserRequest" />
   </binaryOption >

   <binaryOption key="can_canctl1_wupm" condition="can_canctl1_wupm_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanWakeupMode"
      baseType="uint8_t"
      toolTip="If WUPE in CANCTL0 is enabled, this bit defines whether the integrated low-pass filter is\n
               applied to protect the MSCAN from spurious wakeup\n
               If enabled, MSCAN wakes only on a dominant pulse on the CAN bus of length Twup"
      description="WakeUp Mode" >
      <choice name="Wakup unfiltered"  value="0" enum="WakupUnfiltered" />
      <choice name="Wakup filtered"    value="1" enum="WakupFiltered" />
   </binaryOption >

   <binaryOption key="can_canctl1_slpak" condition="can_canctl1_slpak_present"
      hidden="true"
      derived="true"
      typeName="CanSleepModeAcknowledge"
      baseType="uint8_t"
      toolTip="This flag indicates whether the MSCAN module has entered sleep mode"
      description="Sleep Mode Acknowledge" >
      <choice name="Running"     value="0" enum="Running" />
      <choice name="Sleep mode"  value="1" enum="SleepMode" />
   </binaryOption >

   <binaryOption key="can_canctl1_initak" condition="can_canctl1_initak_present"
      hidden="true"
      derived="true"
      typeName="CanInitializationModeAcknowledge"
      baseType="uint8_t"
      toolTip="This flag indicates whether the MSCAN module is in initialization mode.\n
               It is used as a handshake flag for the INITRQ initialization mode request.\n
               Initialization mode is active when INITRQ = 1 and INITAK = 1.\n
               The registers CANCTL1, CANBTR0, CANBTR1, CANIDAC, CANIDAR0-CANIDAR7, and CANIDMR0-CANIDMR7 can\n
               be written only by the CPU when the MSCAN is in initialization mode"
      description="Initialization Mode Acknowledge" >
      <choice name="Running"                     value="0" enum="Running" />
      <choice name="Initialization mode active"  value="1" enum="InitializationModeActive" />
   </binaryOption >

   <!-- ____ CANBTR0 ____ -->
   <title description="Bus Timing Register 0\n
This register configures various CAN bus timing parameters" />

   <choiceOption key="can_canbtr0_sjw" condition="can_canbtr0_sjw_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanSynchronizationJumpWidth"
      baseType="uint8_t"
      toolTip="The synchronization jump width defines the maximum number of time quanta (Tq) clock cycles a bit can\n
               be shortened or lengthened to achieve resynchronization to data transitions on the CAN bus" 
      description="Baud Rate Prescaler" >
      <choice value="0b00" name="1 Tq clock cycle"  enum="1cycle" />
      <choice value="0b01" name="2 Tq clock cycles" enum="2cycles" />
      <choice value="0b10" name="3 Tq clock cycles" enum="3cycles" />
      <choice value="0b11" name="4 Tq clock cycles" enum="4cycles" />
   </choiceOption >

   <intOption key="can_canbtr0_brp" condition="can_canbtr0_brp_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanBaudRatePrescaler"
      baseType="uint8_t"
      toolTip="These bits determine the time quanta (Tq) clock which is used to build up the bit timing.\n
               Prescale = N+1"
      description="Baud Rate Prescaler"
      offset="-1"
      value="1"
      min="0" max="31"
   />

   <!-- ____ CANBTR1 ____ -->
   <title description="Bus Timing Register 1\n
This register configures various CAN bus timing parameters of the MSCAN module" />

   <binaryOption key="can_canbtr1_samp" condition="can_canbtr1_samp_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanSampling"
      baseType="uint8_t"
      toolTip="This bit determines the number of CAN bus samples taken per bit time,\n
               For 3 samples, PHASE_SEG1 must be at least 2 time quanta (Tq)"
      description="Sampling" >
      <choice name="One sample per bit"     value="0" enum="OneSamplePerBit"/>
      <choice name="Three samples per bit"  value="1" enum="ThreeSamplesPerBit"/>
   </binaryOption >

   <choiceOption key="can_canbtr1_tseg1" condition="can_canbtr1_tseg1_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTimeSegment1"
      baseType="uint8_t"
      toolTip="Time segments within the bit time fix the number of clock cycles per bit time and the location of the sample point.\n
               Time = N+1\n
               The bit time is determined by the oscillator frequency, the baud rate prescaler, and the number of time quanta (Tq) clock cycles per bit.\n
               Bit time = (1 + timesegment1 + timesegment2) * (Prescaler value)/ fCANCLK"
      description="Time Segment 1" >
      <choice value="0b0011" name="4 Tq cycles"  enum="4_TqCycles"  />
      <choice value="0b0100" name="5 Tq cycle"   enum="5_TqCycles"  />
      <choice value="0b0101" name="6 Tq cycles"  enum="6_TqCycles"  />
      <choice value="0b0110" name="7 Tq cycle"   enum="7_TqCycles"  />
      <choice value="0b0111" name="8 Tq cycles"  enum="8_TqCycles"  />
      <choice value="0b1000" name="9 Tq cycle"   enum="9_TqCycle"   />
      <choice value="0b1001" name="10 Tq cycles" enum="10_TqCycles" />
      <choice value="0b1010" name="11 Tq cycle"  enum="11_TqCycl2s" />
      <choice value="0b1011" name="12 Tq cycles" enum="12_TqCycles" />
      <choice value="0b1100" name="13 Tq cycle"  enum="13_TqCycles" />
      <choice value="0b1101" name="14 Tq cycles" enum="14_TqCycles" />
      <choice value="0b1110" name="15 Tq cycle"  enum="15_TqCycles" />
      <choice value="0b1111" name="16 Tq cycles" enum="16_TqCycles" />
   </choiceOption>

   <choiceOption key="can_canbtr1_tseg2" condition="can_canbtr1_tseg2_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTimeSegment2"
      baseType="uint8_t"
      toolTip="Time segments within the bit time fix the number of clock cycles per bit time and the location of the sample point."
      description="Time Segment 2" >
      <choice value="0b0000" name="1 Tq cycle"   enum="1_TqCycle"   />
      <choice value="0b0001" name="2 Tq cycles"  enum="2_TqCycles"  />
      <choice value="0b0010" name="3 Tq cycle"   enum="3_TqCycl2s"  />
      <choice value="0b0011" name="4 Tq cycles"  enum="4_TqCycles"  />
      <choice value="0b0100" name="5 Tq cycle"   enum="5_TqCycles"  />
      <choice value="0b0101" name="6 Tq cycles"  enum="6_TqCycles"  />
      <choice value="0b0110" name="7 Tq cycle"   enum="7_TqCycles"  />
      <choice value="0b0111" name="8 Tq cycles"  enum="8_TqCycles"  />
   </choiceOption>


   <!-- ____ CANRFLG ____ -->
   <title description="Receiver Flag Register" />

   <binaryOption key="can_canrflg_wupif" condition="can_canrflg_wupif_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanWakeUpInterruptFlag"
      baseType="uint8_t"
      toolTip="If the MSCAN detects CAN bus activity while in sleep mode and CANTCTL0[WUPE] = 1, the module will\n
               set WUPIF. If not masked, a wake-up interrupt is pending while this flag is set"
      description="Wake-Up Interrupt Flag" >
      <choice name="No wakeup"         value="0" enum="NoWakeup" />
      <choice name="Wakeup requested"  value="1" enum="WakeupRequested" />
   </binaryOption >

   <binaryOption key="can_canrflg_cscif" condition="can_canrflg_cscif_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanCanStatusChangeInterruptFlag"
      baseType="uint8_t"
      toolTip="This flag is set when the MSCAN changes its current CAN bus status due to the actual value of the\n
               transmit error counter (TEC) and the receive error counter (REC)"
      description="CAN Status Change Interrupt Flag" >
      <choice name="No status change"  value="0" enum="NoStatusChange" />
      <choice name="Status changed"    value="1" enum="StatusChanged" />
   </binaryOption >

   <choiceOption key="can_canrflg_rstat" condition="can_canrflg_rstat_present"
      hidden="true"
      derived="true"
      typeName="CanReceiverStatus"
      baseType="uint8_t"
      toolTip="The values of the error counters control the actual CAN bus status of the MSCAN"
      description="Receiver Status" >
      <choice name="RxOK: 0&lt;=receive error counter&lt;96"  value="0" enum="Rxok0LtReceiveErrorCounterLt96" />
      <choice name="RxWRN: 96&lt;=receive error counter&lt;128"  value="1" enum="Rxwrn96LtReceiveErrorCounterLt128" />
      <choice name="RxERR: 128&lt;=receive error counter"  value="2" enum="Rxerr128LtReceiveErrorCounter" />
      <choice name="Bus-off: 256&lt;=transmit error counter"  value="3" enum="BusOff256LtTransmitErrorCounter" />
   </choiceOption >

   <choiceOption key="can_canrflg_tstat" condition="can_canrflg_tstat_present"
      hidden="true"
      derived="true"
      typeName="CanTransmitterStatus"
      baseType="uint8_t"
      toolTip="The values of the error counters control the actual CAN bus status of the MSCAN"
      description="Transmitter Status" >
      <choice name="TxOK: 0&lt;=transmit error counter&lt;96"  value="0" enum="Txok0LtTransmitErrorCounterLt96" />
      <choice name="TxWRN: 96&lt;=transmit error counter&lt;128"  value="1" enum="Txwrn96LtTransmitErrorCounterLt128" />
      <choice name="TxERR: 128&lt;=transmit error counter&lt;256"  value="2" enum="Txerr128LtTransmitErrorCounterLt256" />
      <choice name="Bus-off: 256&lt;=transmit error counter"  value="3" enum="BusOff256LtTransmitErrorCounter" />
   </choiceOption >

   <binaryOption key="can_canrflg_ovrif" condition="can_canrflg_ovrif_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanOverrunInterruptFlag"
      baseType="uint8_t"
      toolTip="This flag is set when a data overrun condition occurs. If not masked, an error interrupt is pending while this
flag is set"
      description="Overrun Interrupt Flag" >
      <choice name="No overrun"        value="0" enum="NoOverrun" />
      <choice name="Overrun detected"  value="1" enum="OverrunDetected" />
   </binaryOption >

   <binaryOption key="can_canrflg_rxf" condition="can_canrflg_rxf_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanReceiveBufferFullFlag"
      baseType="uint8_t"
      toolTip="RXF is set by the MSCAN when a new message is shifted in the receiver FIFO"
      description="Receive Buffer Full Flag" >
      <choice name="No new message"     value="0" enum="NoNewMessage" />
      <choice name="Rx FIFO not empty"  value="1" enum="RxFifoNotEmpty" />
   </binaryOption >

   <!-- ____ CANRIER ____ -->
   <title description="Receiver Interrupt Enable Register\n
This register contains the interrupt enable bits for the interrupt flags described in the\n
CANRFLG register" />

   <binaryOption key="can_canrier_wupie" condition="can_canrier_wupie_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanWakeupInterruptEnable"
      baseType="uint8_t"
      toolTip="WUPIE and WUPE must both be enabled if the recovery mechanism from stop or wait is required"
      description="WakeUp Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canrier_cscie" condition="can_canrier_cscie_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanCanStatusChangeInterruptEnable"
      baseType="uint8_t"
      toolTip=""
      description="CAN Status Change Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <choiceOption key="can_canrier_rstate" condition="can_canrier_rstate_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanReceiverStatusChangeEnable"
      baseType="uint8_t"
      toolTip="These RSTAT enable bits control the sensitivity level in which receiver state changes are causing CSCIF
interrupts"
      description="Receiver Status Change Enable" >
      <choice name="Disabled"       value="0" enum="Disabled"/>
      <choice name="Bus off only"   value="1" enum="BusOffOnly"/>
      <choice name="Rx error only"  value="2" enum="RxErrorOnly"/>
      <choice name="All changes"    value="3" enum="AllChanges"/>
   </choiceOption >

   <choiceOption key="can_canrier_tstate" condition="can_canrier_tstate_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTransmitterStatusChangeEnable"
      baseType="uint8_t"
      toolTip="These TSTAT enable bits control the sensitivity level in which transmitter state changes are causing
CSCIF interrupts"
      description="Transmitter Status Change Enable" >
      <choice name="Disabled"       value="0" enum="Disabled" />
      <choice name="Bus off only"   value="1" enum="BusOffOnly" />
      <choice name="Tx error only"  value="2" enum="TxErrorOnly" />
      <choice name="All changes"    value="3" enum="AllChanges" />
   </choiceOption >

   <binaryOption key="can_canrier_ovrie" condition="can_canrier_ovrie_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanOverrunInterruptEnable"
      baseType="uint8_t"
      toolTip=""
      description="Overrun Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <binaryOption key="can_canrier_rxfie" condition="can_canrier_rxfie_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanReceiverFullInterruptEnable"
      baseType="uint8_t"
      toolTip=""
      description="Receiver Full Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <!-- ____ CANTFLG ____ -->
   <title description="Transmitter Flag Register" />

   <binaryOption key="can_cantflg_txe" condition="can_cantflg_txe_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTransmitterBufferEmpty"
      baseType="uint8_t"
      toolTip="These flags indicates that the associated transmit message buffer is empty, and thus not scheduled for
transmission"
      description="Transmitter Buffer Empty" >
      <choice name="Buffer full"   value="0" enum="BufferFull" />
      <choice name="Buffer empty"  value="1" enum="BufferEmpty" />
   </binaryOption >

   <!-- ____ CANTIER ____ -->
   <title description="Transmitter Interrupt Enable Register\n
This register contains the interrupt enable bits for the transmit buffer empty interrupt flags" />

   <binaryOption key="can_cantier_txeie" condition="can_cantier_txeie_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTransmitterEmptyInterruptEnable"
      baseType="uint8_t"
      toolTip=""
      description="Transmitter Empty Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled" />
      <choice name="Enabled"     value="1" enum="Enabled" />
   </binaryOption >

   <!-- ____ CANTARQ ____ -->
   <title description="Transmitter Message Abort Request Register\n
The CANTARQ register allows abort request of queued messages" />

   <binaryOption key="can_cantarq_abtrq" condition="can_cantarq_abtrq_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanAbortRequest"
      baseType="uint8_t"
      toolTip="The CPU sets the ABTRQx bit to request that a scheduled message buffer (TXEx = 0) be aborted"
      description="Abort Request" >
      <choice name="No request"  value="0" enum="NoRequest" />
      <choice name="Request"     value="1" enum="Request" />
   </binaryOption >

   <!-- ____ CANTAAK ____ -->
   <title description="Transmitter Message Abort Acknowledge Register\n
The CANTAAK register indicates the successful abort of a queued message, if requested by the appropriate bits in the CANTARQ register" />

   <binaryOption key="can_cantaak_abtak" condition="can_cantaak_abtak_present"
      hidden="true"
      derived="true"
      typeName="CanAbortAcknowledge"
      baseType="uint8_t"
      toolTip="This flag acknowledges that a message was aborted due to a pending abort request from the CPU"
      description="Abort Acknowledge" >
      <choice name="Nor Acknowledged"  value="0" enum="NorAcknowledged" />
      <choice name="Acknowledged"      value="1" enum="Acknowledged" />
   </binaryOption >

   <!-- ____ CANTBSEL ____ -->
   <title description="Transmit Buffer Selection Register\n
The CANTBSEL register allows the selection of the actual transmit message buffer,\n
which then will be accessible in the CANTXFG register space" />

   <choiceOption key="can_cantbsel_tx" condition="can_cantbsel_tx_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanTransmitBufferSelect"
      baseType="uint8_t"
      toolTip="The lowest numbered bit places the respective transmit buffer in the CANTXFG register space (e.g., TX1 = 1\n
               and TX0 = 1 selects transmit buffer TX0; TX1 = 1 and TX0 = 0 selects transmit buffer TX1)"
      description="Transmit Buffer Select" >
      <choice name="Choice 0"  value="0" enum="Choice0" />
      <choice name="Choice 1"  value="1" enum="Choice1" />
      <choice name="Choice 2"  value="2" enum="Choice2" />
      <choice name="Choice 3"  value="3" enum="Choice3" />
      <choice name="Choice 4"  value="4" enum="Choice4" />
      <choice name="Choice 5"  value="5" enum="Choice5" />
      <choice name="Choice 6"  value="6" enum="Choice6" />
      <choice name="Choice 7"  value="7" enum="Choice7" />
   </choiceOption >

   <!-- ____ CANIDAC ____ -->
   <title description="Identifier Acceptance Control Register\n
The CANIDAC register is used for identifier acceptance control" />

   <choiceOption key="can_canidac_idam" condition="can_canidac_idam_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanIdentifierAcceptanceMode"
      baseType="uint8_t"
      toolTip="The CPU sets these flags to define the identifier acceptance filter organization. In filter closed mode, no\n
               message is accepted such that the foreground buffer is never reloaded"
      description="Identifier Acceptance Mode" >
      <choice name="Two 32-bit filters"   value="0" enum="Two32BitFilters" />
      <choice name="Four 16-bit filters"  value="1" enum="Four16BitFilters" />
      <choice name="Eight 8-bit filters"  value="2" enum="Eight8BitFilters" />
      <choice name="Filter closed"        value="3" enum="FilterClosed" />
   </choiceOption >

   <choiceOption key="can_canidac_idhit" condition="can_canidac_idhit_present"
      hidden="true"
      derived="true"
      typeName="CanIdentifierAcceptanceHitIndicator"
      baseType="uint8_t"
      toolTip="The MSCAN sets these flags to indicate an identifier acceptance hit.\n
               The IDHIT indicators are always related to the message in the foreground buffer (RxFG).\n
               When a message gets shifted into the foreground buffer of the receiver FIFO the indicators are updated as well"
      description="Identifier Acceptance Hit Indicator" >
      <choice name="Choice 0"  value="0" enum="Choice0" />
      <choice name="Choice 1"  value="1" enum="Choice1" />
      <choice name="Choice 2"  value="2" enum="Choice2" />
      <choice name="Choice 3"  value="3" enum="Choice3" />
      <choice name="Choice 4"  value="4" enum="Choice4" />
      <choice name="Choice 5"  value="5" enum="Choice5" />
      <choice name="Choice 6"  value="6" enum="Choice6" />
      <choice name="Choice 7"  value="7" enum="Choice7" />
   </choiceOption >

   <!-- ____ CANMISC ____ -->
   <title description="Miscellaneous Register" />

   <binaryOption key="can_canmisc_bohold" condition="can_canmisc_bohold_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanBusOffStateHoldUntilUserRequest"
      baseType="uint8_t"
      toolTip="If BORM is set in MSCAN Control Register 1 (CANCTL1), this bit indicates whether the module has\n
               entered the bus-off state. Clearing this bit requests the recovery from bus-off"
      description="Bus-off State Hold Until User Request" >
      <choice name="Not in bus-off state"  value="0" enum="NotInBusOffState" />
      <choice name="In bus-off state"      value="1" enum="InBusOffState" />
   </binaryOption >

   <!-- ____ CANRXERR ____ -->

   <!-- ____ CANTXERR ____ -->

   <!-- ____ CANIDAR ____ -->

   <!-- ____ CANIDMR ____ -->

   <!-- ____ CANIDAR ____ -->

   <!-- ____ CANIDMR ____ -->

   <!-- ____ REIDR ____ -->

   <!-- ____ RSIDR ____ -->

   <!-- ____ REDSR ____ -->

   <!-- ____ RDLR ____ -->
   <title description="Receive Data Length Register\n
This register keeps the data length field of the CAN frame" />

   <choiceOption key="can_rdlr_rdlc" condition="can_rdlr_rdlc_present"
      enabledBy="enablePeripheralSupport"
      typeName="CanDataLengthCodeBits"
      baseType="uint8_t"
      toolTip="The data length code contains the number of bytes (data byte count) of the respective message. During\n
               the transmission of a remote frame, the data length code is transmitted as programmed while the number\n
               of transmitted data bytes is always 0. The data byte count ranges from 0 to 8 for a data frame"
      description="Data Length Code Bits" >
      <choice value="0b000" name="0 bytes" enum="0_bytes" />
      <choice value="0b001" name="1 bytes" enum="1_bytes" />
      <choice value="0b010" name="2 bytes" enum="2_bytes" />
      <choice value="0b011" name="3 bytes" enum="3_bytes" />
      <choice value="0b100" name="4 bytes" enum="4_bytes" />
      <choice value="0b101" name="5 bytes" enum="5_bytes" />
      <choice value="0b110" name="6 bytes" enum="6_bytes" />
      <choice value="0b111" name="6 bytes" enum="7_bytes" />
   </choiceOption>

   <!-- ************* RTSRH ****************** -->

   <!-- ************* RTSRL ****************** -->

   <!-- ************* TEIDR ****************** -->

   <!-- ************* TSIDR ****************** -->

   <!-- ************* TEDSR ****************** -->

   <!-- ************* TDLR ****************** -->

   <!-- ************* TBPR ****************** -->

   <!-- ************* TTSRH ****************** -->

   <!-- ************* TTSRL ****************** -->

   <!-- BasicInfo Instance pointer and Constructors  -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Pointer to $(_BASENAME) hardware instance
      \tvolatile $(_Type) * const $(_basename);
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Constructor
      \t *
      \t * @param $(_basename) $(_BASENAME) hardware instance
      \t */
      \tconstexpr $(_BasicInfo)(volatile $(_Type) * $(_basename)) : $(_basename)($(_basename)) {
      \t}
      \t\n
   ]]></template>

   <!-- BasicInfo Clock methods  -->
   <!-- Individual clock selection -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="=individual_clock_source">
   <![CDATA[
      \t/**
      \t * Get input clock frequency
      \t * (Individual to each peripheral)
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tvirtual uint32_t getInputClockFrequency() const = 0;
      \t\n
   ]]></template>

   <!-- Shared clock selection -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="=shared_clock_source" >
   <![CDATA[
      \t/**
      \t * Get input clock frequency
      \t * (Shared by all peripherals)
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tstatic inline uint32_t getInputClockFrequency() {
      \t   return SimInfo::get$(_Baseclass)Clock();
      \t}
      \t\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     START BasicInfo/Info duplicated methods -->
<!-- ====================================================================================================== -->

<for
   keys="   static    : const    : where     : guard                                      "
   values=" ''        : 'const ' : basicInfo : $(_BasicInfoGuard)                         ;
            'static ' : ''       : info      : $(_InfoGuard)                              "  >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field                     : set   : get   : clear : genCode                 : name"
        values="

         can_canctl0_rxfrm              : true  : true  : false : enableGettersAndSetters : ReceivedFrameFlag;
         can_canctl0_rxact              : false : true  : false : enableGettersAndSetters : ReceiverActiveStatus;
         can_canctl0_cswai              : true  : true  : false : enableGettersAndSetters : CanStopsInWaitMode;
         can_canctl0_synch              : false : true  : false : enableGettersAndSetters : SynchronizedStatus;
         can_canctl0_time               : true  : true  : false : enableGettersAndSetters : TimerEnable;
         can_canctl0_wupe               : true  : true  : false : enableGettersAndSetters : WakeupEnable;
         can_canctl0_slprq              : true  : true  : false : enableGettersAndSetters : SleepModeRequest;
         can_canctl0_initrq             : true  : true  : false : enableGettersAndSetters : InitializationModeRequest;

         can_canctl1_cane               : true  : true  : false : enableGettersAndSetters : MscanEnable;
         can_canctl1_clksrc             : true  : true  : false : enableGettersAndSetters : MscanClockSource;
         can_canctl1_loopb              : true  : true  : false : enableGettersAndSetters : LoopbackSelfTestMode;
         can_canctl1_listen             : true  : true  : false : enableGettersAndSetters : ListenOnlyMode;
         can_canctl1_borm               : true  : true  : false : enableGettersAndSetters : BusOffRecoveryMode;
         can_canctl1_wupm               : true  : true  : false : enableGettersAndSetters : WakeupMode;
         can_canctl1_slpak              : false : true  : false : enableGettersAndSetters : SleepModeAcknowledge;
         can_canctl1_initak             : false : true  : false : enableGettersAndSetters : InitializationModeAcknowledge;

         can_canbtr0_sjw                : true  : true  : false : enableGettersAndSetters : SynchronizationJumpWidth;
         can_canbtr0_brp                : true  : true  : false : enableGettersAndSetters : BaudRatePrescaler;

         can_canbtr1_samp               : true  : true  : false : enableGettersAndSetters : Sampling;
         can_canbtr1_tseg2              : true  : true  : false : enableGettersAndSetters : TimeSegment2;
         can_canbtr1_tseg1              : true  : true  : false : enableGettersAndSetters : TimeSegment1;

         can_canrflg_wupif              : true  : true  : false : enableGettersAndSetters : WakeUpInterruptFlag;
         can_canrflg_cscif              : true  : true  : false : enableGettersAndSetters : CanStatusChangeInterruptFlag;
         can_canrflg_rstat              : false : true  : false : enableGettersAndSetters : ReceiverStatus;
         can_canrflg_tstat              : false : true  : false : enableGettersAndSetters : TransmitterStatus;
         can_canrflg_ovrif              : true  : true  : false : enableGettersAndSetters : OverrunInterruptFlag;
         can_canrflg_rxf                : true  : true  : false : enableGettersAndSetters : ReceiveBufferFullFlag;

         can_canrier_wupie              : true  : true  : false : enableGettersAndSetters : WakeupInterruptEnable;
         can_canrier_cscie              : true  : true  : false : enableGettersAndSetters : CanStatusChangeInterruptEnable;
         can_canrier_rstate             : true  : true  : false : enableGettersAndSetters : ReceiverStatusChangeEnable;
         can_canrier_tstate             : true  : true  : false : enableGettersAndSetters : TransmitterStatusChangeEnable;
         can_canrier_ovrie              : true  : true  : false : enableGettersAndSetters : OverrunInterruptEnable;
         can_canrier_rxfie              : true  : true  : false : enableGettersAndSetters : ReceiverFullInterruptEnable;

         can_cantflg_txe                : true  : true  : false : enableGettersAndSetters : TransmitterBufferEmpty;

         can_cantier_txeie              : true  : true  : false : enableGettersAndSetters : TransmitterEmptyInterruptEnable;

         can_cantarq_abtrq              : true  : true  : false : enableGettersAndSetters : AbortRequest;

         can_cantaak_abtak              : false : true  : false : enableGettersAndSetters : AbortAcknowledge;

         can_cantbsel_tx                : true  : true  : false : enableGettersAndSetters : TransmitBufferSelect;

         can_canidac_idam               : true  : true  : false : enableGettersAndSetters : IdentifierAcceptanceMode;
         can_canidac_idhit              : false : true  : false : enableGettersAndSetters : IdentifierAcceptanceHitIndicator;

         can_canmisc_bohold             : true  : true  : false : enableGettersAndSetters : BusOffStateHoldUntilUserRequest;

         can_rdlr_rdlc                  : true  : true  : false : enableGettersAndSetters : DataLengthCodeBits" >
      <variableTemplate location="%(where)" condition="%(set)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition="%(get)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Get %description
         \t * (%variables)
         \t *
         \t * @return %tooltip
         \t */
         \t%(static)%returnType get%(name)() %(const){
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1c"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void clear%(name)(%params) %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1cIm"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void clear%(name)() %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for>
</for>

<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
XXXXXXXXXXXXXXXXXXXXXX
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo::Init class Member variables ________ -->

   <for keys=" type        : variables                                            : init    "
       values="%baseType   : can_canctl0_rxfrm,can_canctl0_cswai,can_canctl0_time,
                             can_canctl0_wupe,can_canctl0_slprq,can_canctl0_initrq :   0      ;
               %baseType   : can_canctl1_cane,can_canctl1_clksrc,can_canctl1_loopb,
                             can_canctl1_listen,can_canctl1_borm,can_canctl1_wupm :   0      ;
               %baseType   : can_canbtr0_sjw,can_canbtr0_brp                      :   0      ;
               %baseType   : can_canbtr1_samp,can_canbtr1_tseg2,can_canbtr1_tseg1 :   0      ;
               %baseType   : can_canrflg_wupif,can_canrflg_cscif,can_canrflg_ovrif,
                             can_canrflg_rxf                                      :   0      ;
               %baseType   : can_canrier_wupie,can_canrier_cscie,can_canrier_rstate,
                             can_canrier_tstate,can_canrier_ovrie,can_canrier_rxfie :   0      ;
               %baseType   : can_cantflg_txe                                      :   0      ;
               %baseType   : can_cantier_txeie                                    :   0      ;
               %baseType   : can_cantarq_abtrq                                    :   0      ;
               %baseType   : can_cantbsel_tx                                      :   0      ;
               %baseType   : can_canidac_idam                                     :   0      ;
               %baseType   : can_canmisc_bohold                                   :   0      ;
               %baseType   : can_rdlr_rdlc                                        :   0      " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx" >
      <![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]>
      </variableTemplate>
   </for>

   <!-- ____ BasicInfo::Init class Constructors ____________ -->

   <for keys="r"
      values="
            can_canctl0_rxfrm;can_canctl0_cswai;can_canctl0_time;
            can_canctl0_wupe;can_canctl0_slprq;can_canctl0_initrq;
            can_canctl1_cane;can_canctl1_clksrc;can_canctl1_loopb;
            can_canctl1_listen;can_canctl1_borm;can_canctl1_wupm;
            can_canbtr0_sjw;can_canbtr0_brp;
            can_canbtr1_samp;can_canbtr1_tseg2;can_canbtr1_tseg1;
            can_canrflg_wupif;can_canrflg_cscif;can_canrflg_ovrif;
            can_canrflg_rxf;
            can_canrier_wupie;can_canrier_cscie;can_canrier_rstate;
            can_canrier_tstate;can_canrier_ovrie;can_canrier_rxfie;
            can_cantflg_txe;
            can_cantier_txeie;
            can_cantarq_abtrq;
            can_cantbsel_tx;
            can_canidac_idam;
            can_canmisc_bohold;
            can_rdlr_rdlc
            " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::Init class      -->
<!-- ====================================================================================================== -->

   <!-- ____ Interrupt handling (only needed when not done in enablePeripheral.xml) _____________ -->

   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t/**
      \t * $(_Class) interrupt handler
      \t * Passes control to call-back function
      \t */
      \tstatic void irqHandler() {
      \t
      \t   // Execute call-back
      \t   sCallback($(irq_call_parameters));
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo class Configure methods ____ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param $(_basename)            Hardware instance pointer
      \t * @param clockFrequency  Clock frequency
      \t * @param init            Class containing initialisation values
      \t */
      \tstatic void configure(
      \t               volatile $(_Type) *$(_basename),
      \t               const Init    &init) {
      \t
      \t   //clockInitialise($(_basename), clockFrequency, init.clockFrequency);
      \t\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values=" can_canctl0_rxfrm,can_canctl0_cswai,can_canctl0_time,
               can_canctl0_wupe,can_canctl0_slprq,can_canctl0_initrq  : %configRegAssignment  ;
               can_canctl1_cane,can_canctl1_clksrc,can_canctl1_loopb,
               can_canctl1_listen,can_canctl1_borm,can_canctl1_wupm   : %configRegAssignment  ;
               can_canbtr0_sjw,can_canbtr0_brp                        : %configRegAssignment  ;
               can_canbtr1_samp,can_canbtr1_tseg2,can_canbtr1_tseg1   : %configRegAssignment  ;
               can_canrflg_wupif,can_canrflg_cscif,can_canrflg_ovrif,
               can_canrflg_rxf                                        : %configRegAssignment  ;
               can_canrier_wupie,can_canrier_cscie,can_canrier_rstate,
               can_canrier_tstate,can_canrier_ovrie,can_canrier_rxfie : %configRegAssignment  ;
               can_cantflg_txe                                        : %configRegAssignment  ;
               can_cantier_txeie                                      : %configRegAssignment  ;
               can_cantarq_abtrq                                      : %configRegAssignment  ;
               can_cantbsel_tx                                        : %configRegAssignment  ;
               can_canidac_idam                                       : %configRegAssignment  ;
               can_canmisc_bohold                                     : %configRegAssignment  ;
               can_rdlr_rdlc                                          : %configRegAssignment " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx" >
      <![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]>
      </variableTemplate>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const Init &init) const {
      \t
      \t   configure($(_basename), getInputClockFrequency(), init);
      \t}
      \t\n
   ]]>
   </template>
<!-- ====================================================================================================== -->
<!--     END BasicInfo class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START Info class      -->
<!-- ====================================================================================================== -->

   <template where="info" codeGenCondition="$(_InfoGuard)" condition="=individual_clock_source">
   <![CDATA[
      \t/**
      \t * Get input clock frequency
      \t * (Individual to each peripheral)
      \t *
      \t * @return Input clock frequency as a uint32_t in Hz
      \t */
      \tvirtual uint32_t getInputClockFrequency() const override {
      \t   return SimInfo::get$(_Class)Clock();
      \t}
      \t\n
   ]]></template>

   <!-- ____ Info constructors ________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t *   Default Constructor
      \t */
      \t$(_Info)() : $(_BasicInfo)($(_basename)) {
      \t   defaultConfigure();
      \t}
      \t
      \t/**
      \t *   Constructor
      \t */
      \t$(_Info)(const Init &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- Init configure methods -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount==1)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount>1)"
      variables="irq_enum"
      immediateVariables="_hardwareIrqCount">
   <![CDATA[
      \t   for(int index=0; index<$(_hardwareIrqCount); index++) {
      \t      if (init.callbacks[index] != nullptr) {
      \t         // Configure call-back
      \t         setCallback(%returnType0(index), init.callbacks[index]);
      \t         enableNvicInterrupts(%returnType0(index), init.priorities[index]);
      \t      }
      \t   }
      \t\n
   ]]>
   </variableTemplate>
   <template where="info" codeGenCondition="$(_InfoGuard)" condition="=individual_clock_source" >
   <![CDATA[
      \t   $(_BasicInfo)::configure($(_basename), SimInfo::get$(_Class)Clock(), init);
      \t}
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoGuard)" condition="=shared_clock_source" >
   <![CDATA[
      \t   $(_BasicInfo)::configure($(_basename), getInputClockFrequency(), init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {\n
   ]]>
   </template>
   <xi:include href="irqHandlingInit.xml"    />
   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
      separator=","
      terminator=","
      padToComments="40"
      variables="
            can_canctl0_rxfrm,can_canctl0_cswai,can_canctl0_time,
            can_canctl0_wupe,can_canctl0_slprq,can_canctl0_initrq,
            can_canctl1_cane,can_canctl1_clksrc,can_canctl1_loopb,
            can_canctl1_listen,can_canctl1_borm,can_canctl1_wupm,
            can_canbtr0_sjw,can_canbtr0_brp,
            can_canbtr1_samp,can_canbtr1_tseg2,can_canbtr1_tseg1,
            can_canrflg_wupif,can_canrflg_cscif,can_canrflg_ovrif,
            can_canrflg_rxf,
            can_canrier_wupie,can_canrier_cscie,can_canrier_rstate,
            can_canrier_tstate,can_canrier_ovrie,can_canrier_rxfie,
            can_cantflg_txe,
            can_cantier_txeie,
            can_cantarq_abtrq,
            can_cantbsel_tx,
            can_canidac_idam,
            can_canmisc_bohold,
            can_rdlr_rdlc
            " >
   <![CDATA[
      \t%initNonZeroValues\n
   ]]></variableTemplate>
   <template codeGenCondition="$(_InfoGuard)"
   ><![CDATA[
      \t};
      \t\n
   ]]></template>
<!-- ====================================================================================================== -->
<!--     END Info class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     Common      -->
<!-- ====================================================================================================== -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class representing $(_STRUCTNAME) instance
      \t */
      \ttypedef $(_BasicInfo) $(_Structname);
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Info) $(_Class);
      \t\n
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \t//typedef $(_Info) $(_Class);
      \t//using $(_Class) = $(_Class)Info;
      \t//class $(_Class) : public $(_Baseclass)Base_T<$(_Info)> {};
      \t//typedef $(_Baseclass)Base_T<$(_Info)> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="can_files" >
      <copy source="Project_Headers/can-MKE.h"  target="Project_Headers/can.h"  overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ____ Startup ____ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ____ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <aliasOption key="/SIM/sim_pinsel_$(_name)ps"  locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel0_$(_name)ps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel1_$(_name)ps" locked="false" optional="true" />

      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <aliasOption key="/SIM/sim_pinsel_mscanps"  locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel0_mscanps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel1_mscanps" locked="false" optional="true" />
   </category>

   <!--  ____ Signal mapping ____ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</peripheralPage>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- can0_mscan.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="Scalable Controller Area Network" >

   <constant key="suppressInstance"         type="Boolean" value="false"         />
   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"          />
   <constant key="irq_parameters"           type="String"  value="&quot;&quot;"  />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;&quot;"  />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="false"         />
   <xi:include href="_enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * %valueExpression[index]         Formatted value as numeric e.g. 0x12
    * %symbolicExpression[index] Symbolic formatted value e.g. AdcCompare_Disabled
    * %variable[index]                Variable name /ADC0/adc_sc2_acfe
    * %macro[index](value)            C register macro e.g. ADC_SC2_ACFGT(value)
    * %description[index]             Description from controlVar e.g. Compare Function Enable
    * %shortDescription[index]        Short description from controlVar e.g. Compare Function Enable
    * %tooltip[index]                 Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * %paramDescription[index]        Tool-tip from controlVar formatted as param description @param ...
    * %params                         Formatted parameter list for function
    * %paramType[index]               Based on enumStem or typename e.g. AdcCompare (or uint32_t)
    * %paramName[index]               Based on enumStem with lower-case first letter adcCompare
    * %paramType[index]               As for %paramType
    * %paramName[index]               As for %paramName
    * %valueExpression                Numeric variable value e.g. 0x3
    * %symbolicExpression        Symbolic variable value e.g. AdcCompare_Disabled
    * %fieldAssignment         Based on variable etc. Similar to %register = (%register&~%mask) | %paramName;
    * %maskingExpression       Based on variable etc. Similar to (%register&%mask)
    * %variable[index]                Variable name from condition
    * %mask[index]                    From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * %register[index]                Register associated with variable e.g. adc->APCTL1
    * %registerName[index]            Name of corresponding register (lowercase for Init()) e.g. apctl1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Class)BasicInfo&quot;" />

   <!-- ************* CANCTL0 ****************** -->

   <binaryOption key="can_canctl0_rxfrm" condition="can_canctl0_rxfrm_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanRxFrameFlag"
      hidden="true"
      derived="true"
      toolTip="This bit is read and clear only.\n
               It is set when a receiver has received a valid message correctly,"
      description="Received Frame Flag" >
      <choice name="No new message"         value="0" enum="NoNewMessage"/>
      <choice name="New message available"  value="1" enum="NewMessageAvailable"/>
   </binaryOption >

   <binaryOption key="can_canctl0_cswai" condition="can_canctl0_cswai_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanStopInWait"
      toolTip="This bit allows for lower power consumption in wait mode"
      description="CAN Stops in Wait Mode" >
      <choice name="Ignore wait mode"      value="0" enum="IgnoreWaitMode"/>
      <choice name="Suspend in wait mode"  value="1" enum="SuspendInWaitMode"/>
   </binaryOption >

   <binaryOption key="can_canctl0_time" condition="can_canctl0_time_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanTimer"
      toolTip="Enables an internal 16-bit wide free running timer which is clocked by the bit clock rate"
      description="Timer Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canctl0_wupe" condition="can_canctl0_wupe_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanWakeup"
      toolTip="Allows the MSCAN to restart from sleep mode or from power down mode when traffic detected on CAN"
      description="WakeUp Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canctl0_slprq" condition="can_canctl0_slprq_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanSleep"
      toolTip="This bit requests the MSCAN to enter sleep mode"
      description="Sleep Mode Request" >
      <choice name="Normal mode"          value="0" enum="NormalMode"/>
      <choice name="Initialisation mode"  value="1" enum="InitialisationMode"/>
   </binaryOption >

   <binaryOption key="can_canctl0_initrq" condition="can_canctl0_initrq_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanInitialisationReq"
      toolTip="When this bit is set by the CPU, the MSCAN skips to initialization mode.\n
               Any ongoing transmission or reception is aborted and synchronization to the CAN bus is lost.\n
               The module indicates entry to initialization mode by setting INITAK = 1"
      description="Initialization Mode Request" >
      <choice name="Normal mode"          value="0" enum="NormalMode"/>
      <choice name="Initialisation mode"  value="1" enum="InitialisationMode"/>
   </binaryOption >

   <!-- ************* CANCTL1 ****************** -->

   <binaryOption key="can_canctl1_cane" condition="can_canctl1_cane_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanEnable"
      toolTip="Module enable"
      description="MSCAN Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canctl1_clksrc" condition="can_canctl1_clksrc_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanClockSource"
      toolTip="This bit defines the clock source for the MSCAN module"
      description="MSCAN Clock Source" >
      <choice name="Oscillator clock"  value="0" enum="OscillatorClock"/>
      <choice name="Bus clock"         value="1" enum="BusClock"/>
   </binaryOption >

   <binaryOption key="can_canctl1_loopb" condition="can_canctl1_loopb_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanLoopback"
      toolTip="Allows the MSCAN to perform an internal loop-back test"
      description="Loop-back Self Test Mode" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canctl1_listen" condition="can_canctl1_listen_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanListen"
      toolTip="This bit configures the MSCAN as a CAN bus monitor"
      description="Listen Only Mode" >
      <choice name="Normal"            value="0" enum="Normal"/>
      <choice name="Listen only mode"  value="1" enum="ListenOnly"/>
   </binaryOption >

   <binaryOption key="can_canctl1_borm" condition="can_canctl1_borm_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanBusOffRecovery"
      toolTip="This bit configures the bus-off state recovery mode of the MSCAN\n
               See Bosch CAN 2.0A/B protocol specification"
      description="Bus-Off Recovery Mode" >
      <choice name="Automatic"     value="0" enum="Automatic"/>
      <choice name="User request"  value="1" enum="UserRequest"/>
   </binaryOption >

   <binaryOption key="can_canctl1_wupm" condition="can_canctl1_wupm_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanWakeUpMode"
      toolTip="If WUPE in CANCTL0 is enabled, this bit defines whether the integrated low-pass filter is\n
               applied to protect the MSCAN from spurious wakeup\n
               If enabled, MSCAN wakes only on a dominant pulse on the CAN bus of length Twup"
      description="WakeUp Mode" >
      <choice name="Wakup unfiltered"  value="0" enum="WakupUnfiltered"/>
      <choice name="Wakup filtered"    value="1" enum="WakupFiltered"/>
   </binaryOption >

   <!-- ************* CANBTR0 ****************** -->

   <choiceOption key="can_canbtr0_sjw" condition="can_canbtr0_sjw_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanJumpWidth"
      description="Synchronization Jump Width"
      toolTip="The synchronization jump width defines the maximum number of time quanta (Tq) clock cycles a bit can\n
               be shortened or lengthened to achieve resynchronization to data transitions on the CAN bus" >
      <choice value="0b00" name="1 Tq clock cycle"  enum="1cycle" />
      <choice value="0b01" name="2 Tq clock cycles" enum="2cycles" />
      <choice value="0b10" name="3 Tq clock cycles" enum="3cycles" />
      <choice value="0b11" name="4 Tq clock cycles" enum="4cycles" />
   </choiceOption>

   <intOption key="can_canbtr0_brp" condition="can_canbtr0_brp_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanBaudPrescale"
      enumType="uint8_t"
      description="Baud Rate Prescaler"
      toolTip="These bits determine the time quanta (Tq) clock which is used to build up the bit timing.\n
               Prescale = N+1"
      offset="-1"
   />

   <!-- ************* CANBTR1 ****************** -->

   <binaryOption key="can_canbtr1_samp" condition="can_canbtr1_samp_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanbtr1Samp"
      toolTip="This bit determines the number of CAN bus samples taken per bit time,\n
               For 3 samples, PHASE_SEG1 must be at least 2 time quanta (Tq)"
      description="Sampling" >
      <choice name="One sample per bit"     value="0" enum="OneSamplePerBit"/>
      <choice name="Three samples per bit"  value="1" enum="ThreeSamplesPerBit"/>
   </binaryOption >

   <choiceOption key="can_canbtr1_tseg1" condition="can_canbtr1_tseg1_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      enumType="uint8_t"
      typeName="CanTimeSegment1"
      description="Time Segment 1"
      toolTip="Time segments within the bit time fix the number of clock cycles per bit time and the location of the sample point.\n
               Time = N+1\n
               The bit time is determined by the oscillator frequency, the baud rate prescaler, and the number of time quanta (Tq) clock cycles per bit.\n
               Bit time = (1 + timesegment1 + timesegment2) * (Prescaler value)/ fCANCLK">
      <choice value="0b0011" name="4 Tq cycles"  enum="4_TqCycles"  />
      <choice value="0b0100" name="5 Tq cycle"   enum="5_TqCycles"  />
      <choice value="0b0101" name="6 Tq cycles"  enum="6_TqCycles"  />
      <choice value="0b0110" name="7 Tq cycle"   enum="7_TqCycles"  />
      <choice value="0b0111" name="8 Tq cycles"  enum="8_TqCycles"  />
      <choice value="0b1000" name="9 Tq cycle"   enum="9_TqCycle"   />
      <choice value="0b1001" name="10 Tq cycles" enum="10_TqCycles" />
      <choice value="0b1010" name="11 Tq cycle"  enum="11_TqCycl2s" />
      <choice value="0b1011" name="12 Tq cycles" enum="12_TqCycles" />
      <choice value="0b1100" name="13 Tq cycle"  enum="13_TqCycles" />
      <choice value="0b1101" name="14 Tq cycles" enum="14_TqCycles" />
      <choice value="0b1110" name="15 Tq cycle"  enum="15_TqCycles" />
      <choice value="0b1111" name="16 Tq cycles" enum="16_TqCycles" />
   </choiceOption>

   <choiceOption key="can_canbtr1_tseg2" condition="can_canbtr1_tseg2_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      enumType="uint8_t"
      typeName="CanTimeSegment2"
      description="Time Segment 2"
      toolTip="Time segments within the bit time fix the number of clock cycles per bit time and the location of the sample point.\n
               Time = N+1">
      <choice value="0b0000" name="1 Tq cycle"   enum="1_TqCycle"   />
      <choice value="0b0001" name="2 Tq cycles"  enum="2_TqCycles"  />
      <choice value="0b0010" name="3 Tq cycle"   enum="3_TqCycl2s"  />
      <choice value="0b0011" name="4 Tq cycles"  enum="4_TqCycles"  />
      <choice value="0b0100" name="5 Tq cycle"   enum="5_TqCycles"  />
      <choice value="0b0101" name="6 Tq cycles"  enum="6_TqCycles"  />
      <choice value="0b0110" name="7 Tq cycle"   enum="7_TqCycles"  />
      <choice value="0b0111" name="8 Tq cycles"  enum="8_TqCycles"  />
   </choiceOption>

   <!-- ************* CANRFLG ****************** -->

   <binaryOption key="can_canrflg_wupif" condition="can_canrflg_wupif_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrflgWupif"
      toolTip="If the MSCAN detects CAN bus activity while in sleep mode and CANTCTL0[WUPE] = 1, the module will\n
               set WUPIF. If not masked, a wake-up interrupt is pending while this flag is set"
      description="Wake-Up Interrupt Flag" >
      <choice name="No wakeup"         value="0" enum="NoWakeup"/>
      <choice name="Wakeup requested"  value="1" enum="WakeupRequested"/>
   </binaryOption >

   <binaryOption key="can_canrflg_cscif" condition="can_canrflg_cscif_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrflgCscif"
      toolTip="This flag is set when the MSCAN changes its current CAN bus status due to the actual value of the\n
               transmit error counter (TEC) and the receive error counter (REC)"
      description="CAN Status Change Interrupt Flag" >
      <choice name="No status change"  value="0" enum="NoStatusChange"/>
      <choice name="Status changed"    value="1" enum="StatusChanged"/>
   </binaryOption >

   <binaryOption key="can_canrflg_ovrif" condition="can_canrflg_ovrif_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrflgOvrif"
      toolTip="This flag is set when a data overrun condition occurs. If not masked, an error interrupt is pending while this
flag is set"
      description="Overrun Interrupt Flag" >
      <choice name="No overrun"        value="0" enum="NoOverrun"/>
      <choice name="Overrun detected"  value="1" enum="OverrunDetected"/>
   </binaryOption >

   <binaryOption key="can_canrflg_rxf" condition="can_canrflg_rxf_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrflgRxf"
      toolTip="RXF is set by the MSCAN when a new message is shifted in the receiver FIFO"
      description="Receive Buffer Full Flag" >
      <choice name="No new message"     value="0" enum="NoNewMessage"/>
      <choice name="Rx FIFO not empty"  value="1" enum="RxFifoNotEmpty"/>
   </binaryOption >

   <!-- ************* CANRIER ****************** -->

   <binaryOption key="can_canrier_wupie" condition="can_canrier_wupie_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierWupie"
      toolTip="WUPIE and WUPE must both be enabled if the recovery mechanism from stop or wait is required"
      description="WakeUp Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canrier_cscie" condition="can_canrier_cscie_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierCscie"
      description="CAN Status Change Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <choiceOption key="can_canrier_rstate" condition="can_canrier_rstate_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierRstate"
      toolTip="These RSTAT enable bits control the sensitivity level in which receiver state changes\n
               are causing CSCIF interrupts"
      description="Receiver Status Change Enable" >
      <choice name="Disabled"       value="0" enum="Disabled"/>
      <choice name="Bus off only"   value="1" enum="BusOffOnly"/>
      <choice name="Rx error only"  value="2" enum="RxErrorOnly"/>
      <choice name="All changes"    value="3" enum="AllChanges"/>
   </choiceOption >

   <choiceOption key="can_canrier_tstate" condition="can_canrier_tstate_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierTstate"
      toolTip="These TSTAT enable bits control the sensitivity level in which transmitter state
               changes are causing CSCIF interrupts"
      description="Transmitter Status Change Enable" >
      <choice name="Disabled"       value="0" enum="Disabled"/>
      <choice name="Bus off only"   value="1" enum="BusOffOnly"/>
      <choice name="Tx error only"  value="2" enum="TxErrorOnly"/>
      <choice name="All changes"    value="3" enum="AllChanges"/>
   </choiceOption >

   <binaryOption key="can_canrier_ovrie" condition="can_canrier_ovrie_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierOvrie"
      description="Overrun Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="can_canrier_rxfie" condition="can_canrier_rxfie_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanrierRxfie"
      description="Receiver Full Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <!-- ************* CANTFLG ****************** -->

   <binaryOption key="can_cantflg_txe" condition="can_cantflg_txe_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCantflgTxe"
      toolTip="These flags indicates that the associated transmit message buffer is empty, and\n
               thus not scheduled for transmission"
      description="Transmitter Buffer Empty" >
      <choice name="Buffer full"   value="0" enum="BufferFull"/>
      <choice name="Buffer empty"  value="1" enum="BufferEmpty"/>
   </binaryOption >

   <!-- ************* CANTIER ****************** -->

   <binaryOption key="can_cantier_txeie" condition="can_cantier_txeie_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCantierTxeie"
      description="Transmitter Empty Interrupt Enable" >
      <choice name="Disabled"    value="0" enum="Disabled"/>
      <choice name="Enabled"     value="1" enum="Enabled"/>
   </binaryOption >

   <!-- ************* CANTARQ ****************** -->

   <binaryOption key="can_cantarq_abtrq" condition="can_cantarq_abtrq_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCantarqAbtrq"
      toolTip="The CPU sets the ABTRQx bit to request that a scheduled message buffer (TXEx = 0) be aborted"
      description="Abort Request" >
      <choice name="No request"  value="0" enum="NoRequest"/>
      <choice name="Request"     value="1" enum="Request"/>
   </binaryOption >

   <!-- ************* CANTBSEL ****************** -->

   <intOption key="can_cantbsel_tx" condition="can_cantbsel_tx_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="uint8_t"
      description="Transmit Buffer Select"
      toolTip="The lowest numbered bit places the respective transmit buffer in the CANTXFG register space (e.g., TX1 = 1\n
               and TX0 = 1 selects transmit buffer TX0; TX1 = 1 and TX0 = 0 selects transmit buffer TX1)"
   />

   <!-- ************* CANIDAC ****************** -->

   <choiceOption key="can_canidac_idam" condition="can_canidac_idam_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanidacIdam"
      toolTip="The CPU sets these flags to define the identifier acceptance filter organization. In filter closed mode, no\n
               message is accepted such that the foreground buffer is never reloaded"
      description="Identifier Acceptance Mode" >
      <choice name="Two 32-bit filters"   value="0" enum="Two32BitFilters"/>
      <choice name="Four 16-bit filters"  value="1" enum="Four16BitFilters"/>
      <choice name="Eight 8-bit filters"  value="2" enum="Eight8BitFilters"/>
      <choice name="Filter closed"        value="3" enum="FilterClosed"/>
   </choiceOption >

   <!-- ************* CANMISC ****************** -->

   <binaryOption key="can_canmisc_bohold" condition="can_canmisc_bohold_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      typeName="CanCanmiscBohold"
      toolTip="If BORM is set in MSCAN Control Register 1 (CANCTL1), this bit indicates whether the module has\n
               entered the bus-off state. Clearing this bit requests the recovery from bus-off"
      description="Bus-off State Hold Until User Request" >
      <choice name="Not in bus-off state"  value="0" enum="NotInBusOffState"/>
      <choice name="In bus-off state"      value="1" enum="InBusOffState"/>
   </binaryOption >

   <!-- ************* CANRXERR ****************** -->

   <!-- ************* CANTXERR ****************** -->

   <!-- ************* CANIDAR ****************** -->

   <!-- ************* CANIDMR ****************** -->

   <!-- ************* CANIDAR ****************** -->

   <!-- ************* CANIDMR ****************** -->

   <!-- ************* REIDR ****************** -->

   <!-- ************* RSIDR ****************** -->

   <!-- ************* REDSR ****************** -->

   <!-- ************* RDLR ****************** -->

   <choiceOption key="can_rdlr_rdlc" condition="can_rdlr_rdlc_present"
      enabledBy="/$(_BASENAME)/enablePeripheralSupport"
      enumType="uint8_t"
      typeName="CanDataLength"
      description="Data Length Code Bits"
      toolTip="The data length code contains the number of bytes (data byte count) of the respective message. During\n
               the transmission of a remote frame, the data length code is transmitted as programmed while the number\n
               of transmitted data bytes is always 0. The data byte count ranges from 0 to 8 for a data frame" >
      <choice value="0b000" name="0 bytes" enum="0_bytes" />
      <choice value="0b001" name="1 bytes" enum="1_bytes" />
      <choice value="0b010" name="2 bytes" enum="2_bytes" />
      <choice value="0b011" name="3 bytes" enum="3_bytes" />
      <choice value="0b100" name="4 bytes" enum="4_bytes" />
      <choice value="0b101" name="5 bytes" enum="5_bytes" />
      <choice value="0b110" name="6 bytes" enum="6_bytes" />
      <choice value="0b111" name="6 bytes" enum="7_bytes" />
   </choiceOption>

   <!-- ************* RTSRH ****************** -->

   <!-- ************* RTSRL ****************** -->

   <!-- ************* TEIDR ****************** -->

   <!-- ************* TSIDR ****************** -->

   <!-- ************* TEDSR ****************** -->

   <!-- ************* TDLR ****************** -->

   <!-- ************* TBPR ****************** -->

   <!-- ************* TTSRH ****************** -->

   <!-- ************* TTSRL ****************** -->

<!-- Graphic here -->

   <for keys="field:name"
        values="
      can_canctl0_rxfrm:ClearRxFlag" >
      <setTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void %(name)() {
         \t   %register = %register | %mask;
         \t}\n\n
      ]]></setTemplate>
   </for>

   <setTemplate variables="can_cantflg_txe, can_cantbsel_tx" codeGenCondition="enableGettersAndSetters"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * %tooltip0
      \t * %tooltip1
      \t */
      \tstatic uint8_t getFreeTxBuffer() {
      \t
      \t   %register1 = %register0;
      \t   return %register1;
      \t}\n\n
   ]]></setTemplate>
   <for keys="field:name"
        values="
      can_canctl0_rxfrm:RxFrameFlag;
      can_canctl0_cswai:StopInWait;
      can_canctl0_time:Timer;
      can_canctl0_wupe:Canctl0Wupe;
      can_canctl0_slprq:Wakeup;
      can_canctl0_initrq:Sleep;
      can_canctl1_cane:Enable;
      can_canctl1_clksrc:ClockSource;
      can_canctl1_loopb:Loopback;
      can_canctl1_listen:ListenOnly;
      can_canctl1_borm:BusOffRecovery;
      can_canctl1_wupm:WakeupFilter;
      can_canbtr1_samp:Sampling;
      can_canrflg_wupif:WakeupInterruptFlag;
      can_canrflg_cscif:StatusChangeFlag;
      can_canrflg_ovrif:OverflowFlag;
      can_canrflg_rxf:BufferFullFlag;
      can_canrier_wupie:Interrupt;
      can_canrier_cscie:StatusChangeInterrupt;
      can_canrier_rstate:RxStatusChangeInterrupt;
      can_canrier_tstate:TxStatusChangeInterrupt;
      can_canrier_ovrie:Overrun;
      can_canrier_rxfie:RxFull;
      can_cantflg_txe:TxEmpty;
      can_cantier_txeie:TxEmptyInterrupt;
      can_cantarq_abtrq:Abort;
      can_canidac_idam:IdentifierAcceptanceMode;
      can_canmisc_bohold:BusOffStateHold" >
      <setTemplate variables="%(field)" codeGenCondition="enableGettersAndSetters"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment
         \t}
         \t
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></setTemplate>
   </for>

<!--   ========== CAN Init class =============================== -->

   <template key="init_description" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Class)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(uint32_t status) {
      \t *    (void) status;
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   CanCanctl0Rxfrm_NoNewMessage              // Received Frame Flag,
      \t *   CanCanctl0Cswai_IgnoreWaitMode            // CAN Stops in Wait Mode,
      \t *   CanCanctl0Time_Disabled                   // Timer Enable,
      \t *   CanCanctl0Wupe_Disabled                   // WakeUp Enable,
      \t *   CanCanctl0Slprq_NormalMode                // Sleep Mode Request,
      \t *   CanCanctl0Initrq_NormalMode               // Initialization Mode Request,
      \t *   CanCanctl1Cane_Disabled                   // MSCAN Enable,
      \t *   CanCanctl1Clksrc_OscillatorClock          // MSCAN Clock Source,
      \t *   CanCanctl1Loopb_Disabled                  // Loop-back Self Test Mode,
      \t *   CanCanctl1Listen_Normal                   // Listen Only Mode,
      \t *   CanCanctl1Borm_Automatic                  // Bus-Off Recovery Mode,
      \t *   CanCanctl1Wupm_WakupUnfiltered            // WakeUp Mode,
      \t *   0,                                        // Synchronization Jump Width,
      \t *   0,                                        // Baud Rate Prescaler,
      \t *   CanCanbtr1Samp_OneSamplePerBit            // Sampling,
      \t *   0,                                        // Time Segment 2,
      \t *   0,                                        // Time Segment 1,
      \t *   CanCanrflgWupif_NoWakeup                  // Wake-Up Interrupt Flag,
      \t *   CanCanrflgCscif_NoStatusChange            // CAN Status Change Interrupt Flag,
      \t *   CanCanrflgOvrif_NoOverrun                 // Overrun Interrupt Flag,
      \t *   CanCanrflgRxf_NoNewMessage                // Receive Buffer Full Flag,
      \t *   CanCanrierWupie_Disabled                  // WakeUp Interrupt Enable,
      \t *   CanCanrierCscie_Disabled                  // CAN Status Change Interrupt Enable,
      \t *   CanCanrierRstate_Disabled                 // Receiver Status Change Enable,
      \t *   CanCanrierTstate_Disabled                 // Transmitter Status Change Enable,
      \t *   CanCanrierOvrie_Disabled                  // Overrun Interrupt Enable,
      \t *   CanCanrierRxfie_Disabled                  // Receiver Full Interrupt Enable,
      \t *   CanCantflgTxe_BufferFull                  // Transmitter Buffer Empty,
      \t *   CanCantierTxeie_Disabled                  // Transmitter Empty Interrupt Enable,
      \t *   CanCantarqAbtrq_NoRequest                 // Abort Request,
      \t *   0,                                        // Transmit Buffer Select,
      \t *   CanCanidacIdam_Two32BitFilters            // Identifier Acceptance Mode,
      \t *   CanCanmiscBohold_NotInBusOffState         // Bus-off State Hold Until User Request,
      \t *   0,                                        // Data Length Code Bits,
      \t *
      \t *    $(_name)Callback,                // Call-back to execute on event - call-back function name
      \t *    NvicPriority_Low,                // Priority for interrupt - Low
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
   ]]>
   </template>

   <template namespace="usbdm" >
   <![CDATA[
      class $(_Class)BasicInfo {
      \t
      public:\n
   ]]>
   </template>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" discardRepeats="true"
      variables="/$(_BASENAME)/irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></initialValueTemplate>

   <template namespace="usbdm" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Class) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));\n
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for ISR */
      \tstatic CallbackFunction sCallback;
      \t
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t * @param[in]  canCallback Callback function to execute on interrupt
      \t */
      \tstatic void setCallback(CallbackFunction canCallback) {
      \t   if (canCallback == nullptr) {
      \t      canCallback = unhandledCallback;
      \t   }
      \t   usbdm_assert(
      \t         (sCallback == unhandledCallback) || (sCallback == canCallback),
      \t         "Handler already set");
      \t   sCallback = canCallback;
      \t}
      \t
      \t/**
      \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t */
      \tstatic void irqHandler() {
      \t
      \t   //.....IRQ handler code here..........
      \t
      \t   // Execute call-back
      \t   sCallback($(irq_call));
      \t   return;
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback for programmatically set handler */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallback = $(_Class)Info::unhandledCallback;
      \t\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" >
   <![CDATA[
      $(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

<!--   Member variables -->

   <initialValueTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canctl0_rxfrm,can_canctl0_cswai,can_canctl0_time,can_canctl0_wupe,can_canctl0_slprq,can_canctl0_initrq"
   ><![CDATA[
      \t   /// Control Register 0
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canctl1_cane,can_canctl1_clksrc,can_canctl1_loopb,can_canctl1_listen,can_canctl1_borm,can_canctl1_wupm"
   ><![CDATA[
      \t   /// Control Register 1
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canbtr0_sjw,can_canbtr0_brp"
   ><![CDATA[
      \t   /// Bus Timing Register 0
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canbtr1_samp,can_canbtr1_tseg2,can_canbtr1_tseg1"
   ><![CDATA[
      \t   /// Bus Timing Register 1
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canrflg_wupif,can_canrflg_cscif,can_canrflg_ovrif,can_canrflg_rxf"
   ><![CDATA[
      \t   /// Receiver Flag Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canrier_wupie,can_canrier_cscie,can_canrier_rstate,can_canrier_tstate,can_canrier_ovrie,can_canrier_rxfie"
   ><![CDATA[
      \t   /// Receiver Interrupt Enable Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_cantflg_txe"
   ><![CDATA[
      \t   /// Transmitter Flag Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_cantier_txeie"
   ><![CDATA[
      \t   /// Transmitter Interrupt Enable Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_cantarq_abtrq"
   ><![CDATA[
      \t   /// Transmitter Message Abort Request Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canidac_idam"
   ><![CDATA[
      \t   /// Identifier Acceptance Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_canmisc_bohold"
   ><![CDATA[
      \t   /// Miscellaneous Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      variables="can_rdlr_rdlc"
   ><![CDATA[
      \t   /// Receive Data Length Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName0 = %symbolicExpression1;
      \t\n
   ]]></initialValueTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(Info::DefaultInitValue);
      \t}
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t   // ..........  Configure ...........
      \t
      \t   // Enable peripheral clock
      \t   Info::enableClock();
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
             condition="irqHandlingMethod" ><![CDATA[
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      Info::setCallback(init.callbackFunction);
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/InitMethod" namespace="all" discardRepeats="true" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
      \t   // ..........  Regs to init .......... ;
      \t   can->CANCTL0    = init.canctl0;
      \t   can->CANCTL1    = init.canctl1;
      \t   can->CANBTR0    = init.canbtr0;
      \t   can->CANBTR1    = init.canbtr1;
      \t   can->CANRFLG    = init.canrflg;
      \t   can->CANRIER    = init.canrier;
      \t   can->CANTFLG    = init.cantflg;
      \t   can->CANTIER    = init.cantier;
      \t   can->CANTARQ    = init.cantarq;
      \t   can->CANTBSEL    = init.cantbsel;
      \t   can->CANIDAC    = init.canidac;
      \t   can->CANMISC    = init.canmisc;
      \t   can->CANRXERR    = init.canrxerr;
      \t   can->CANTXERR    = init.cantxerr;
      \t   can->CANIDAR    = init.canidar;
      \t   can->CANIDMR    = init.canidmr;
      \t   can->CANIDAR    = init.canidar;
      \t   can->CANIDMR    = init.canidmr;
      \t   can->REIDR    = init.reidr;
      \t   can->RSIDR    = init.rsidr;
      \t   can->REDSR    = init.redsr;
      \t   can->RDLR    = init.rdlr;
      \t   can->TEIDR    = init.teidr;
      \t   can->TSIDR    = init.tsidr;
      \t   can->TEDSR    = init.tedsr;
      \t   can->TDLR    = init.tdlr;
      \t   can->TBPR    = init.tbpr;
      \t   can->TTSRH    = init.ttsrh;
      \t   can->TTSRL    = init.ttsrl;
      \t}
      \t\n
   ]]></template>

<!--   Constructors -->

   <setTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <setTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></setTemplate>

   <for keys="r"
      values="
            can_canctl0_rxfrm;
            can_canctl0_cswai;
            can_canctl0_time;
            can_canctl0_wupe;
            can_canctl0_slprq;
            can_canctl0_initrq;
            can_canctl1_cane;
            can_canctl1_clksrc;
            can_canctl1_loopb;
            can_canctl1_listen;
            can_canctl1_borm;
            can_canctl1_wupm;
            can_canbtr0_sjw;
            can_canbtr1_samp;
            can_canrflg_wupif;
            can_canrflg_cscif;
            can_canrflg_ovrif;
            can_canrflg_rxf;
            can_canrier_wupie;
            can_canrier_cscie;
            can_canrier_rstate;
            can_canrier_tstate;
            can_canrier_ovrie;
            can_canrier_rxfie;
            can_cantflg_txe;
            can_cantier_txeie;
            can_cantarq_abtrq;
            can_canidac_idam;
            can_canmisc_bohold;
            can_rdlr_rdlc
            " >
      <setTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>

   <for keys="r"
      values="
            can_canbtr0_brp;
            can_canbtr1_tseg2;
            can_canbtr1_tseg1
            " >
      <setTemplate namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         \t    * @param value %description
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%paramType0 value, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask0) | %macro0(value);
         \t   }
         \t\n
      ]]>
      </setTemplate>
   </for>


<!--   Default Initialisation value -->

   <initialValueTemplate codeGenCondition="/$(_BASENAME)/enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            can_canctl0_rxfrm,
            can_canctl0_cswai,
            can_canctl0_time,
            can_canctl0_wupe,
            can_canctl0_slprq,
            can_canctl0_initrq,
            can_canctl1_cane,
            can_canctl1_clksrc,
            can_canctl1_loopb,
            can_canctl1_listen,
            can_canctl1_borm,
            can_canctl1_wupm,
            can_canbtr0_sjw,
            can_canbtr0_brp,
            can_canbtr1_samp,
            can_canbtr1_tseg2,
            can_canbtr1_tseg1,
            can_canrflg_wupif,
            can_canrflg_cscif,
            can_canrflg_ovrif,
            can_canrflg_rxf,
            can_canrier_wupie,
            can_canrier_cscie,
            can_canrier_rstate,
            can_canrier_tstate,
            can_canrier_ovrie,
            can_canrier_rxfie,
            can_cantflg_txe,
            can_cantier_txeie,
            can_cantarq_abtrq,
            can_canidac_idam,
            can_canmisc_bohold,
            can_rdlr_rdlc
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <template namespace="usbdm" >
      <![CDATA[
      \t}; // $(_Class)BasicInfo::Init\n\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" >
      <![CDATA[
      }; // $(_Class)BasicInfo\n\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" namespace="all" codeGenCondition="/$(_BASENAME)/enablePeripheralSupport" ><![CDATA[
   \t/**
   \t * Class representing $(_NAME)
   \t */
   \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id = "can_files" >
      <copy source="Project_Headers/can-MKE.h"  target="Project_Headers/can.h"  overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" namespace="all" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" namespace="all" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* Signal mapping ****************** -->
   <category name="SIM" description="Pin mapping and clock enables">
      <aliasOption key="/SIM/sim_scgc_$(_name)"      locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel_$(_name)ps"  locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel0_$(_name)ps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel1_$(_name)ps" locked="false" optional="true" />

      <aliasOption key="/SIM/sim_scgc_mscan"      locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel_mscanps"  locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel0_mscanps" locked="false" optional="true" />
      <aliasOption key="/SIM/sim_pinsel1_mscanps" locked="false" optional="true" />
   </category>

   <signals enabledBy="enablePeripheralSupport" locked="true" />

</peripheralPage>

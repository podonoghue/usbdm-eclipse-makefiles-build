<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- tpm_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <!-- ____ Class Declaration ________ -->
   <constant key="_basicInfo_declaration" type="String"
      value='"class $(_Structname)BasicInfo : public $(_Baseclass)CommonInfo {\n
      \n
      public:\n"' />

   <constant key="_class_declaration" type="String"
      value='"$(_Class)Info : public $(_Structname)BasicInfo"' />

   <constant key = "disable_peripheral"      value = '"tpm->SC = TPM_SC_CMOD(0);"' type="String"  />

   <equation key="irq_parameters"            value=""  />
   <equation key="irq_dummy_parameters"      value=""  />
   <equation key="irq_call"                  value=""  />
   <equation key="generateDefault"           value="false"         />
   <equation key="configureInStartupDefault" value="false"         />
   <xi:include href="enablePeripheral.xml"  />

   <!-- ____ Constants ____________ -->

   <template><![CDATA[
      \t//! Number of channels implemented
      \tstatic constexpr unsigned NumChannels = $(_channelCount);

      \t//! Number of channel event vectors implemented
      \tstatic constexpr unsigned NumChannelVectors = $(_hardwareIrqCount);\n\n
   ]]></template>

   <!-- ____ Hidden ________ -->

   <binaryOption key="tpm_sc_tof" condition="tpm_sc_tof_present"
      typeName="TpmOverflowFlag"
      baseType="uint8_t"
      derived="true"
      hidden="true"
      description="Timer Overflow Flag"
      toolTip="Set by hardware when the TPM counter passes the value in the MOD register.\n
               The TOF bit is cleared by reading the SC register while TOF is set and then\n
               writing a 0 to TOF bit. Writing a 1 to TOF has no effect.\n
               If another overflow occurs between the read and write operations,\n
               the write operation has no effect; therefore, TOF remains set indicating\n
               an overflow has occurred. In this case, a TOF interrupt request is\n
               not lost due to the clearing sequence for a previous TOF." >
      <choice value="0" name="No Overflow"            enum="NoOverflow"  />
      <choice value="1" name="Counter Has Overflowed" enum="CounterHasOverflowed"  />
   </binaryOption>

   <intOption key="tpm_status_status" condition="tpm_status_present"
      typeName="TpmEventStatus"
      baseType='=Exists("tpm_status_tof_present")?"uint16_t":"uint8_t"'
      derived="true"
      hidden="true"
      description="Timer Events"
      toolTip="The STATUS register contains a copy of the CHnF status flag \n
               from the CnSC for each TPM channel. (May also include SC[TOF])"
   />

   <!-- ____ Main Configuration ________ -->

   <title description="Main configuration"/>

   <choiceOption key="mode"
      enabledBy="enablePeripheralSupport"
      target="tpm_sc_cpwms"
      description="Main operating mode for TPM"
      toolTip="Main Mode"
      disabledValue="0" >
      <choice value="0" ref="0" name="Disabled"     />
      <choice value="1" ref="0" name="Left aligned"
         toolTip="Left aligned (counter runs [0...mod]),  supports:\n
                 - Input capture\n
                 - Dual-edge capture\n
                 - Output compare\n
                 - Edge-aligned PWM\n
                 - Combined PWM"       />
      <choice value="2" ref="1" name="Centre aligned"
         toolTip="Centre aligned (counter runs [(0...mod...0)]), supports:\n
          - Centre-aligned PWM"
      />
      <choice value="3" ref="0" name="Quadrature decoder" condition="tpm_qdctrl_quaden_present"
         toolTip="Quadrature Decode (counter clocked by decoder), supports:\n
          - Quadrature decode using two channels"
      />
      <choice value="0" ref="0" name="Disabled" enabledBy="false" />
   </choiceOption>

   <constant key="None"    value="0"   type="Long" />
   <constant key="Left"    value="1"   type="Long" />
   <constant key="Centre"  value="2"   type="Long" />
   <constant key="Quad"    value="3"   type="Long" />

   <binaryOption key="tpm_sc_cpwms"
      hiddenBy="(mode==(None))"
      locked="true"
      enabledBy="enablePeripheralSupport"
      typeName="TpmCountMode"
      baseType="uint8_t"
      description="Counting mode"
      toolTip="Counting Mode" >
      <choice value="0" name="Left-aligned (count up)"        toolTip="Left-aligned   (0...mod)"     enum="LeftAligned"    />
      <choice value="1" name="Centre-aligned (count up-down)" toolTip="Centre-aligned (0...mod...0)" enum="CentreAligned"  />
   </binaryOption>

   <!-- ____ Main Counter ________ -->
   <title description="Main Counter" />

   <!-- MCG clock -->
   <choiceOption key="tpmClockConfig" condition="/MCG/_present"
      description="Clock configuration"
      target="system_tpm_clock"
      toolTip="Selects the clock configuration used for calculations if System TPM Clock is chosen as clock source" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_tpm_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_tpm_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_tpm_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_tpm_clock[3]"  />
   </choiceOption>

   <intOption key="system_tpm_clock"
      locked="true"
      derived="true"
      description="System TPM Clock"
      toolTip="Based on current clock configuration"
      units="Hz"
      />

   <choiceOption key="tpm_sc_cmod" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      description="Clock Source"
      typeName="TpmClockSource"
      baseType="uint8_t"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module" >
      <choice value="0" name="Disabled"              enum="Disabled"            ref="disabled"                       code="0" />
      <choice value="1" name="System TPM Clock"      enum="SystemTpmClock"      ref="system_tpm_clock"               code="SimInfo::getTpmClock()"                  isDefault="true"  />
      <choice value="2" name="External clock"        enum="ExternalClock"       ref="/SIM/$(_name)ExternalClock"     code="SimInfo::get$(_Class)ExternalClockFrequency()" condition="/SIM/$(_name)ExternalClock" />
   </choiceOption>

   <binaryOption key="externalClockUsed"
      ref="tpm_sc_cmod==2"
      derived="true"
      locked="true"
      hidden="true" >
      <choice value="0" name="External clock unused" />
      <choice value="1" name="External clock used"   />
   </binaryOption>

   <intOption key="inputClockFrequency"
      enabledBy="enablePeripheralSupport"
      locked="true"
      description="Frequency of input clock to timer"
      toolTip="This is the main clock for the Timer Counter"
      derived="true"
      units="Hz"/>

   <choiceOption key="tpm_sc_ps"
      hiddenBy="(mode==(None))"
      enabledBy="enablePeripheralSupport"
      description="Counter clock prescaler"
      typeName="TpmPrescale"
      baseType="uint8_t"
      target="clock"
      toolTip="Selects the prescaler for the module" >
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"        enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="(inputClockFrequency)/2."   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="(inputClockFrequency)/4."   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="(inputClockFrequency)/8."   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="(inputClockFrequency)/16."  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="(inputClockFrequency)/32."  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="(inputClockFrequency)/64."  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="(inputClockFrequency)/128." enum="DivBy128" />
   </choiceOption>

   <floatOption key="clock"
      hiddenBy="mode==(None,Quad)"
      description="Counter tick rate"
      toolTip="The tick rate of the main counter"
      derived="true"
      locked="true"
      units="Hz"
    />

   <floatOption key="clockPeriod"
      hidden="true"
      ref="(1.0/clock)"
      locked="true"
      derived="true"
   />

   <binaryOption key="freeRunningCounter"
      hiddenBy="mode!=(Left,Quad)"
      enabledBy="!(mode!=(Left,Quad))"
      description="Counter free-running"
      toolTip="Forces the full range for counter [0..65535]\n
               This is usually convenient for input-capture operations\n
               making use of modulo-16 calculations with counter roll-overs"
      name="freeRunning" >
      <choice value="0" name="Period mode"       />
      <choice value="1" name="Free-running mode" />
   </binaryOption>

   <intOption key="tpm_mod_mod"
      hiddenBy="mode==(None)"
      enabledBy="!freeRunningCounter"
      description="End value for counter"
      toolTip="The timer counts from 0 to this value"
      valueFormat="%s"
      baseType="uint16_t"
      units="ticks"
      value="65535" min="0" max="65535" />

   <intOption key="tpm_cnt_count" condition="tpm_cnt_count_present"
      hidden="true"
      locked="true"
      derived="true"
      description="Main counter (writing any value clears counter)"
      toolTip="Main counter for Timer"
      baseType="uint16_t"
      units="ticks"
      value="0" />

   <floatOption key="tpm_modPeriod"
      enabledBy="inputClockFrequency!=0"
      hiddenBy="mode==(None,Quad)"
      ref="clockPeriod*(tpm_sc_cpwms?(2*(tpm_mod_mod)):(tpm_mod_mod+1))"
      unlockedBy="!freeRunningCounter"
      description="Period or minimum interval of timer"
      toolTip="In left-aligned or centre-aligned this is the period of the timer\n
               In free-running mode it is the minimum interval"
      derived="true"
      units="s" />

   <choiceOption key="tpm_sc_action" condition="tpm_sc_toie_present&amp;&amp;tpm_sc_dma_present"
      hiddenBy="mode==(None)"
      valueFormat="TPM_SC_TOIE(%s),TPM_SC_DMA(%s)"
      typeName="TpmOverflowAction"
      baseType="uint16_t"
      description="Action on Counter overflow"
      toolTip="Enable interrupt and/or DMA on counter overflow" >
       <choice value="0,0" name="No action"                    enum="None"             />
       <choice value="0,1" name="DMA request"                  enum="Dma"              />
       <choice value="1,0" name="Interrupt request"            enum="Interrupt"        enabledBy="irqHandlingMethod" />
       <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  enabledBy="irqHandlingMethod" />
   </choiceOption>

   <binaryOption key="tpm_sc_action" condition="tpm_sc_toie_present&amp;&amp;!tpm_sc_dma_present"
      hiddenBy="mode==(None)"
      enabledBy="irqHandlingMethod"
      valueFormat="TPM_SC_TOIE(%s)"
      baseType="uint8_t"
      typeName="TpmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt on counter overflow" >
      <choice value="0" name="No action"          enum="None"       />
      <choice value="1" name="Overflow Interrupt" enum="Interrupt"  />
   </binaryOption>

   <choiceOption key="tpm_channel_number"
      hidden="true"
      derived="true"
      baseType="uint8_t"
      valueFormat="%s"
      typeName="TpmChannelNum"
      description="Channel Number"
      toolTip="Selects a channel" >
      <choiceExpansion value="%(ch)" name="Channel %(ch)" enum="%(ch)" keys="ch" dim="8" />
      <choice value="(uint8_t(-1))" name="No Channel"     enum="None" />
   </choiceOption>

   <!--  ____ Hidden info ________________ -->

   <category hidden="true">

   <!-- ____ Independent Channels ________________ -->

   <for keys="ch" dim="=_channelCount" >

      <choiceOption key="tpm_cnsc_mode_independent[%(ch)]"
         signal="$(_NAME)_CH%(ch)"
         enabledBy="enablePeripheralSupport&amp;&amp;!channelPairing[%(ch)&amp;0b1110]"
         valueFormat="TPM_CnSC_MS(%s),TPM_CnSC_ELS(%s)"
         baseType="uint16_t"
         typeName="TpmChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (PWM/Input capture/Output compare)" >
         <!--              +......... MS(B:A)  -->
         <!--              |    +.... ELS(B:A) -->
         <!--              |    |              -->
         <!--              v    v              -->
          <choice value="0b00,0b00"  name="Channel Disabled"                    enum="Disabled"                 />
          <!-- 1-3 -->
          <choice value="0b00,0b01"  name="Input Capture Rising-edge"           enum="InputCaptureRisingEdge"   />
          <choice value="0b00,0b10"  name="Input Capture Falling-edge"          enum="InputCaptureFallingEdge"  />
          <choice value="0b00,0b11"  name="Input Capture Either-edge"           enum="InputCaptureEitherEdge"   />
          <!-- 4-7 -->
          <choice value="0b01,0b00"  name="Software Compare (pin unused)"       enum="OutputCompare"            />
          <choice value="0b01,0b01"  name="Output Compare Toggle"               enum="OutputCompareToggle"      />
          <choice value="0b01,0b10"  name="Output Compare Clear"                enum="OutputCompareClear"       />
          <choice value="0b01,0b11"  name="Output Compare Set"                  enum="OutputCompareSet"         />
          <!-- 8-9 -->
          <choice value="0b10,0b10"  name="Pwm High-true Pulses (Edge/Centre)"  enum="PwmHighTruePulses"        />
          <choice value="0b10,0b01"  name="Pwm Low-true Pulses (Edge/Centre)"   enum="PwmLowTruePulses"         />
          <choice value="0b11,0b10"  name="Pulse Low on Match"                  enum="PulseLow"                 />
          <choice value="0b11,0b01"  name="Pulse High on Match"                 enum="PulseHigh"                />
      </choiceOption>

      <choiceOption key="tpm_cnsc_action_independent[%(ch)]" condition="tpm_cnsc_chie_present&amp;&amp;tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]!=0)"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]!=0)"
         valueFormat="TPM_CnSC_CHIE(%s),TPM_CnSC_DMA(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="tpm_cnsc_action_independent[%(ch)]" condition="tpm_cnsc_chie_present&amp;&amp;!tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]!=0)"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="TPM_CnSC_CHIE(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <choiceOption key="tpm_filter_fval_independent[%(ch)]" condition="tpm_filter_ch%(ch)fval_present"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]!=(0,4))"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]!=(0,4))"
         description="Channel Filter"
         typeName="TpmFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel.\n
                  On input capture this acts as a filter\n
                  On output compare this delays the output to provide dead-time between outputs" >
         <choice          value="0"         name="Filter Disabled"                        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="tpm_filter_fval_delay_independent[%(ch)]" condition="tpm_filter_fval_independent[%(ch)]"
         hiddenBy="!(tpm_filter_fval_independent[%(ch)]!=(0,4))"
         enabledBy="(tpm_filter_fval_independent[%(ch)]!=(0,4))"
         description="Channel Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*tpm_filter_fval_independent[%(ch)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <binaryOption key="tpm_cnsc_icrst_independent[%(ch)]" condition="tpm_cnsc_icrst_present"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         valueFormat="TPM_CnSC_ICRST(%s)"
         typeName="TpmChannelReset"
         baseType="uint8_t"
         description="Reset counter on channel IC event"
         toolTip="TPM counter reset is driven by the selected event of the channel\n
                  in the Input Capture mode.\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1." >
         <choice value="0" name="Disabled" enum="Disabled" />
         <choice value="1" name="Enabled"  enum="CounterReset"  />
      </binaryOption>

      <intOption key="tpm_cnv_independent[%(ch)]"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]>=4)"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]>=4)"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="tpm_mod_mod" />

      <floatOption key="tpm_cnvEventTime_independent[%(ch)]"
         hiddenBy="!(tpm_cnsc_mode_independent[%(ch)]>=4)"
         enabledBy="(tpm_cnsc_mode_independent[%(ch)]>=4)"
         ref="tpm_cnv_independent[%(ch)]*clockPeriod"
         valueFormat="%s"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value, converted to ticks, is compared against the main counter"
         value="0" min="0" max="tpm_mod_mod*clockPeriod" />

      <floatOption key="tpm_cnvHighTime_independent[%(ch)]"
         hiddenBy="tpm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="(tpm_cnsc_mode_independent[%(ch)]==8)?
            (tpm_sc_cpwms?2.0:1.0)*(tpm_cnv_independent[%(ch)])*clockPeriod:
            (tpm_sc_cpwms?2.0:1.0)*(tpm_mod_mod-tpm_cnv_independent[%(ch)])*clockPeriod"
         valueFormat="%s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="tpm_cnvDutyCycle_independent[%(ch)]"
         hiddenBy="tpm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="tpm_cnvHighTime_independent[%(ch)]/tpm_modPeriod"
         valueFormat="%s"
         units="percent"
         description="Output duty cycle as pecentage"
         toolTip="Calculated duty cycle" />
   </for>

<if condition="tpm_combine_present">

   <!-- ____ Paired Channels ________________ -->

   <!-- Odd channels when paired - Dual-edge Capture or PWM
        This combines the two separate sets of values from:
        - tpm_cnsc_secondEdge[%(oddCh)]
        - tpm_cnsc_mode_odd_pwm[%(oddCh)]
   -->
   <choiceOption key="tpm_cnsc_mode_odd[1]"
      derived="true"
      valueFormat="TPM_CnSC_ELS(%s)"
      description="Odd channel mode"
      typeName="TpmOddChannelMode"
      disabledValue="0b00"
      toolTip="Behaviour of second channel when channels are paired"
      >
      <!--              +...... ELS(B:A)
                        |
                        v                  -->
       <choice value="0b00" name="Pin Disabled"         enum="Disabled"
          toolTip="The pin associated with the second channel is not used by the TPM" />
        <!-- = tpm_cnsc_secondEdge -->
       <choice value="0b01" name="Capture Rising-edge"   enum="RisingEdge"
         toolTip="Odd channel captures CNV on next rising edge of channel input" />
       <choice value="0b10" name="Capture Falling-edge"  enum="FallingEdge"
         toolTip="Odd channel captures CNV on next falling edge of channel input" />
       <choice value="0b11" name="Capture Either-edge"   enum="EitherEdge"
         toolTip="Odd channel captures CNV on next rising or falling edge of channel input" />
        <!-- = tpm_cnsc_mode_odd_pwm -->
       <choice value="0b01" name="Normal"         enum="Normal"
         toolTip="The odd channel pin equals the even channel pin (ignoring dead-time)" />
       <choice value="0b10" name="Complementary"  enum="Complementary"
         toolTip="The odd channel pin is the complement of the even channel pin (ignoring dead-time)" />
   </choiceOption>

   <!-- COMBINE.COMSWAP -->
   <choiceOption key="tpm_combine_comswap" condition="tpm_combine_comswap0_present"
      valueFormat="TPM_COMBINE_COMSWAP0(%s)"
      hiddenBy="true"
      typeName="TpmCombineSwap"
      baseType="uint8_t"
      description="Combine Channel Even and Odd Swap"
      toolTip="When set, the even channel is used for the input capture and 1st compare,\n
               the odd channel is used for the 2nd compare."
      derived="true" >
      <choice value="0"  name="Even channel 1st compare" enum="EvenChannelCompare" />
      <choice value="1"  name="Odd channel 1st compare"  enum="OddChannelCompare"  />
      <choice value="0"  name="Even channel capture"     enum="EvenChannelCapture" />
      <choice value="1"  name="Odd channel capture"      enum="OddChannelCapture"  />
   </choiceOption>

   <for keys="    Num : evenCh : oddCh"
        values="   0  :   0  :   1;
                   1  :   2  :   3;
                   2  :   4  :   5;
                   3  :   6  :   7" >

      <if condition="=%(evenCh) >=_channelCount">
         <break/>
      </if>

      <!-- Even channels when paired -->
      <choiceOption key="tpm_cnsc_mode_even[%(evenCh)]"
         enabledBy="enablePeripheralSupport&amp;&amp;channelPairing[%(evenCh)]"
         valueFormat="(TPM_COMBINE_COMBINE0(%s)&lt;&lt;8),TPM_CnSC_MS(%s),TPM_CnSC_ELS(%s)"
         baseType="uint16_t"
         typeName="TpmEvenChannelMode"
         description="Paired Channel mode and Ch %(evenCh) function"
         toolTip="Determines channel operation (Combined PWM or Dual-edge capture)"
         >
         <!--            +............ COMBINE
                         |   +........ MS(B:A)
                         |   |    +... ELS(B:A)
                         |   |    |
                         v   v    v                 -->
          <choice value="0,0b00,0b00" name="Channel Pair Disabled"             enum="Disabled"                         />
          <!-- 1-2 .............. -->
          <choice value="1,0b10,0b01" name="Combined PWM Positive-pulse"       enum="CombinePositivePulse"             />
          <choice value="1,0b10,0b10" name="Combine PWM Negative-pulse"        enum="CombineNegativePulse"             />
          <!-- 3-5 .............. -->
          <choice value="1,0b00,0b01" name="Dual-edge Capture Rising-edge"     enum="DualEdgeCaptureRisingEdge"        />
          <choice value="1,0b00,0b10" name="Dual-edge Capture Falling-edge"    enum="DualEdgeCaptureFallingEdge"       />
          <choice value="1,0b00,0b11" name="Dual-edge Capture Either-edge"     enum="DualEdgeCaptureEitherEdge"        />
      </choiceOption>

      <variable key="_combined_pwm%(Num)"          type="Boolean" expression="tpm_cnsc_mode_even[%(evenCh)]==(1,2)"   />
      <variable key="_dual_edge_capture%(Num)"     type="Boolean" expression="tpm_cnsc_mode_even[%(evenCh)]==(3,4,5)" />

      <!-- Odd channels when paired - PWM -->
      <choiceOption key="tpm_cnsc_mode_odd_pwm[%(oddCh)]"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         valueFormat="TPM_CnSC_ELS(%s)"
         description="Odd channel Output Control"
         typeName="TpmOddChannelMode"
         disabledValue="0b00"
         toolTip="Controls the functioning of the output of the second channel in a pair"
         >
         <!--              +...... ELS(B:A)
                           |
                           v                  -->
         <choice value="0b00" name="Pin Disabled"           enum="Disabled"
            toolTip="The pin associated with the second channel is not controlled by the TPM"
          />
         <choice value="0b01" name="Normal"         enum="Normal"
            toolTip="The odd channel pin equals the even channel pin (ignoring dead-time)" />
         <choice value="0b10" name="Complementary"  enum="Complementary"
            toolTip="The odd channel pin is the complement of the even channel pin (ignoring dead-time)" />


      </choiceOption>

      <!-- Odd channels when paired - Dual-edge Capture -->
      <choiceOption key="tpm_cnsc_secondEdge[%(oddCh)]"
         hiddenBy="!_dual_edge_capture%(Num)"
         enabledBy="_dual_edge_capture%(Num)"
         valueFormat="TPM_CnSC_ELS(%s)"
         description="Odd channel Capture Polarity"
         typeName="TpmOddChannelMode"
         disabledValue="0b00"
         toolTip="Polarity for capturing the second edge in Dual-edge capture mode (2nd event/channel)"
         >
         <!--              +...... ELS(B:A)
                           |
                           v                  -->
          <choice value="0b00" name="Not used"             enum="Disabled"    />
          <choice value="0b01" name="Capture Rising-edge"  enum="RisingEdge"  />
          <choice value="0b10" name="Capture Falling-edge" enum="FallingEdge" />
          <choice value="0b11" name="Capture Either-edge"  enum="EitherEdge"  />
      </choiceOption>

      <intOption key="tpm_cnv_paired[%(evenCh)]"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Even channel O/C Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="tpm_mod_mod" />

      <intOption key="tpm_cnv_paired[%(oddCh)]"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Odd channel O/C Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="tpm_mod_mod" />

      <floatOption key="tpm_pwmHighTime[%(evenCh)]"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         locked="true"
         derived="true"
         ref="(tpm_cnv_paired[%(oddCh)]-tpm_cnv_paired[%(evenCh)])*clockPeriod"
         valueFormat="%s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="tpm_pwmDutyCycle[%(evenCh)]"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         locked="true"
         derived="true"
         ref="tpm_pwmHighTime[%(evenCh)]/tpm_modPeriod"
         valueFormat="%s"
         units="percent"
         description="Output duty cycle as pecentage"
         toolTip="Calculated duty cycle" />

      <!-- COMBINE.COMSWAP -->
      <choiceOption key="tpm_combine_comswap_pwm%(Num)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         typeName="TpmCombineSwap"
         baseType="uint8_t"
         description="Combined Channel Even and Odd Swap"
         toolTip="When set, the odd channel is used for the 1st compare,\n
                  the even channel is used for the 2nd compare." >
         <choice value="0"  name="Even channel 1st compare" enum="EvenChannelCompare" />
         <choice value="1"  name="Odd channel 1st compare"  enum="OddChannelCompare"  />
      </choiceOption>

      <choiceOption key="tpm_combine_comswap_dec%(Num)"
         hiddenBy="!_dual_edge_capture%(Num)"
         enabledBy="_dual_edge_capture%(Num)"
         typeName="TpmCombineSwap"
         description="Combined Channel Even and Odd Swap"
         toolTip="When set, the even channel is used for the input capture rather than the even channel" >
         <choice value="0"  name="Even channel capture"     enum="EvenChannelCapture" />
         <choice value="1"  name="Odd channel capture"      enum="OddChannelCapture"  />
      </choiceOption>


      <!-- Even channel -->
      <choiceOption key="tpm_cnsc_action_paired[%(evenCh)]" condition="tpm_cnsc_chie_present&amp;&amp;tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         valueFormat="TPM_CnSC_CHIE(%s),TPM_CnSC_DMA(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Even Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="tpm_cnsc_action_paired[%(evenCh)]" condition="tpm_cnsc_chie_present&amp;&amp;!tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="TPM_CnSC_CHIE(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Even Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <!-- Odd channel -->
      <choiceOption key="tpm_cnsc_action_paired[%(oddCh)]" condition="tpm_cnsc_chie_present&amp;&amp;tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         valueFormat="TPM_CnSC_CHIE(%s),TPM_CnSC_DMA(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Odd Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="tpm_cnsc_action_paired[%(oddCh)]" condition="tpm_cnsc_chie_present&amp;&amp;!tpm_cnsc_dma_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(tpm_cnsc_mode_even[%(evenCh)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="TPM_CnSC_CHIE(%s)"
         baseType="uint8_t"
         typeName="TpmChannelAction"
         description="Action on Odd Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <!-- FILTER.FVAL -->

      <choiceOption key="tpm_filter_fval_paired[%(evenCh)]" condition="tpm_filter_ch%(evenCh)fval_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]>0)"
         enabledBy="tpm_cnsc_mode_even[%(evenCh)]>0"
         description="Even Channel Filter"
         typeName="TpmFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel.\n
                  On input capture this acts as a filter\n
                  On output compare this delays the output to provide dead-time between outputs" >
         <choice          value="0"         name="Filter Disabled"        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="tpm_filter_fval_delay_paired[%(evenCh)]" condition="tpm_filter_fval_paired[%(evenCh)]"
         hiddenBy="!(tpm_filter_fval_paired[%(evenCh)]>0)"
         enabledBy="tpm_filter_fval_paired[%(evenCh)]>0"
         description="Even Channel Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*tpm_filter_fval_paired[%(evenCh)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <choiceOption key="tpm_filter_fval_paired[%(oddCh)]" condition="tpm_filter_ch%(oddCh)fval_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]>0)"
         enabledBy="tpm_cnsc_mode_even[%(evenCh)]>0"
         description="Odd Channel Filter"
         typeName="TpmFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel.\n
                  On input capture this acts as a filter\n
                  On output compare this delays the output to provide dead-time between outputs" >
         <choice          value="0"         name="Filter Disabled"        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="tpm_filter_fval_delay_paired[%(oddCh)]" condition="tpm_filter_fval_paired[%(oddCh)]"
         hiddenBy="!(tpm_filter_fval_paired[%(oddCh)]>0)"
         enabledBy="tpm_filter_fval_paired[%(oddCh)]>0"
         description="Odd Channel Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*tpm_filter_fval_paired[%(oddCh)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <binaryOption key="tpm_cnsc_icrst_paired[%(oddCh)]" condition="tpm_cnsc_icrst_present"
         hiddenBy="!(tpm_cnsc_mode_even[%(evenCh)]>=3)"
         enabledBy="tpm_cnsc_mode_even[%(evenCh)]>=3"
         valueFormat="TPM_CnSC_ICRST(%s)"
         typeName="TpmChannelReset"
         baseType="uint8_t"
         description="Reset counter on 2nd IC event"
         toolTip="Enables the channel IC event to reset the shared counter" >
         <choice value="0" name="Disabled"                   enum="Disabled" />
         <choice value="1" name="Counter is reset on event"  enum="CounterReset"  />
      </binaryOption>

   </for>
</if>
   </category>

<!--  ____  Channel Configuration  ________________ -->

   <categoryOption key="Channels" description="Channel Configuration" hiddenBy="mode==(None,Quad)" >

      <for keys="    Num : evenCh : oddCh"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <if condition="=%(evenCh) >=_channelCount">
            <break/>
         </if>

         <constant key="channelPairing[%(evenCh)]" value="false" condition="!tpm_combine_combine%(Num)_present" type="Boolean"/>

         <binaryOption key="channelPairing[%(evenCh)]" condition="tpm_combine_combine%(Num)_present"
            enabledBy="mode==Left"
            description="Channel %(evenCh) &amp; %(oddCh) Pairing"
            toolTip="This allows the paired channels to operate in Combine or Dual edge modes" >

            <choice value="0" name="Channels %(evenCh) &amp; %(oddCh) operate independently"
               toolTip="Operation in \n
                  - Input capture\n
                  - Output compare\n
                  - Edge or Centre aligned PWM"
            />
            <choice value="1" name="Channels %(evenCh) &amp; %(oddCh) are paired"
               toolTip="Operation in \n
                  - Dual-edge Input capture\n
                  - Combined PWM"
            />
         </binaryOption>

      <!-- ... Calculation of pin use (in independent and paired modes) .... -->

      <if condition="tpm_combine_present">
         <!-- Even channel -->
         <variable key="inputModeCh%(evenCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(evenCh)]==(1,2,3))||(tpm_cnsc_mode_even[%(evenCh)]>=3)" />

         <!-- Odd channel -->
         <variable key="inputModeCh%(oddCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(oddCh)]==(1,2,3))||(tpm_cnsc_mode_even[%(evenCh)]>=3)" />

         <!-- Even channel -->
         <variable key="outputModeCh%(evenCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(evenCh)]>=5)||(tpm_cnsc_mode_even[%(evenCh)]==(1,2))" />

         <!-- Odd channel -->
         <variable key="outputModeCh%(oddCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(oddCh)]>=5)||(tpm_combine_comswap_pwm%(evenCh)==1)" />
      <else/>
         <!-- Even channel -->
         <variable key="inputModeCh%(evenCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(evenCh)]==(1,2,3))" />

         <!-- Odd channel -->
         <variable key="inputModeCh%(oddCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(oddCh)]==(1,2,3))" />

         <!-- Even channel -->
         <variable key="outputModeCh%(evenCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(evenCh)]>=5)" />

         <!-- Odd channel -->
         <variable key="outputModeCh%(oddCh)" type="Boolean"
            expression="(tpm_cnsc_mode_independent[%(oddCh)]>=5)" />
      </if>

      <!-- Even channel -->
      <variable key="Ch%(oddCh)PinInUse" type="Boolean"
         expression="outputModeCh%(oddCh)||inputModeCh%(oddCh)" />

      <!-- Odd channel -->
      <variable key="Ch%(evenCh)PinInUse" type="Boolean"
         expression="outputModeCh%(evenCh)||inputModeCh%(evenCh)" />

      </for>

      <for keys="    Num : evenCh : oddCh"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <if condition="=%(evenCh) >=_channelCount">
            <break/>
         </if>

         <list name="*" hiddenBy="channelPairing[%(evenCh)]" >
            <!-- Independent channels -->

            <!-- Even channels -->
            <title description="Channel %(evenCh)" />

            <aliasOption key="tpm_cnsc_mode_independent[%(evenCh)]"         locked="false" />
            <aliasOption key="tpm_cnsc_action_independent[%(evenCh)]"       locked="false" />
            <aliasOption key="tpm_filter_fval_independent[%(evenCh)]"       locked="false" optional="discard" />
            <aliasOption key="tpm_filter_fval_delay_independent[%(evenCh)]"                optional="discard" />
            <aliasOption key="tpm_cnsc_icrst_independent[%(evenCh)]"        locked="false" optional="discard" />
            <aliasOption key="tpm_cnv_independent[%(evenCh)]"               locked="false" />
            <aliasOption key="tpm_cnvEventTime_independent[%(evenCh)]"      locked="false" />
            <aliasOption key="tpm_cnvHighTime_independent[%(evenCh)]"       locked="false" />
            <aliasOption key="tpm_cnvDutyCycle_independent[%(evenCh)]"      locked="false" />

            <!-- Odd channels -->
            <title description="Channel %(oddCh)" />

            <aliasOption key="tpm_cnsc_mode_independent[%(oddCh)]"         locked="false" />
            <aliasOption key="tpm_cnsc_action_independent[%(oddCh)]"       locked="false" />
            <aliasOption key="tpm_filter_fval_independent[%(oddCh)]"       locked="false" optional="discard" />
            <aliasOption key="tpm_filter_fval_delay_independent[%(oddCh)]"                optional="discard" />
            <aliasOption key="tpm_cnsc_icrst_independent[%(oddCh)]"        locked="false" optional="discard" />

            <aliasOption key="tpm_cnv_independent[%(oddCh)]"               locked="false" />
            <aliasOption key="tpm_cnvEventTime_independent[%(oddCh)]"      locked="false" />
            <aliasOption key="tpm_cnvHighTime_independent[%(oddCh)]"       locked="false" />
            <aliasOption key="tpm_cnvDutyCycle_independent[%(oddCh)]"      locked="false" />
         </list>

<if condition="tpm_combine_present">

         <list name="*" hiddenBy="!channelPairing[%(evenCh)]" condition="tpm_combine_combine%(Num)_present" >

            <!-- Paired channels -->
            <title description="Paired channels %(evenCh) &amp; %(oddCh)" />

            <aliasOption key="tpm_cnsc_mode_even[%(evenCh)]"    locked="false" />
            <aliasOption key="tpm_cnsc_secondEdge[%(oddCh)]"    locked="false" />
            <aliasOption key="tpm_cnsc_mode_odd_pwm[%(oddCh)]"  locked="false" />

            <aliasOption key="tpm_cnsc_icrst_paired[%(oddCh)]"  locked="false"  optional="discard" />

            <aliasOption key="tpm_cnv_paired[%(evenCh)]"        locked="false" />
            <aliasOption key="tpm_cnv_paired[%(oddCh)]"         locked="false" />
            <aliasOption key="tpm_pwmHighTime[%(evenCh)]"   />
            <aliasOption key="tpm_pwmDutyCycle[%(evenCh)]"  />

            <aliasOption key="tpm_combine_comswap_pwm%(Num)"    locked="false" />
            <aliasOption key="tpm_combine_comswap_dec%(Num)"    locked="false" />

            <aliasOption key="tpm_cnsc_action_paired[%(evenCh)]"  locked="false" />
            <aliasOption key="tpm_cnsc_action_paired[%(oddCh)]"   locked="false" />

            <aliasOption key="tpm_filter_fval_paired[%(evenCh)]"       locked="false" optional="discard" />
            <aliasOption key="tpm_filter_fval_delay_paired[%(evenCh)]"                optional="discard" />
            <aliasOption key="tpm_filter_fval_paired[%(oddCh)]"        locked="false" optional="discard" />
            <aliasOption key="tpm_filter_fval_delay_paired[%(oddCh)]"                 optional="discard" />

            <aliasOption key="tpm_cnsc_icrst_paired[%(ch)]"  locked="false"  optional="discard" />
            <aliasOption key="tpm_cnsc_icrst_paired[%(ch)]"  locked="false"  optional="discard" />
         </list>
</if>
      </for>
   </categoryOption>

   <!-- ____ Run-time Checks ____ -->

   <categoryOption description="Run-time checks" key="runtimeChecks"
      hiddenBy="mode!=(Left,Centre)"
   >

      <binaryOption key="check_minimums"
         enabledBy="enablePeripheralSupport"
         description="Check minimum interval and resolution"
         toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
         <choice value="0" name="No checks done" />
         <choice value="1" name="Do checks"  isDefault="true" />
      </binaryOption>

      <intOption key="minimumInterval"
         enabledBy="check_minimums"
         description="Minimum usable interval in ticks"
         toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
                  when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
         value="20" min="0" max="65535"/>

      <intOption key="minimumResolution"
         enabledBy="check_minimums"
         description="Minimum resolution for PWM interval"
         toolTip="This value is used as a minimum value for the timer period in ticks \n
            so that a reasonable resolution is available for PWM duty-cycle"
         value="100" min="0" max="65535" />
   </categoryOption>

   <!-- ____ Miscellaneous ______________ -->

   <categoryOption key="Miscellaneous" description="Miscellaneous"
      hiddenBy="mode==(None,Quad)"
   >

      <!-- ____ POL ______________ -->

      <choiceOption key="tpm_pol_pol_enum" condition="tpm_pol_present"
         valueFormat="%s"
         hidden="true"
         derived="true"
         typeName="TpmPolarity"
         baseType="uint16_t"
         description="Channel Polarity"
         toolTip="Selects the polarity of channels inputs/outputs" >
         <choiceExpansion name="Ch%(ch) Active-low"  enum="Ch%(ch)_ActiveLow"  value='=Format("0x%04XU",0xFF00+(1&lt;&lt;(%(ch))))'            keys="ch" dim="8"/>
         <choice          name="All Active-low"      enum="All_ActiveLow"      value='0xFFFFU' />
         <choiceExpansion name="Ch%(ch) Active-high" enum="Ch%(ch)_ActiveHigh" value='=Format("0x%04XU",0xFF00^(1&lt;&lt;(%(ch)+8)))' keys="ch" dim="8"/>
         <choice          name="All Active-high"     enum="All_ActiveHigh"     value='0x0000U' />
      </choiceOption>

      <bitmaskOption key="tpm_pol_pol" condition="tpm_pol_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="TpmPolarity"
         baseType="uint16_t"
         enumText="=polarityEnums"
         description="Channel Polarity"
         toolTip="Bitmask defining the polarity of channels inputs/outputs"
         value="0"
         bitDescription="@SignalList(8)"
         bitList="Ch%iActiveLow"
         bitmask="=(1&lt;&lt;_channelCount)-1" />

      <!-- ____ CONF ______________ -->

      <binaryOption key="tpm_conf_dozeen" condition="tpm_conf_dozeen_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmDozeMode"
         baseType="uint32_t"
         description="Doze Enable"
         toolTip="Selects the TPM behaviour in wait mode." >
         <choice value="0" name="Continue in Doze mode."             enum="Running"/>
         <choice value="1" name="Counter paused and inputs ignored"  enum="Paused"/>
      </binaryOption >

      <choiceOption key="tpm_conf_dbgmode" condition="tpm_conf_dbgmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmBdmMode"
         baseType="uint32_t"
         description="Behaviour in BDM Mode"
         toolTip="Selects the TPM behaviour in Debug mode." >
         <choice  value="0" name="Stopped, outputs functional" enum="Paused"/>
         <choice  value="3" name="Running"                     enum="Running"/>
      </choiceOption >


      <!-- ____ Global timebase ______________ -->

      <title description="Global timebase" />

      <binaryOption key="tpm_conf_gtbsync" condition="tpm_conf_gtbsync_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmGlobalTimebaseSync"
         baseType="uint32_t"
         description="Global Time Base Synchronization"
         toolTip="When enabled, the TPM counter is synchronised to the global time base.\n
                  It uses the global timebase enable, trigger and overflow to ensure the\n
                  TPM counter starts incrementing at the same time as the global timebase,\n
                  stops incrementing at the same time as the global timebase and is reset\n
                  at the same time as the global timebase. This field should only be \n
                  changed when the TPM counter is disabled." >
         <choice value="0" name="Disabled"            enum="Disabled" />
         <choice value="1" name="Use global timebase" enum="Enabled"  />
      </binaryOption >

      <binaryOption key="tpm_conf_gtbeen" condition="tpm_conf_gtbeen_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmUseGlobalTimebase"
         baseType="uint32_t"
         description="Global Time Base Enable"
         toolTip="Configures the TPM to use an externally generated global time base counter.\n
                  When an externally generated timebase is used, the internal TPM counter is\n
                  not used by the channels but can be used to generate a periodic interruptor\n
                  DMA request using the Modulo register and timer overflow flag." >
         <choice value="0" name="Use internally generated TPM counter"     enum="Disabled" />
         <choice value="1" name="Use externally generated global timebase" enum="Enabled"  />
      </binaryOption >

      <binaryOption key="tpm_conf_csot" condition="tpm_conf_csot_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmStart"
         baseType="uint32_t"
         description="Counter Start on Trigger"
         toolTip="When set, the TPM counter will not start incrementing after it is enabled\n
                  until a rising edge on the selected trigger input is detected.\n
                  If the TPM counter is stopped due to an overflow, a rising edge on the selected\n
                  trigger input will also cause the TPM counter to start incrementing again.\n
                  The trigger input is ignored if the TPM counter is paused during debug mode \n
                  or doze mode.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice value="0" name="Normal operation (starts immediately)" enum="Immediately" />
         <choice value="1" name="Starts on trigger"                     enum="OnTrigger" />
      </binaryOption>

      <binaryOption key="tpm_conf_csoo" condition="tpm_conf_csoo_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmAfterOverflow"
         baseType="uint32_t"
         description="Counter Stop On Overflow"
         toolTip="When set, the TPM counter will stop incrementing once the counter equals\n
                  the MOD value and incremented (this also sets the TOF).\n
                  Reloading the counter with 0 by writing to the counter register or\n
                  due to a trigger input does not cause the counter to stop incrementing.\n
                  Once the counter has stopped incrementing, the counter will not start\n
                  incrementing unless it is disabled and then enabled again, or a rising\n
                  edge on the selected trigger input is detected when CSOT set.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice value="0" name="Continue after overflow"         enum="Continue" />
         <choice value="1" name="Wait for trigger after overflow" enum="WaitForTrigger" />
      </binaryOption>

      <binaryOption key="tpm_conf_crot" condition="tpm_conf_crot_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmReload"
         baseType="uint32_t"
         description="Counter Reload On Trigger"
         toolTip="When set, the TPM counter will reload with 0 (and initialize PWM outputs\n
                  to their default value) when a rising edge is detected on the selected trigger input.\n
                  The trigger input is ignored if the TPM counter is paused during debug mode or doze mode.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice value="0" name="No reload (Normal operation)" enum="IgnoreTrigger" />
         <choice value="1" name="Reload counter on trigger"    enum="OnTrigger" />
      </binaryOption>

      <binaryOption key="tpm_conf_cpot" condition="tpm_conf_cpot_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmPause"
         description="Counter Pause On Trigger"
         toolTip="When enabled, the counter will pause incrementing while the trigger\n
                  remains asserted (level sensitive).\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice value="0" name="Ignore trigger (Normal operation)" enum="Never" />
         <choice value="1" name="Pause while trigger asserted"      enum="WhileTriggerAsserted" />
      </binaryOption>

      <!-- ___ Triggers ___ -->

      <binaryOption key="tpm_conf_trgpol" condition="tpm_conf_trgpol_present"
         enabledBy="enablePeripheralSupport"
         typeName="TpmTriggerPolarity"
         baseType="uint32_t"
         description="Trigger Polarity"
         toolTip="Selects the polarity of the external trigger source.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice value="0" name="Active-low"  enum="ActiveLow" />
         <choice value="1" name="Active-high" enum="ActiveHigh" />
      </binaryOption>

      <choiceOption key="tpm_conf_trgsel_ext" condition="tpm_conf_trgsrc_present&amp;&amp;tpm_conf_trgsel_present"
         valueFormat="TPM_CONF_TRGSRC(%s),TPM_CONF_TRGSEL(%s)"
         typeName="TpmExternalTrigger"
         baseType="uint32_t"
         description="External Triggers"
         toolTip="Selects the external input trigger to use for starting, reloading and/or pausing the counter.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choice          value="1,0"        name="Internal Source" enum="Internal" />
         <choiceExpansion value="0,%(value)" name="%(name)"  enum="%(enum)" keys="value:name:enum" values="=/TPM/_trigger_sources" condition="/TPM/_trigger_sources" />
         <choiceExpansion value="0,%(i)"     name="External Source %(i)"  enum="Src%(i)" keys="i" dim="16" condition="!/TPM/_trigger_sources"/>
      </choiceOption>

      <choiceOption key="tpm_conf_trgsel_ext" condition="!tpm_conf_trgsrc_present&amp;&amp;tpm_conf_trgsel_present"
         valueFormat="TPM_CONF_TRGSEL(%s)"
         typeName="TpmInternalTrigger"
         baseType="uint32_t"
         description="External Triggers"
         toolTip="Selects the external input trigger to use for starting, reloading and/or pausing the counter.\n
                  This field should only be changed when the TPM counter is disabled." >
         <choiceExpansion value="%(value)" name="%(name)"  enum="%(enum)" keys="value:name:enum" values="=/TPM/_trigger_sources" condition="/TPM/_trigger_sources"/>
         <choiceExpansion value="%(i)"     name="External Source %(i)"  enum="Src%(i)" keys="i" dim="16"       condition="!/TPM/_trigger_sources"/>
      </choiceOption>

      <choiceOption key="tpm_conf_trgsel_int_masks"
         valueFormat="TPM_CONF_TRGSRC_MASK|TPM_CONF_TRGSEL(%s)"
         typeName="TpmInternalTrigger"
         baseType="uint32_t"
         description="Internal Triggers"
         toolTip="Selects the internal input trigger to use for starting, reloading and/or pausing the counter.\n
                  The channel selected should be configured for input capture.\n
                  Only a rising edge input capture can be used to initially start the counter using\n
                  the CSOT configuration; either rising edge or falling edge input capture can be\n
                  used to reload the counter using the CROT configuration; and the state of the \n
                  channel input pin is used to pause the counter using the CPOT configuration.\n
                  The channel polarity register can be used to invert the polarity of the channel\n
                  input pins.\n
                  This field should only be changed when the TPM counter is disabled."
         >
         <choiceExpansion value='=Format("0x%02XU", 1&lt;&lt;%(ch))' name="Enable Trigger from %(ch)" enum="Ch%(ch)" keys="ch" dim="8" />
      </choiceOption>

      <bitmaskOption key="tpm_conf_trgsel_int" condition="tpm_conf_trgsrc_present&amp;&amp;tpm_conf_trgsel_present"
         valueFormat="TPM_CONF_TRGSRC_MASK|TPM_CONF_TRGSEL(%s)"
         enabledBy="tpm_conf_trgsel_ext==0"
         hiddenBy="tpm_conf_trgsel_ext!=0"
         typeName="TpmInternalTrigger"
         baseType="uint32_t"
         description="Internal Triggers"
         toolTip="Selects the internal input trigger to use for starting, reloading and/or pausing the counter.\n
                  The channel selected should be configured for input capture.\n
                  Only a rising edge input capture can be used to initially start the counter using\n
                  the CSOT configuration; either rising edge or falling edge input capture can be\n
                  used to reload the counter using the CROT configuration; and the state of the \n
                  channel input pin is used to pause the counter using the CPOT configuration.\n
                  The channel polarity register can be used to invert the polarity of the channel\n
                  input pins.\n
                  This field should only be changed when the TPM counter is disabled."
         bitmask="=(1&lt;&lt;_channelCount)-1"
         bitList="Ch%i"
         bitDescription="Channel %i" />

   </categoryOption>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_control" />
   <xi:include href="tpm_quadrature_decoder.xml"/>
   <deleteVariables variables="_control"/>

   <!-- ____ Info class members ____________ -->

   <variableTemplate variables="minimumResolution"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumResolution  = $(?check_minimums:$(minimumResolution):0);\n\n
   ]]></variableTemplate>

   <variableTemplate variables="minimumInterval"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumInterval  = $(?check_minimums:$(minimumInterval):0);\n\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)/static_functions" where="all"
      discardRepeats="true"
      variables="tpm_sc_cpwms,tpm_sc_cmod,tpm_sc_ps"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Enables clock to peripheral and configures all pins.
      \t * Configures main operating settings for timer.
      \t *
      %paramDescription
      \t */
      \tstatic void configure(%params) {
      \t
      \t   // Enable clock to peripheral
      \t   Info::enable();
      \t
      \t   // Disable timer to change settings
      \t   %register = 0;
      \t
      \t   // Make sure write has completed (disabled)
      \t   (void)(%register);
      \t
      \t   // Write new value
      \t   %register = %paramExpression;
      \t}\n\n
   ]]></variableTemplate>

   <variableTemplate where="info" discardRepeats="true"
      variables="tpm_pol_pol" ><![CDATA[
      \t/**
      \t * Set polarity of all channels
      \t *
      \t * @param channelMask   Bit mask 0 => active-high, 1 => active-low
      \t */
      \tstatic void setPolarity(uint32_t channelMask) {
      \t   tpm->POL = channelMask;
      \t}
      \t
      \t/**
      \t * Set polarity of selected channel
      \t *
      \t * @param tpmPolarity  Channel polarity to set
      \t */
      \tstatic void setPolarity(TpmPolarity tpmPolarity) {
      \t      tpm->POL= (tpm->POL&(tpmPolarity>>8))|tpmPolarity;
      \t}\n\n
   ]]></variableTemplate>

<!--  ___ Static/Non-Static Methods ______________

      key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true"  => By name non_static_functions & static_functions in tpm.h


-->
   <for  keys="   key                  : static    : const    : getInputClockFrequency         : channel : Tpm       : isStatic : namespace"
         values=" non_static_functions : ''        : ' const' : getInputClockFrequencyVirtual  : CHANNEL : TpmBase   : false    : all;
                  static_functions     : 'static ' : ''       : 'Info::getInputClockFrequency' : channel : OwningTpm : true     : forceInfo
   " >
      <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
         discardRepeats="true"
         variables="tpm_sc_cmod,tpm_sc_ps"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask0);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t *
         %paramDescription
         \t */
         \t%(static)void selectClock(%params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         \t
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         \t
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         \t
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></variableTemplate>

      <for keys="  f            :  n"
         values=" tpm_sc_cpwms  : CountMode;
                  tpm_sc_cmod   : ClockSource;
                  tpm_sc_ps     : Prescaler" >
         <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
            \t
            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;
            \t
            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);
            \t
            \t   // Write new value
            \t   %register = %registerName;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)(%register&~%mask);
            \t}\n\n
         ]]></variableTemplate>
      </for>

      <for keys="  f           :  n"
         values=" tpm_mod_mod  : CounterMaximumValue" >
         <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t * This value is write-buffered and updated by MOD synchronisation
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Write new value
            \t   %register = %paramExpression;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%returnType get%(n)()%(const) {
            \t
            \t   return %returnType(%register);
            \t}\n\n
         ]]></variableTemplate>
      </for>

      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Set period
         \t *
         \t * @param[in] period   Period in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note The counter load value (CNTIN) is cleared
         \t * @note The counter modulo value (MOD) is modified to obtain the requested period
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setPeriod(Seconds period)%(const) {
         \t
         \t   uint16_t modValue = 0;
         \t
         \t   uint8_t sc = tpm->SC;
         \t
         \t   float inputClock = %(getInputClockFrequency)((TpmClockSource)(sc&TPM_SC_CMOD_MASK));
         \t   ErrorCode rc = TpmCommonInfo::calculateTimingParameters(inputClock, period, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t   // Disable timer to change prescaler and period
         \t   tpm->SC  = 0;
         \t
         \t   // Configure for modulo operation
         \t   tpm->MOD = modValue;
         \t
         \t   // Clear counter
         \t   tpm->CNT = 0;
         \t
         \t   // Set prescale and enable timer
         \t   tpm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Set maximum interval for input-capture or output compare.
         \t * Input Capture and Output Compare will be able to operate over
         \t * at least this period without overflow.
         \t *
         \t * @param[in] interval Interval in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note Counter is configured for free-running mode i.e. 0-65535
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setMaximumInterval(Seconds interval)%(const) {
         \t
         \t   uint16_t       modValue;
         \t
         \t   uint8_t sc = tpm->SC;
         \t
         \t   float inputClock = %(getInputClockFrequency)((TpmClockSource)(sc&TPM_SC_CMOD_MASK));
         \t   ErrorCode rc = TpmCommonInfo::calculateTimingParameters(inputClock, interval, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t
         \t   // Disable timer to change prescaler and period
         \t   tpm->SC  = 0;
         \t
         \t   // Configure for free-running mode
         \t   // This is the usual value for IC or OC set-up
         \t   tpm->MOD = 0_ticks;
         \t
         \t   // Clear counter
         \t   tpm->CNT = 0;
         \t
         \t   // Set prescale and enable timer
         \t   tpm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Get frequency of timer tick
         \t *
         \t * @return Timer frequency in Hz
         \t */
         \t%(static)float getTickFrequencyAsFloat()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   float prescaleFactor = 1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((TpmClockSource)(tpm->SC&TPM_SC_CMOD_MASK))/prescaleFactor;
         \t}
         \t
         \t/**
         \t * Get clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz (may underflow)
         \t */
         \t%(static)uint32_t getTickFrequencyAsInt()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   int prescaleFactor = 1<<((tpm->SC&TPM_SC_PS_MASK)>>TPM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((TpmClockSource)(tpm->SC&TPM_SC_CMOD_MASK))/prescaleFactor;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Convert time in microseconds to time in ticks
         \t *
         \t * @param[in] time Time in microseconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t * @note Will set error code if calculated value is less the Timer minimum resolution
         \t */
         \t%(static)Ticks convertMicrosecondsToTicks(int time)%(const) {
         \t
         \t   // Calculate period
         \t   uint32_t tickRate = getTickFrequencyAsInt();
         \t   uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if constexpr (Info::minimumInterval>0) {
         \t      if (rv < Info::minimumInterval) {
         \t         // Attempt to set too short a period
         \t         setErrorCode(E_TOO_SMALL);
         \t      }
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Converts time in seconds to time in ticks
         \t *
         \t * @param[in] seconds Time interval in seconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
         \t * @note Will set error code if calculated value is less the minimum resolution
         \t */
         \t%(static)Ticks convertSecondsToTicks(Seconds seconds)%(const) {
         \t
         \t   // Calculate period
         \t   float    tickRate = getTickFrequencyAsFloat();
         \t   uint64_t rv       = rintf((float)seconds*tickRate);
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if (rv < Info::minimumInterval) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in microseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in microseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMicroseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in milliseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in milliseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMilliseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in seconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in seconds
         \t */
         \t%(static)Seconds convertTicksToSeconds(Ticks timeInTicks)%(const) {
         \t   return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
         \t}
         \t/**
         \t * Get Timer count
         \t *
         \t * @return Timer count value
         \t */
         \t%(static)uint16_t getTime()%(const) {
         \t   return tpm->CNT;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Reset counter to initial value
         \t */
         \t%(static)void resetTime()%(const) {
         \t   // Note: writing ANY value loads CNT from CNTIN
         \t   tpm->CNT = 0;
         \t}
         \t
         \t/**
         \t * Get timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t */
         \t%(static)unsigned getInterruptFlags()%(const) {
         \t   return tpm->STATUS;
         \t}
         \t
         \t/**
         \t * Clear selected timer event flags
         \t *
         \t * @param channelMask Mask indicating which channel flags to clear
         \t *                    There is one bit for each channel
         \t *
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)void clearSelectedInterruptFlags(uint32_t channelMask)%(const) {
         \t   // Clear flags (w1c)
         \t   tpm->STATUS = channelMask;
         \t}
         \t
         \t/**
         \t * Clear timer overflow event flag
         \t */
         \t%(static)void clearOverflowInterruptFlag() {
         \t   // Clear TOI flag (w1c)
         \t   tpm->SC = tpm->SC | TPM_SC_TOF_MASK;
         \t}
         \t
         \t/**
         \t * Get and clear timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t *
         \t * @note Only flags captured in the return value are cleared
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)unsigned getAndClearInterruptFlags()%(const) {
         \t   // Note - w1c flags
         \t   // so only flags captured in status are cleared
         \t   unsigned status = tpm->STATUS;
         \t   tpm->STATUS = status;
         \t   return status;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Enable Timer Overflow interrupts
         \t */
         \t%(static)void enableTimerOverflowInterrupts()%(const) {
         \t   tpm->SC = tpm->SC | TPM_SC_TOIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable Timer Overflow interrupts
         \t */
         \t%(static)void disableTimerOverflowInterrupts()%(const) {
         \t   tpm->SC = tpm->SC & ~TPM_SC_TOIE_MASK;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" discardRepeats="true" ><![CDATA[
         \t/*
         \t * *****************************************************************
         \t *          Channel functions
         \t * *****************************************************************
         \t */
         \t\n
      ]]></template>

      <variableTemplate key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true"
         variables="tpm_cnsc_action_independent[], tpm_channel_number"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Set action on event
         \t * (%variable)
         \t *
         %paramDescription
         \t */
         \t%(static)void setAction(%params) %(const) {
         \t
         \t   tpm->CONTROLS[tpmChannelNum].CnSC =
         \t      (tpm->CONTROLS[tpmChannelNum].CnSC&~%mask) | tpmChannelAction;
         \t}
         \t\n
      ]]></variableTemplate>

      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Set PWM duty cycle.
         \t * Higher precision float version
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage (float)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(float dutyCycle, int channel)%(const) {
         \t   if (tpm->SC&TPM_SC_CPWMS_MASK) {
         \t      tpm->CONTROLS[channel].CnV  = round((dutyCycle*tpm->MOD)/100.0f);
         \t   }
         \t   else {
         \t      tpm->CONTROLS[channel].CnV  = round((dutyCycle*(tpm->MOD+1))/100.0f);
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM duty cycle
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(int dutyCycle, int channel)%(const) {
         \t   if (tpm->SC&TPM_SC_CPWMS_MASK) {
         \t      tpm->CONTROLS[channel].CnV  = (dutyCycle*tpm->MOD)/100;
         \t   }
         \t   else {
         \t      tpm->CONTROLS[channel].CnV  = (dutyCycle*(tpm->MOD+1))/100;
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM high time in ticks
         \t * Assumes value is less than period
         \t *
         \t * @param[in] highTime   PWM high time in ticks
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t * @return E_TOO_LARGE on success
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Ticks highTime, int channel)%(const) {
         \t
         \t   if (tpm->SC&TPM_SC_CPWMS_MASK) {
         \t      // In CPWM the pulse width is doubled
         \t      highTime = Ticks((highTime+1_ticks)/2U);
         \t   }
         #ifdef DEBUG_BUILD
         \t   if ((unsigned)highTime > tpm->MOD) {
         \t      return setErrorCode(E_TOO_LARGE);
         \t   }
         #endif
         \t   tpm->CONTROLS[channel].CnV  = (unsigned)highTime;
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Get Timer event time
         \t *
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return Absolute time of last event in ticks i.e. value from timer event register
         \t */
         \t%(static)Ticks getEventTime(int channel)%(const) {
         \t   return Ticks(tpm->CONTROLS[channel].CnV);
         \t}
         \t
         \t/**
         \t * Set Timer event time
         \t *
         \t * This value is write-buffered and updated by Cnv synchronisation.
         \t *
         \t * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
         \t * @param[in] channel    Timer channel
         \t */
         \t%(static)void setEventTime(Ticks eventTime, int channel)%(const) {
         \t   tpm->CONTROLS[channel].CnV = (unsigned)eventTime;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current event time
         \t *
         \t * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setDeltaEventTime(Ticks offset, int channel)%(const) {
         \t   tpm->CONTROLS[channel].CnV = tpm->CONTROLS[channel].CnV + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current timer count value
         \t *
         \t * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setRelativeEventTime(Ticks offset, int channel)%(const) {
         \t   tpm->CONTROLS[channel].CnV = tpm->CNT + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set PWM high time in seconds
         \t *
         \t * @param[in] highTime   PWM high time in seconds
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t *
         \t * @note The actual CnV register update may be delayed by the TPM Register Synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Seconds highTime, int channel)%(const) {
         \t   return setHighTime(convertSecondsToTicks(highTime), channel);
         \t}
         \t
      ]]></template>

   <!-- ___ Channel Functions __________________ -->

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="tpm_cnsc_action_independent[]"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    * (%variable)
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void setAction(%params)%(const) {
      \t
      \t      tpm->CONTROLS[%(channel)].CnSC =
      \t           (tpm->CONTROLS[%(channel)].CnSC & ~%mask) | %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="tpm_cnsc_mode_independent[], tpm_cnsc_action_independent[]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    * (%variable)
      \t    *
      %paramDescription
      \t
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void configure(%params)%(const) {
      \t
      \t      tpm->CONTROLS[%(channel)].CnSC =
      \t           (tpm->CONTROLS[%(channel)].CnSC & ~%mask) | %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="tpm_cnsc_mode_independent[]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Disables timer channel (sets mode to TpmChannelMode_Disabled)
      \t    */
      \t   %(static)void disable()%(const) {
      \t      setMode(TpmChannelMode_Disabled);
      \t   }
      \t
      \t   /**
      \t    * Get channel mode.
      \t    *
      \t    * @return Current mode of operation for the channel
      \t    */
      \t   %(static) %returnType getMode()%(const) {
      \t      return %returnType(tpm->CONTROLS[%(channel)].CnSC & %mask);
      \t   }
      \t
      \t   /**
      \t    * Set channel mode
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void setMode(%params)%(const) {
      \t      tpm->CONTROLS[%(channel)].CnSC =
      \t            (tpm->CONTROLS[%(channel)].CnSC & ~%mask)|%paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <template key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true" ><![CDATA[
      \t   /**
      \t    * Set PWM high time in ticks.
      \t    * Assumes value is less than period
      \t    *
      \t    * @param[in] highTime   PWM high time in ticks
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Ticks highTime)%(const) {
      \t      return %(Tpm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in seconds.
      \t    * Higher precision float version
      \t    *
      \t    * @param[in] highTime   PWM high time in seconds
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Seconds highTime)%(const) {
      \t      return %(Tpm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle.
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDutyCycle(int dutyCycle)%(const) {
      \t      %(Tpm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDutyCycle(float dutyCycle)%(const) {
      \t      %(Tpm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDeltaEventTime(Ticks offset)%(const) {
      \t      %(Tpm)::setDeltaEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time relative to current timer count value.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setRelativeEventTime(Ticks offset)%(const) {
      \t      %(Tpm)::setRelativeEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Absolute Timer event time.
      \t    *
      \t    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setEventTime(Ticks eventTime)%(const) {
      \t      %(Tpm)::setEventTime(eventTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Absolute Timer event time.
      \t    *
      \t    * @return Absolute time of last event in ticks i.e. value from timer event register
      \t    */
      \t   %(static) Ticks getEventTime()%(const) {
      \t      return %(Tpm)::getEventTime(%(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Timer interrupt/event flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    */
      \t   %(static) bool getInterruptFlag()%(const) {
      \t      return (tpm->CONTROLS[%(channel)].CnSC&TPM_CnSC_CHF_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Get and Clear Timer channel interrupt flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    *
      \t    * @note Only flags captured in the return value are cleared
      \t    */
      \t   %(static) bool getAndClearInterruptFlag()%(const) {
      \t      // Note - w1c flags
      \t      uint8_t cnsc = tpm->CONTROLS[%(channel)].CnSC;
      \t      tpm->CONTROLS[%(channel)].CnSC = cnsc|CHANNEL_MASK;
      \t      return (cnsc&CHANNEL_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Clear interrupt flag on channel.
      \t    */
      \t   %(static)void clearInterruptFlag()%(const) {
      \t      // Note - w1c flags
      \t      tpm->CONTROLS[CHANNEL].CnSC = tpm->CONTROLS[CHANNEL].CnSC|TPM_CnSC_CHF_MASK;
      \t   }\n\n
   ]]></template>
   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="tpm_pol_pol" ><![CDATA[
      \t   /**
      \t    * Set polarity of channel.
      \t    *
      \t    * @param active Polarity to set
      \t    */
      \t   %(static)void setPolarity(Polarity active)%(const) {
      \t      if (active == ActiveHigh) {
      \t         tpm->POL = tpm->POL & ~CHANNEL_MASK;
      \t      }
      \t      else {
      \t         tpm->POL = tpm->POL | CHANNEL_MASK;
      \t      }
      \t   }\n\n
      ]]></variableTemplate>
   </for>

   <clockCodeTemplate variable="tpm_sc_cmod"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      %paramDescription
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!-- ___ CommonInfo class ______________ -->

   <template where="commonInfo" condition="!/$(_basename)_common_info_done" ><![CDATA[
      \t/**
      \t * Calculate TPM timing parameters to achieve a given period
      \t *
      \t * @param[in]    inputClock Input clock to Timer
      \t * @param[in]    period     Period in seconds
      \t * @param[inout] sc         Proposed TPM.SC value (must include CPWMS fields)
      \t *                          PS field is updated
      \t * @param[out]   mod        Calculated TPM.MOD values
      \t *
      \t * @return E_NO_ERROR   Success!!
      \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
      \t * @return E_TOO_LARGE  Requested period is too large
      \t */
      \tstatic ErrorCode calculateTimingParameters(float inputClock, Seconds period, uint8_t &sc, uint16_t &mod) {
      \t
      \t   unsigned prescaleFactor=1;
      \t   unsigned prescalerValue=0;
      \t
      \t   // Check if CPWMS is set (affects period calculation)
      \t   bool centreAligned = (sc&TPM_SC_CPWMS_MASK);
      \t
      \t   constexpr uint32_t maxModValue = TPM_MOD_MOD_MASK;
      \t
      \t   while (prescalerValue<=7) {
      \t      float clock    = inputClock/prescaleFactor;
      \t      float modValueF = period*clock;
      \t      if (centreAligned) {
      \t         // PeriodInTicks = 2*MOD
      \t         modValueF = modValueF/2;
      \t      }
      \t      else {
      \t         // PeriodInTicks = MOD+1
      \t         modValueF = modValueF - 1;
      \t      }
      \t      unsigned modValue = round(modValueF);
      \t      if (modValue <= maxModValue) {
      \t         sc   = (sc&~TPM_SC_PS_MASK)|TPM_SC_PS(prescalerValue);
      \t         mod  = modValue;
      \t         return E_NO_ERROR;
      \t      }
      \t      prescalerValue++;
      \t      prescaleFactor <<= 1;
      \t   }
      \t   // Too long a period
      \t   usbdm_assert(false, "Interval is too long");
      \t   return setErrorCode(E_TOO_LARGE);
      \t}
      \t\n
   ]]></template>

   <constant key="/$(_basename)_common_info_done" condition="!/$(_basename)_common_info_done" />

<!--  ___ Init class ______________ -->

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * //
      \t * // $(_BASENAME) call-back
      \t * //
      \t * // @param status  Status reflecting active inputs
      \t * //
      \t * void $(_basename)Callback() {
      \t *    ...
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_Baseclass)Init {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    TpmCountMode_LeftAligned ,        // Alignment (Count mode) - Left-aligned (count up)
      \t *    TpmOverflowAction_None ,          // Action on Counter overflow - No action
      \t *    TpmClockSource_SystemTpmClock ,   // Clock Source - System clock
      \t *
      \t *    TpmPrescale_DivBy16,              // Clock prescaler
      \t *    3000_ticks,                       // Counter modulo (mod) value
      \t *                                      //  ----- OR -----
      \t *    100_ms,                           // Timer period or minimum interval in seconds
      \t *
      \t *    TpmDozeMode_Running ,             // Doze Enable - Continue in Doze mode.
      \t *    TpmBdmMode_Running ,              // Debug Mode - Running
      \t *    TpmGlobalTimebaseSync_Disabled ,  // Global Time Base Synchronization - Disabled
      \t *    TpmUseGlobalTimebase_Disabled ,   // Global Time Base Enable - Use internally generated TPM counter
      \t *    TpmStart_Immediately ,            // Counter Start on Trigger - Normal operation (starts immediately)
      \t *    TpmAfterOverflow_Continue ,       // Counter Stop On Overflow - Continue after overflow
      \t *    TpmReload_IgnoreTrigger ,         // Counter Reload On Trigger - No reload (Normal operation)
      \t *    TpmPause_Never ,                  // Counter Pause On Trigger - Ignore trigger (Normal operation)
      \t *    TpmPolarity_Ch0ActiveLow,         // Channel polarity - Channel 0 active-low
      \t *    TpmPolarity_Ch1ActiveLow,         // Channel polarity - Channel 1 active-low
      \t *    TpmTriggerPolarity_ActiveLow ,    // Trigger Polarity - Active-low
      \t *
      \t *                                      // Either internal with multiple sources
      \t *    TpmTriggerSource_Internal ,       // Trigger Source - Trigger source is internal
      \t *    TpmInternalTrigger_Ch0,           // Internal Trigger Select - Channel 0 Input capture
      \t *    TpmInternalTrigger_Ch1,           // Internal Trigger Select - Channel 0 Input capture
      \t *                                      //  --- OR ---
      \t *                                      // External with a single source
      \t *    TpmTriggerSource_External ,       // Trigger Source - Trigger source is external
      \t *    TpmTriggerSelect_CMP0,            // Trigger Select - CMP0
      \t *
      \t *    timerCallback,                    // Shared call-back (overflow)
      \t *    timerChannelCallback,             // Shared call-back (all channels)
      \t *    NvicPriority_VeryHigh,            // IRQ level for this peripheral
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_Baseclass)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!-- ____ Init class Member variables ________ -->

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
    ><![CDATA[
      %multilineDescription
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <for keys=" type        : variables                                         : init    "
       values="%baseType   : tpm_pol_pol                                       : 0       ;
               %baseType   : tpm_mod_mod                                       : 0       ;
               %returnType : tpm_modPeriod                                     : 0_s     ;
               %baseType   : tpm_sc_action,tpm_sc_cpwms,tpm_sc_cmod,tpm_sc_ps  : 0       ;
               %baseType   : tpm_conf_dozeen,tpm_conf_dbgmode,
                             tpm_conf_gtbsync,tpm_conf_gtbeen,
                             tpm_conf_csot,tpm_conf_csoo,
                             tpm_conf_crot,tpm_conf_cpot,
                             tpm_conf_trgpol,
                             tpm_conf_trgsel_int,tpm_conf_trgsel_ext,          : 0       ">
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %defaultValue;\n\n
   ]]></variableTemplate >

<!-- ____ Init class Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for overflow and fault interrupt call-back
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramExpression Overflow and fault interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(CallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->callbackFunction = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t   %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <!-- Bit set/clear in Field -->
   <for keys="r" values="
      tpm_pol_pol" >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
            \t      // Modify bit
            \t      %registerName = (%registerName&(%paramExpression>>8))|%paramExpression;
            \t   }
            \t\n
         ]]></variableTemplate>
      </for>

   <!-- Bit set in Field -->
   <for keys="r" values="
      tpm_conf_trgsel_int" >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      // Set bit
         \t      %registerName = %registerName|%paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <!-- Exclusive Fields -->
   <for keys="r" values="tpm_sc_action;tpm_sc_cpwms;tpm_sc_cmod;tpm_sc_ps;
                         tpm_conf_dozeen;tpm_conf_dbgmode;tpm_conf_gtbsync;tpm_conf_gtbeen;
                         tpm_conf_csot;tpm_conf_csoo;tpm_conf_crot;tpm_conf_cpot;
                         tpm_conf_trgpol;tpm_conf_trgsel_ext" >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
         multipleParamsOnNewline="true"
         nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="tpm_sc_ps, tpm_mod_mod"
      params=",mod_ticks"
      linePadding="xxx"
      nonDefaultParams="2"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0    = (%registerName0&~%mask0) | %paramName0;
      \t      %registerName1   = %paramName1;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      nonDefaultParams="2"
      variables="tpm_modPeriod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      mod   = 0;
      \t      %registerName = %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t}; // class $(_Structname)BasicInfo::Init\n\n
   ]]></template>

<!-- ____ Init class Configure method ____ -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Configure TPM from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const Init &init) {
      \t
      \t   // Enable peripheral (clock and pins as needed)
      \t   enable();\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   setCallbacks(init);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   uint8_t  sc    = init.sc;
      \t   uint16_t mod   = init.mod;
      \t
      \t   if (init.modperiod != 0) {
      \t
      \t      // Calculate sc.ps, mod (assumes cntin=0 or non-existent)
      \t      const float inputClock = getInputClockFrequency((TpmClockSource)(sc&TPM_SC_CMOD_MASK));
      \t      ErrorCode rc = calculateTimingParameters(inputClock, init.modperiod, sc, mod);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }
      \t      if constexpr (minimumResolution>0) {
      \t         if (mod < minimumResolution) {
      \t            // Too short a period for minimum resolution
      \t            return setErrorCode(E_TOO_SMALL);
      \t         }
      \t      }
      \t   }\n
   ]]></template>
   <for keys=
          " var                                   : statement                          "
   values=" tpm_sc_action,tpm_sc_cpwms,
            tpm_sc_cmod,tpm_sc_ps                 : %register = 0                      ;
            tpm_mod_mod                           : %register = mod                    ;
            tpm_cnt_count                         : %register = 0                      ;
            tpm_sc_action,tpm_sc_cpwms,
            tpm_sc_cmod,tpm_sc_ps                 : %register = sc                     ;
            tpm_pol_pol                           : %configRegAssignment               ;
            tpm_conf_dozeen,tpm_conf_dbgmode,
            tpm_conf_gtbsync,tpm_conf_gtbeen,
            tpm_conf_csot,tpm_conf_csoo,
            tpm_conf_crot,tpm_conf_cpot,
            tpm_conf_trgpol,
            tpm_conf_trgsel_int,
            tpm_conf_trgsel_ext                   : %configRegAssignment               " >
      <variableTemplate codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)"
         variables="%(var)"
         linePadding="xxx"
      ><![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!-- ____ Default Initialisation value ________ -->

   <!--  variableTemplate where="usbdm" codeGenCondition='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(irqHandlerName!="")'
      variables="irqHandlerName"
   ><![CDATA[
      \t/**
      \t * Handler for callback
      \t */
      \textern void $(irqHandlerName)(void);
      \t\n
   ]]>
   </variableTemplate -->
   <variableTemplate codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)"
      separator=","
      terminator=","
      variables="
         tpm_sc_action,tpm_sc_cpwms,tpm_sc_cmod,tpm_sc_ps,
         tpm_mod_mod,
         tpm_pol_pol,
         tpm_conf_dozeen,tpm_conf_dbgmode,
         tpm_conf_gtbsync,tpm_conf_gtbeen,
         tpm_conf_csot,tpm_conf_csoo,tpm_conf_crot,tpm_conf_cpot,
         tpm_conf_trgpol,tpm_conf_trgsel_ext,tpm_conf_trgsel_int"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression\n
      \t//  $(irqHandlerName)
      \t};
      \t\n
   ]]>
   </variableTemplate>

<!-- ___ ChannelInit class ______________ -->

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Baseclass)Channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::ChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    TpmChannelNum_3,            // Channel to initialise (may be unused if specifically provided as parameter)
      \t *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
      \t *    TpmChannelAction_None ,     // Action on Channel Event - No action
      \t *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
      \t *    0_ticks,                    // Output Compare Event time
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[TpmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configure(channelInit)
      \t * @endcode
      \t */
      \tclass ChannelInit {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]></template>

   <!-- ____ ChannelInit Class Member variables ________ -->

   <for keys=" type        : variables                         : init                 "
       values="%baseType   : tpm_cnv_independent[]             : 0                    ;
               uint8_t     : tpm_cnsc_mode_independent[],
                             tpm_cnsc_action_independent[],
                             tpm_cnsc_icrst_independent[]      : 0                    ;
               %paramType  : tpm_channel_number                : %paramType_None      ;
               %baseType   : tpm_filter_fval_independent[]     : %paramType_Disabled  " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <!-- ____ ChannelInit Constructors ____________ -->

   <for keys="   r   "
      values=" tpm_channel_number;
               tpm_cnsc_mode_independent[];
               tpm_cnsc_action_independent[];
               tpm_cnsc_icrst_independent[];
               tpm_filter_fval_independent[];
               tpm_cnv_independent[]" >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t}; // class  $(_Structname)BasicInfo::ChannelInit\n\n
   ]]></template>

   <!-- ____ ChannelInit Configure methods ____________ -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const ChannelInit &channelInit) {
      \t   return configure(channelInit.channel, channelInit);
      \t}
      \t
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelNum  Select channel to initialise.
      \t *                    This allows applying channelInit to arbitrary channel
      \t * @param init        Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(TpmChannelNum channelNum, const ChannelInit &init) {
      \t
      \t   // Disable clock so changes have immediate effect
      \t   uint8_t sc = tpm->SC;
      \t   tpm->SC = 0;
      \t\n
   ]]></template>
   <for keys=
            "  var                          : reg"
      values="
              tpm_cnsc_mode_independent[],
              tpm_cnsc_action_independent[] : CnSC    ;
              tpm_cnv_independent[]         : CnV     " >
      <variableTemplate codeGenCondition="enablePeripheralSupport"
         variables="%(var)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   tpm->CONTROLS[channelNum].%(reg) = init.%registerName;
         \t\n
      ]]></variableTemplate>
   </for>
   <variableTemplate codeGenCondition="enablePeripheralSupport"
      variables="tpm_filter_fval_independent[]"
      condition="tpm_filter_fval_independent[]"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   tpm->FILTER = (tpm->FILTER & (TPM_FILTER_CH0FVAL_MASK<<(channelNum*4)))|(init.filter<<(channelNum*4));
      \t\n
   ]]></variableTemplate>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Restore clock
      \t   tpm->SC = sc;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Configure Channel from values specified in channelInit array
      \t *
      \t * @param channelInit Array containing initialisation values
      \t */
      \ttemplate<size_t N>
      \tstatic ErrorCode configure(const ChannelInit (&channelInit)[N]) {
      \t
      \t   ErrorCode rc = E_NO_ERROR;
      \t   for (size_t i=0; i<N; i++) {
      \t      rc = configure(channelInit[i].channel, channelInit[i]);
      \t      if (rc != E_NO_ERROR) {
      \t         break;
      \t      }
      \t   }
      \t   return rc;
      \t}
      \t\n
   ]]></template>

   <!-- ____ ChannelInit Default Initialisation value ____________ -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)ChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
   ]]></template>
   <for keys="ch" dim="=_channelCount" >
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(tpm_cnsc_mode_independent[%(ch)]!=0)"
         separator=","
         terminator=","
         variables="
            tpm_cnsc_mode_independent[%(ch)],
            tpm_cnsc_action_independent[%(ch)],
            ftpm_cnsc_icrst_independent[%(ch)],
            tpm_cnv_independent[%(ch)],
            tpm_filter_fval_independent[%(ch)]"
      ><![CDATA[
         \t{
         \t   TpmChannelNum_%(ch),
         %initExpression\n\t},\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \n\t};\n\n
  ]]></template>

<if condition="tpm_combine_present" >
<!--   ___ DualChannelInit class ______________ -->

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of a pair of $(_Baseclass)Channels operating in Paired mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::DualChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    // Paired values (i.e. corresponding values for both channels) must be present as pairs
      \t *    TpmChannelNum_0, // and TpmChannelNum_1
      \t *
      \t *    TpmEvenChannelMode_DualEdgeCaptureRisingEdge,   // Paired Channel mode and Ch 0 function - Dual-edge Capture Rising-edge
      \t *    TpmOddChannelMode_FallingEdge ,                 // Odd channel (1) Capture Polarity - Capture Falling-edge
      \t *    TpmCombineSwap_EvenChannelCapture,              // Combine Channel 0 and 1 Swap - Even channel capture
      \t *    TpmFilter_16_clocks ,                           // Channel 0 Filter - 16 clock cycles
      \t *    TpmFilter_20_clocks ,                           // Channel 1 Filter - 20 clock cycles
      \t *    TpmChannelAction_Dma ,                          // Action on First (Ch 0) Event - DMA request
      \t *    TpmChannelAction_Interrupt,                     // Action on Second (Ch 1) Event - Interrupt Request
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[TpmChannelNum_0]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configure(channelInit)
      \t * @endcode
      \t */
      \tclass DualChannelInit {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr DualChannelInit(const DualChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr DualChannelInit() = default;
      \t\n
   ]]></template>

   <!-- DualChannelInit Class Member variables -->

   <for keys=" type        : variables                               : init                     "
       values="%baseType   : tpm_cnv_paired[0],tpm_cnv_paired[1]     : {0,0}                    ;
               uint8_t     : tpm_cnsc_mode_even[],
                             tpm_cnsc_mode_odd[1]                    : {0,0}                    " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(variables)"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName[2] = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <for keys=" type        : variables                               : init                     "
       values="%baseType   : tpm_combine_comswap                     : 0                    ;
               %paramType  : tpm_channel_number                      : %paramType_None      ;
               %baseType   : tpm_filter_fval_paired[]                : %paramType_Disabled  " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(variables)"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <!-- ____ DualChannelInit Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="tpm_cnsc_mode_even[0]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variable)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName[0] = %paramExpression;
      \t
      \t      // %paramExpression also includes COMBINE
      \t      combine = (combine&~TPM_COMBINE_COMBINE0_MASK) | (tpmEvenChannelMode>>8);
      \t   }
      \t\n
   ]]></variableTemplate>

   <for keys="    r                       : index "
      values="    tpm_channel_number      :       ;
                  tpm_cnsc_mode_odd[1]    : [1]   "    >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
         \t
         \t      %registerName%(index) = %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <for keys="   reg                                                  : param  "
      values=" tpm_cnsc_action_paired[0],tpm_cnsc_action_paired[1]    : action " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         params="%(param)Even, %(param)Odd"
         variables="%(reg)"
         nonDefaultParams="2"
         linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%(reg))
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName[0]    = (%registerName[0]&~%mask0) | %paramName0;
      \t      %registerName[1]    = (%registerName[1]&~%mask0) | %paramName1;
      \t   }
      \t\n
      ]]></variableTemplate>
   </for>

   <for keys="   reg                               : param  "
      values=" tpm_cnv_paired[0],tpm_cnv_paired[1] : eventTime  " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         params="%(param)Even, %(param)Odd"
         variables="%(reg)"
         nonDefaultParams="2"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(reg))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
         \t
         \t      %registerName[0] = %paramName0;
         \t      %registerName[1] = %paramName1;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      params="filterEven, filterOdd"
      variables="tpm_filter_fval_paired[0],tpm_filter_fval_paired[1]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variable)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName = %paramName0 | (%paramName1<<4);
      \t   }
      \t\n
   ]]></variableTemplate>

   <for keys="   var                      : index "
      values=" tpm_combine_comswap        :       ;
               tpm_cnsc_icrst_paired[1]   : [1]   " >
      <variableTemplate where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(var)"
         linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%(var))
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName%(index) = (%registerName%(index)&~%mask) | %paramName;
      \t   }
      \t\n
      ]]></variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t}; // class  $(_Structname)BasicInfo::DualChannelInit\n\n
   ]]></template>

   <!-- ____ DualChannelInit Configure methods ____________ -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure a pair of channels from values specified in dualChannelInit
      \t *
      \t * @param dualChannelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const DualChannelInit &dualChannelInit) {
      \t   return configure(dualChannelInit.channel, dualChannelInit);
      \t}
      \t
      \t/**
      \t * Configure a pair of channels from values specified in dualChannelInit
      \t *
      \t * @param channelNum      Select channel to initialise.
      \t *                        This allows applying channelInit to arbitrary channel
      \t * @param dualChannelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(TpmChannelNum channelNum, const DualChannelInit &dualChannelInit) {
      \t
      \t   // Disable clock so changes have immediate effect
      \t   uint8_t sc = tpm->SC;
      \t   tpm->SC = 0;
      \t
      \t   // Even channel value controls paired channels n,n+1
      \t   const unsigned offset = 4*channelNum;
      \t   const uint32_t mask = 0xFF<<offset;
      \t   tpm->COMBINE = (tpm->COMBINE & ~mask) | (uint32_t(dualChannelInit.combine)<<offset);
      \t
      \t   // Configure timer channel
      \t   tpm->CONTROLS[channelNum].CnV    = dualChannelInit.cnv[0];
      \t   tpm->CONTROLS[channelNum+1].CnV  = dualChannelInit.cnv[1];
      \t   tpm->CONTROLS[channelNum].CnSC   = dualChannelInit.cnsc[0];
      \t   tpm->CONTROLS[channelNum+1].CnSC = dualChannelInit.cnsc[1];
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="tpm_filter_fval_independent[]&amp;&amp;tpm_combine_present" ><![CDATA[
      \t   tpm->FILTER = (tpm->FILTER & ((TPM_FILTER_CH1FVAL_MASK|TPM_FILTER_CH0FVAL_MASK)<<offset))|
      \t                  (dualChannelInit.filter<<offset);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Restore clock
      \t   tpm->SC = sc;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Configure a pairs of channels from values specified in dualChannelInit array
      \t *
      \t * @param dualChannelInit Array containing initialisation values
      \t */
      \ttemplate<size_t N>
      \tstatic ErrorCode configure(const DualChannelInit (&dualChannelInit)[N]) {
      \t
      \t   ErrorCode rc = E_NO_ERROR;
      \t   for (size_t i=0; i<N; i++) {
      \t      rc = configure(dualChannelInit[i].channel, dualChannelInit[i]);
      \t      if (rc != E_NO_ERROR) {
      \t         break;
      \t      }
      \t   }
      \t   return rc;
      \t}
      \t\n
   ]]></template>

   <!--  DualChannelInit Default Initialisation value -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)DualChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr DualChannelInit DefaultDualChannelInitValues[] = {\n
   ]]></template>
   <for keys=   "evenCh : oddCh : pairedCh "
        values= "0      : 1     :   0 ;
                 2      : 3     :   1 ;
                 4      : 5     :   2 ;
                 6      : 7     :   3 " >
      <if condition="=%(evenCh)>=_channelCount">
         <break/>
      </if>
      <!-- Common -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         separator=","
         terminator=","
         variables="
            tpm_cnsc_mode_even[%(evenCh)]"
      ><![CDATA[
         \t{
         \t   TpmChannelNum_%(evenCh), // and TpmChannelNum_%(oddCh)
         %initExpression\n
      ]]></variableTemplate>

      <!-- Combined PWM  -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(tpm_cnsc_mode_even[%(evenCh)]==(1,2))"
         separator=","
         terminator=","
         variables="
            tpm_cnsc_mode_odd_pwm[%(oddCh)],
            tpm_cnv_paired[%(evenCh)],
            tpm_cnv_paired[%(oddCh)],
            tpm_combine_comswap_pwm%(pairedCh)"
      ><![CDATA[
         %initExpression\n
      ]]></variableTemplate>

      <!-- Dual capture -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(tpm_cnsc_mode_even[%(evenCh)]>=3)"
         separator=","
         terminator=","
         variables="
            tpm_cnsc_secondEdge[%(oddCh)],
            tpm_combine_comswap_dec%(evenCh),
            tpm_cnsc_icrst_paired[%(oddCh)]"
      ><![CDATA[
         %initExpression\n
      ]]></variableTemplate>

      <!-- Common -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(tpm_cnsc_mode_even[%(evenCh)]!=0)"
         separator=","
         terminator=","
         variables="
            tpm_filter_fval_paired[%(evenCh)],
            tpm_filter_fval_paired[%(oddCh)],
            tpm_cnsc_action_paired[%(evenCh)],
            tpm_cnsc_action_paired[%(oddCh)]"
      ><![CDATA[
         %initExpression\n\t},\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" condition="tpm_combine_present" ><![CDATA[
      \n\t};\n\n
  ]]></template>
</if>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_code" />
   <xi:include href="tpm_quadrature_decoder.xml"/>
   <deleteVariables variables="_code"/>

<!--  ___ End of class  $(_Structname)BasicInfo ______________ -->

<!-- ___ Set interrupt handlers ___________ -->

<!--
   <template  codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Set overflow and fault interrupt call-back
      \t *
      \t * @param[in] newCallback Callback function to execute on interrupt.
      \t *                        Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t */
      \tstatic ErrorCode setCallback(CallbackFunction newCallback) {
      \t
      \t   if (newCallback == nullptr) {
      \t      newCallback = unhandledCallback;
      \t   }
      \t   sCallback = newCallback;
      \t   return E_NO_ERROR;
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="!irqHandlingMethod&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setCallbacks(const Init &) {
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="!irqHandlingMethod&amp;&amp;enablePeripheralSupport" condition="tpm_combine_present" ><![CDATA[
      \t/**
      \t * Set channel callbacks from DualChannelInit structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setChannelCallback(const DualChannelInit &) {
      \t}
      \t\n
   ]]></template>
   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(_hardwareIrqCount==1)" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for shared channel call-backs i.e. all channels use same call-back
      \t *
      \t * @param[in] callback Callback function to execute on channel interrupt.
      \t *                     Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note The channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      \t   if (callback == nullptr) {
      \t      channelCallbacks[0] = unhandledChannelCallback;
      \t      return E_NO_ERROR;
      \t   }
      #ifdef DEBUG_BUILD
      \t   // Callback is shared across all channels. Check if callback already assigned
      \t   if ((channelCallbacks[0] != unhandledChannelCallback) &&
      \t       (channelCallbacks[0] != callback)) {
      \t      return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      \t   }
      #endif
      \t   channelCallbacks[0] = callback;
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @note Channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic void setCallbacks(const Init &init) {
      \t
      \t   disableNvicInterrupts();
      \t   setCallback(init.callbackFunction);
      \t   setChannelCallback(init.channelCallbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(_hardwareIrqCount>1)" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for individual channel call-backs
      \t *
      \t * @param[in] irqNum     Index of handler to set call-back for
      \t * @param[in] callback   Callback function to execute on channel interrupt.
      \t *                       Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note Sevral channel call-backs are provided
      \t */
      \tstatic ErrorCode setChannelCallback(unsigned irqNum, ChannelCallbackFunction callback) {
      \t
      \t   if (irqNum>=irqCount) {
      \t      return setErrorCode(ErrorCode::E_ILLEGAL_PARAM);
      \t   }
      \t   if (callback == nullptr) {
      \t      channelCallbacks[irqNum] = unhandledChannelCallback;
      \t      return ErrorCode::E_NO_ERROR;
      \t   }
      \t   channelCallbacks[irqNum] = callback;
      \t   return ErrorCode::E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \t static void setCallbacks(const Init &init) {
      \t
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>
-->
   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(_hardwareIrqCount==1)" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @note Channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic void setCallbacks(const Init &init) {
      \t
      \t   disableNvicInterrupts();
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>

   <!--  Calculate if any channels configured  -->
   <for keys="ch" dim="=_channelCount">
      <if condition="!do_channel_init">
         <!-- 1st time -->
         <equation key="do_channel_init" value='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;((tpm_cnsc_mode_independent[%(ch)]>0)' />
      <else />
         <equation key="do_channel_init" value='=do_channel_init+"||(tpm_cnsc_mode_independent[%(ch)]>0)"' />
      </if>
   </for>
   <equation key="do_channel_init" value='=do_channel_init+")"' />
   <!-- printVar key="do_channel_init" / -->

   <for keys="ch" values="0;2;4;6" condition="tpm_combine_present" >
      <break condition="=%(ch)>=_channelCount" />
      <if condition="!do_dualchannel_init">
         <!-- 1st time -->
         <equation key="do_dualchannel_init" value='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;((tpm_cnsc_mode_even[%(ch)]>0)' />
      <else />
         <equation key="do_dualchannel_init" value='=do_dualchannel_init+"||(tpm_cnsc_mode_even[%(ch)]>0)"' />
      </if>
   </for>
   <equation key="do_dualchannel_init" value='=do_dualchannel_init+")"' condition="tpm_combine_present" />
   <!-- printVar key="do_dualchannel_init" / -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Default configuration using settings from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t   // Base configuration for I/C, O/C and PWM
      \t   configure(DefaultInitValue);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode==Quad)" ><![CDATA[
      \t   // Configuration for Quadrature decoder
      \t   configure(DefaultQuadInitValue);
      \t\n
   ]]></template>
   <template codeGenCondition="=do_channel_init" ><![CDATA[
      \t   // Configuration of individual channels
      \t   configure(DefaultChannelInitValues);
      \t\n
   ]]></template>
   <template codeGenCondition="=do_dualchannel_init" condition="tpm_combine_present" ><![CDATA[
      \t   // Configuration of paired channels
      \t   configure(DefaultDualChannelInitValues);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t\n
   ]]></template>

   <!-- ____ Getters and Setters __________________ -->
   <xi:include href="tpm_getters_setters.xml"/>


   <!-- ____ Common __________________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Baseclass)Base_T<$(_Class)Info> $(_Class);\n
   ]]>
   </template>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_declaration" />
   <xi:include href="tpm_quadrature_decoder.xml"/>
   <deleteVariables variables="_declaration"/>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.TpmValidate" >
   </validate>

   <projectActionList id="tpm_files" >
      <copy source="Project_Headers/tpm.h"            target="Project_Headers/tpm.h"            overwrite="true" derived="true" />
      <copy source="Snippets/tpm-pwm-example.cpp"     target="Snippets/tpm-pwm-example.cpp"     overwrite="true" derived="true"/>
      <copy source="Snippets/tpm-ic-example.cpp"      target="Snippets/tpm-ic-example.cpp"      overwrite="true" derived="true"/>
      <copy source="Snippets/tpm-oc-example.cpp"      target="Snippets/tpm-oc-example.cpp"      overwrite="true" derived="true"/>
      <copy source="Snippets/tpm-oc-init-example.cpp" target="Snippets/tpm-oc-init-example.cpp" overwrite="true" derived="true"/>
   </projectActionList>

   <!-- ____ Startup __________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration __________________ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping __________________ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />
   <signals name="TPM" optional="true" />

</fragment>

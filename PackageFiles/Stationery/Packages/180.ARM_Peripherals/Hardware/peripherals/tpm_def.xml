<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- tpm_quad.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <xi:include href="_default_instance.xml"/>

   <xi:include href="_irqOption.xml"/>
   
   <aliasOption key="/SIM/sim_sopt2_pllfllsel" constant="false"  optional="true" /> 
   <aliasOption key="/SIM/sim_sopt2_tpmsrc"    constant="false"  optional="true" />
   <aliasOption key="/SIM/system_tpm_clock"    optional="true"                   />

   <binaryOption key="check_minimums" 
      description="Check minimum interval and minimum resolution"
      toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
      <choice value="0" name="No checks done" />
      <choice value="1" name="Do checks"  isDefault="true" />
   </binaryOption>

   <intOption key="minimumInterval" 
      description="Minimum usable interval in ticks"
      toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
               when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
      value="20" min="0" max="65535"/>
      
   <intOption key="minimumResolution" 
      description="Minimum resolution for PWM interval"
      toolTip="This value is used as a minimum value for the timer period in ticks \n
         so that a reasonable resolution is available for PWM duty-cycle"
      value="100" min="0" max="65535" />
      
   <intOption key="tpmExternalClock" 
      description="TPM External clock "
      toolTip="Clock frequency of external clock supplied to TPM_CLKIN pin"
      value="0" min="0" units="Hz"/>

   <choiceOption key="tpm_sc_cmod" 
      description="Clock Source"
      enumStem="TpmClockSource"
      enumType="uint16_t"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module">
      <choice value="0" name="Disabled"         ref="disabled"              code="0"                      enum="Disabled"        />
      <choice value="1" name="System TPM Clock" ref="/SIM/system_tpm_clock" code="SimInfo::getTpmClock()" enum="SystemTpmClock"  isDefault="true"  />
      <choice value="2" name="External clock"   ref="tpmExternalClock"      code="tpmExternalClock"       enum="ExternalClock"   />
   </choiceOption>
   
   <intOption key="inputClockFrequency" 
      constant="true"
      description="Frequency of input clock to timer"
      derived="true"
      units="Hz"/>
      
   <choiceOption key="tpm_sc_ps" 
      description="Clock prescaler"
      enumStem="TpmPrescale"
      enumType="uint16_t"
      target="clockFrequency"
      toolTip="Selects the prescaler for the module">
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"      enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="(inputClockFrequency)/2."   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="(inputClockFrequency)/4."   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="(inputClockFrequency)/8."   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="(inputClockFrequency)/16."  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="(inputClockFrequency)/32."  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="(inputClockFrequency)/64."  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="(inputClockFrequency)/128." enum="DivBy128" />
   </choiceOption>
      
   <intOption key="clockFrequency" 
      constant="true"
      description="Frequency of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="Hz"/>
   
   <floatOption key="clockPeriod" 
      ref="clockFrequency;(1.0/clockFrequency)"
      constant="true"
      description="Period of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="s"/>
      
   <choiceOption key="tpm_sc_mode"
      valueFormat="TPM_SC_TOF(%s),TPM_SC_CPWMS(%s)"
      enumStem="TpmMode"
      enumType="uint16_t"
      description="Alignment and whether interval or free-running mode"
      toolTip="Left-aligned   (0...mod) or\n
               Centre-aligned (0...mod...0) or\n
               Free-running   (0...maximum_value)">
      <choice value="0,0" name="Left-aligned (count up)"         enum="LeftAligned"    />
      <choice value="0,1" name="Centre-aligned (count up-down)"  enum="CentreAligned"  />
      <choice value="1,0" name="Free-running (count up)"         enum="FreeRunning"  isDefault="true" />
   </choiceOption>
   
   <intOption key="tpm_mod" description="End value for counter"
      enabledBy="tpm_sc_mode!=2"
      toolTip="The timer counts from 0 to this value"
      typeName="Ticks &amp;"
      valueFormat="%s_ticks"
      value="65535" min="0" max="65535" />
           
   <floatOption key="tpm_modPeriod" 
      ref="clockPeriod*((tpm_sc_mode==2)?(65536):((tpm_sc_mode==1)?(2*(tpm_mod)):(tpm_mod+1)))" 
      typeName="Seconds &amp;"     
      valueFormat="%s_s"
      description="Period or minimum interval of timer"
      toolTip="In left-aligned or centre-aligned this is the period of the timer\n
               In free-running mode it is the minimum interval"
      derived="true"
      min="0" units="s"/>
      
   <choiceOption key="tpm_sc_action" condition="tpm_sc_toie_present&amp;&amp;tpm_sc_dma_present"
      enabledBy="irqHandlingMethod"
      valueFormat="TPM_SC_TOIE(%s),TPM_SC_DMA(%s)"
      enumType="uint16_t"
      enumStem="TpmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt and/or DMA on counter overflow">
       <choice value="0,0" name="No action"                    enum="None"             />                              
       <choice value="0,1" name="DMA request"                  enum="Dma"              />                              
       <choice value="1,0" name="Interrupt request"            enum="Interrupt"        />                              
       <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  />                              
   </choiceOption>
   
   <binaryOption key="tpm_sc_action" condition="tpm_sc_toie_present&amp;&amp;!tpm_sc_dma_present"
      enabledBy="irqHandlingMethod"
      valueFormat="TPM_SC_TOIE(%s)"
      enumType="uint16_t"
      enumStem="TpmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt on counter overflow">
      <choice value="0" name="No action"          enum="None"       />
      <choice value="1" name="Overflow Interrupt" enum="Interrupt"  />
   </binaryOption>

   <choiceOption key="tpm_channel_number"
      hidden="true"
      derived="true"
      enumType="uint8_t"
      valueFormat="%s"
      enumStem="TpmChannelNum"
      description="Channel Number"
      toolTip="Select a channel">
      <choice value="0"             name="Channel 0"      enum="0" />
      <choice value="1"             name="Channel 1"      enum="1" />
      <choice value="2"             name="Channel 2"      enum="2" />
      <choice value="3"             name="Channel 3"      enum="3" />
      <choice value="4"             name="Channel 4"      enum="4" />
      <choice value="5"             name="Channel 5"      enum="5" />
      <choice value="6"             name="Channel 6"      enum="6" />
      <choice value="7"             name="Channel 7"      enum="7" />
      <choice value="(uint8_t(-1))" name="No Channel"     enum="None" />      
   </choiceOption>
   
   <!--  **************** Channels **************** -->
   
   <for keys="ch" dim="NumChannels">
      <stringOption name="TPM Channel %(ch)" key="TpmChannel%(ch)" derived="true" value="----- %(ch) -----"/>
      
      <choiceOption key="tpm_cnsc_mode[%(ch)]" condition="tpm_combine_decap0_present&amp;&amp;tpm_cnsc_ms_present&amp;&amp;tpm_cnsc_els_present"
         valueFormat="(TPM_COMBINE_DECAPEN0(%s)&lt;&lt;8),(TPM_COMBINE_COMBINE0(%s)&lt;&lt;8),TPM_CnSC_MS(%s),TPM_CnSC_ELS(%s)"
         enumType="uint16_t"
         enumStem="TpmChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (PWM/Input capture/Output compare)">
          <choice value="0,0,0,0" name="Disabled"                                   enum="Disabled"                               />                              
          <choice value="0,0,0,1" name="Input Capture Rising-edge"                  enum="InputCaptureRisingEdge"                 />
          <choice value="0,0,0,2" name="Input Capture Falling-edge"                 enum="InputCaptureFallingEdge"                />
          <choice value="0,0,0,3" name="Input Capture Either-edge"                  enum="InputCaptureEitherEdge"                 />
          <choice value="0,0,1,0" name="Output Compare No action"                   enum="OutputCompare"                          />
          <choice value="0,0,1,1" name="Output Compare Toggle"                      enum="OutputCompareToggle"                    />
          <choice value="0,0,1,2" name="Output Compare Clear"                       enum="OutputCompareClear"                     />
          <choice value="0,0,1,3" name="Output Compare Set"                         enum="OutputCompareSet"                       />
          <choice value="0,0,2,2" name="Pwm High-true Pulses"                       enum="PwmHighTruePulses"                      />
          <choice value="0,0,2,1" name="Pwm Low-true Pulses"                        enum="PwmLowTruePulses"                       />
          <choice value="1,0,0,1" name="Dual-edge Capture One-Shot Rising-edge"     enum="DualEdgeCaptureOneShotRisingEdge"       condition="(%(ch)&amp;1)==0" />
          <choice value="1,0,1,1" name="Dual-edge Capture Continuous Rising-edge"   enum="DualEdgeCaptureContinuousRisingEdge"    condition="(%(ch)&amp;1)==0" />
          <choice value="1,0,0,2" name="Dual-edge Capture One-Shot Falling-edge"    enum="DualEdgeCaptureOneShotFallingEdge"      condition="(%(ch)&amp;1)==0" />
          <choice value="1,0,1,2" name="Dual-edge Capture Continuous Falling-edge"  enum="DualEdgeCaptureContinuousFallingEdge"   condition="(%(ch)&amp;1)==0" />
          <choice value="0,1,0,2" name="Combined Positive-pulse"                    enum="CombinePositivePulse"                   condition="(%(ch)&amp;1)==0" />
          <choice value="0,1,0,1" name="Combine Negative-pulse"                     enum="CombineNegativePulse"                   condition="(%(ch)&amp;1)==0" />
      </choiceOption>
   
      <choiceOption key="tpm_cnsc_mode[%(ch)]" condition="!tpm_combine_decap0_present&amp;&amp;tpm_cnsc_ms_present&amp;&amp;tpm_cnsc_els_present"
         valueFormat="TPM_CnSC_MS(%s),TPM_CnSC_ELS(%s)"
         enumType="uint16_t"
         enumStem="TpmChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (PWM/Input capture/Output compare)">
          <choice value="0,0" name="Disabled"                                   enum="Disabled"                               />                              
          <choice value="0,1" name="Input Capture Rising-edge"                  enum="InputCaptureRisingEdge"                 />
          <choice value="0,2" name="Input Capture Falling-edge"                 enum="InputCaptureFallingEdge"                />
          <choice value="0,3" name="Input Capture Either-edge"                  enum="InputCaptureEitherEdge"                 />
          <choice value="1,0" name="Output Compare No action"                   enum="OutputCompare"                          />
          <choice value="1,1" name="Output Compare Toggle"                      enum="OutputCompareToggle"                    />
          <choice value="1,2" name="Output Compare Clear"                       enum="OutputCompareClear"                     />
          <choice value="1,3" name="Output Compare Set"                         enum="OutputCompareSet"                       />
          <choice value="2,2" name="Pwm High-true Pulses"                       enum="PwmHighTruePulses"                      />
          <choice value="2,1" name="Pwm Low-true Pulses"                        enum="PwmLowTruePulses"                       />
      </choiceOption>
   
      <choiceOption key="tpm_cnsc_action[%(ch)]" condition="tpm_cnsc_chie_present&amp;&amp;tpm_cnsc_dma_present"
         valueFormat="TPM_CnSC_CHIE(%s),TPM_CnSC_DMA(%s)"
         enumType="uint8_t"
         enumStem="TpmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt and/or DMA on channel event">
          <choice value="0,0" name="No action"                    enum="None"             />                              
          <choice value="0,1" name="DMA request"                  enum="Dma"              />                              
          <choice value="1,0" name="Interrupt request"            enum="Interrupt"        />                              
          <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  />                              
      </choiceOption>
   
      <binaryOption key="tpm_cnsc_action[%(ch)]" condition="tpm_cnsc_chie_present&amp;&amp;!tpm_cnsc_dma_present"
         valueFormat="TPM_CnSC_CHIE(%s)"
         enumType="uint8_t"
         enumStem="TpmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt on channel event">
          <choice value="0" name="No action"              enum="None"             />                              
          <choice value="1" name="Interrupt request"      enum="Interrupt"        />                              
      </binaryOption>
   
      <binaryOption key="tpm_cnsc_icrst[%(ch)]" condition="tpm_cnsc_icrst_present"
         valueFormat="TPM_CnSC_ICRST(%s)"
         enumStem="TpmChannelReset"
         enumType="uint8_t"
         description="Reset counter on channel IC event"
         toolTip="Enables the channel IC event to reset the shared counter">
         <choice value="0" name="Disabled" enum="Disabled" />
         <choice value="1" name="Enabled"  enum="Enabled"  />
      </binaryOption>
      
      <intOption key="tpm_cnv[%(ch)]"
         valueFormat="%s_ticks" 
         typeName="Ticks &amp;"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter in output compare modes"
         value="0" min="0" max="65535" />
      
      <floatOption key="tpm_cnvEventTime[%(ch)]"
         enabledBy="((tpm_cnsc_mode[%(ch)]&gt;=4)&amp;&amp;(tpm_cnsc_mode[%(ch)]&lt;=7))||(tpm_cnsc_mode[%(ch)]&gt;=14)"
         ref="tpm_cnv[%(ch)]*clockPeriod"
         valueFormat="%s_s" 
         typeName="Seconds &amp;"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value is compared against the main counter in output compare modes"
         value="0" min="0" max="65535" />
      
   </for>
      
   <initialValueTemplate variables="minimumResolution"     
   ><![CDATA[
      \t/// %description
      \tstatic constexpr uint32_t minimumResolution  = $(?check_minimums:$(minimumResolution):0);\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate variables="minimumInterval"     
   ><![CDATA[
      \t/// %description
      \tstatic constexpr uint32_t minimumInterval  = $(?check_minimums:$(minimumInterval):0);\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate variables="tpmExternalClock"     
   ><![CDATA[
      \t/// %description
      \tstatic constexpr uint32_t tpmExternalClock =  $(tpmExternalClock);
   ]]></initialValueTemplate>


   <category name="Advanced" description="Advanced options">
      <aliasOption key="/SIM/sim_sopt4_tpm$(_instance)clksel" optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_tpm$(_instance)ch0src" optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt9_tpm$(_instance)clksel" optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt9_tpm$(_instance)ch0src" optional="true" constant="false" />
   </category>

<!-- ========== Methods =============================== -->
   <for  keys  =" k                    : static    : const" 
         values=" non_static_functions : ''        : ' const';
                  static_functions     : 'static ' : ''     
   ">
      <setTemplate key="/TPM/%(k)" namespace="all"
         discardRepeats="true"
         variables="tpm_sc_cmod,tpm_sc_ps"
         nonDefaultParams="2" 
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask1);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t *
         %comments
         \t */
         \t%(static)void selectClock(
         %params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></setTemplate>
            
      <for keys="  f           :  n" 
         values=" tpm_sc_cmod  : setClockSource;
                  tpm_sc_ps    : setPrescaler;
                  tpm_sc_mode  : setMode">
         <setTemplate key="/TPM/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2" 
         ><![CDATA[
            \t/**
            \t * Set %description
            \t *
            %comments
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void %(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
            
            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;
            
            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);
            
            \t   // Write new value
            \t   %register = %registerName;
            \t}\n\n
         ]]></setTemplate>
      </for>
            
      <setTemplate key="/TPM/%(k)" namespace="all"
         discardRepeats="true"
         variables="tpm_mod,tpm_sc_ps"
      ><![CDATA[
         \t/**
         \t * Set maximum value of timer counter.
         \t *
         \t * @param[in] endValue Modulo value in ticks (<65535), 0 = 65536.
         \t * @param[in] suspend  Whether to suspend timer during change.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note The timer may be disabled while making changes.
         \t * @note This value is write-buffered and updated by MOD synchronisation
         \t *       unless suspend is true.
         \t */
         \t%(static)void setCounterMaximumValue(Ticks endValue, bool suspend=false)%(const) {
         \t   uint32_t %registerName1;
         \t   if (suspend) {
         \t      // Disable timer so register changes are immediate
         \t      sc = %register1;
         \t      %register1 = 0;
         \t      (void)(%register1);
         \t   }
         \t   %register0 = (unsigned)endValue;
         \t   if (suspend) {
         \t      %register1 = sc;
         \t   }
         \t}
         \t/**
         \t * Get maximum value of timer counter.
         \t *
         \t * @return Counter modulo value in ticks (<65535), 0 = 65536.
         \t */
         \t%(static)Ticks getCounterMaximumValue()%(const) {
         \t   return Ticks((unsigned)(tpm->MOD));
         \t}\n\n
      ]]></setTemplate>
   
   </for>

   <clockCodeTemplate variable="tpm_sc_cmod"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      %paramDescription
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t   
      \t   switch(%paramExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!--  ========== TPM Init class =============================== -->

   <template key="init_description" namespace="all" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_class)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Tpm$(_instance)::Init tpmInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    TpmMode_Freerunning,           // Alignment and whether interval or free-running mode
      \t *    TpmOverflowInterrupt_Disabled, // Overflow Interrupt
      \t *    NvicPriority_Normal,           // IRQ level for this peripheral
      \t *    TpmClockSource_SystemClock,    // Clock Source
      \t *
      \t *    // Either 
      \t *    TpmPrescale_DivBy16,           // Clock prescaler
      \t *    10_ticks, 3000_ticks,          // Counter start (cntin) and end (mod) values
      \t *    // OR
      \t *    100_ms,                        // Timer period or minimum interval in seconds
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise TPM from values specified above
      \t * Tpm$(_instance)::configure(tpmInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" ><![CDATA[
      class $(_class)BasicInfo {
      \t
      public:\n\n
   ]]></template>

   <setTemplate namespace="usbdm"
       variables="irqHandlingMethod">
   <![CDATA[
      \t/**
      \t * Type definition for $(_class) %description call back.
      \t */
      \ttypedef void (*%enumClass)();\n\n
   ]]></setTemplate>

   <template namespace="usbdm"><![CDATA[
$(init_description)
      \tclass Init {
      \t
      \tpublic:
      \t   /**                               
      \t    * Copy Constructor                  
      \t    */                             
      \t   constexpr Init(const Init &other) = default;
      \t   
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>
   
<!--  Member variables -->
  
   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod" 
      variables="irqHandlingMethod" 
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>
   
   <initialValueTemplate namespace="usbdm"  
      variables="tpm_sc_action,tpm_sc_cpwms,tpm_sc_cmod,tpm_sc_ps,tpm_sc_mode"
   ><![CDATA[
      \t   /// Status And Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod" 
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"  
      variables="tpm_cntin"
   ><![CDATA[
      \t   /// %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate namespace="usbdm"  
      variables="tpm_mod"
   ><![CDATA[
      \t   /// %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>
   
   <initialValueTemplate namespace="usbdm"  
      variables= "tpm_modPeriod"
    ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_s;\n\n
   ]]></initialValueTemplate >

<!--  Configure method -->
  
   <setTemplate variables="tpm_sc_cmod" discardRepeats="true" key="/TPM/InitMethod" namespace="all" ><![CDATA[
      \t/**
      \t * Configure TPM from values specified in init
      \t
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const typename Info::Init &init) {
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled and non-null
      \t      if (init.callbackFunction != nullptr) {
      \t         setCallback(init.callbackFunction);
      \t      }
      \t      enableNvicInterrupts(init.irqlevel);
      \t   }
      \t   uint8_t  sc    = init.sc;
      \t   uint16_t mod   = init.mod;
      \t
      \t   if (init.modperiod != 0) {
      \t
      \t      // Calculate sc.ps, mod (assumes cntin=0)
      \t      ErrorCode rc = calculateTimingParameters(init.modperiod, sc, mod);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }
      \t   }
      \t   if (init.sc&TpmMode_FreeRunning) {
      \t      // Make free-running
      \t      mod   = TPM_MOD_MOD_MASK;
      \t   }
      \t   // Disable timer to change clock (unable to switch directly between clock sources)
      \t   tpm->SC  = 0;
      \t   
      \t   // End value for counter
      \t   tpm->MOD = mod;
      \t   
      \t   // Restart counter
      \t   tpm->CNT = 0;
      \t
      \t   // Configure timer
      \t   tpm->SC  = sc;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></setTemplate>

<!--  Constructors -->
  
   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod" 
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%enumParam0 = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>
   
   <constructorTemplate namespace="usbdm"
      variables="/PCR/nvic_irqLevel" 
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      #if $(irqHandlingMethod)
      \t      %registerName = %paramExpression;
      #else
      \t      (void)%paramExpression;
      #endif
      \t   }\n\n
   ]]></constructorTemplate>
   
   <for keys="r" values="tpm_sc_action;tpm_sc_cpwms;tpm_sc_mode;tpm_sc_cmod">
      <constructorTemplate  namespace="usbdm" 
         variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   
   <constructorTemplate namespace="usbdm" 
      variables="tpm_sc_ps, tpm_mod"
      linePadding="xxx" 
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 and %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName0 = (%registerName0&%mask0) | %enumParam0;
         \t      %registerName1 = %enumParam1;
         \t   }
         \t\n
   ]]></constructorTemplate>
   
   <constructorTemplate namespace="usbdm" 
      nonDefaultParams="2"
      variables="tpm_modPeriod"
      linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      mod   = 0;
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>
   
   <template namespace="usbdm" ><![CDATA[
      \t};\n\n
   ]]></template>

<!--  Default Initialisation value -->
  
   <initialValueTemplate
      separator=","
      terminator=","     
      variables="
         tpm_sc_mode,
         tpm_sc_action,
         irqLevel,
         tpm_sc_cmod,     
         tpm_sc_ps,
         tpm_cntin,     
         tpm_mod"     
   ><![CDATA[
      $(init_description)
      \ttypedef $(_class)BasicInfo::Init Init;
      \t
      \t/**
      \t * $(_class) interrupt call back
      \t */
      \ttypedef $(_class)BasicInfo::CallbackFunction CallbackFunction;
      \t
      \t/**
      \t * Default initialisation value for Tpm$(_instance)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

<!--  ========== TPM CHANNEL Init class =============================== -->

   <template key="channel_init_description" namespace="all"><![CDATA[
      \t/**
      \t * Class used to do initialisation of Tpm$(_instance)Channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Tpm$(_instance)::ChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    TpmChannelNum_3,            // Channel to initialise
      \t *    TpmChannelMode_Disabled ,   // Channel Mode - Disabled
      \t *    TpmChannelAction_None ,     // Action on Channel Event - No action
      \t *    TpmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
      \t *    0_ticks,                    // Output Compare Event time
      \t * 
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_class)::DefaultChannelInitValues[TpmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise TPM from values specified above
      \t * Tpm$(_instance)::configureChannel(channelInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm"><![CDATA[
$(channel_init_description)
      \tclass ChannelInit {
      \t
      \tpublic:
      \t   /**                               
      \t    * Copy Constructor                  
      \t    */                             
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t   
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]></template>
   
<!--  Member variables -->
  
   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors>1)" 
      variables="irqHandlingMethod" 
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>
   
   <initialValueTemplate namespace="usbdm"  
      variables="tpm_cnv"
   ><![CDATA[
      \t   /// %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>
     
   <initialValueTemplate namespace="usbdm"  
      variables="tpm_cnsc_mode"
   ><![CDATA[
      \t   /// Channel Status And Control Register
      \t   uint16_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm"  
      variables="tpm_channel_number"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = TpmChannelNum_None;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors>1)"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = %enumClass_Normal;\n\n
   ]]></initialValueTemplate>

<!-- Configure method -->
   
   <template discardRepeats="true" key="/TPM/ChannelInitMethod" namespace="all" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configureChannel(const typename Info::ChannelInit &channelInit) {
      \t
      \t   // Enable peripheral clock
      \t   Info::enableClock();
      \t\n
   ]]></template>
   <template discardRepeats="true" key="/TPM/ChannelInitMethod" namespace="all" condition="tpm_combine_combine0_present" ><![CDATA[
      \t   // Configure timer combine mode
      \t   if ((channelInit.channel&0b1) == 0) {
      \t      // Even channel value controls paired channels n,n+1
      \t      const unsigned offset = 4*channelInit.channel;
      \t      const uint32_t mask = 0xFF<<offset;
      \t      tpm->COMBINE = (tpm->COMBINE & ~mask) | (((channelInit.cnsc>>8)<<offset)&mask);
      \t   }\n
   ]]></template>
   <template discardRepeats="true" key="/TPM/ChannelInitMethod" namespace="all" ><![CDATA[
      \t   // Configure timer channel
      \t   tpm->CONTROLS[channelInit.channel].CnV  = channelInit.cnv;
      \t   tpm->CONTROLS[channelInit.channel].CnSC = channelInit.cnsc;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!--  Constructors -->
  
   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors>1)" 
      variables="irqHandlingMethod" 
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      this->%enumParam0 = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>
   
   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors>1)" 
      variables="/PCR/nvic_irqLevel" 
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      #if $(irqHandlingMethod)
      \t      %registerName = %paramExpression;
      #else
      \t      (void)%paramExpression;
      #endif
      \t   }\n\n
   ]]></constructorTemplate>
   
   <for keys="r" values="
      tpm_cnsc_mode;
      tpm_cnsc_action;
      tpm_cnsc_icrst">
      <constructorTemplate  namespace="usbdm"
         variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t   
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   
   <for keys="r" values="
      tpm_channel_number;
      tpm_cnv">
      <constructorTemplate  namespace="usbdm"
         variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t   
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>   
   <template namespace="usbdm"><![CDATA[
      \t};\n\n
   ]]></template>

<!--  Default Initialisation value -->

  <template><![CDATA[
      $(channel_init_description)
      \ttypedef $(_class)BasicInfo::ChannelInit ChannelInit;
      \t
      \t/**
      \t * Default initialisation value for Tpm$(_instance)ChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
  ]]></template>
   <for keys="ch" dim="NumChannels">
      <initialValueTemplate
         separator=","
         terminator=","     
         variables="
            tpm_cnsc_mode[%(ch)],
            tpm_cnsc_action[%(ch)],
            tpm_cnsc_icrst[%(ch)],
            tpm_cnv[%(ch)]"     
      ><![CDATA[
         \t{
         \t   TpmChannelNum_%(ch),
         %initExpression\n\t},\n
      ]]></initialValueTemplate>
   </for>
  <template><![CDATA[
      \n\t};\n\n
  ]]></template>
   
   <template namespace="usbdm" ><![CDATA[
      };\n\n
   ]]></template>

<!--  ========== Misc =============================== -->
   
   <template namespace="all" key="/HARDWARE/StaticObjects" discardRepeats="true" ><![CDATA[
   \t/**
   \t * Callback to catch unhandled channel interrupt
   \t *
   \t * @param mask Mask identifying channel
   \t */
   \tvoid tpmUnhandledChannelCallback(uint8_t mask) {
   \t   (void)mask;
   \t   setAndCheckErrorCode(E_NO_HANDLER);
   \t}\n\n
   ]]></template>
   
   <template><![CDATA[
   \t/**
   \t * Type definition for channel interrupt call back
   \t *
   \t * @param[in] status Flags indicating interrupt source channel(s)
   \t */
   \ttypedef void (*ChannelCallbackFunction)(uint8_t status);
   \t
   \t/**
   \t * Callback table for programmatically set handlers
   \t */
   \tstatic ChannelCallbackFunction sChannelCallbacks[$(NumChannelVectors)];\n\n
   ]]></template>

   <template namespace="all" key="/HARDWARE/StaticObjects" ><![CDATA[
      \t/**
      \t * Callback table for programmatically set handlers for $(_class)
      \t */
      \t$(_class)Info::ChannelCallbackFunction $(_class)Info::sChannelCallbacks[] = {\n\n
   ]]></template>
      <for keys="ch" dim="NumChannelVectors">
         <template namespace="all" key="/HARDWARE/StaticObjects" ><![CDATA[
            \t   tpmUnhandledChannelCallback,\n
         ]]></template>
      </for>
   <template namespace="all" key="/HARDWARE/StaticObjects" ><![CDATA[
      \t};\n\n
   ]]></template>
   
   <xi:include href="_clockOption.xml"/>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.TpmValidate">
   </validate>

   <projectActionList id = "tpm_files" >
      <copy source="Project_Headers/tpm.h"         target="Project_Headers/tpm.h"          overwrite="true" derived="true" />
      <copy source="Snippets/tpm-pwm-example.cpp"  target="Snippets/tpm-pwm-example.cpp"   overwrite="true" derived="true"/>
      <copy source="Snippets/tpm-ic-example.cpp"   target="Snippets/tpm-ic-example.cpp"    overwrite="true" derived="true"/>
      <copy source="Snippets/tpm-oc-example.cpp"   target="Snippets/tpm-oc-example.cpp"    overwrite="true" derived="true"/>
   </projectActionList>
         
   <template key="/TPM/declarations" namespace="all"  
   ><![CDATA[
   /**
    * Class representing $(_name)
    */
   class $(_class) : public $(_base_class)Base_T<$(_class)Info> {};\n\n
   ]]></template>

   <template key="/TPM/quadDeclarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_class) as Quadrature decoder
   \t */
   \ttypedef $(_base_class)QuadDecoder_T<$(_class)Info> $(_base_class)QuadDecoder$(_instance);\n
   ]]></template>

   <signals/>

</fragment>

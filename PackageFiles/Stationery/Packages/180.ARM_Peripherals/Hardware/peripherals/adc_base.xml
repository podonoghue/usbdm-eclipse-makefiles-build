<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- adc0_diff_a.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <!-- ____ Class Declarations ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <constant key="disable_peripheral" value='"adc->SC1[0] = ADC_SC1_ADCH(-1);"'  type="String" />

   <equation key="suppressIrqHandler"         value="" />
   <equation key="irq_parameters"             value='uint32_t result, AdcChannelNum channel'  />
   <equation key="irq_dummy_parameters"       value='uint32_t, AdcChannelNum'                 />
   <equation key="irq_call_parameters"        value='adc->R[0], AdcChannelNum(adc->SC1[0]&amp;ADC_SC1_ADCH_MASK)'  />
   <equation key="generateDefault"            value="false"     />
   <equation key="configureInStartupDefault"  value="false"     />
   <xi:include href="enablePeripheral.xml"    />
   <title />

   <!-- ____ SC1 ____ -->
   <choiceOption key="adc_sc1_channel" condition="adc_sc1_adch_present"
      valueFormat="%s"
      hidden="true"
      derived="true"
      typeName="AdcChannelNum"
      baseType="uint8_t"
      toolTip="Selects an ADC channel"
      description="ADC Channel number" >
      <choiceExpansion keys="ch" dim="0,3"  value="%(ch)"               name="Channel SE%(ch)"    enum="Se%(ch)"    />
      <choice                               value="4"                   name="AFirst"             enum="AFirst"     />
      <choiceExpansion keys="ch" dim="4,7"  value="%(ch)"               name="Channel SE%(ch)a"   enum="Se%(ch)a"   />
      <choice                               value="7"                   name="ALast"              enum="ALast"      />
      <choiceExpansion keys="ch" dim="8,30" value="%(ch)"               name="Channel SE%(ch)"    enum="Se%(ch)"    />
      <choice                               value="31"                  name="Disabled"           enum="Disabled"  isDefault="true" />
      <choice                               value="32"                  name="DiffFirst"          enum="DiffFirst" condition="adc_sc1_diff_present" />
      <choiceExpansion keys="ch" dim="0,3"  value="=ToString(32+%(ch))" name="Diff Channel %(ch)" enum="Diff%(ch)" condition="adc_sc1_diff_present" />
      <choice                               value="=ToString(32+3)"     name="DiffLast"           enum="DiffLast"  condition="adc_sc1_diff_present" />
      <choice                               value="=ToString(36)"     name="BFirst"             enum="BFirst"    />
      <choiceExpansion keys="ch" dim="4,7"  value="=ToString(36+%(ch)-4)" name="Channel SE%(ch)b"   enum="Se%(ch)b"  />
      <choice                               value="=ToString(36+7-4)"     name="BLast"              enum="BLast"     />
   </choiceOption>

   <choiceOption key="adc_sc1_adch" condition="adc_sc1_adch_present"
      hidden="true"
      derived="true"
      typeName="AdcChannelNum"
      baseType="uint8_t"
      toolTip="Selects an ADC channel"
      description="ADC Channel number" >
      <choice          value="4"                   name="AFirst"             enum="AFirst"     />
   </choiceOption>

   <choiceOption key="adc$(_instance)_sc1_channel" condition="adc_sc1_adch_present"
      hidden="true"
      derived="true"
      valueFormat="%s"
      typeName="Adc$(_instance)ChannelNum"
      baseType="AdcChannelNum"
      toolTip="Selects an ADC channel"
      description="ADC Channel number"
      generateAsConstants="true" >
      <choiceExpansion keys="sig" values='=SignalList("^($(_NAME)_SE.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$1")'
         signal="%(sig)"
         name='@SignalDescription("%(sig)","^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
         enum='=Prettify(ToUppercase(ReplaceAll("%(sig)","^$(_NAME)_(.*)$","$1")))' delimiter="," condition='="%(sig)"!="-"'
         value='="AdcChannelNum_"+Prettify(ToUppercase(ReplaceAll("%(sig)","^$(_NAME)_(.*)$","$1")))' />
      <choiceExpansion keys="sig" values='=SignalList("^($(_NAME)_DP.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$1")'
         signal="%(sig)"
         name='@SignalDescription("%(sig)","^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
         enum='=Prettify(ToUppercase(ReplaceAll("%(sig)","^$(_NAME)_DP(.*)$","Diff$1")))' delimiter="," condition='="%(sig)"!="-"'
         value='="AdcChannelNum_"+Prettify(ToUppercase(ReplaceAll("%(sig)","^$(_NAME)_DP(.*)$","Diff$1")))' />
   </choiceOption>

   <binaryOption key="adc_sc1_aien"
      description="Action on conversion completion"
      typeName="AdcAction"
      baseType="uint8_t"
      hidden="true"
      toolTip="Controls whether an interrupt is triggered at the end of each conversion" >
      <choice value="0" enum="None"       name="None"      isDefault="true" />
      <choice value="1" enum="Interrupt"  name="Interrupt" />
   </binaryOption>

   <binaryOption key="adc_sc1_coco" condition="adc_sc1_coco_present"
      hidden="true"
      derived="true"
      typeName="AdcCompleteFlag"
      baseType="uint8_t"
      toolTip=""
      description="Conversion Complete Flag" >
      <choice name="Not complete"  value="0" enum="NotComplete"/>
      <choice name="Complete"      value="1" enum="Complete"/>
   </binaryOption >

   <binaryOption key="adc_sc1_diff" condition="adc_sc1_diff_present"
      hidden="true"
      typeName="AdcDifferential"
      baseType="uint8_t"
      toolTip="Enable differential conversion"
      description="Differential Mode Enable" >
      <choice name="Single-ended"  value="0" enum="SingleEnded"/>
      <choice name="Differential"  value="1" enum="Differential"/>
   </binaryOption >

<!-- __________  PGA features _______________________________ -->
   <title description="Programmable Gain" condition="adc_pga_pgag_present" />
   <choiceOption key="adc_pga_pgaen" condition="adc_pga_pgaen_present"
      enabledBy="enablePeripheralSupport"
      description="PGA Enable and mode"
      valueFormat="(%s)"
      typeName="AdcPgaMode"
      toolTip="">
      <choice value="ADC_PGA_PGAEN(0)"                   name="PGA is disabled"          enum="Disabled" isDefault="true" />
      <choice value="ADC_PGA_PGAEN(1)|ADC_PGA_PGALPb(0)" name="PGA is in low power mode" enum="LowPower"      />
      <choice value="ADC_PGA_PGAEN(1)|ADC_PGA_PGALPb(1)" name="PGA is in normal mode"    enum="NormalPower"   />
   </choiceOption>

   <choiceOption key="adc_pga_pgag" condition="adc_pga_pgag_present"
      enabledBy="enablePeripheralSupport"
      description="PGA Gain Setting"
      typeName="AdcPgaGain"
      toolTip="Sets gain of PGA amplifier">
      <choice value="0" name="Gain = x1"  enum="x1" isDefault="true" />
      <choice value="1" name="Gain = x2"  enum="x2"   />
      <choice value="2" name="Gain = x4"  enum="x4"   />
      <choice value="3" name="Gain = x8"  enum="x8"   />
      <choice value="4" name="Gain = x16" enum="x16"  />
      <choice value="5" name="Gain = x32" enum="x32"  />
      <choice value="6" name="Gain = x64" enum="x64"  />
   </choiceOption>

   <binaryOption key="adc_pga_pgachp" condition="adc_pga_pgachp_present"
      enabledBy="enablePeripheralSupport"
      description="PGA chopping"
      valueFormat="ADC_PGA_PGACHPb(%s)"
      typeName="AdcPgaChop"
      toolTip="Controls PGA chopping to remove/reduce offset">
      <choice value="0" enum="Disabled" name="No chopping"        isDefault="true" />
      <choice value="1" enum="Enabled"  name="Chopping enabled"   />
   </binaryOption>

<!-- __________  ADC clock sources _______________________________ -->

   <intOption key="adcInternalClock"
      enabledBy="enablePeripheralSupport"
      derived="true"
      locked="true"
      description="Frequency of Internal ADC clock"
      toolTip="Varies with ADLPC and ADHSC"
      value="2000000"
      origin="Internal ADC clock"
      units="Hz"/>

   <choiceOption key="adc_cfg1_adiclk"
      enabledBy="enablePeripheralSupport"
      description="ADC Input Clock"
      typeName="AdcClockSource"
      baseType="uint8_t"
      toolTip="Clock source for the ADC module" >
      <choice value="0" name="Bus clock"                  enum="BusClock"     code="SystemBusClock"            />
      <choice value="1" name="Bus clock/2"                enum="BusClockDiv2" code="SystemBusClock/2"          condition="!/SIM/system_irc48m_clock[]" />
      <choice value="1" name="Irc48M clock"               enum="Irc48mClk"    code="SimInfo::irc48mClock"      condition="/SIM/system_irc48m_clock[]"  />
      <choice value="2" name="Alternate clock (OSCERCLK)" enum="OscerClk"     code="Osc0Info::getOscerClock()" />
      <choice value="3" name="Asynchronous clock (ADACK)" enum="Asynch"       code="$(adcInternalClock)"       isDefault="true" />
   </choiceOption>

   <choiceOption key="adc_cfg1_adiv"
      hidden="true"
      description="Clock Divide Select"
      typeName="AdcClockDivider"
      baseType="uint8_t"
      toolTip="Selects the divide ratio used by the ADC to generate the internal clock ADCK">
      <choice value="0" name="Divide by 1" enum="Div1" isDefault="true" />
      <choice value="1" name="Divide by 2" enum="Div2" />
      <choice value="2" name="Divide by 4" enum="Div4" />
      <choice value="3" name="Divide by 8" enum="Div8" />
   </choiceOption>

<!--  __________ CFG1/CFG2/SC2/SC3 _______________________________ -->

   <title />

   <choiceOption key="adc_cfg1_mode" description="ADC Resolution"
      enabledBy="enablePeripheralSupport"
      typeName="AdcResolution"
      baseType="uint8_t"
      toolTip="The resolutions available vary with single-ended/differential modes\n
               Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff" >
      <choice value="0" name="8-bit unsigned (single-ended mode)"   enum="8bit_se"    />
      <choice value="2" name="10-bit unsigned (single-ended mode)"  enum="10bit_se"   />
      <choice value="1" name="12-bit unsigned (single-ended mode)"  enum="12bit_se"   />
      <choice value="3" name="16-bit unsigned (single-ended mode)"  enum="16bit_se"   condition="adc_cfg1_mode_16bit_present" />
      <choice value="0" name="9-bit signed (differential mode)"     enum="9bit_diff"  condition="adc_cfg1_mode_diff_present" />
      <choice value="2" name="11-bit signed (differential mode)"    enum="11bit_diff" condition="adc_cfg1_mode_diff_present" />
      <choice value="1" name="13-bit signed (differential mode)"    enum="13bit_diff" condition="adc_cfg1_mode_diff_present" />
      <choice value="3" name="16-bit signed (differential mode)"    enum="16bit_diff" condition="adc_cfg1_mode_diff_present&amp;&amp;adc_cfg1_mode_16bit_present" />
   </choiceOption>

   <binaryOption key="adc_cfg1_adlpc" description="Low-Power Configuration"
      enabledBy="enablePeripheralSupport"
      typeName="AdcPower"
      baseType="uint8_t"
      toolTip="Adjust power consumption">
      <choice value="0" enum="Normal" name="Normal power configuration" isDefault="true" />
      <choice value="1" enum="Low"    name="Low-power configuration (reduced speed)" />
   </binaryOption>

   <choiceOption key="adc_sample" description="Long Sample Time Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcSample"
      valueFormat="(%s)"
      baseType="uint8_t"
      toolTip="Selects sample times \n
               Longer times allow higher impedance inputs to be accurately sampled or\n
               shorter times maximise conversion speed for lower impedance inputs\n
               It also affects the conversion rate and power consumption for continuous mode">
      <choice value="ADC_CFG1_ADLSMP(0)"                    enum="4cycles"   name="4 ADCK total" isDefault="true" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(3)" enum="6cycles"   name="+2 ADCK cycles; 6 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(2)" enum="10cycles"  name="+6 ADCK cycles; 10 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(1)" enum="16cycles"  name="+12 ADCK cycles; 16 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(0)" enum="24cycles"  name="+20 ADCK cycles; 24 ADCK total" />
   </choiceOption>

   <binaryOption key="adc_cfg1_adlsmp" condition="adc_cfg1_adlsmp_present"
      hidden="true"
      typeName="AdcSampleMode"
      baseType="uint32_t"
      description="Sample Time Configuration"
      toolTip="" >
      <choice name="Short sample time"  value="0" enum="ShortSampleTime" />
      <choice name="Long sample time"   value="1" enum="LongSampleTime" />
   </binaryOption >

   <choiceOption key="adc_cfg2_adlsts" condition="adc_cfg2_adlsts_present"
      hidden="true"
      typeName="AdcSampleLength"
      baseType="uint32_t"
      description="Long Sample Time Select"
      toolTip="" >
      <choice name="20 extra cycles"  value="0" enum="20ExtraCycles" />
      <choice name="12 extra cycles"  value="1" enum="12ExtraCycles" />
      <choice name="6 extra cycles"   value="2" enum="6ExtraCycles" />
      <choice name="2 extra cycles"   value="3" enum="2ExtraCycles" />
   </choiceOption >

   <choiceOption key="adc_sc3_avg" description="Hardware Average Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcAveraging"
      valueFormat="ADC_SC3_CAL(%s),ADC_SC3_CALF(%s),ADC_SC3_AVGE(%s),ADC_SC3_AVGS(%s)"
      baseType="uint8_t"
      toolTip="Determines how many ADC conversions will be averaged\n
               by the hardware to create the ADC result">
      <choice value="0,0,0,0" enum="off"  name="1 sample"     isDefault="true" />
      <choice value="0,0,1,0" enum="4"    name="4 samples"    />
      <choice value="0,0,1,1" enum="8"    name="8 samples"    />
      <choice value="0,0,1,2" enum="16"   name="16 samples"   />
      <choice value="0,0,1,3" enum="32"   name="32 samples"   />
      <choice value="1,1,1,3" enum="Cal"  name="32 samples + clear flag + start calibration" hidden="true" />
   </choiceOption>

   <binaryOption key="adc_cfg2_adhsc" description="High-Speed Configuration"
      enabledBy="enablePeripheralSupport"
      typeName="AdcClockRange"
      baseType="uint8_t"
      toolTip="Configures the ADC for high-speed clock operation\n
               This actually extends the number of conversion clock cycles\n
               but is offset by allowing a faster input clock">
      <choice value="0" enum="Normal" name="Normal conversion sequence selected" isDefault="true" />
      <choice value="1" enum="High"   name="High-speed conversion sequence selected" />
   </binaryOption>

   <binaryOption key="adc_cfg2_adacken" description="Asynchronous Clock Output Enable"
      enabledBy="enablePeripheralSupport"
      typeName="AdcAsyncClock"
      baseType="uint8_t"
      toolTip="Enables the ADC internal asynchronous clock source irrespective of ADC need.\n
               This reduces the initial delay at the start of a sequence of conversions.\n
	            It also allows use of the ADC internal clock as a clock source for other peripherals">
      <choice value="0" enum="Disabled" name="Asynchronous clock output disabled" isDefault="true" />
      <choice value="1" enum="Enabled" name="Asynchronous clock output enabled" />
   </binaryOption>

   <choiceOption key="adc_sc2_refsel" description="Voltage Reference Selection"
      enabledBy="enablePeripheralSupport"
      typeName="AdcRefSel"
      baseType="uint8_t"
      toolTip="Selects the voltage reference source used for conversions">
      <choice value="0" enum="VrefHL"        name="VRefH and VRefl" isDefault="true" />
      <choice value="1" enum="VrefhAndVrefl" name="Gnd and VrefOut(1.2V)" />
      <choice value="0" enum="Default"       name="Default" />
   </choiceOption>

   <binaryOption key="adc_sc2_dmaen" condition="adc_sc2_dmaen_present"
      enabledBy="enablePeripheralSupport"
      description="DMA Enable"
      typeName="AdcDma"
      baseType="uint8_t"
      toolTip="Enables use of DMA with ADC">
      <choice value="0" enum="Disabled" name="Disabled" isDefault="true" />
      <choice value="1" enum="Enabled"  name="Enabled" />
   </binaryOption>

   <binaryOption key="adc_cfg2_muxsel"
      enabledBy="enablePeripheralSupport"
      typeName="AdcMuxsel"
      baseType="uint8_t"
      description="A/B multiplexor selection"
      toolTip="Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b">
      <choice value="0" enum="A"  name="The multiplexor selects A channels" />
      <choice value="1" enum="B"  name="The multiplexor selects B channels" isDefault="true" />
   </binaryOption>

   <binaryOption key="adc_sc3_adco"
      description="Single or continuous conversion"
      enabledBy="enablePeripheralSupport"
      typeName="AdcContinuous"
      baseType="uint8_t"
      toolTip="Selects between single and continuous conversion">
      <choice value="0" enum="Disabled" name="Single conversion on each trigger" isDefault="true" />
      <choice value="1" enum="Enabled"  name="Continuous conversions after 1st trigger" />
   </binaryOption>

   <binaryOption key="adc_sc3_cal"
      hidden="true"
      derived="true"
      description="Start Calibration"
      typeName="AdcCalibrate"
      baseType="uint8_t"
      toolTip="Begins the calibration sequence when set.\n
               This field stays set while the calibration is in progress and is cleared when \n
               the calibration sequence is completed.\n
               CALF must be checked to determine the result of the calibration sequence.\n
               Once started, the calibration routine cannot be interrupted by writes to the ADC\n
               registers or the results will be invalid and CALF will set.\n
               Setting CAL will abort any current conversion." >
      <choice value="0" enum="NoAction" name="No Action" />
      <choice value="1" enum="Start"    name="Starts calibration or indicates calibration in progress" />
   </binaryOption>

   <binaryOption key="adc_sc3_calf"
      hidden="true"
      derived="true"
      description="Calibration Failed Flag"
      typeName="AdcCalibrateResult"
      baseType="uint8_t"
      toolTip="Displays the result of the calibration sequence.\n
               The calibration sequence will fail if SC2[ADTRG] = 1,\n
               any ADC register is written, or any stop mode is entered\n
               before the calibration sequence completes.\n
               Writing 1 to CALF clears it." >
      <choice value="0" enum="Completed" name="Calibration successfully completed" />
      <choice value="1" enum="Failed"    name="Calibration failed" />
   </binaryOption>

   <choiceOption key="adc_sc2_compare" description="Compare function"
      enabledBy="enablePeripheralSupport"
      typeName="AdcCompare"
      baseType="uint8_t"
      valueFormat="ADC_SC2_ACFE(%s),ADC_SC2_ACREN(%s),ADC_SC2_ACFGT(%s),(%s)"
      toolTip="Enables comparison of ADC result with CV1 and CV2" >
      <choice value="0,0,0,0"    enum="Disabled"              name="No comparison done"                              isDefault="true"    />
      <choice value="1,0,0,0"    enum="LessThan"              name="ADC value &lt; low"                              />
      <choice value="1,0,1,0"    enum="GreaterThanOrEqual"    name="ADC value &gt;= low"                             />
      <choice value="1,1,0,0"    enum="OutsideRangeExclusive" name="(ADC value &lt; low) or (ADC value &gt; high)"   />
      <choice value="1,1,1,0x80" enum="OutsideRangeInclusive" name="(ADC value &lt;= low) or (ADC value &gt;= high)" />
      <choice value="1,1,0,0x80" enum="InsideRangeExclusive"  name="(low &lt; ADC value &lt; high)"                  />
      <choice value="1,1,1,0"    enum="InsideRangeInclusive"  name="(low &lt;= ADC value &lt;= high)"                />
   </choiceOption>

   <intOption key="adc_cv1" description="ADC CV low value"
      hiddenBy="adc_sc2_compare==0"
      valueFormat="%s"
      baseType="uint16_t"
      toolTip="CV Low threshold value\n
         This value will be used for CV1 or CV2 as needed" />

   <intOption key="adc_cv2" description="ADC CV high value"
      hiddenBy="adc_sc2_compare&lt;3"
      valueFormat="%s"
      baseType="uint16_t"
      toolTip="CV High threshold value\n
         This value will be used for CV1 or CV2 as needed" />

   <intOption key="adc_r_d"
      hidden="true"
      derived="true"
      description="ADC Result"
      toolTip="Result from ADC conversion as unsigned value"
      baseType="uint16_t"
      />

   <intOption key="adc_r_ud"
      valueFormat="ADC_R_D(%s)"
      hidden="true"
      derived="true"
      description="ADC Result"
      toolTip="Result from ADC conversion as signed value"
      baseType="int16_t"
      />

   <binaryOption key="adc_sc2_adtrg" description="Conversion Trigger Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcTrigger"
      baseType="uint8_t"
      toolTip="Selects the type of trigger used for initiating a conversion">
      <choice value="0" enum="Software" name="Software trigger (by writing to SC1[0])" isDefault="true" />
      <choice value="1" enum="Hardware" name="Hardware trigger (ADHWT source)" />
   </binaryOption>

   <choiceOption key="adc_pretrigger" description="Selects the pretrigger"
      enabledBy="enablePeripheralSupport"
      typeName="AdcPretrigger"
      valueFormat="(%s)"
      baseType="uint8_t"
      hidden="true"
      toolTip="Selects which SC1[x]/R[x] register pair to use">
      <choiceExpansion keys="pretrigger" dim="=adc_sc1_dim"
         name="Use pretrigger %(pretrigger) = SC1[%(pretrigger)]/R[%(pretrigger)]" value="%(pretrigger)" enum="%(pretrigger)"/>
   </choiceOption>

   <for keys="pretrigger" dim="=adc_sc1_dim" >

      <title description="Pretrigger %(pretrigger)" hiddenBy="!adc_sc2_adtrg" />

      <choiceOption key="adc_sc1[%(pretrigger)]_adch"
         derivedFrom="adc$(_instance)_sc1_channel"
         hiddenBy="(%(pretrigger)!=0)&amp;&amp;!adc_sc2_adtrg" >
      </choiceOption>

      <binaryOption key="adc_sc1[%(pretrigger)]_aien"
         derivedFrom="adc_sc1_aien"
         hiddenBy="(%(pretrigger)!=0)&amp;&amp;!adc_sc2_adtrg" >
      </binaryOption>
   </for>

   <binaryOption key="adc_sc2_adact" description="Conversion Active"
      hidden="true"
      derived="true"
      typeName="AdcActiveFlag"
      baseType="uint8_t"
      toolTip="Indicates that a conversion or hardware averaging is in progress.\n
               Set when a conversion is initiated and cleared when a conversion is completed or aborted" >
      <choice value="0" enum="Idle" name="Conversion not in progress." isDefault="true" />
      <choice value="1" enum="Busy" name="Conversion in progress." />
   </binaryOption>


<!-- ====================================================================================================== -->
<!--     START BasicInfo Class -->
<!-- ====================================================================================================== -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Channel number used for PGA
      \tstatic constexpr uint32_t PGA_CHANNEL = 2;
      \t\n
   ]]></template>

   <!-- BasicInfo Instance pointer and Constructors  -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Pointer to $(_BASENAME) hardware instance
      \tvolatile $(_Type) * const $(_basename);
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Constructor
      \t *
      \t * @param $(_basename) $(_BASENAME) hardware instance
      \t */
      \tconstexpr $(_BasicInfo)(volatile $(_Type) * $(_basename)) : $(_basename)($(_basename)) {
      \t}
      \t\n
   ]]></template>

   <!-- BasicInfo Clock methods  -->

   <clockCodeTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variable="adc_cfg1_adiclk"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      \t * @param %paramName %tooltip
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%paramType %paramName) {
      \t
      \t   switch(%paramName) {
      \t      default: return 0;
      %body
      \t   }
      \t}
      \t\n
   ]]></clockCodeTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Calculate ADC clock divider (ADC_CFG1_ADIV) and confirm clock source (ADC_CFG1_ADICLK)
      \t *
      \t * @param cfg1 ADC CFG1 register value
      \t * @param cfg2 ADC CFG2 register value
      \t *
      \t * @return modified cfg1 value (ADC_CFG1_ADIV|ADC_CFG1_ADICLK fields may be changed)
      \t */
      \tstatic unsigned calculateClockDivider(uint8_t cfg1, uint8_t cfg2) {
      \t
      \t   AdcClockSource adcClockSource = AdcClockSource(ADC_CFG1_ADICLK_MASK&cfg1);
      \t   AdcClockRange  adcClockRange  = AdcClockRange(ADC_CFG2_ADHSC(cfg2));
      \t   AdcPower       adcPower       = AdcPower(ADC_CFG1_ADLPC(cfg1));
      \t
      \t   // Clear existing fields
      \t   cfg1 &= ~(ADC_CFG1_ADICLK_MASK|ADC_CFG1_ADIV_MASK);
      \t
      \t   if (adcClockSource == AdcClockSource_Asynch) {
      \t      // Internal clock is always OK with /1
      \t      return cfg1|AdcClockSource_Asynch|AdcClockDivider_Div1;
      \t   }
      \t   static constexpr unsigned MinClock =  2000000;
      \t   unsigned maxClock = 0;
      \t   switch(adcPower|adcClockRange) {
      \t      case AdcPower_Low|AdcClockRange_Normal :
      \t      maxClock =  4000000;
      \t      break;
      \t      case AdcPower_Low|AdcClockRange_High :
      \t      maxClock =  6000000; // Guess
      \t      break;
      \t      case AdcPower_Normal|AdcClockRange_Normal :
      \t      maxClock =  8000000;
      \t      break;
      \t      case AdcPower_Normal|AdcClockRange_High :
      \t      maxClock = 12000000;
      \t      break;
      \t   }
      \t   unsigned adiv;
      \t   for(;;) {
      \t      unsigned clockFrequency = getInputClockFrequency(adcClockSource);
      \t      for (adiv=0; adiv<=3; adiv++) {
      \t         if ((clockFrequency <= maxClock) && (clockFrequency >= MinClock)) {
      \t            break;
      \t         }
      \t         clockFrequency /= 2;
      \t      }
      #if $(/adc_alt_clock_is_busDiv2:false)
      \t      if ((adiv>3) && (adcClockSource == AdcClockSource_BusClock)) {
      \t         // Automatically switch from  AdcClockSource_Bus -> AdcClockSource_Busdiv2
      \t         adcClockSource = AdcClockSource_BusClockDiv2;
      \t         continue;
      \t      }
      #endif
      \t      break;
      \t   }
      \t   usbdm_assert(adiv<4, "Unable to find suitable ADC clock");
      \t   return cfg1|adcClockSource|ADC_CFG1_ADIV(adiv);
      \t}
      \t\n
   ]]></template>

   <if condition="adc_cfg1_mode" >
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
      <![CDATA[
         \t/**
         \t * Get ADC maximum conversion value for an single-ended range
         \t *
         \t * @param adcResolution
         \t *
         \t * @return range e.g. AdcResolution_8bit_se => (2^8)-1
         \t */
         \tstatic constexpr int getSingleEndedMaximum(AdcResolution adcResolution) {
         \t   switch(adcResolution) {
         \t      case AdcResolution_8bit_se:  return (1<<8)-1;
         \t      case AdcResolution_10bit_se: return (1<<10)-1;
         \t      case AdcResolution_12bit_se: return (1<<12)-1;\n
      ]]></template>
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_cfg1_mode_16bit_present" ><![CDATA[
         \t      case AdcResolution_16bit_se: return (1<<16)-1;\n
      ]]></template>
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
      <![CDATA[
         \t      default:                     return 0;
         \t   }
         \t}\n\n
      ]]></template>
   </if>

   <if condition="adc_cfg1_mode&amp;&amp;adc_cfg1_mode_diff_present">
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
      <![CDATA[
      \t/**
      \t * Get ADC maximum conversion value for an differential range
      \t *
      \t * @param adcResolution
      \t *
      \t * @return range e.g. AdcResolution_9bit_diff => (2^8)-1
      \t */
      \tstatic constexpr int getDifferentialMaximum(AdcResolution adcResolution) {
      \t   switch(adcResolution) {
      \t      case AdcResolution_9bit_diff:   return (1<<8)-1;
      \t      case AdcResolution_11bit_diff:  return (1<<10)-1;
      \t      case AdcResolution_13bit_diff:  return (1<<12)-1;\n
      ]]></template>
      <template  where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_cfg1_mode_16bit_present" >
      <![CDATA[
      \t      case AdcResolution_16bit_diff:  return (1<<15)-1;\n
      ]]></template>
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
      <![CDATA[
      \t      default:                        return 0;
      \t   }
      \t}\n
      ]]></template>
   </if>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
   \t/**
   \t * Map ADC Channel number to physical channel index
   \t *
   \t * @param adcChannelNum Channel number (index into Info table)
   \t *
   \t * @return  Physical channel number i.e. hardware value
   \t */
   \tstatic constexpr int mapChannelNumToPhysicalChannelNum(AdcChannelNum adcChannelNum) {
   \t
   #if $(adc_sc1_diff_present:false) // adc_sc1_diff_present
   \t   if (adcChannelNum<=AdcChannelNum_DiffLast) {
   \t      // channels SE0-SE4,SE4a-SE7a,SE8-SE31,DIFF0-DIFF4
   \t      return int(adcChannelNum);
   \t   }
   #else
   \t   if (adcChannelNum<=AdcChannelNum_Disabled) {
   \t      // channels SE0-SE4,SE4a-SE7a,SE8-SE31
   \t      return int(adcChannelNum);
   \t   }
   #endif
   \t   if (adcChannelNum<=AdcChannelNum_BLast) {
   \t      // channels SE4b-SE7b
   \t      return int(adcChannelNum)&ADC_SC1_ADCH_MASK;
   \t   }
   \t   return -1;
   \t}\t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
   \t/**
   \t * ADC calibrate.
   \t * Calibrates the ADC before first use.
   \t *
   \t * @note Set up the ADC clock and resolution before calibration
   \t *
   \t * @return E_NO_ERROR       Calibration successful
   \t * @return E_CALIBRATE_FAIL Failed calibration
   \t */
   \tstatic ErrorCode calibrate(volatile ADC_Type *adc) {
   \t
   \t   // Save modified registers
   \t   uint8_t sc2 = adc->SC2;
   \t   uint8_t sc3 = adc->SC3;
   \t
#ifndef ADC_SC2_DMAEN_MASK
   \t   static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK;
#else
   \t   static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK|ADC_SC2_DMAEN_MASK;
#endif
   \t
   \t   // Disable hardware trigger
   \t   adc->SC2 = sc2 & ~mask;
   \t
   \t   // Start calibration
   \t   adc->SC3 = AdcAveraging_Cal;
   \t
   \t   // Wait for calibration to complete
   \t   while ((adc->SC1[0] & ADC_SC1_COCO_MASK) == 0) {
   \t      __asm__("nop");
   \t   }
   \t
   \t   // Clear COCO
   \t   (void)adc->R[0];
   \t
   \t   // Check if calibration failed
   \t   bool failed = adc->SC3 & ADC_SC3_CALF_MASK;
   \t
   \t   // Restore original register values
   \t   adc->SC2 = sc2;
   \t   adc->SC3 = sc3;
   \t
   \t   // Check calibration outcome
   \t   if(failed) {
   \t      // Failed calibration
   \t      return setErrorCode(E_CALIBRATE_FAIL);
   \t   }
   \t
   \t   // Calibration factor
   \t   uint16_t calib;
   \t   calib = adc->CLPS + adc->CLP4 + adc->CLP3 + adc->CLP2 + adc->CLP1 + adc->CLP0;
   \t   calib /= 2;
   \t   calib |= (1<<15);  // Set MSB
   \t   adc->PG = calib;
   \t
#ifdef ADC_MG_MG_MASK
   \t   calib = adc->CLMS + adc->CLM4 + adc->CLM3 + adc->CLM2 + adc->CLM1 + adc->CLM0;
   \t   calib /= 2;
   \t   calib |= (1<<15);  // Set MSB
   \t   adc->MG = calib;
#endif
   \t
   \t   return E_NO_ERROR;
   \t}
   \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Limit channel to permitted range.
      \t * Used to prevent noise from static assertion checks that detect a condition already detected in a more useful fashion.
      \t *
      \t * @param channel   Channel number to limit
      \t *
      \t * @return Index limited to permitted range
      \t */
      \ttemplate<class Info>
      \tstatic inline constexpr int limitIndex(int channel) {
      \t   if (channel<0) {
      \t      return 0;
      \t   }
      \t   if (channel>(Info::numSignals-1)) {
      \t      return Info::numSignals-1;
      \t   }
      \t   return channel;
      \t}
      \t
      \t/** Class to static check channel exists and is mapped to an input pin */
      \tCreatePeripheralPinChecker("ADC");
      \t\n
   ]]>
   </template>


<!-- ====================================================================================================== -->
<!--     START BasicInfo/Info duplicated methods -->
<!-- ====================================================================================================== -->

<for
   keys="   static    : const    : where     : guard                                      "
   values=" ''        : 'const ' : basicInfo : $(_BasicInfoGuard)                         ;
            'static ' : ''       : info      : $(_InfoGuard)                              "  >

   <template location="%(where)" codeGenCondition="%(guard)" >
   <![CDATA[
protected:
   \t/**
   \t * Initiates a conversion at the current resolution but does not wait for it to complete.
   \t * Intended for use with interrupts or DMA.
   \t *
   \t * @param[in] sc1Value SC1 register value.
   \t *                     This includes channel, differential mode, interrupt and mux selection.
   \t */
   \t%(static)void startConversion(int sc1Value) %(const){
   \t
   \t   // Select A/B Mux
   \t   if ((sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum_BFirst) {
   \t      adc->CFG2 = adc->CFG2|ADC_CFG2_MUXSEL_MASK;
   \t      sc1Value -= AdcChannelNum_BFirst-4;
   \t   }
   \t   else {
   \t      adc->CFG2 = adc->CFG2&~ADC_CFG2_MUXSEL_MASK;
   \t   }
   \t   // Trigger conversion
   \t   adc->SC1[0] = sc1Value;
   \t   (void)adc->SC1[0];
   \t};
   \t
   \t/**
   \t * Initiates a conversion but does not wait for it to complete.
   \t * Intended for use with interrupts or DMA.
   \t *
   \t * @param[in] sc1Value SC1 register value.
   \t *                     This includes channel, differential mode, interrupt and mux selection.
   \t * @param adcResolution      New Resolution to use (persistent)
   \t */
   \t%(static)void startConversion(const int sc1Value, AdcResolution adcResolution) %(const){
   \t
   \t   // Set resolution
   \t   adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
   \t   startConversion(sc1Value);
   \t};
   \t
   \t/**
   \t * Initiates a conversion at the current resolution and waits for it to complete.
   \t *
   \t * @param[in] sc1Value SC1 register value.
   \t *                     This includes channel, differential mode, interrupt and mux selection.
   \t *
   \t * @return - The result of the conversion as an integer converted from 16-bit ADC value
   \t *           For single-ended conversions this will be zero extended
   \t *           For differential conversions this will be sign-extended
   \t *
   \t * @note Result is signed but will always be positive for single-ended conversions.
   \t */
   \t%(static)int readAnalogue(uint32_t sc1Value) %(const){
   \t
   \t   startConversion(sc1Value);
   \t   while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
   \t      __asm__("nop");
   \t   }
   \t   return getConversionResult();
   \t};
   \t
   \t/**
   \t * Initiates a conversion and waits for it to complete.
   \t *
   \t * @param[in] sc1Value SC1 register value.
   \t *                     This includes channel, differential mode, interrupt and mux selection.
   \t * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
   \t *
   \t * @return - The result of the conversion as an integer converted from 16-bit ADC value
   \t *           For single-ended conversions this will be zero extended
   \t *           For differential conversions this will be sign-extended
   \t *
   \t * @note Result is signed but will always be positive for single-ended conversions.
   \t * @note The resolution used affects all future conversion on all channels on the ADC
   \t */
   \t%(static)int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) %(const){
   \t   adc->CFG1 = (adc->CFG1&~ADC_CFG1_MODE_MASK)|adcResolution;
   \t   return readAnalogue(sc1Value);
   \t};
   \t\n
   ]]>
   </template>

   <template location="%(where)" codeGenCondition="%(guard)" >
   <![CDATA[
public:
   \t/**
   \t * ADC calibrate.
   \t * Calibrates the ADC before first use.
   \t *
   \t * @note Set up the ADC clock and resolution before calibration
   \t *
   \t * @return E_NO_ERROR       Calibration successful
   \t * @return E_CALIBRATE_FAIL Failed calibration
   \t */
   \t%(static)ErrorCode calibrate() %(const){
   \t   return $(_BasicInfo)::calibrate($(_basename));
   \t}
   \t
   \t/**
   \t * Initiates a conversion and waits for it to complete.
   \t *
   \t * @param adcChannelNum Number of channel to convert
   \t *
   \t * @return - The result of the conversion as an integer converted from 16-bit ADC value
   \t *           For single-ended conversions this will be zero extended
   \t *           For differential conversions this will be sign-extended
   \t *
   \t * @note Result is signed but will always be positive for single-ended conversions.
   \t */
   \t%(static)int readAnalogue(AdcChannelNum adcChannelNum) %(const){
   \t
   \t   return readAnalogue((uint32_t)adcChannelNum);
   \t}
   \t
   \t/**
   \t * Enables hardware trigger mode of operation and configures the channel.
   \t * Note this does not configure the MUX which should be done beforehand
   \t *
   \t * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
   \t * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel
   \t *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
   \t */
   \t%(static)void enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) %(const){
   \t
   \t   // Enable hardware triggers
   \t   adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1);
   \t
   \t   // Configure channel to use for hardware trigger input
   \t   if ((sc1Value&~ADC_SC1_AIEN_MASK)>=AdcChannelNum_BFirst) {
   \t      sc1Value -= AdcChannelNum_BFirst-4;
   \t   }
   \t   adc->SC1[adcPretrigger] = sc1Value;
   \t}
   \t
   \t/**
   \t * Configure comparison mode.
   \t *
   \t * @param[in] adcCompare   Comparison operation to enable
   \t * @param[in] low          Lower threshold
   \t * @param[in] high         Higher threshold (if needed)
   \t */
   \t%(static)void enableComparison(AdcCompare adcCompare, int low=INT_MIN, int high=INT_MAX) %(const){
   \t
   \t   usbdm_assert (low<=high, "ADC Low level > high level");
   \t
   \t   // Juggle CV1, CV2 values to satisfy comparison rules
   \t   switch (adcCompare) {
   \t      case AdcCompare_Disabled:
   \t         break;
   \t      case AdcCompare_LessThan:
   \t      case AdcCompare_GreaterThanOrEqual:
   \t         adc->CV1 = low;
   \t         break;
   \t      case AdcCompare_OutsideRangeExclusive:
   \t      case AdcCompare_InsideRangeInclusive:
   \t         adc->CV1 = low;
   \t         adc->CV2 = high;
   \t         break;
   \t      case AdcCompare_InsideRangeExclusive:
   \t      case AdcCompare_OutsideRangeInclusive:
   \t         adc->CV1 = high;
   \t         adc->CV2 = low;
   \t         break;
   \t   }
   \t   // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
   \t   static constexpr uint32_t mask = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1)|ADC_SC2_ACREN(1);
   \t
   \t   // Set comparison fields
   \t   adc->SC2 = adc->SC2 | (adc->SC2&~mask)|(adcCompare&mask);
   \t}
   \t
   \t/**
   \t * Gets result of last software initiated conversion
   \t *
   \t * @return The result of the conversion as an integer converted from 16-bit ADC value
   \t *         For single-ended conversions this will be zero extended
   \t *         For differential conversions this will be sign-extended
   \t *
   \t * @note Result is signed but will always be positive for single-ended conversions.
   \t * @note This will also clear the conversion flag if set
   \t */
   \t%(static)int getConversionResult() %(const){
   \t
   \t   // This is a 32-bit value with leading zeroes i.e unsigned
   \t   int value = ADC_R_D_MASK & (adc->R[0]);
   \t
#if defined(ADC_SC1_DIFF_MASK)
   \t   if (adc->SC1[0] & ADC_SC1_DIFF_MASK) {
   \t      // Differential conversion - convert to signed
   \t      return static_cast<int16_t>(value);
   \t   }
#endif
   \t
   \t   return value;
   \t};
   \t
   \t/**
   \t * Gets result of hardware initiated conversion
   \t *
   \t * @param preTrigger Pretrigger to use (identifies which SC1 register to access)
   \t *
   \t * @return The result of the conversion as an integer converted from 16-bit ADC value
   \t *         For single-ended conversions this will be zero extended
   \t *         For differential conversions this will be sign-extended
   \t *
   \t * @note Result is signed but will always be positive for single-ended conversions.
   \t * @note This will also clear the conversion flag if set
   \t */
   \t%(static)int getHardwareConversionResult(AdcPretrigger preTrigger) %(const){
   \t
   \t   // This is a 32-bit value with leading zeroes i.e unsigned
   \t   int value = ADC_R_D_MASK & (adc->R[preTrigger]);
   \t
#if defined(ADC_SC1_DIFF_MASK)
   \t   if (adc->SC1[preTrigger] & ADC_SC1_DIFF_MASK) {
   \t      // Differential conversion - convert to signed
   \t      return static_cast<int16_t>(value);
   \t   }
#endif
   \t
   \t   return value;
   \t};
   \t
   \t/**
   \t * Set clock source
   \t *
   \t * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
   \t * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
   \t *
   \t * @note This affects all channels on the ADC.\n
   \t * The resulting ADC clock rate should be restricted to the following ranges:\n
   \t *  [2..12MHz] for 16-bit conversion modes  \n
   \t *  [1..18MHz] for other conversion modes
   \t */
   \t%(static)void setClockSource(
   \t                       AdcClockSource adcClockSource,
   \t                       AdcClockDivider adcClockDivider=AdcClockDivider_Div1) %(const){
   \t   adc->CFG1 = (adc->CFG1&~(ADC_CFG1_ADIV_MASK|ADC_CFG1_ADICLK_MASK))|adcClockSource|adcClockDivider;
   \t}
   \t
   \t\n
   ]]>
   </template>

   <template location="%(where)" codeGenCondition="%(guard)" condition="adc_pga_pgaen_present&amp;&amp;adc_pga_pgachpb_present" >
   <![CDATA[
   \t/**
   \t * Configure Programmable Gain Amplifier.
   \t * Only affects the single channel associated with the PGA.
   \t *
   \t * @param adcPgaMode Mode to operate in (or disabled)
   \t * @param adcPgaGain Gain
   \t * @param adcPgaChop PGA chopping control
   \t *
   \t * @note Chopping should only be used in conjunction with even-numbered averaging
   \t *       since the chopping is applied between consecutive conversions.
   \t */
   \t%(static)void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_1, AdcPgaChop adcPgaChop=AdcPgaChop_Enabled) %(const){
   \t   adc->PGA = adcPgaMode|adcPgaGain|adcPgaChop;
   \t}
   \t
   \t/**
   \t * Measure PGA offset
   \t * The PGA should be configured for intended use before doing this.
   \t *
   \t * @note  If chopping is enabled, then the returned value represents the residual offset after
   \t *        chopping and can be applied to correct later conversions done with chopping enabled.
   \t *        If chopping is disabled, then the return value is the entire offset and may be
   \t *        applied to correct conversions with chopping disabled.
   \t *
   \t * @note To apply offset correction subtract <b>[(pga_offset_measurement*(Gain+1))/(64+1)]</b> from
   \t *       the ADC result, where Gain is the PGA gain during actual ADC operation.
   \t *
   \t * @return Offset measurement. (pga_offset * (64+1))
   \t */
   \t%(static)int measurePgaOffset() %(const){
   \t   adc->PGA = adc->PGA | ADC_PGA_PGAOFSM_MASK;
   \t   int offset = readAnalogue(PGA_CHANNEL);
   \t   adc->PGA = adc->PGA & ~ADC_PGA_PGAOFSM_MASK;
   \t   return offset;
   \t}
   \t\n
   ]]>
   </template>
   <template location="%(where)" codeGenCondition="%(guard)" condition="adc_pga_pgaen_present&amp;&amp;!adc_pga_pgachpb_present" >
   <![CDATA[
   \t/**
   \t * Configure Programmable Gain Amplifier.
   \t * Only affects the single channel associated with the PGA.
   \t *
   \t * @param adcPgaMode Mode to operate in (or disabled)
   \t * @param adcPgaGain Gain
   \t */
   \t%(static)void configurePga(AdcPgaMode adcPgaMode, AdcPgaGain adcPgaGain=AdcPgaGain_x1) %(const){
   \t   adc->PGA = adcPgaMode|adcPgaGain;
   \t}
   \t\n
   ]]>
   </template>

   <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;enableGettersAndSetters"
      variables="adc_sample" >
   <![CDATA[
      \t/**
      \t * Set %description
      \t * (%variables)
      \t *
      %paramDescription
      \t */
      \t%(static)void setSampleTime(%params) %(const){
      \t
      \t   adc->CFG1 = (adc->CFG1&~ADC_CFG1_ADLSMP_MASK) | (%paramExpression&ADC_CFG1_ADLSMP_MASK);
      \t   adc->CFG2 = (adc->CFG2&~ADC_CFG2_ADLSTS_MASK) | (%paramExpression&ADC_CFG2_ADLSTS_MASK);
      \t}
      \t
      \t/**
      \t * Get %description
      \t * (%variables)
      \t *
      \t * @return %tooltip
      \t */
      \t%(static)%paramType getSampleTime() {
      \t   return %paramType((adc->CFG1&~ADC_CFG1_ADLSMP_MASK)|(adc->CFG2&~ADC_CFG2_ADLSTS_MASK));
      \t}
      \t\n
   ]]>
   </variableTemplate>

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field           : set   : get   : clear : genCode                 : name"
        values="
         adc_cfg1_adlpc       : true  : true  : false : enableGettersAndSetters : LowPower;
         adc_cfg1_adiv        : true  : true  : false : enableGettersAndSetters : ClockDivider;
         adc_cfg1_mode        : true  : true  : false : true                    : Resolution;
         adc_cfg1_adiclk      : true  : true  : false : enableGettersAndSetters : ClockSelect;

         adc_cfg2_muxsel      : true  : true  : false : true                    : Muxsel;
         adc_cfg2_adacken     : true  : true  : false : true                    : AsynchronousClock;
         adc_cfg2_adhsc       : true  : true  : false : enableGettersAndSetters : HighSpeed;

         adc_sc2_adact        : false : true  : false : true                    : ConversionActive;
         adc_sc2_adtrg        : true  : true  : false : enableGettersAndSetters : Trigger;
         adc_sc2_acfe         : true  : true  : false : enableGettersAndSetters : CompareFunction;
         adc_sc2_acfgt        : true  : true  : false : enableGettersAndSetters : CompareFunctionGT;
         adc_sc2_acren        : true  : true  : false : enableGettersAndSetters : CompareFunctionRange;
         adc_sc2_dmaen        : true  : true  : false : true                    : Dma;
         adc_sc2_refsel       : true  : true  : false : enableGettersAndSetters : Reference;

         adc_sc3_adco         : true  : true  : false : true                    : ContinuousConversions;
         adc_sc3_avg          : true  : true  : false : true                    : Averaging;

         adc_ofs_ofs          : true  : true  : false : enableGettersAndSetters : Offset;

         adc_pg_pg            : true  : true  : false : enableGettersAndSetters : PlusGain;

         adc_mg_mg            : true  : true  : false : enableGettersAndSetters : MinusGain" >

      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition="%(set)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition="%(get)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Get %description
         \t * (%variables)
         \t *
         \t * @return %tooltip
         \t */
         \t%(static)%returnType get%(name)() %(const){
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition='="w1c"=="%(clear)"'
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void clear%(name)(%params) %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition='="w1cIm"=="%(clear)"'
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void clear%(name)() %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for> <!-- Getters/Setters 1 -->

   <for keys="field                     : set   : get   : clear : genCode                 : context                : name"
        values="
         adc_pretrigger,adc_sc1_coco    : false : true  : false : enableGettersAndSetters : %s[%%paramName0]       : CompleteFlag;
         adc_pretrigger,adc_sc1_aien    : false : true  : false : enableGettersAndSetters : %s[%%paramName0]       : Interrupt" >
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition="%(set)"
         context="%(context)"
         variables="%(field)"
         nonDefaultParams="2" >
      <![CDATA[
         \t/**
         \t * Set %description1
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment1;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition="%(get)"
         context="%(context)"
         variables="%(field)"
         nonDefaultParams="2" >
      <![CDATA[
         \t/**
         \t * Get %description1
         \t * (%variables)
         \t *
         %paramDescription0
         \t *
         \t * @return %tooltip1
         \t */
         \t%(static)%paramType1 get%(name)(%param0) %(const){
         \t   return %fieldExtract1;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" codeGenCondition="%(guard)&amp;&amp;%(genCode)" condition="%(clear)"
         context="%(context)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description1
         \t * (%variables)
         \t *
         \t * %tooltip
         \t *
         %paramDescription0
         \t */
         \t%(static)void clear%(name)(%param0) %(const){
         \t   %register1 = %register1|%mask1;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for> <!-- Getters/Setters 2 -->
</for> <!-- Static/Instance methods -->

<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   // Omitted parameters are take to be zero unless a base value is given
      \t *   AdcClockSource_Asynch ,  // ADC Clock Source
      \t *   AdcClockDivider_1 ,      // Clock Divide Select
      \t *   AdcResolution_8bit_se ,  // ADC Resolution
      \t *   AdcPower_Normal ,        // Low-Power Configuration
      \t *   AdcClockRange_Normal ,   // High-Speed Configuration
      \t *   AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable
      \t *   AdcRefSel_VrefHL ,       // Voltage Reference Selection
      \t *   AdcDma_Disabled ,        // DMA Enable
      \t *   AdcMuxsel_B ,            // Selects between A/B multiplexor inputs on some ADC channels
      \t *   AdcInterrupt_Disabled ,  // Enables conversion interrupts
      \t *   AdcDma_Disabled ,        // DMA Enable
      \t *   AdcTrigger_Software ,    // Conversion Trigger Select
      \t *   AdcAveraging_off ,       // Hardware Average Select
      \t *   AdcContinuous_Disabled , // Selects between single and continuous conversion
      \t *
      \t *   // These 2/3 parameters must appear in this order
      \t *   AdcCompare_LessThan ,    // Compare function
      \t *   5000 ,                   // ADC CV low value
      \t *   6000 ,                   // ADC CV high value (May be omitted)
      \t *
      \t *   AdcPretrigger_0, AdcChannelNum_11,    AdcAction_None,         // Settings for ADC hardware trigger #0
      \t *   AdcPretrigger_1, AdcChannelNum_Diff0, AdcAction_Interrupt,    // Settings for ADC hardware trigger #1
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo::Init class Member variables ________ -->

   <for keys=" type        : variables                                            : init    "
       values="%baseType   : adc_cv1                                              :   0      ;
               %baseType   : adc_cv2                                              :   0      ;
               %baseType   : adc_cfg1_adiclk,adc_cfg1_mode,adc_cfg1_adlpc,
                             adc_sample                                           :   0      ;
               %baseType   : adc_cfg2_adhsc,adc_cfg2_adacken,adc_cfg2_muxsel,
                             adc_sample                                           :   0      ;
               %baseType   : adc_sc2_refsel,adc_sc2_dmaen,adc_sc2_compare,
                             adc_sc2_adtrg                                        :   0      ;
               %baseType   : adc_sc3_avg,adc_sc3_adco                             :   0      " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx" >
      <![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]>
      </variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_sc2_adtrg"
      variables="adc_sc1_adch,adc_sc1_aien"
      linePadding="xxx" >
   <![CDATA[
      %multilineDescription
      \t   uint8_t %registerName[$(_STRUCTNAME)_SC1_COUNT] = {\n
   ]]>
   </variableTemplate>
   <for keys="i" dim="=adc_sc1_dim">
      <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_sc2_adtrg" >
      <![CDATA[
         \t      AdcChannelNum_Disabled,\n
      ]]></template>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_sc2_adtrg" ><![CDATA[
      \t   };\n\n
   ]]>
   </template>

   <!-- ____ BasicInfo::Init class Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" condition="adc_sc2_adtrg"
      variables="adc_pretrigger,adc_sc1_adch,adc_sc1_aien"
      linePadding="xxx"
      nonDefaultParams="3" >
   <![CDATA[
      \t   /**
      \t    * Constructor for hardware pretrigger
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      if ((adcChannelNum>=AdcChannelNum_AFirst)&&(adcChannelNum<=AdcChannelNum_ALast)) {
      \t         cfg2 &= ~ADC_CFG2_MUXSEL_MASK;
      \t      }
      \t      else if ((adcChannelNum>=AdcChannelNum_BFirst)&&(adcChannelNum<=AdcChannelNum_BLast)) {
      \t         cfg2 |= ADC_CFG2_MUXSEL_MASK;
      \t      }
      \t      %registerName1[%paramName0] = mapChannelNumToPhysicalChannelNum(%paramName1)|%paramName2;
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <for keys="r"
     values="adc_cfg1_adiclk;adc_cfg1_mode;adc_cfg1_adlpc;
             adc_cfg2_adhsc;adc_cfg2_adacken;adc_cfg2_muxsel;
             adc_sc2_refsel;adc_sc2_dmaen;adc_sc2_adtrg;
             adc_sc3_avg;adc_sc3_adco">
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="adc_sample"
      linePadding="xxx" >
   <![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      cfg1 = (cfg1&~ADC_CFG1_ADLSMP_MASK) | (%paramExpression&ADC_CFG1_ADLSMP_MASK);
      \t      cfg2 = (cfg2&~ADC_CFG2_ADLSTS_MASK) | (%paramExpression&ADC_CFG2_ADLSTS_MASK);
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="adc_sc2_compare,adc_cv1,adc_cv2"
      linePadding="xxx"
      nonDefaultParams="3" >
   <![CDATA[
      \t   /**
      \t    * Configure %description0, %description1 and %description2
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param[in] adcCompare   Comparison operation to enable
      \t    * @param[in] low          Lower threshold
      \t    * @param[in] high         Higher threshold (if needed)
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%paramType0 %paramName0, int low, int high=0, Types... rest) : Init(rest...) {
      \t
      \t      // Juggle CV1, CV2 values to satisfy comparison rules
      \t      switch (adcCompare) {
      \t         default:
      \t            cv1 = low;
      \t            cv2 = high;
      \t            break;
      \t         case AdcCompare_InsideRangeExclusive:
      \t         case AdcCompare_OutsideRangeInclusive:
      \t            cv1 = high;
      \t            cv2 = low;
      \t            break;
      \t      }
      \t      // Mask for valid bits (note adcCompare value may contain out-of-bound bits)
      \t      constexpr uint32_t mask = %mask0;
      \t
      \t      // Set comparison fields
      \t      %registerName0 = (%registerName0&~mask)|(%paramName0&mask);
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START BasicInfo::InitVectors class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     END BasicInfo::InitVectors class      -->
<!-- ====================================================================================================== -->

   <!-- ____ BasicInfo class Configure methods ____ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param $(_basename)           Hardware instance pointer
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(
      \t               volatile $(_Type) *$(_basename),
      \t               const Init    &init) {
      \t\n
      \t   // Calculate clock dividers and update cfg1
      \t   uint8_t cfg1 = calculateClockDivider(init.cfg1, init.cfg2);
      \t\n
   ]]>
   </template>
   <for keys=
             " var                                                    : statement            "
      values=" adc_cfg1_adlpc,adc_cfg1_adiv,
               adc_cfg1_mode,adc_cfg1_adiclk                          : %register=cfg1 ;
               adc_cfg2_muxsel,adc_cfg2_adacken,adc_cfg2_adhsc        : %configRegAssignment ;
               adc_cv1                                                : %configRegAssignment ;
               adc_cv2                                                : %configRegAssignment ;
               adc_sc2_adtrg,adc_sc2_acfe,adc_sc2_acfgt,
               adc_sc2_acren,adc_sc2_dmaen,adc_sc2_refsel             : %configRegAssignment ;
               adc_sc3_adco,adc_sc3_avg                               : %configRegAssignment ;
               adc_ofs_ofs                                            : %configRegAssignment " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx" >
      <![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]>
      </variableTemplate>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t   calibrate(adc);
      \t\n
   ]]>
   </template>
   <variableTemplate where="basicInfo" codeGenCondition="enablePeripheralSupport" condition="adc_sc2_adtrg"
      variables="adc_sc2_adtrg,adc_sc1_adch" >
   <![CDATA[
      \t   // Set up channel information
      \t   for (size_t index=0; index<$(_STRUCTNAME)_SC1_COUNT; index++) {
      \t      %register1[index] = init.%registerName1[index];
      \t   }
      \t\n
   ]]>
   </variableTemplate>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const Init &init) const {
      \t
      \t   configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START Info class      -->
<!-- ====================================================================================================== -->
   <!-- ____ Info constructors ________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/** Get reference to ADC hardware as struct */
      \tstatic volatile ADC_Type &adcPtr() { return (ADC_Type &)adc; }
      \t
      \t/** @return Base address of ADC hardware as uint32_t */
      \tstatic constexpr uint32_t adcBase() { return baseAddress; }
      \t/** @return Base address of ADC.SC1[index] registers as uint32_t */
      \tstatic constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
      \t/** @return Base address of ADC.R[index] registers as uint32_t */
      \tstatic constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t *   Default Constructor
      \t */
      \t$(_Info)() : $(_BasicInfo)($(_basename)) {
      \t   defaultConfigure();
      \t}
      \t
      \t/**
      \t *   Constructor
      \t */
      \t$(_Info)(const Init &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- Init configure methods -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t   $(_BasicInfo)::configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr $(_BasicInfo)::Init DefaultInitValue = {\n
   ]]>
   </template>

   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
      separator=","
      terminator=","
      padToComments="35"
      variables="
         adc_cfg1_adiclk,
         adc_cfg1_mode,
         adc_cfg1_adlpc,
         adc_cfg2_adhsc,
         adc_cfg2_adacken,
         adc_cfg2_muxsel,
         adc_sc2_refsel,
         adc_sc2_dmaen,
         adc_sc2_adtrg,
         adc_sc3_avg,
         adc_sc3_adco,
         adc_sample" >
   <![CDATA[
      \t%initNonZeroValues\n
   ]]></variableTemplate>

   <variableTemplate codeGenCondition="$(_InfoGuard)&amp;&amp;(adc_sc2_compare!=0)"
      separator=","
      terminator=","
      padToComments="45"
      variables="
         adc_sc2_compare,
         adc_cv1,
         adc_cv2"
   ><![CDATA[
      \t
      \t   // The following values must be in order %initExpression\n
   ]]></variableTemplate>

   <for keys="pretrigger" dim="=adc_sc1_dim" >
      <variableTemplate codeGenCondition="$(_InfoGuard)&amp;&amp;((%(pretrigger)==0)||adc_sc2_adtrg)"
         separator=","
         terminator=","
         padToComments="35"
         variables="
            adc_sc1[%(pretrigger)]_adch,
            adc_sc1[%(pretrigger)]_aien"
            >
      <![CDATA[
         \t
         \t   // The following values must be in order
         \t   AdcPretrigger_%(pretrigger),             // sc1[%(pretrigger)]/r[%(pretrigger)] ,%initExpression\n
      ]]></variableTemplate>
   </for>

   <template codeGenCondition="$(_InfoGuard)"
   ><![CDATA[
      \t};
      \t\n
   ]]></template>

   <!-- ____ Interrupt handling _____________ -->

   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t/**
      \t * $(_Class) interrupt handler
      \t * Passes control to call-back function
      \t */
      \tstatic void irqHandler() {
      \t
      \t   if (adc->SC1[0] & ADC_SC1_COCO_MASK) {
      \t      // Execute call-back
      \t      sCallback(adc->R[0], AdcChannelNum(adc->SC1[0]&ADC_SC1_ADCH_MASK));
      \t   }
      \t   if (adc->SC1[1] & ADC_SC1_COCO_MASK) {
      \t      // Execute call-back
      \t      sCallback(adc->R[1], AdcChannelNum(adc->SC1[1]&ADC_SC1_ADCH_MASK));
      \t   }
      \t   return;
      \t}
      \t\n
   ]]>
   </template>

<!--  __________  ADC MISC _______________________________ -->

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_pretrigger" ><![CDATA[
   \t/**
   \t * Enables hardware trigger mode of operation and configures the channel.
   \t *
   \t * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
   \t * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel
   \t *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
   \t */
   \tvoid enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) const {
   \t   // Set hardware triggers
   \t   adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1);
   \t   // Configure channel for hardware trigger input
   \t   adc->SC1[adcPretrigger] = sc1Value;
   \t}
   \t\n
   ]]></template>

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_pretrigger &amp;&amp; adc_sc2_dmaen" ><![CDATA[
   \t/**
   \t * Enables hardware trigger mode of operation and configures the channel.
   \t *
   \t * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
   \t * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.
   \t *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
   \t * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
   \t */
   \tvoid enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger, AdcDma adcDma) const {
   \t   // Set hardware triggers
   \t   adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1)|adcDma;
   \t   // Configure channel for hardware trigger input
   \t   adc->SC1[adcPretrigger] = sc1Value;
   \t}
   \t\n
   ]]></template>

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_sc2_dmaen" ><![CDATA[
   \t/**
   \t * Enable/disable DMA.
   \t *
   \t * @param[in] adcDma  Controls DMA operation.
   \t */
   \tvoid enableDma(AdcDma adcDma = AdcDma_Enabled) const {
   \t   // Set up DMA
   \t   if (adcDma) {
   \t      adc->SC2 = adc->SC2 | ADC_SC2_DMAEN_MASK;
   \t   }
   \t   else {
   \t      adc->SC2 = adc->SC2 & ~ADC_SC2_DMAEN_MASK;
   \t   }
   \t}\t\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     END Info class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     Common      -->
<!-- ====================================================================================================== -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class representing $(_STRUCTNAME) instance
      \t */
      \ttypedef $(_BasicInfo) $(_Structname);
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Baseclass)Base_T<$(_Info)> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="adc_files" >
      <copy source="Project_Headers/adc.h"                    target="Project_Headers/adc.h"                    overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-comparison-example.cpp" target="Snippets/analogue-comparison-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-example.cpp"            target="Snippets/analogue-example.cpp"            overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-diff-example.cpp"       target="Snippets/analogue-diff-example.cpp"       overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-interrupt-example.cpp"  target="Snippets/analogue-interrupt-example.cpp"  overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-joystick-example.cpp"   target="Snippets/analogue-joystick-example.cpp"   overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ____ Startup ____ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ____ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping ____ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</fragment>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- adc0_diff_a.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <constant key="irq_parameters"           type="String"  value="&quot;uint32_t result, int channel&quot;"  />
   <constant key="irq_dummy_parameters"     type="String"  value="&quot;uint32_t, int&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;adc->R[0], adc->SC1[0]&amp;ADC_SC1_ADCH_MASK&quot;"  />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="true"          />
   <xi:include href="enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <constant key="disable_peripheral" value="&quot;adc->SC1[0] = ADC_SC1_ADCH(-1);&quot;"  type="String" />

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Structname)BasicInfo&quot;" />

   <!-- SC1 -->
   <if condition="!adc_sc1_diff_present">
      <choiceOption key="adc_sc1_channel" condition="adc_sc1_adch_present"
         hidden="true"
         valueFormat="ADC_SC1_ADCH(%s)"
         typeName="AdcChannelNum"
         enumType="uint8_t"
         toolTip="Selects an ADC channel"
         description="ADC Channel number" >
         <choiceExpansion keys="ch" dim="31" value="%(ch)" name="Channel %(ch)" enum="%(ch)" />
         <choice                             value="31"    name="Disabled"      enum="Disabled" isDefault="true" />
      </choiceOption>
   <else/>
      <choiceOption key="adc_sc1_channel" condition="adc_sc1_adch_present"
         hidden="true"
         valueFormat="ADC_SC1_DIFF(%s),ADC_SC1_ADCH(%s)"
         typeName="AdcChannelNum"
         enumType="uint8_t"
         toolTip="Number selecting an ADC channel"
         description="ADC Channel number" >
         <choiceExpansion keys="ch" dim="31" value="0,%(ch)" name="Channel %(ch)" enum="%(ch)" />
         <choiceExpansion keys="ch" dim="5"  value="1,%(ch)" name="Channel %(ch)" enum="Diff%(ch)" />
         <choice                             value="0,31"    name="Disabled"      enum="Disabled" isDefault="true" />
      </choiceOption>
   </if>

   <binaryOption key="adc_sc1_aien"
      description="Action on conversion completion"
      enabledBy="irqHandlingMethod"
      typeName="AdcAction"
      hidden="true"
      toolTip="Controls whether an interrupt is triggered at the end of each conversion" >
      <choice value="0" enum="Disabled" name="None"      isDefault="true" />
      <choice value="1" enum="Enabled"  name="Interrupt" />
   </binaryOption>

   <binaryOption key="adc_sc1_coco" condition="adc_sc1_coco_present"
      hidden="true"
      typeName="AdcCompleteFlag"
      toolTip=""
      description="Conversion Complete Flag" >
      <choice name="Not complete"  value="0" enum="NotComplete"/>
      <choice name="Complete"      value="1" enum="Complete"/>
   </binaryOption >

   <binaryOption key="adc_sc1_diff" condition="adc_sc1_diff_present"
      hidden="true"
      typeName="AdcDifferential"
      toolTip="Enable differential conversion"
      description="Differential Mode Enable" >
      <choice name="Single-ended"  value="0" enum="SingleEnded"/>
      <choice name="Differential"  value="1" enum="Differential"/>
   </binaryOption >

<!-- ==========  PGA features =============================== -->
   <title description="Programmable Gain" condition="adc_pga_pgag_present" />
   <choiceOption key="adc_pga_pgaen" condition="adc_pga_pgaen_present"
      enabledBy="enablePeripheralSupport"
      description="PGA Enable and mode"
      valueFormat="(%s)"
      typeName="AdcPgaMode"
      toolTip="">
      <choice value="ADC_PGA_PGAEN(0)"                   name="PGA is disabled"          enum="Disabled" isDefault="true" />
      <choice value="ADC_PGA_PGAEN(1)|ADC_PGA_PGALPb(0)" name="PGA is in low power mode" enum="LowPower"      />
      <choice value="ADC_PGA_PGAEN(1)|ADC_PGA_PGALPb(1)" name="PGA is in normal mode"    enum="NormalPower"   />
   </choiceOption>

   <choiceOption key="adc_pga_pgag" condition="adc_pga_pgag_present"
      enabledBy="enablePeripheralSupport"
      description="PGA Gain Setting"
      typeName="AdcPgaGain"
      toolTip="Sets gain of PGA amplifier">
      <choice value="0" name="Gain = x1"  enum="x1" isDefault="true" />
      <choice value="1" name="Gain = x2"  enum="x2"   />
      <choice value="2" name="Gain = x4"  enum="x4"   />
      <choice value="3" name="Gain = x8"  enum="x8"   />
      <choice value="4" name="Gain = x16" enum="x16"  />
      <choice value="5" name="Gain = x32" enum="x32"  />
      <choice value="6" name="Gain = x64" enum="x64"  />
   </choiceOption>

   <binaryOption key="adc_pga_pgachp" condition="adc_pga_pgachp_present"
      enabledBy="enablePeripheralSupport"
      description="PGA chopping"
      valueFormat="ADC_PGA_PGACHPb(%s)"
      typeName="AdcPgaChop"
      toolTip="Controls PGA chopping to remove/reduce offset">
      <choice value="0" enum="Disabled" name="No chopping"        isDefault="true" />
      <choice value="1" enum="Enabled"  name="Chopping enabled"   />
   </binaryOption>

<!-- ==========  ADC clock sources =============================== -->

   <intOption key="adcInternalClock"
      enabledBy="enablePeripheralSupport"
      derived="true"
      locked="true"
      description="Frequency of Internal ADC clock"
      toolTip="Varies with ADLPC and ADHSC"
      value="2000000"
      origin="Internal ADC clock"
      units="Hz"/>

   <choiceOption key="adc_cfg1_adiclk"
      enabledBy="enablePeripheralSupport"
      description="ADC Clock Source"
      typeName="AdcClockSource"
      toolTip="Clock source for the ADC module" >
      <choice value="0" name="Bus clock"                  enum="BusClock"     code="SystemBusClock"            />
      <choice value="1" name="Bus clock/2"                enum="BusClockDiv2" code="SystemBusClock/2"          condition="!/SIM/system_irc48m_clock[]" />
      <choice value="1" name="Irc48M clock"               enum="Irc48mClk"    code="SimInfo::irc48mClock"      condition="/SIM/system_irc48m_clock[]"  />
      <choice value="2" name="Alternate clock (OSCERCLK)" enum="OscerClk"     code="Osc0Info::getOscerClock()" />
      <choice value="3" name="Asynchronous clock (ADACK)" enum="Asynch"       code="$(adcInternalClock)"       isDefault="true" />
   </choiceOption>

   <choiceOption key="adc_cfg1_adiv"
      hidden="true"
      description="Clock Divide Select"
      typeName="AdcClockDivider"
      toolTip="Selects the divide ratio used by the ADC to generate the internal clock ADCK">
      <choice value="0" name="Divide by 1" enum="Div1" isDefault="true" />
      <choice value="1" name="Divide by 2" enum="Div2" />
      <choice value="2" name="Divide by 4" enum="Div4" />
      <choice value="3" name="Divide by 8" enum="Div8" />
   </choiceOption>

<!--  ========== ADC =============================== -->

   <title />

   <choiceOption key="adc_cfg1_mode" description="ADC Resolution"
      enabledBy="enablePeripheralSupport"
      typeName="AdcResolution"
      toolTip="The resolutions available vary with single-ended/differential modes\n
               Note the equivalence between modes e.g. 8-bit-se = 9-bit-diff" >
      <choice value="0" name="8-bit unsigned (single-ended mode)"   enum="8bit_se"    />
      <choice value="2" name="10-bit unsigned (single-ended mode)"  enum="10bit_se"   />
      <choice value="1" name="12-bit unsigned (single-ended mode)"  enum="12bit_se"   />
      <choice value="3" name="16-bit unsigned (single-ended mode)"  enum="16bit_se"   condition="adc_cfg1_mode_16bit_present" />
      <choice value="0" name="9-bit signed (differential mode)"     enum="9bit_diff"  condition="adc_cfg1_mode_diff_present" />
      <choice value="2" name="11-bit signed (differential mode)"    enum="11bit_diff" condition="adc_cfg1_mode_diff_present" />
      <choice value="1" name="13-bit signed (differential mode)"    enum="13bit_diff" condition="adc_cfg1_mode_diff_present" />
      <choice value="3" name="16-bit signed (differential mode)"    enum="16bit_diff" condition="adc_cfg1_mode_diff_present&amp;&amp;adc_cfg1_mode_16bit_present" />
   </choiceOption>

   <binaryOption key="adc_cfg1_adlpc" description="Low-Power Configuration"
      enabledBy="enablePeripheralSupport"
      typeName="AdcPower"
      toolTip="Adjust power consumption">
      <choice value="0" enum="Normal" name="Normal power configuration" isDefault="true" />
      <choice value="1" enum="Low"    name="Low-power configuration (reduced speed)" />
   </binaryOption>

   <choiceOption key="adc_sample" description="Long Sample Time Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcSample"
      valueFormat="(%s)"
      toolTip="Selects sample times \n
               Longer times allow higher impedance inputs to be accurately sampled or\n
               shorter times maximize conversion speed for lower impedance inputs\n
               It also affects the conversion rate and power consumption for continuous mode">
      <choice value="ADC_CFG1_ADLSMP(0)"                    enum="4cycles"   name="4 ADCK total" isDefault="true" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(3)" enum="6cycles"   name="+2 ADCK cycles; 6 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(2)" enum="10cycles"  name="+6 ADCK cycles; 10 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(1)" enum="16cycles"  name="+12 ADCK cycles; 16 ADCK total" />
      <choice value="ADC_CFG1_ADLSMP(1)|ADC_CFG2_ADLSTS(0)" enum="24cycles"  name="+20 ADCK cycles; 24 ADCK total" />
   </choiceOption>

   <choiceOption key="adc_sc3_avg" description="Hardware Average Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcAveraging"
      valueFormat="ADC_SC3_CAL(%s),ADC_SC3_CALF(%s),ADC_SC3_AVGE(%s),ADC_SC3_AVGS(%s)"
      toolTip="Determines how many ADC conversions will be averaged\n
               by the hardware to create the ADC result">
      <choice value="0,0,0,0" enum="off"  name="1 sample"     isDefault="true" />
      <choice value="0,0,1,0" enum="4"    name="4 samples"    />
      <choice value="0,0,1,1" enum="8"    name="8 samples"    />
      <choice value="0,0,1,2" enum="16"   name="16 samples"   />
      <choice value="0,0,1,3" enum="32"   name="32 samples"   />
      <choice value="1,1,1,3" enum="Cal"  name="32 samples + clear flag + start calibration" />
   </choiceOption>

   <binaryOption key="adc_cfg2_adhsc" description="High-Speed Configuration"
      enabledBy="enablePeripheralSupport"
      typeName="AdcClockRange"
      toolTip="Configures the ADC for high-speed clock operation\n
               This actually extends the number of conversion clock cycles\n
               but is offset by allowing a faster input clock">
      <choice value="0" enum="Normal" name="Normal conversion sequence selected" isDefault="true" />
      <choice value="1" enum="High"   name="High-speed conversion sequence selected" />
   </binaryOption>

   <binaryOption key="adc_cfg2_adacken" description="Asynchronous Clock Output Enable"
      enabledBy="enablePeripheralSupport"
      typeName="AdcAsyncClock"
      toolTip="Enables the ADC internal asynchronous clock source irrespective of ADC need.\n
         This reduces the initial delay at the start of a sequence of conversions.\n
	 It also allows use of the ADC internal clock as a clock source for other peripherals">
      <choice value="0" enum="Disabled" name="Asynchronous clock output disabled" isDefault="true" />
      <choice value="1" enum="Enabled" name="Asynchronous clock output enabled" />
   </binaryOption>

   <choiceOption key="adc_sc2_refsel" description="Voltage Reference Selection"
      enabledBy="enablePeripheralSupport"
      typeName="AdcRefSel"
      toolTip="Selects the voltage reference source used for conversions">
      <choice value="0" enum="VrefHL"        name="VRefH and VRefl" isDefault="true" />
      <choice value="1" enum="VrefhAndVrefl" name="Gnd and VrefOut(1.2V)" />
      <choice value="0" enum="Default"       name="Default" />
   </choiceOption>

   <binaryOption key="adc_sc2_dmaen" condition="adc_sc2_dmaen_present"
      enabledBy="enablePeripheralSupport"
      description="DMA Enable"
      typeName="AdcDma"
      toolTip="Enables use of DMA with ADC">
      <choice value="0" enum="Disabled" name="Disabled" isDefault="true" />
      <choice value="1" enum="Enabled"  name="Enabled" />
   </binaryOption>

   <binaryOption key="adc_pretrigger" description="Selects the pretrigger"
      enabledBy="enablePeripheralSupport"
      typeName="AdcPretrigger"
      valueFormat="(%s)"
      hidden="true"
      toolTip="Selects which SC1[x]/R[x] register pair to use">
      <choice value="0" enum="0"  name="Use pretrigger 0 = SC1[0]/R[0]" isDefault="true" />
      <choice value="1" enum="1"  name="Use pretrigger 1 = SC1[1]/R[1]" />
   </binaryOption>

   <binaryOption key="adc_cfg2_muxsel"
      enabledBy="enablePeripheralSupport"
      typeName="AdcMuxsel"
      description="A/B multiplexor selection"
      toolTip="Some ADC inputs may be multiplexed to two pins e.g. adcCh4a and adcCh4b">
      <choice value="0" enum="A"  name="The multiplexor selects A channels" />
      <choice value="1" enum="B"  name="The multiplexor selects B channels" isDefault="true" />
   </binaryOption>

   <binaryOption key="adc_sc3_adco"
      description="Single or continuous conversion"
      enabledBy="enablePeripheralSupport"
      typeName="AdcContinuous"
      toolTip="Selects between single and continuous conversion">
      <choice value="0" enum="Disabled" name="Single conversion on each trigger" isDefault="true" />
      <choice value="1" enum="Enabled"  name="Continuous conversions after 1st trigger" />
   </binaryOption>

   <choiceOption key="adc_sc2_compare" description="Compare function"
      enabledBy="enablePeripheralSupport"
      typeName="AdcCompare"
      valueFormat="ADC_SC2_ACFE(%s),ADC_SC2_ACREN(%s),ADC_SC2_ACFGT(%s),(%s)"
      toolTip="Enables comparison of ADC result with CV1 and CV2" >
      <choice value="0,0,0,0"            enum="Disabled"              name="No comparison done"                              isDefault="true"    />
      <choice value="1,0,0,0"            enum="LessThan"              name="ADC value &lt; low"                              />
      <choice value="1,0,1,0"            enum="GreaterThanOrEqual"    name="ADC value &gt;= low"                             />
      <choice value="1,1,0,(0&lt;&lt;8)" enum="OutsideRangeExclusive" name="(ADC value &lt; low) or (ADC value &gt; high)"   />
      <choice value="1,1,1,(1&lt;&lt;8)" enum="OutsideRangeInclusive" name="(ADC value &lt;= low) or (ADC value &gt;= high)" />
      <choice value="1,1,0,(1&lt;&lt;8)" enum="InsideRangeExclusive"  name="(low &lt; ADC value &lt; high)"                  />
      <choice value="1,1,1,(0&lt;&lt;8)" enum="InsideRangeInclusive"  name="(low &lt;= ADC value &lt;= high)"                />
   </choiceOption>

   <intOption key="adc_cv1" description="ADC CV low value"
      enabledBy="adc_sc2_compare>=1"
      valueFormat="%s"
      toolTip="CV Low threshold value\n
         This value will be used for CV1 or CV2 as needed"
      derived="true" />

   <intOption key="adc_cv2" description="ADC CV high value"
      enabledBy="adc_sc2_compare>=3"
      valueFormat="%s"
      toolTip="CV High threshold value\n
         This value will be used for CV1 or CV2 as needed"
      derived="true" />

   <binaryOption key="adc_sc2_adtrg" description="Conversion Trigger Select"
      enabledBy="enablePeripheralSupport"
      typeName="AdcTrigger"
      toolTip="Selects the type of trigger used for initiating a conversion">
      <choice value="0" enum="Software" name="Software trigger (write to SC1A)" isDefault="true" />
      <choice value="1" enum="Hardware" name="Hardware trigger (ADHWT source)" />
   </binaryOption>


<!-- Setters and getters -->

   <for keys="field           : get   : set   : genCode                 : name"
        values="
         adc_sample           : true  : true  : enableGettersAndSetters : SampleTime;
         adc_cfg1_adlpc       : true  : true  : enableGettersAndSetters : LowPower;
         adc_cfg1_adiv        : true  : true  : enableGettersAndSetters : ClockDivider;
         adc_cfg1_mode        : true  : true  : enableGettersAndSetters : Resolution;
         adc_cfg1_adiclk      : true  : true  : enableGettersAndSetters : ClockSelect;
         adc_cfg2_muxsel      : true  : true  : enableGettersAndSetters : Muxsel;
         adc_cfg2_adacken     : true  : true  : enableGettersAndSetters : AsyncClockEnable;
         adc_cfg2_adhsc       : true  : true  : enableGettersAndSetters : HighSpeed;
         adc_sc2_adact        : true  : false : enableGettersAndSetters : ConversionActive;
         adc_sc2_adtrg        : true  : true  : enableGettersAndSetters : Trigger;
         adc_sc2_acfe         : true  : true  : enableGettersAndSetters : CompareFunction;
         adc_sc2_acfgt        : true  : true  : enableGettersAndSetters : CompareFunctionGT;
         adc_sc2_acren        : true  : true  : enableGettersAndSetters : CompareFunctionRange;
         adc_sc2_dmaen        : true  : true  : enableGettersAndSetters : Dma;
         adc_sc2_refsel       : true  : true  : enableGettersAndSetters : Reference;
         adc_sc3_cal          : true  : true  : enableGettersAndSetters : Calibrate;
         adc_sc3_calf         : true  : false : enableGettersAndSetters : CalibrateFlag;
         adc_sc3_adco         : true  : true  : enableGettersAndSetters : Continuous;
         adc_sc3_avg          : true  : true  : enableGettersAndSetters : Average;
         adc_ofs_ofs          : true  : true  : enableGettersAndSetters : Offset;
         adc_pg_pg            : true  : true  : enableGettersAndSetters : PlusGain;
         adc_mg_mg            : true  : true  : enableGettersAndSetters : MinusGain" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <for keys="field           : get   : set   : genCode                 : name"
        values="
         adc_sc1_coco         : true  : false : enableGettersAndSetters : CompleteFlag;
         adc_sc1_aien         : true  : true  : enableGettersAndSetters : Interrupt;
         adc_sc1_channel      : true  : true  : enableGettersAndSetters : Channel" >
      <variableTemplate variables="adc_pretrigger,%(field)" condition="%(set)" codeGenCondition="%(genCode)"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Set %description1
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(
         %params) {
         \t   %register1[%paramName0] = (%register1[%paramName0]&~%mask1)|%paramName1; // %(field)
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="adc_pretrigger,%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description1
         \t *
         %paramDescription0
         \t *
         \t * @return %tooltip1
         \t */
         \tstatic %paramType1 get%(name)(%paramType0 %paramName0) {
         \t   return (%paramType1)(%register1[%paramName0]&%mask1); // %(field)
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!--   ========== class $(_Structname)BasicInfo =============================== -->

   <template namespace="baseClass" ><![CDATA[
      class $(_Structname)BasicInfo {

      public:\n
   ]]></template>

   <clockCodeTemplate namespace="baseClass"
      variable="adc_cfg1_adiclk"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      \t * @param %paramName %tooltip
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getAdcClock(%paramType %paramName) {
      \t
      \t   switch(%paramName) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

   <template namespace="baseClass" ><![CDATA[
      \t/**
      \t * Calculate ADC clock divider (ADC_CFG1_ADIV) and confirm clock source (ADC_CFG1_ADICLK)
      \t *
      \t * @param cfg1 ADC CFG1 register value
      \t * @param cfg2 ADC CFG2 register value
      \t *
      \t * @return modified cfg1 value (ADC_CFG1_ADIV|ADC_CFG1_ADICLK fields may be changed)
      \t */
      \tstatic unsigned calculateClockDivider(uint8_t cfg1, uint8_t cfg2) {
      \t
      \t   AdcClockSource adcClockSource = AdcClockSource(ADC_CFG1_ADICLK_MASK&cfg1);
      \t   AdcClockRange  adcClockRange  = AdcClockRange(ADC_CFG2_ADHSC(cfg2));
      \t   AdcPower       adcPower       = AdcPower(ADC_CFG1_ADLPC(cfg1));
      \t
      \t   // Clear existing fields
      \t   cfg1 &= ~(ADC_CFG1_ADICLK_MASK|ADC_CFG1_ADIV_MASK);
      \t
      \t   if (adcClockSource == AdcClockSource_Asynch) {
      \t      // Internal clock is always OK with /1
      \t      return cfg1|AdcClockSource_Asynch|AdcClockDivider_Div1;
      \t   }
      \t   static constexpr unsigned MinClock =  2000000;
      \t   unsigned maxClock = 0;
      \t   switch(adcPower|adcClockRange) {
      \t      case AdcPower_Low|AdcClockRange_Normal :
      \t      maxClock =  4000000;
      \t      break;
      \t      case AdcPower_Low|AdcClockRange_High :
      \t      maxClock =  6000000; // Guess
      \t      break;
      \t      case AdcPower_Normal|AdcClockRange_Normal :
      \t      maxClock =  8000000;
      \t      break;
      \t      case AdcPower_Normal|AdcClockRange_High :
      \t      maxClock = 12000000;
      \t      break;
      \t   }
      \t   unsigned adiv;
      \t   for(;;) {
      \t      unsigned clockFrequency = getAdcClock(adcClockSource);
      \t      for (adiv=0; adiv<=3; adiv++) {
      \t         if ((clockFrequency <= maxClock) && (clockFrequency >= MinClock)) {
      \t            break;
      \t         }
      \t         clockFrequency /= 2;
      \t      }
      #if $(/adc_alt_clock_is_busDiv2:false)
      \t      if ((adiv>3) && (adcClockSource == AdcClockSource_BusClock)) {
      \t         // Automatically switch from  AdcClockSource_Bus -> AdcClockSource_Busdiv2
      \t         adcClockSource = AdcClockSource_BusClockDiv2;
      \t         continue;
      \t      }
      #endif
      \t      break;
      \t   }
      \t   usbdm_assert(adiv<4, "Unable to find suitable ADC clock");
      \t   return cfg1|adcClockSource|ADC_CFG1_ADIV(adiv);
      \t}
      \t\n
   ]]></template>

   <if condition="adc_cfg1_mode" >
      <template namespace="baseClass" ><![CDATA[
         \t/**
         \t * Get ADC maximum conversion value for an single-ended range
         \t *
         \t * @param adcResolution
         \t *
         \t * @return range e.g. AdcResolution_8bit_se => (2^8)-1
         \t */
         \tstatic constexpr int getSingleEndedMaximum(AdcResolution adcResolution) {
         \t   switch(adcResolution) {
         \t      case AdcResolution_8bit_se:  return (1<<8)-1;
         \t      case AdcResolution_10bit_se: return (1<<10)-1;
         \t      case AdcResolution_12bit_se: return (1<<12)-1;\n
      ]]></template>
      <template namespace="baseClass" condition="adc_cfg1_mode_16bit_present" ><![CDATA[
         \t      case AdcResolution_16bit_se: return (1<<16)-1;\n
      ]]></template>
      <template namespace="baseClass" ><![CDATA[
         \t      default:                     return 0;
         \t   }
         \t}\n\n
      ]]></template>
   </if>

   <if condition="adc_cfg1_mode&amp;&amp;adc_cfg1_mode_diff_present">
      <template namespace="baseClass" ><![CDATA[
      \t/**
      \t * Get ADC maximum conversion value for an differential range
      \t *
      \t * @param adcResolution
      \t *
      \t * @return range e.g. AdcResolution_9bit_diff => (2^8)-1
      \t */
      \tstatic constexpr int getDifferentialMaximum(AdcResolution adcResolution) {
      \t   switch(adcResolution) {
      \t      case AdcResolution_9bit_diff:   return (1<<8)-1;
      \t      case AdcResolution_11bit_diff:  return (1<<10)-1;
      \t      case AdcResolution_13bit_diff:  return (1<<12)-1;\n
      ]]></template>
      <template  namespace="baseClass" condition="adc_cfg1_mode_16bit_present" ><![CDATA[
      \t      case AdcResolution_16bit_diff:  return (1<<15)-1;\n
      ]]></template>
      <template namespace="baseClass" ><![CDATA[
      \t      default:                        return 0;
      \t   }
      \t}\n
      ]]></template>
   </if>

   <template namespace="baseClass" ><![CDATA[
   \t/**
   \t * ADC calibrate.
   \t * Calibrates the ADC before first use.
   \t *
   \t * @note Set up the ADC clock and resolution before calibration
   \t *
   \t * @return E_NO_ERROR       Calibration successful
   \t * @return E_CALIBRATE_FAIL Failed calibration
   \t */
   \tstatic ErrorCode calibrate(volatile ADC_Type *adc) {
   \t
   \t   // Save modified registers
   \t   uint8_t sc2 = adc->SC2;
   \t   uint8_t sc3 = adc->SC3;
   \t
#ifndef ADC_SC2_DMAEN_MASK
   \t   static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK;
#else
   \t   static constexpr uint32_t mask = ADC_SC2_ADTRG_MASK|ADC_SC2_ACFE_MASK|ADC_SC2_DMAEN_MASK;
#endif
   \t
   \t   // Disable hardware trigger
   \t   adc->SC2 = sc2 & ~mask;
   \t
   \t   // Start calibration
   \t   adc->SC3 = AdcAveraging_Cal;
   \t
   \t   // Wait for calibration to complete
   \t   while ((adc->SC1[0] & ADC_SC1_COCO_MASK) == 0) {
   \t      __asm__("nop");
   \t   }
   \t
   \t   // Clear COCO
   \t   (void)adc->R[0];
   \t
   \t   // Check if calibration failed
   \t   bool failed = adc->SC3 & ADC_SC3_CALF_MASK;
   \t
   \t   // Restore original register values
   \t   adc->SC2 = sc2;
   \t   adc->SC3 = sc3;
   \t
   \t   // Check calibration outcome
   \t   if(failed) {
   \t      // Failed calibration
   \t      return setErrorCode(E_CALIBRATE_FAIL);
   \t   }
   \t
   \t   // Calibration factor
   \t   uint16_t calib;
   \t   calib = adc->CLPS + adc->CLP4 + adc->CLP3 + adc->CLP2 + adc->CLP1 + adc->CLP0;
   \t   calib /= 2;
   \t   calib |= (1<<15);  // Set MSB
   \t   adc->PG = calib;
   \t
#ifdef ADC_MG_MG_MASK
   \t   calib = adc->CLMS + adc->CLM4 + adc->CLM3 + adc->CLM2 + adc->CLM1 + adc->CLM0;
   \t   calib /= 2;
   \t   calib |= (1<<15);  // Set MSB
   \t   adc->MG = calib;
#endif
   \t
   \t   return E_NO_ERROR;
   \t   }
   ]]>
   </template>

   <!--   ========== Interrupt handling =============================== -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></variableTemplate>

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Baseclass) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for ISR */
      \tstatic CallbackFunction sCallback;
      \t
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t * @param[in]  $(_basename)Callback Callback function to execute on interrupt
      \t *                             Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(CallbackFunction $(_basename)Callback) {
      \t   if ($(_basename)Callback == nullptr) {
      \t      $(_basename)Callback = unhandledCallback;
      \t   }
      \t   // Allow either no handler set yet or removing handler
      \t   usbdm_assert(
      \t         (sCallback == unhandledCallback) || ($(_basename)Callback == unhandledCallback),
      \t         "Handler already set");
      \t   sCallback = $(_basename)Callback;
      \t}
      \t
      \t/**
      \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t */
      \tstatic void irqHandler() {
      \t
      \t   //.....IRQ handler code here..........
      \t
      \t   if (adc->SC1[0] & ADC_SC1_COCO_MASK) {
      \t   // Execute call-back
      \t      sCallback(adc->R[0], adc->SC1[0]&ADC_SC1_ADCH_MASK);
      \t   }
      \t   if (adc->SC1[1] & ADC_SC1_COCO_MASK) {
      \t   // Execute call-back
      \t      sCallback(adc->R[1], adc->SC1[1]&ADC_SC1_ADCH_MASK);
      \t   }
      \t   return;
      \t}
      \t\n
   ]]>
   </template>

   <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Callback for programmatically set handler for $(_Class)
      \t */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallback = $(_Structname)BasicInfo::unhandledCallback;
      \t\n
   ]]>
   </template>

   <!--   ========== ADC Init class =============================== -->

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(uint32_t status) {
      \t *    (void) status;
      \t * }
      \t *
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   // Omitted parameters are take to be zero unless a base value is given
      \t *   AdcClockSource_Asynch ,  // ADC Clock Source
      \t *   AdcClockDivider_1 ,      // Clock Divide Select
      \t *   AdcResolution_8bit_se ,  // ADC Resolution
      \t *   AdcPower_Normal ,        // Low-Power Configuration
      \t *   AdcClockRange_Normal ,   // High-Speed Configuration
      \t *   AdcAsyncClock_Disabled , // Asynchronous Clock Output Enable
      \t *   AdcRefSel_VrefHL ,       // Voltage Reference Selection
      \t *   AdcDma_Disabled ,        // DMA Enable
      \t *   AdcMuxsel_B ,            // Selects between A/B multiplexor inputs on some ADC channels
      \t *   AdcInterrupt_Disabled ,  // Enables conversion interrupts
      \t *   AdcDma_Disabled ,        // DMA Enable
      \t *   AdcTrigger_Software ,    // Conversion Trigger Select
      \t *   AdcAveraging_off ,       // Hardware Average Select
      \t *   AdcContinuous_Disabled , // Selects between single and continuous conversion
      \t *
      \t *   // These 2/3 parameters must appear in this order
      \t *   AdcCompare_LessThan ,    // Compare function
      \t *   5000 ,                   // ADC CV low value
      \t *   6000 ,                   // ADC CV high value (May be omitted)
      \t *
      \t *   AdcPretrigger_0, AdcChannelNum_11,    AdcAction_Disabled,   // Settings for ADC hardware trigger #0
      \t *   AdcPretrigger_1, AdcChannelNum_Diff0, AdcAction_Enabled,    // Settings for ADC hardware trigger #1
      \t *
      \t *   $(_name)Callback,                 // Call-back to execute on event - call-back function name
      \t *   NvicPriority_Low,                 // Priority for interrupt - Low
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!--   Member variables -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>


   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" condition="adc_sc2_adtrg"
      variables="adc_sc1_channel,adc_sc1_aien" ><![CDATA[
      \t   ///  Hardware trigger values: %description0 and %description1 values
      \t   uint8_t %registerName[$(_STRUCTNAME)_SC1_COUNT] = {\n
   ]]></variableTemplate>
   <for keys="i" dim="=adc_sc1_dim">
      <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" condition="adc_sc2_adtrg" ><![CDATA[
         \t      AdcChannelNum_Disabled,\n
      ]]></template>
   </for>
   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" condition="adc_sc2_adtrg" ><![CDATA[
      \t   };\n\n
   ]]></template>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_cv1"
   ><![CDATA[
      \t   ///  %description
      \t   uint16_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_cv2"
   ><![CDATA[
      \t   ///  %description
      \t   uint16_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_cfg1_adiclk,
         adc_cfg1_mode,
         adc_cfg1_adlpc"
   ><![CDATA[
      \t   ///  ADC Configuration Register 1
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_cfg2_adhsc,
         adc_cfg2_adacken,
         adc_sc2_refsel,
         adc_sc2_dmaen,
         adc_cfg2_muxsel,
         adc_sc2_compare"
   ><![CDATA[
      \t   ///  ADC Configuration Register 2
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_sc2_dmaen,
         adc_sc2_adtrg"
   ><![CDATA[
      \t   ///  ADC Status and Control Registers 2
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="
         adc_sc3_avg,
         adc_sc3_adco"
   ><![CDATA[
      \t   ///  ADC Status and Control Registers 3
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName0 = %symbolicExpression1;
      \t\n
   ]]></variableTemplate>

   <!--   Constructors -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" condition="adc_sc2_adtrg"
      variables="adc_pretrigger,adc_sc1_channel,adc_sc1_aien"
      linePadding="xxx"
      nonDefaultParams="3" >
   <![CDATA[
      \t   /**
      \t    * Constructor for hardware pretrigger
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName1[%paramName0] = %paramName1|%paramName2;
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <for keys="r" values="
         adc_cfg1_adiclk;
         adc_cfg1_mode;
         adc_cfg1_adlpc;
         adc_cfg2_adhsc;
         adc_cfg2_adacken;
         adc_cfg2_muxsel;
         adc_sc2_refsel;
         adc_sc2_dmaen;
         adc_sc2_adtrg;
         adc_sc3_avg;
         adc_sc3_adco">
      <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="adc_sample"
      linePadding="xxx" >
   <![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      cfg1 = (cfg1&~ADC_CFG1_ADLSMP_MASK) | (%paramExpression&ADC_CFG1_ADLSMP_MASK);
      \t      cfg2 = (cfg2&~ADC_CFG2_ADLSTS_MASK) | (%paramExpression&ADC_CFG2_ADLSTS_MASK);
      \t   }
      \t\n
   ]]>
   </variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="adc_sc2_compare,adc_cv1,adc_cv2"
      linePadding="xxx"
      nonDefaultParams="3" >
   <![CDATA[
      \t   /**
      \t    * Configure %description0, %description1 and %description2
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param[in] adcCompare   Comparison operation to enable
      \t    * @param[in] low          Lower threshold
      \t    * @param[in] high         Higher threshold (if needed)
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%paramType0 %paramName0, int low, int high=0, Types... rest) : Init(rest...) {
      \t
      \t      // Juggle CV1, CV2 values to satisfy comparison rules
      \t      switch (adcCompare) {
      \t         case AdcCompare_Disabled:
      \t            break;
      \t         case AdcCompare_LessThan:
      \t         case AdcCompare_GreaterThanOrEqual:
      \t            cv1 = low;
      \t            break;
      \t         case AdcCompare_OutsideRangeExclusive:
      \t         case AdcCompare_InsideRangeInclusive:
      \t            cv1 = low;
      \t            cv2 = high;
      \t            break;
      \t         case AdcCompare_InsideRangeExclusive:
      \t         case AdcCompare_OutsideRangeInclusive:
      \t            cv1 = high;
      \t            cv2 = low;
      \t            break;
      \t      }
      \t      // Mask for valid bits (note adcCompare value may contain out-of-bound bits)
      \t      constexpr uint32_t mask = %mask0;
      \t
      \t      // Set comparison fields
      \t      %registerName0 = (%registerName0&~mask)|(%paramName0&mask);
      \t   }
      \t\n
   ]]>
   </variableTemplate>

<!--   Default Initialisation value -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
         adc_cfg1_adiclk,
         adc_cfg1_mode,
         adc_cfg1_adlpc,
         adc_sample,
         adc_cfg2_adhsc,
         adc_cfg2_adacken,
         adc_sc2_refsel,
         adc_sc2_dmaen,
         adc_cfg2_muxsel,
         adc_sc2_adtrg,
         adc_sc3_avg,
         adc_sc3_adco,
         adc_sc2_compare,
         adc_cv1,
         adc_cv2,
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};
      \t\n
   ]]></variableTemplate>

<!--   Configure methods -->

   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template codeGenCondition="irqHandlingMethod" condition="irqHandlingMethod" >
   <![CDATA[
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t\n
   ]]>
   </template>
   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t   // Calculate clock dividers and update cfg1
      \t   uint8_t cfg1 = calculateClockDivider(init.cfg1, init.cfg2);
      \t
      \t   adc->CFG1    = cfg1;
      \t   adc->CFG2    = init.cfg2;
      \t   adc->SC2     = init.sc2;
      \t\n
   ]]>
   </template>
   <variableTemplate codeGenCondition="enablePeripheralSupport"
      condition="adc_sc2_adtrg"
      variables="adc_sc2_adtrg,adc_sc1_diff" >
   <![CDATA[
      \t   if (init.%registerName0 & %mask0) {
      \t      // Set up hardware trigger conversion information
      \t      for (size_t index=0; index<$(_STRUCTNAME)_SC1_COUNT; index++) {
      \t         %register1[index] = init.%registerName1[index];
      \t      }
      \t   }\n
   ]]>
   </variableTemplate>
   <template codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t   adc->SC3     = init.sc3;
      \t   adc->CV1     = init.cv1;
      \t   adc->CV2     = init.cv2;
      \t
      \t   calibrate(adc);
      \t}
      \t\n
   ]]>
   </template>

<!--  ==========  ADC MISC =============================== -->

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_pretrigger" ><![CDATA[
   \t/**
   \t * Enables hardware trigger mode of operation and configures the channel.
   \t *
   \t * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
   \t * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
   \t *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
   \t */
   \tvoid enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger) const {
   \t   // Set hardware triggers
   \t   adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1);
   \t   // Configure channel for hardware trigger input
   \t   adc->SC1[adcPretrigger] = sc1Value;
   \t}
   \t\n
   ]]></template>

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_pretrigger &amp;&amp; adc_sc2_dmaen" ><![CDATA[
   \t/**
   \t * Enables hardware trigger mode of operation and configures the channel.
   \t *
   \t * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
   \t * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
   \t *                            This corresponds to pre-triggers in the PDB channels and SC1[n] register setups
   \t * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
   \t */
   \tvoid enableHardwareConversion(int sc1Value, AdcPretrigger adcPretrigger, AdcDma adcDma) const {
   \t   // Set hardware triggers
   \t   adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG(1)|adcDma;
   \t   // Configure channel for hardware trigger input
   \t   adc->SC1[adcPretrigger] = sc1Value;
   \t}
   \t\n
   ]]></template>

   <template  discardRepeats="true" key="/ADC/methods" condition="adc_sc2_dmaen" ><![CDATA[
   \t/**
   \t * Enable/disable DMA.
   \t *
   \t * @param[in] adcDma  Controls DMA operation.
   \t */
   \tvoid enableDma(AdcDma adcDma = AdcDma_Enabled) const {
   \t   // Set up DMA
   \t   if (adcDma) {
   \t      adc->SC2 = adc->SC2 | ADC_SC2_DMAEN_MASK;
   \t   }
   \t   else {
   \t      adc->SC2 = adc->SC2 & ~ADC_SC2_DMAEN_MASK;
   \t   }
   \t}\t\n
   ]]></template>

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}; // class $(_Structname)BasicInfo::Init
      \t\n
   ]]>
   </template>

   <template namespace="baseClass" >
   <![CDATA[
      }; // class $(_Structname)BasicInfo
      \t\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};
      \t//typedef $(_Baseclass)Base_T<$(_Class)Info> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="adc_files" >
      <copy source="Project_Headers/adc.h"                    target="Project_Headers/adc.h"                    overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-comparison-example.cpp" target="Snippets/analogue-comparison-example.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-example.cpp"            target="Snippets/analogue-example.cpp"            overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-diff-example.cpp"       target="Snippets/analogue-diff-example.cpp"       overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-interrupt-example.cpp"  target="Snippets/analogue-interrupt-example.cpp"  overwrite="true"  derived="true" />
      <copy source="Snippets/analogue-joystick-example.cpp"   target="Snippets/analogue-joystick-example.cpp"   overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="@isSupportedinStartup" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* SIM configuration ****************** -->
   <category name="Advanced" description="SIM configuration">
      <aliasOption key="/SIM/sim_scgc6_$(_name)"      locked="false" optional="true" />
      <aliasOption key="/SIM/sim_sopt7_adc$(_instance)pretrgsel" locked="false" optional="true"/>
      <aliasOption key="/SIM/sim_sopt7_adc$(_instance)trgsel"    locked="false" optional="true"/>
   </category>

   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</fragment>

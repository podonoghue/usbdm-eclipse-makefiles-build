<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- usb0_otg_clkrcv_c.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="USB OTG Controller with clock recovery" >

   <constant key="enableGettersAndSetters"  value="false" type="Boolean" />

   <!-- Interrupt control for this peripheral -->
   <constant key="irq_pattern"      type="String"  value="&quot;^$(_NAME)$&quot;"           />
   <constant key="irq_ClassHandler" type="String"  value="&quot;$(_Class)::irqHandler&quot;" />
   <irqOption key="irqHandlingMethod"
      hidden="true"
      valueFormat="%s"
      modify="true"
      enabledBy="enablePeripheralSupport"
      typeName="CallbackFunction"
      description="Peripheral interrupt handling"
      toolTip="Interrupts always required."
      pattern="=irq_pattern"
      classHandler="=irq_ClassHandler"
      value="true"
      locked="true"
      derived="true"
      />

   <constant key="generateDefault"           type="Boolean" value="false"         />
   <constant key="configureInStartupDefault" type="Boolean" value="false"         />
   <xi:include href="enablePeripheral.xml"  />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Structname)BasicInfo&quot;" />

   <title description="Clocks" />

   <aliasOption key="/SIM/system_usb_clkin_clock"     locked="false" optional="true" />

   <for keys="n" dim="=/SIM/numberOfClockSettings" >
      <aliasCategoryOption key="/MCG/ClockConfig[%(n)]" >
         <aliasOption key="/SIM/system_peripheral_clock[%(n)]"    optional="true"/>
         <aliasOption key="/SIM/sim_sopt2_usbsrc[%(n)]"           locked="false" optional="true"/>
         <aliasOption key="/SIM/sim_clkdiv2_usb[%(n)]"            locked="false" optional="true"/>
         <aliasOption key="/SIM/system_usbfs_clock[%(n)]"         optional="true"/>
      </aliasCategoryOption>
   </for>

   <title description="Clock Recovery" />

   <!-- ************* CLK_RECOVER_IRC_EN ****************** -->

   <choiceOption key="usb_clk_recover_irc_en_irc_en"
      condition="usb_clk_recover_irc_en_irc_en_present&amp;&amp;usb_clk_recover_irc_en_reg_en_present"
      enabledBy="enablePeripheralSupport"
      register="clk_recover_irc_en"
      typeName="UsbIrc48mClockEnable"
      valueFormat="USB_CLK_RECOVER_IRC_EN_IRC_EN(%s),USB_CLK_RECOVER_IRC_EN_REG_EN(%s)"
      description="IRC48M enable"
      toolTip="This is used to control when the the on-chip IRC48M module is enabled\n
               It will also be enabled if selected as a peripheral clock or MCG clock source if powered\n
               It can be used as a clock source for FS USB device mode operation">
      <choice value="0,0"  enum="Disabled"         name="Power disabled - not available at all"     />
      <choice value="0,1"  enum="Peripheral"       name="Available as general clock source"         isDefault="true"  />
      <choice value="1,1"  enum="PeripheralAndUsb" name="Available as general and USB clock source" />
   </choiceOption>

   <choiceOption key="usb_clk_recover_irc_en_irc_en"
      condition="usb_clk_recover_irc_en_irc_en_present&amp;&amp;!usb_clk_recover_irc_en_reg_en_present"
      enabledBy="enablePeripheralSupport"
      register="clk_recover_irc_en"
      typeName="UsbIrc48mClockEnable"
      description="IRC48M enable"
      toolTip="This is used to control when the the on-chip IRC48M module is enabled\n
               It will also be enabled if selected as a peripheral clock or MCG clock source if powered\n
               It can be used as a clock source for FS USB device mode operation">
      <choice value="0"  enum="Peripheral"       name="Available as general clock source"         isDefault="true"  />
      <choice value="1"  enum="PeripheralAndUsb" name="Available as general and USB clock source" />
   </choiceOption>

   <!-- ************* CLK_RECOVER_CTRL ****************** -->

   <choiceOption key="usb_clk_recover_ctrl_tracking_mode" condition="usb_clk_recover_ctrl_clock_recover_en_present"
      enabledBy="usb_clk_recover_irc_en_irc_en&gt;1"
      register="clk_recover_ctrl"
      typeName="UsbIrc48mClockTrackingMode"
      valueFormat="USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(%s),USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(%s)"
      description="IRC48M mode for USB operation"
      toolTip="This controls the mode of clock recovery when IRC48M is used as a crystal-less USB clock\n
               The clock recovery block trims the IRC48M against USB bus transitions to get an accurate 48Mhz clock\n
               It has two phases after being initially enabled: rough phase and tracking phase\n
               The steps used to tune the IRC48M are different during these two phases\n
               The step in rough phase is larger than that in tracking phase">
      <choice value="0,0"  enum="Disabled"              name="Tracking disabled"                               />
      <choice value="1,0"  enum="AlwaysFineTracking"    name="Always fine after initial rough tracking"        />
      <choice value="1,1"  enum="RoughAndFineTracking"  name="Revert to rough tracking on USB reset or resume" />
   </choiceOption>

   <binaryOption key="usb_clk_recover_ctrl_restart_ifrtrim_en" condition="usb_clk_recover_ctrl_restart_ifrtrim_en_present"
      enabledBy="usb_clk_recover_ctrl_tracking_mode&gt;0"
      register="clk_recover_ctrl"
      typeName="UsbIrc48mClockResetTrim"
      description="Restart from IFR trim value"
      toolTip="IRC48 has a default trim fine value whose default value is factory trimmed (the IFR trim value)\n
               The clock recover block tracks the accuracy of the clock 48Mhz and keeps updating the trim fine value accordingly\n
               This action controls when the trim value is reset to the IFR value">
      <choice value="0"  enum="Keep"    name="Start from last trim value" isDefault="true" />
      <choice value="1"  enum="Restart" name="Restart from factory trim value" />
   </binaryOption>

   <for keys="field                                : set   : get   : clear : genCode                 : name"
        values="
         usb_clk_recover_ctrl_tracking_mode        : true  : true  : false : enableGettersAndSetters : TrackingMode;
         usb_clk_recover_ctrl_restart_ifrtrim_en   : true  : true  : false : enableGettersAndSetters : TrackingTrim;
         usb_clk_recover_irc_en_irc_en             : true  : true  : false : enableGettersAndSetters : Irc48MzEnable" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         \tstatic void clear%(name)() {
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!--   ========== class $(_Structname)BasicInfo =============================== -->

   <template namespace="baseClass" ><![CDATA[
      class $(_Structname)BasicInfo {

      public:\n
   ]]></template>

   <!--   ========== USB ClockRecoveryInit class =============================== -->

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass) Clock Recovery
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultClockRecovery for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::ClockRecoveryInit $(_name)ClockRecoveryInit {
      \t *
      \t *   // Setup values
      \t * UsbIrc48mClockTrackingMode_Disabled , // IRC48M mode for USB operation - Tracking disabled
      \t * UsbIrc48mClockResetTrim_Keep , // Restart from IFR trim value - Start from last trim value
      \t * UsbIrc48MHzEnable_Disabled,  // IRC48M enable - Disable the IRC48M module (default)
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultClockRecovery   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)ClockRecoveryInit)
      \t * @endcode
      \t */
      \tclass ClockRecoveryInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ClockRecoveryInit(const ClockRecoveryInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ClockRecoveryInit() = default;
      \t\n
   ]]>
   </template>

   <!--   Member variables -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="usb_clk_recover_ctrl_tracking_mode,usb_clk_recover_ctrl_restart_ifrtrim_en"
   ><![CDATA[
      \t   /// USB Clock recovery control
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="usb_clk_recover_irc_en_irc_en"
   ><![CDATA[
      \t   /// IRC48M oscillator enable register
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <!--   Constructors -->

   <for keys="r"
      values="
            usb_clk_recover_ctrl_tracking_mode;
            usb_clk_recover_ctrl_restart_ifrtrim_en;
            usb_clk_recover_irc_en_irc_en
            " >
      <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ClockRecoveryInit(%params, Types... rest) : ClockRecoveryInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

<!--   Default Initialisation value -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            usb_clk_recover_ctrl_tracking_mode,
            usb_clk_recover_ctrl_restart_ifrtrim_en,
            usb_clk_recover_irc_en_irc_en
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ClockRecoveryInit DefaultClockRecovery = {%initExpression
      \t};
      \t\n
   ]]></variableTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(Info::DefaultClockRecovery);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::ClockRecoveryInit &init) {
      \t
      \t   // Enable peripheral clock
      \t   Info::enableClock();
      \t\n
      \t   usb->CLK_RECOVER_CTRL          = init.clk_recover_ctrl;
      \t   usb->CLK_RECOVER_IRC_EN        = init.clk_recover_irc_en;
      \t   usb->CLK_RECOVER_INT_STATUS    = init.clk_recover_int_status;
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}; // class $(_Structname)BasicInfo::ClockRecoveryInit
      \t\n
   ]]>
   </template>

   <template namespace="baseClass" >
   <![CDATA[
      }; // class $(_Structname)BasicInfo
      \t\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info, 64> {};
      \t//typedef $(_Baseclass)Base_T<$(_Class)Info,64> $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="usb_files">
      <copy source="Project_Headers/usb.h"                     target="Project_Headers/usb.h"                     overwrite="true"  derived="true" />
      <copy source="Project_Headers/usb_defs.h"                target="Project_Headers/usb_defs.h"                overwrite="true"  derived="true" />
      <copy source="Project_Headers/usb_endpoint.h"            target="Project_Headers/usb_endpoint.h"            overwrite="true"  derived="true" />
      <copy source="Snippets/usb_cdc_interface.cpp"            target="Snippets/usb_cdc_interface.cpp"            overwrite="true"  derived="true" />
      <copy source="Snippets/usb_cdc_interface.h"              target="Snippets/usb_cdc_interface.h"              overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_bulk.cpp"      target="Snippets/usb_implementation_bulk.cpp"      overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_bulk.h"        target="Snippets/usb_implementation_bulk.h"        overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_cdc.cpp"       target="Snippets/usb_implementation_cdc.cpp"       overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_cdc.h"         target="Snippets/usb_implementation_cdc.h"         overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_composite.cpp" target="Snippets/usb_implementation_composite.cpp" overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation_composite.h"   target="Snippets/usb_implementation_composite.h"   overwrite="true"  derived="true" />
      <copy source="Snippets/usb_implementation.h"             target="Snippets/usb_implementation.h"             overwrite="true"  derived="true" />
      <copy source="Snippets/usb.cpp"                          target="Snippets/usb.cpp"                          overwrite="true"  derived="true" />
   </projectActionList>

   <!-- ************* SIM configuration ****************** -->
   <category name="Advanced" description="SIM configuration" >
      <aliasOption key="/SIM/sim_sopt1_usbregen"   locked="false" optional="true" />
      <aliasOption key="/SIM/sim_sopt1_usbsstby"   locked="false" optional="true" />
      <aliasOption key="/SIM/sim_sopt1_usbvstby"   locked="false" optional="true" />
      <aliasOption key="=_scgc_clock"              locked="false" condition="_scgc_clock" />
   </category>

   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</peripheralPage>

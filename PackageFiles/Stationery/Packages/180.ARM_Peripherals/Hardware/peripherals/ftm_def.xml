<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- ftm_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <constant key="suppressInstance"         type="Boolean" value="false"         />
   <constant key="peripheralUsesInterrupts" type="Boolean" value="true"          />
   <constant key="irq_parameters"           type="String"  value="&quot;uint8_t&quot;"  />
   <constant key="irq_call"                 type="String"  value="&quot;0&quot;"  />
   <constant key="isGeneratedByDefault"     type="Boolean" value="false"         />
   <constant key="isSupportedinStartup"     type="Boolean" value="true"          />
   <xi:include href="_enablePeripheral.xml"  />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%variable[index]            Variable name
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <!-- ====================== constants ====================== -->
   <constant key = "disable_peripheral"      value = "&quot;ftm->SC = FTM_SC_CLKS(0);&quot;" type="String"  />

   <intOption key="NumChannels"
      hidden="true"
      locked="true"
      derived="true"
      description="Number of Channels"
      toolTip="The number of timer channels available"
      value="=_channelCount" />

   <intOption key="NumChannelVectors"
      hidden="true"
      locked="true"
      derived="true"
      description="Number of Channel interrupt vectors"
      toolTip="Number of channel event interrupt vectors - \n
               Multiple Channels may be mapped to the same vector"
      value="=_irqCount" />

   <template><![CDATA[
      \t//! Number of channels implemented
      \tstatic constexpr unsigned NumChannels = $(NumChannels);

      \t//! Number of channel event vectors implemented
      \tstatic constexpr unsigned NumChannelVectors = $(NumChannelVectors);\n\n
   ]]></template>

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Class)BasicInfo&quot;" />

   <title description="Clocking" />

   <choiceOption key="ftm_sc_clks" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      description="Clock Source"
      typeName="FtmClockSource"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module" >
      <choice value="0" name="Disabled"              ref="disabled"                      code="0"                enum="Disabled"            />
      <choice value="1" name="System clock"          ref="/SIM/system_bus_clock[0]"      code="SystemBusClock"   enum="SystemClock"         isDefault="true" />
      <choice value="2" name="Fixed frequency clock" ref="/MCG/system_mcgffclk_clock[0]" code="SystemMcgFFClock" enum="FixedFrequencyClock" />
      <choice value="3" name="External clock"        ref="ftmExternalClock"              code="ftmExternalClock" enum="ExternalClock"       />
   </choiceOption>

   <binaryOption key="externalClockUsed"
      ref="ftm_sc_clks == 3"
      derived="true"
      locked="true"
      hidden="true"
   >
      <choice value="0" name="External clock unused" />
      <choice value="1" name="External clock used"   />
   </binaryOption>

   <choiceOption key="ftm_sc_clks"  condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      description="FTM Clock Source"
      typeName="FtmClockSource"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module" >
      <choice value="0" name="Disabled"              ref="disabled"                      code="0"                enum="Disabled"            />
      <choice value="1" name="System timer clock"    ref="/SIM/system_timer_clock[0]"    code="SystemTimerClock" enum="SystemTimerClock"    isDefault="true" />
      <choice value="2" name="Fixed frequency clock" ref="/ICS/system_icsffclk_clock[0]" code="SystemIcsFFClock" enum="FixedFrequencyClock" />
      <choice value="3" name="External clock"        ref="ftmExternalClock"              code="ftmExternalClock" enum="ExternalClock"       />
   </choiceOption>

   <intOption key="ftmExternalClock"
      enabledBy="enablePeripheralSupport&amp;&amp;(ftm_sc_clks==3)"
      description="FTM External clock"
      toolTip="Assumed clock frequency used for calculations when External clock is selected"
      value="0" min="0" units="Hz"/>

   <intOption key="inputClockFrequency"
      enabledBy="enablePeripheralSupport"
      locked="true"
      description="Frequency of input clock to timer"
      derived="true"
      units="Hz"/>

<!-- ================ Main Configuration ====================== -->

   <title description="Main configuration"/>

   <choiceOption key="mode"
      enabledBy="enablePeripheralSupport"
      target="ftm_sc_cpwms"
      description="Main operating mode for FTM"
      toolTip="Main Mode"
      disabledValue="0"
   >
      <choice value="1" name="Left aligned" ref="0"
         toolTip="Left aligned (counter runs [0...mod]),  supports:\n
                 - Input capture\n
                 - Dual-edge capture\n
                 - Output compare\n
                 - Edge-aligned PWM\n
                 - Combined PWM"       />
      <choice value="2" name="Centre aligned" ref="1"
         toolTip="Centre aligned (counter runs [(0...mod...0)]), supports:\n
          - Centre-aligned PWM"
      />
      <choice value="3" name="Quadrature decoder" ref="0"
         toolTip="Quadrature Decode (counter clocked by decoder), supports:\n
          - Quadrature decode using two channels"
      />
      <choice value="0" name="Disabled" ref="0" enabledBy="false" />
   </choiceOption>
   <constant key="Left"    value="0"   type="Long" />
   <constant key="Centre"  value="1"   type="Long" />
   <constant key="Quad"    value="2"   type="Long" />
   <constant key="None"    value="3"   type="Long" />

   <binaryOption key="ftm_sc_cpwms"
      hidden="true"
      locked="true"
      enabledBy="enablePeripheralSupport"
      typeName="FtmCountMode"
      description="Alignment (Count mode)"
      toolTip="Left-aligned   (0...mod) or\n
               Centre-aligned (0...mod...0)" >
      <choice value="0" name="Left-aligned (count up)"         enum="LeftAligned"    />
      <choice value="1" name="Centre-aligned (count up-down)"  enum="CentreAligned"  />
   </binaryOption>

   <categoryOption description="Run-time checks" key="runtimeChecks"
      hiddenBy="mode!=(Left,Centre)"
   >

      <binaryOption key="check_minimums"
         enabledBy="enablePeripheralSupport"
         description="Check minimum interval and minimum resolution"
         toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
         <choice value="0" name="No checks done" />
         <choice value="1" name="Do checks"  isDefault="true" />
      </binaryOption>

      <intOption key="minimumInterval"
         enabledBy="check_minimums"
         description="Minimum usable interval in ticks"
         toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
                  when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
         value="20" min="0" max="65535"/>

      <intOption key="minimumResolution"
         enabledBy="check_minimums"
         description="Minimum resolution for PWM interval"
         toolTip="This value is used as a minimum value for the timer period in ticks \n
            so that a reasonable resolution is available for PWM duty-cycle"
         value="100" min="0" max="65535" />
   </categoryOption>

   <choiceOption key="ftm_sc_ps"
      hiddenBy="mode==(None)"
      enabledBy="enablePeripheralSupport"
      description="Clock prescaler"
      typeName="FtmPrescale"
      target="clock"
      toolTip="Selects the prescaler for the module" >
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"        enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="(inputClockFrequency)/2."   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="(inputClockFrequency)/4."   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="(inputClockFrequency)/8."   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="(inputClockFrequency)/16."  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="(inputClockFrequency)/32."  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="(inputClockFrequency)/64."  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="(inputClockFrequency)/128." enum="DivBy128" />
   </choiceOption>

   <floatOption key="clock"
      hiddenBy="mode==(None,Quad)"
      description="Counter tick rate"
      toolTip="The tick rate of the main counter"
      derived="true"
      locked="true"
      units="Hz"
    />

   <floatOption key="clockPeriod"
      hidden="true"
      ref="(1.0/clock)"
      locked="true"
      derived="true"
   />

   <binaryOption key="freeRunningCounter"
      hiddenBy="mode!=(Left,Quad)"
      description="Counter free-running"
      toolTip="Forces the full range for counter [0..65535]\n
               This is usually convenient for input-capture operations\n
               making use of modulo-16 calculations will counter roll-overs"
      name="freeRunning"
   >
      <choice value="0" name="Period mode"       />
      <choice value="1" name="Free-running mode" />
   </binaryOption>

   <intOption key="ftm_mod"
      hiddenBy="mode==(None)"
      enabledBy="!freeRunningCounter"
      description="End value for counter"
      toolTip="The timer counts from 0 to this value"
      typeName="Ticks &amp;"
      units="ticks"
      value="65535" min="0" max="65535" />

   <floatOption key="ftm_modPeriod"
      enabledBy="inputClockFrequency!=0"
      hiddenBy="mode==(None,Quad)"
      ref="clockPeriod*(ftm_sc_cpwms?(2*(ftm_mod)):(ftm_mod+1))"
      typeName="Seconds &amp;"
      unlockedBy="!freeRunningCounter"
      valueFormat="%s_s"
      description="Period or minimum interval of timer"
      toolTip="In left-aligned or centre-aligned this is the period of the timer\n
               In free-running mode it is the minimum interval"
      derived="true"
      units="s" />

   <choiceOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;ftm_sc_dma_present"
      hiddenBy="mode==(None)"
      enabledBy="irqHandlingMethod"
      valueFormat="FTM_SC_TOIE(%s),FTM_SC_DMA(%s)"
      enumType="uint16_t"
      typeName="FtmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt and/or DMA on counter overflow" >
       <choice value="0,0" name="No action"                    enum="None"             />
       <choice value="0,1" name="DMA request"                  enum="Dma"              />
       <choice value="1,0" name="Interrupt request"            enum="Interrupt"        />
       <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  />
   </choiceOption>

   <binaryOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;!ftm_sc_dma_present"
      hiddenBy="mode==(None)"
      enabledBy="irqHandlingMethod"
      valueFormat="FTM_SC_TOIE(%s)"
      enumType="uint8_t"
      typeName="FtmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt on counter overflow" >
      <choice value="0" name="No action"          enum="None"       />
      <choice value="1" name="Overflow Interrupt" enum="Interrupt"  />
   </binaryOption>

   <!-- ************* Miscellaneous ****************** -->

   <categoryOption key="Miscellaneous" description="Miscellaneous"
      hiddenBy="mode==(None,Quad)"
   >
      <!-- not sensible to initialise these -->
      <!-- binaryOption key="ftm_mode_captest" condition="ftm_mode_captest_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmCaptestMode"
         description="Capture Test Mode Enable" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption -->

      <binaryOption key="ftm_mode_pwmsync" condition="ftm_mode_pwmsync_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModePwmsync"
         description="PWM Synchronization Mode"
         toolTip="Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.\n
                  It only configures the synchronization when SYNCMODE is 0." >
         <choice name="Unrestricted"  value="0" enum="NoRestrictions"
               toolTip="MOD, CnV, OUTMASK and FTM counter synch may use software or hardware trigger"
         />
         <choice name="Restricted"    value="1" enum="Restricted"
               toolTip="MOD and CnV use software trigger, OUTMASK and counter synch use hardware trigger"
         />
      </binaryOption >

      <binaryOption key="ftm_mode_wpdis" condition="ftm_mode_wpdis_present"
         locked="true"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModeWpdis"
         description="Write Protection Disable"
         toolTip="This value is applied after main FTM configuration" >
         <choice name="Enabled"     value="0" enum="Enabled"  />
         <choice name="Disabled"    value="1" enum="Disabled" />
      </binaryOption >

      <binaryOption key="ftm_mode_ftmen" condition="ftm_mode_ftmen_present"
         locked="true"
         enabledBy="enablePeripheralSupport"
         typeName="FtmModeFtmen"
         description="FTM Mode Enable"
         toolTip="This field is write protected. It can be written only when MODE[WPDIS] = 1" >
         <choice name="TPM registers only"  value="0" enum="TpmRegistersOnly" />
         <choice name="All registers"       value="1" enum="AllRegisters"     isDefault="true" />
      </binaryOption >

      <choiceOption key="ftm_conf_bdmmode" condition="ftm_conf_bdmmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfBdmmode"
         toolTip="Selects the FTM behavior in Debug mode."
         description="Controls operation in BDM Mode" >
         <choice name="Stopped, outputs functional"            value="0" enum="Stopped_OutputsFunctional"/>
         <choice name="Stopped, outputs forced to safe value"  value="1" enum="Stopped_OutputsForcedToSafeValue"/>
         <choice name="Stopped, outputs frozen"                value="2" enum="Stopped_OutputsFrozen"/>
         <choice name="Functioning"                            value="3" enum="Functioning"/>
      </choiceOption >

      <intOption key="ftm_conf_numtof" condition="ftm_conf_numtof_present"
         enumType="uint8_t"
         enabledBy="enablePeripheralSupport"
         typeName="ftm_OverflowDivider"
         description="TOF Frequency"
         toolTip="Selects the ratio between counter overflows and the number of times the TOF bit is set.\n
                  The TOF is set for the 1st overflow and then ignored for N further overflows."
         min="0" max="31"
         value="0"
      />
   </categoryOption>

   <!-- ************* DEADTIME ****************** -->

   <categoryOption key="deadTime" description="Deadtime"
      toolTip="Configure the Fault control, Synchronization, Dead-time insertion, \n
               Dual Edge Capture mode, Complementary, and Combine mode for each pair of channels"
      hiddenBy="mode==(None,Quad)"
      >

      <choiceOption key="ftm_deadtime_dtps" condition="ftm_deadtime_dtps_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmDeadtimePrescale"
         description="Dead-time Prescaler Value"
         toolTip="Scale value for dead-time" >
         <choice name="Divide by 1"   value="0" enum="DivideBy1"/>
         <choice name="Divide by 4"   value="2" enum="DivideBy4"/>
         <choice name="Divide by 16"  value="3" enum="DivideBy16"/>
      </choiceOption >

      <intOption key="ftm_deadtime_dtval" condition="ftm_deadtime_dtval_present"
         enabledBy="enablePeripheralSupport"
         units="ticks"
         description="Dead-time Value"
         toolTip="This tick value is scaled by the dead-time prescaler"
         min="0" max="0x3F"
      />

      <timeOption key="ftm_deadtime" condition="ftm_deadtime_dtval_present"
         ref="ftm_deadtime_dtval*((ftm_deadtime_dtps==0)?1:((ftm_deadtime_dtps==1)?4:16))"
         periodEquation="ftm_deadtime*clockPeriod"
         description="Calculated dead-time"
         toolTip="Dead-time calculated using clock specified in clocking"
         units="ticks"
       />

      <for keys   =" num : pair"
           values =" 0   : 0 &amp; 1 ;
                     1   : 2 &amp; 3 ;
                     2   : 4 &amp; 5 ;
                     3   : 6 &amp; 7 ;
           " >
         <bitmaskOption key="ftm_combine%(num)" condition="ftm_combine_comb%(num)_present"
            enabledBy="enablePeripheralSupport"
            typeName="FtmCombine%(num)"
            enumType="uint8_t"
            bitmask="0"
            bitList="COMBINE%(num), COMP%(num), DECAPEN%(num), DECAP%(num), DTEN%(num), SYNCEN%(num), FAULTEN%(num)"
            description="Paired Channels %(pair)"
            bitDescription="
               Combine Channels enable,
               Complementary output mode enable,
               Dual Edge Capture Mode captures,
               Dual Edge Capture Mode enable,
               Dead-time Insertion enable,
               PWM synchronization enable,
               Fault Control enable"
            toolTip="Options controlling paired operation of channels" />
      </for>

      <!-- ************* INVCTRL ****************** -->
<!--
      <equation key="polarityEnums"    value="" />
      <equation key="polarityChannels" value="" />
      <for keys="ch" dim="8" >
         <equation key="polarityEnums"
            condition="/FTM0/ftm_pol_pol%(ch)_present||/FTM1/ftm_pol_pol%(ch)_present||
                       /FTM2/ftm_pol_pol%(ch)_present||/FTM3/ftm_pol_pol%(ch)_present"
            value="
               =polarityEnums+
               &quot;\t   FtmPolarity_Ch%(ch)_ActiveLow   = (uint8_t(~FTM_POL_POL%(ch)(0))&lt;&lt;8)|FTM_POL_POL%(ch)(1),\n&quot;+
               &quot;\t   FtmPolarity_Ch%(ch)_ActiveHigh  = (uint8_t(~FTM_POL_POL%(ch)(1))&lt;&lt;8)|FTM_POL_POL%(ch)(0),\n&quot;"
          />
         <equation key="polarityChannels"
            condition="ftm_pol_pol%(ch)_present"
            value="=polarityChannels+&quot;CH%(ch),&quot;"
          />
      </for>

      <equation key="polarityEnums"
         value="=polarityEnums+
               &quot;\t   FtmPolarity_All_ActiveLow   = (uint8_t(~FTM_POL_POL(0x00))&lt;&lt;8)|FTM_POL_POL(0xFF),\n&quot;+
               &quot;\t   FtmPolarity_All_ActiveHigh  = (uint8_t(~FTM_POL_POL(0xFF))&lt;&lt;8)|FTM_POL_POL(0x00),\n&quot;" />

      <stringOption key="polarityEnums_"    value="=polarityEnums" />
      <stringOption key="polarityChannels_" value="=polarityChannels" />

      <equation key="externalChannels" value="" />
      <for keys="ch" dim="8" >
         <equation key="externalChannels"
            condition="/FTM0/ftm_invctrl_inv%(ch)en_present||/FTM1/ftm_invctrl_inv%(ch)en_present||
                       /FTM2/ftm_invctrl_inv%(ch)en_present||/FTM3/ftm_invctrl_inv%(ch)en_present"
            value="
            =externalChannels+
            &quot;\t   FtmInvctrl%(ch)_1_Inverted    = FTM_INVCTRL_INV%(ch)EN(1),\n&quot;"
          />
      </for>

      <! Not sensible to configure statically >
      <for keys="    Num : Left : Right"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <binaryOption key="ftm_invctrl_inv%(Num)en"
            condition="/FTM0/ftm_invctrl_inv%(Num)en_present||/FTM1/ftm_invctrl_inv%(Num)en_present||
                       /FTM2/ftm_invctrl_inv%(Num)en_present||/FTM3/ftm_invctrl_inv%(Num)en_present"
            enabledBy="enablePeripheralSupport"
            typeName="FtmInvctrl%(Left)_%(Right)"
            description="Paired Channels %(Left) &amp; %(Right) Inverting Enable"
            toolTip="Selects the inverting operation for the corresponding pair channels\n
                     This register has a write buffer. \n
                     The INVmEN bit is updated by the INVCTRL register synchronization." >
            <choice name="Not inverted"  value="0" enum="NotInverted" />
            <choice name="Inverted"      value="1" enum="Inverted"    />
         </binaryOption >
      </for>
-->

   </categoryOption>

   <!-- ************* Synchronization of Buffered Registers ****************** -->

   <categoryOption key="Synchronization" description="Synchronization of Buffered Registers"
      hiddenBy="mode==(None,Quad)"
   >

      <binaryOption key="ftm_sync_swsync" condition="ftm_sync_swsync_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncSwsync"
         description="Software Trigger for PWM Synchronization "
         toolTip="Selects the software trigger as the PWM synchronization trigger.\n
                  The software trigger happens when a 1 is written to SWSYNC bit." >
         <choice name="Not selected"  value="0" enum="NotSelected"/>
         <choice name="Selected"      value="1" enum="Selected"/>
      </binaryOption >

      <bitmaskOption key="ftm_sync_trig" condition="hardwareTriggerPinMap"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHardwareTrigger"
         enumType="uint32_t"
         valueFormat="FtmHardwareTrigger(%s)"
         description="Hardware trigger inputs"
         toolTip="Enables hardware trigger to the PWM synchronization.\n
                  Hardware trigger occurs on a rising edge of the corresponding trigger input signal."
         bitmask="0"
         bitList="=hardwareTriggerPinMap"
         pinMap="=&quot;FTM$(_instance)_TRIG%i:&quot;+hardwareTriggerPinMap"
         value="0" />

      <binaryOption key="ftm_sync_synchom" condition="ftm_sync_synchom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncSynchom"
         description="Output Mask Synchronization with buffer"
         toolTip="Selects when the OUTMASK register is updated with the value of its buffer" >
         <choice name="Rising edges of the system clock"  value="0" enum="RisingEdgesOfSystemClock"/>
         <choice name="PWM synchronization"               value="1" enum="PwmSynchronization"/>
      </binaryOption >

      <binaryOption key="ftm_sync_reinit" condition="ftm_sync_reinit_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmReinitOnSync"
         description="Counter Reinitialization"
         toolTip="Determines if the FTM counter is reinitialized when \n
                  the selected synchronization trigger is detected. \n
                  It only configures the synchronization when SYNCMODE is zero." >
         <choice name="Counts normally"                        value="0" enum="Disabled"/>
         <choice name="Updated with initial value on trigger"  value="1" enum="Enabled"/>
      </binaryOption >

   </categoryOption>

   <categoryOption key="PWM Synchronization" description="Reload Points"
      hiddenBy="mode==(None,Quad)"
   >

      <binaryOption key="ftm_pwmload_ldok" condition="ftm_pwmload_ldok_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPwmload"
         description="Load Enable"
         toolTip="Enables loading of MOD/CNTIN/CnV from buffers when Counter=MOD" >
         <choice name="Loading disabled"  value="0" enum="Disabled"/>
         <choice name="Loading enabled"   value="1" enum="Enabled"/>
      </binaryOption >

      <bitmaskOption key="ftm_pwmload_chsel" condition="ftm_pwmload_chsel_present"
         enabledBy="enablePeripheralSupport"
         typeName="uint32_t"
         description="Match Channel Select"
         toolTip="Selects which channel trigger loading of MOD/CNTIN/CnV from buffers\n
                  If enabled, the loading occurs when the counbter reaches CnV"
         bitmask="0xFF"
         bitList="CH%i"
      />

      <binaryOption key="ftm_sync_cntmin" condition="ftm_sync_cntmin_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncCntmin"
         description="Minimum Loading Point Enable"
         toolTip="Selects the minimum loading point for loading of MOD/CNTIN/CnV from buffers. \n
                  If enabled, the loading occurs when the FTM counter reaches CNTIN." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <binaryOption key="ftm_sync_cntmax" condition="ftm_sync_cntmax_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncCntmax"
         description="Maximum Loading Point Enable"
         toolTip="Selects the maximum loading point for loading of MOD/CNTIN/CnV from buffers.\n
                  If enabled, the loading occurs when the FTM counter reaches MOD." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >
   </categoryOption>

   <!--  **************** External Triggers **************** -->
   <categoryOption key="Triggers" description="Generation of External Triggers"
      hiddenBy="mode==(None,Quad)"
   >

      <equation key="triggerEnums"    value="" />
      <equation key="triggerChannels" value="" />
      <for keys="ch" values="2;3;4;5;0;1" >
         <equation key="triggerEnums"
            condition="/FTM0/ftm_exttrig_ch%(ch)trig_present||/FTM1/ftm_exttrig_ch%(ch)trig_present||
                       /FTM2/ftm_exttrig_ch%(ch)trig_present||/FTM3/ftm_exttrig_ch%(ch)trig_present"
            value="
            =triggerEnums+
            &quot;\t   FtmExternalTrigger_ch%(ch)   = FTM_EXTTRIG_CH%(ch)TRIG_MASK,\n&quot;"
          />
         <equation key="triggerChannels"
            condition="ftm_exttrig_ch%(ch)trig_present"
            value="=triggerChannels+&quot;CH%(ch)TRIG,&quot;"
          />
         <equation key="triggerChannels"
            condition="!ftm_exttrig_ch%(ch)trig_present"
            value="=triggerChannels+&quot;,&quot;"
          />
      </for>

      <equation key="triggerEnums"    value="=triggerEnums+&quot;\t   FtmExternalTrigger_cntin = FTM_EXTTRIG_INITTRIGEN_MASK,\n&quot;" />
      <equation key="triggerChannels" value="=triggerChannels+&quot;CNTIN,&quot;" />

      <bitmaskOption key="ftm_exttrig_trig" condition="ftm_exttrig_inittrigen_present"
         enabledBy="enablePeripheralSupport"
         description="External Trigger Enable"
         toolTip="Bitmask enabling generation of the external trigger when the FTM\n
                  counter is equal to a channel CnV register or CNTIN"
         valueFormat="%s"
         typeName="FtmExternalTrigger"
         enumType="uint8_t"
         value="0"
         bitmask="0"
         bitList="=triggerChannels"
         enumText="=triggerEnums"
         />
      <deleteOption key="triggerEnums_" />
      <deleteOption key="triggerChannels" />

   </categoryOption>

   <categoryOption key="chanelInitialisation" description="Initialisation of Channel Outputs" >

      <binaryOption key="ftm_mode_init" condition="ftm_mode_init_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmInitialiseOutputs"
         description="Initialisation of Channel Outputs"
         toolTip="When written to 1 the channels outputs are initialized according to the state of\n
                  their corresponding bit in the OUTINIT register\n
                  This is applied after the main FTM configuration" >
         <choice name="No initialisation" value="0" enum="Unchanged"/>
         <choice name="Initialised"       value="1" enum="Initialised"/>
      </binaryOption >

      <!-- ************* OUTINIT ****************** -->
      <bitmaskOption key="ftm_outinit_choi" condition="ftm_outinit_choi_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="FtmInitialValue"
         enumType="uint8_t"
         enumText="\t   FtmInitialValue_AllLow  = 0x00,\n\t   FtmInitialValue_AllHigh = 0xFF"
         description="Channel Output Initialization Value"
         toolTip="Bitmask defining the value that is forced\n
                  into the channel output when initialization occurs."
         value="0"
         bitmask="0"
         bitList="CH(0-7)" />

   </categoryOption>

   <categoryOption key="channelPolarity" description="Output Channel Polarity" >

      <!-- ************* POL ****************** -->

      <equation key="polarityEnums"    value="" />
      <equation key="polarityChannels" value="" />
      <for keys="ch" dim="8" >
         <equation key="polarityEnums"
            condition="/FTM0/ftm_pol_pol%(ch)_present||/FTM1/ftm_pol_pol%(ch)_present||
                       /FTM2/ftm_pol_pol%(ch)_present||/FTM3/ftm_pol_pol%(ch)_present"
            value="
               =polarityEnums+
               &quot;\t   FtmPolarity_Ch%(ch)_ActiveLow   = (uint8_t(~FTM_POL_POL%(ch)(0))&lt;&lt;8)|FTM_POL_POL%(ch)(1),\n&quot;+
               &quot;\t   FtmPolarity_Ch%(ch)_ActiveHigh  = (uint8_t(~FTM_POL_POL%(ch)(1))&lt;&lt;8)|FTM_POL_POL%(ch)(0),\n&quot;"
          />
         <equation key="polarityChannels"
            condition="ftm_pol_pol%(ch)_present"
            value="=polarityChannels+&quot;CH%(ch),&quot;"
          />
      </for>

      <equation key="polarityEnums"
         value="=polarityEnums+
               &quot;\t   FtmPolarity_All_ActiveLow   = (uint8_t(~FTM_POL_POL(0x00))&lt;&lt;8)|FTM_POL_POL(0xFF),\n&quot;+
               &quot;\t   FtmPolarity_All_ActiveHigh  = (uint8_t(~FTM_POL_POL(0xFF))&lt;&lt;8)|FTM_POL_POL(0x00),\n&quot;" />

      <bitmaskOption key="ftm_pol_pol" condition="ftm_pol_pol_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="FtmPolarity"
         enumType="uint16_t"
         enumText="=polarityEnums"
         description="Channel Output Polarity"
         toolTip="Bitmask defining the active-low channel outputs (1=ActiveLow).\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1."
         value="0"
         bitmask="0"
         bitList="=polarityChannels" />

      <deleteOption key="polarityEnums" />
      <deleteOption key="polarityChannels_" />
   </categoryOption>

   <choiceOption key="ftm_channel_number"
      hidden="true"
      derived="true"
      enumType="uint8_t"
      valueFormat="%s"
      typeName="FtmChannelNum"
      description="Channel Number"
      toolTip="Select a channel" >
      <choice value="0"             name="Channel 0"      enum="0" />
      <choice value="1"             name="Channel 1"      enum="1" />
      <choice value="2"             name="Channel 2"      enum="2" />
      <choice value="3"             name="Channel 3"      enum="3" />
      <choice value="4"             name="Channel 4"      enum="4" />
      <choice value="5"             name="Channel 5"      enum="5" />
      <choice value="6"             name="Channel 6"      enum="6" />
      <choice value="7"             name="Channel 7"      enum="7" />
      <choice value="(uint8_t(-1))" name="No Channel"     enum="None" />
   </choiceOption>

   <categoryOption key="globalTimebase" description="Global timebase"
      hiddenBy="mode!=(Left,Centre)"
   >

      <binaryOption key="ftm_conf_gtbeout" condition="ftm_conf_gtbeout_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfGtbeout"
         description="Global Time Base Output"
         toolTip="Enables the global time base signal generation to other FTMs" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <binaryOption key="ftm_conf_gtbeen" condition="ftm_conf_gtbeen_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmConfGtbeen"
         description="External Global Time Base Enable"
         toolTip="Configures the FTM to use an external global time base signal that is generated by another FTM." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

   </categoryOption>

   <categoryOption key="synchronizationConfiguration" description="Synchronization Configuration"
      hiddenBy="mode!=(Left,Centre)"
   >

      <binaryOption key="ftm_synconf_hwsoc" condition="ftm_synconf_hwsoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncSwoctrl"
         description="SWOCTRL sync by hardware"
         toolTip="Controls SWOCTRL synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="SWOCTRL register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwinvc" condition="ftm_synconf_hwinvc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncInvctrl"
         description="INVCTRL sync by hardware"
         toolTip="Controls INVCTRL synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="INVCTRL register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwom" condition="ftm_synconf_hwom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncOutmask"
         description="OUTMASK sync by hardware"
         toolTip="Controls OUTMASK synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="OUTMASK register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwwrbuf" condition="ftm_synconf_hwwrbuf_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncRegs"
         description="MOD/CNTIN/CV sync by hardware"
         toolTip="Controls MOD/CNTIN/CV synchronization by hardware trigger" >
         <choice name="Unaffected"                       value="0" enum="Unaffected"/>
         <choice name="MOD/CNTIN/CV registers synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwrstcnt" condition="ftm_synconf_hwrstcnt_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmHwSyncCounter"
         description="Counter sync by hardware"
         toolTip="Controls Counter synchronization by hardware trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="Counter register synched"   value="1" enum="OnHardwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swsoc" condition="ftm_synconf_swsoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncSwoctrl"
         description="SWOCTRL sync by software"
         toolTip="Controls SWOCTRL synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="SWOCTRL register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swinvc" condition="ftm_synconf_swinvc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncInvCtrl"
         description="INVCTRL synch by software"
         toolTip="Controls INVCTRL synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="INVCTRL register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swom" condition="ftm_synconf_swom_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncOutmask"
         description="OUTMASK sync by software"
         toolTip="Controls OUTMASK synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="OUTMASK register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swwrbuf" condition="ftm_synconf_swwrbuf_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncRegs"
         description="MOD/CNTIN/CV synch by software"
         toolTip="Controls MOD/CNTIN/CV synchronization by software trigger" >
         <choice name="Unaffected"                      value="0" enum="Unaffected"/>
         <choice name="MOD/CNTIN/CV register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_swrstcnt" condition="ftm_synconf_swrstcnt_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSwSyncCounter"
         description="Counter synch by software"
         toolTip="Controls counter synchronization by software trigger" >
         <choice name="Unaffected"                 value="0" enum="Unaffected"/>
         <choice name="Counter register synched"   value="1" enum="OnSoftwareTrigger"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_syncmode" condition="ftm_synconf_syncmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmSyncPwm"
         description="Synchronization Mode"
         toolTip="Selects the PWM Synchronization mode" >
         <choice name="Legacy PWM synch"    value="0" enum="LegacyPwmSynch"   />
         <choice name="Enhanced PWM synch"  value="1" enum="EnhancedPwmSynch" />
      </binaryOption >

      <binaryOption key="ftm_synconf_swoc" condition="ftm_synconf_swoc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncSwoctrl"
         description="SWOCTRL Register Synch"
         toolTip="Controls SWOCTRL Register Synchronization with buffer" >
         <choice name="On rising edges of system clock"  value="0" enum="OnRisingClockEdge" />
         <choice name="By PWM synchronization"           value="1" enum="OnPwmSynch"        />
      </binaryOption >

      <binaryOption key="ftm_synconf_invc" condition="ftm_synconf_invc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncInvctrl"
         description="INVCTRL Register Synch"
         toolTip="Controls INVCTRL Register Synchronization with buffer" >
         <choice name="On rising edges of system clock"  value="0" enum="OnRisingClockEdge" />
         <choice name="By PWM synchronization"           value="1" enum="OnPwmSynch"        />
      </binaryOption >

      <binaryOption key="ftm_synconf_cntinc" condition="ftm_synconf_cntinc_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBufferSyncCounter"
         description="CNTIN Register Synch"
         toolTip="CNTIN Register Synchronization with buffer" >
         <choice name="Updated on rising edges of system clock"  value="0" enum="OnRisingClockEdge"/>
         <choice name="Updated by PWM synchronization"           value="1" enum="OnPwmSynch"/>
      </binaryOption >

      <binaryOption key="ftm_synconf_hwtrigmode" condition="ftm_synconf_hwtrigmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmTriggerSyncr"
         description="Hardware Trigger Mode"
         toolTip="Controls how hardware triggers are cleared" >
         <choice name="TRIGj cleared on trigger detect"  value="0" enum="OnTrigger"/>
         <choice name="TRIGj unaffected"                 value="1" enum="Unaffected"/>
      </binaryOption >
   </categoryOption>

   <!-- ************* SWOCTRL ****************** -->

   <!-- Not sensible to configure statically -->
   <for keys="Ch" dim="8" >
      <choiceOption key="ftm_swoctrl_ch%(Ch)ocv"
         condition="/FTM0/ftm_swoctrl_ch%(Ch)oc_present||/FTM1/ftm_swoctrl_ch%(Ch)oc_present||
                    /FTM2/ftm_swoctrl_ch%(Ch)oc_present||/FTM3/ftm_swoctrl_ch%(Ch)oc_present"
         hidden="true"
         valueFormat="FTM_SWOCTRL_CH%(Ch)OC(%s),FTM_SWOCTRL_CH%(Ch)OCV(%s)"
         enabledBy="enablePeripheralSupport"
         typeName="FtmForceOutput%(Ch)"
         description="Channel %(Ch) Output Control"
         toolTip="Enables and selects value to force to channel output" >
         <choice name="Output not forced"  value="0,0" enum="NotForced" />
         <choice name="Forces output 0"    value="1,0" enum="Forces0"   />
         <choice name="Forces output 1"    value="1,1" enum="Forces1"   />
      </choiceOption >
   </for>

<!-- ============================ FAULT INPUTS ============================= -->

   <categoryOption key="faultControl" description="Fault Input Control"
      hiddenBy="mode!=(Left,Centre)"
   >

      <choiceOption key="ftm_mode_faultm"
         hidden="true"
         condition="ftm_mode_faultm_present"
         enabledBy="ftm_mode_ftmen"
         typeName="FtmFaultMode"
         description="Fault Control Mode"
         toolTip="This is a write-once after reset setting" >
         <choice name="Disabled"                                    value="0" enum="Disabled"/>
         <choice name="Even channels with manual fault clearing"    value="1" enum="EvenChannelsManualFaultClearing"/>
         <choice name="All channels with manual fault clearing"     value="2" enum="AllChannelsManualFaultClearing"/>
         <choice name="All channels with automatic fault clearing"  value="3" enum="AllChannelsAutomaticFaultClearing"/>
      </choiceOption >
      <aliasOption key="ftm_mode_faultm" optional="true" locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))" />

      <binaryOption key="ftm_mode_faultie"
         hidden="true"
         condition="ftm_mode_faultie_present"
         enabledBy="ftm_mode_faultm>0"
         typeName="FtmFaultAction"
         description="Action on Fault event" >
         <choice name="No action"    value="0" enum="Ignored"/>
         <choice name="Interrupt"    value="1" enum="Interrupt"/>
      </binaryOption >

      <aliasOption key="ftm_mode_faultie" optional="true" locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))" />

      <choiceOption key="ftm_fltctrl_ffval"
         hidden="true"
         condition="ftm_fltctrl_ffval_present"
         enabledBy="ftm_mode_faultm>0"
         description="Fault Input Filter"
         typeName="FtmFaultFilter"
         toolTip="Selects the filter value for the fault inputs.." >
         <choice value="0"  name="Filter Disabled"  enum="Disabled" isDefault="true" />
         <choice value="1"  name="1 Clock cycle "   enum="1_clock"   />
         <choice value="2"  name="2 Clock cycles"   enum="2_clocks"  />
         <choice value="3"  name="3 Clock cycles"   enum="3_clocks"  />
         <choice value="4"  name="4 Clock cycles"   enum="4_clocks"  />
         <choice value="5"  name="5 Clock cycles"   enum="5_clocks"  />
         <choice value="6"  name="6 Clock cycles"   enum="6_clocks"  />
         <choice value="7"  name="7 Clock cycles"   enum="7_clocks"  />
         <choice value="8"  name="8 Clock cycles"   enum="8_clocks"  />
         <choice value="9"  name="9 Clock cycles"   enum="9_clocks"  />
         <choice value="10" name="10 Clock cycles"  enum="10_clocks" />
         <choice value="11" name="11 Clock cycles"  enum="11_clocks" />
         <choice value="12" name="12 Clock cycles"  enum="12_clocks" />
         <choice value="13" name="13 Clock cycles"  enum="13_clocks" />
         <choice value="14" name="14 Clock cycles"  enum="14_clocks" />
         <choice value="15" name="15 Clock cycles"  enum="15_clocks" />
      </choiceOption>

      <aliasOption key="ftm_fltctrl_ffval" optional="true"  locked="false"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))"
      />
      <floatOption key="ftm_fltctrl_filterdelay"
         condition="(SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||
                     SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;))"
         locked="true"
         derived="true"
         enabledBy="ftm_fltctrl_ffval!=0"
         ref="(ftm_fltctrl_ffval)/(inputClockFrequency*1.0)"
         description="Filter delay"
         units="s"
         min="0.0"
       />

      <for keys="inp" dim="8" >
         <choiceOption key="ftm_fltctrl_fault%(inp)en" condition="ftm_fltctrl_fault%(inp)en_present"
            hidden="true"
            valueFormat="FTM_FLTCTRL_FAULT%(inp)EN(%s),FTM_FLTCTRL_FFLTR%(inp)EN(%s)"
            enabledBy="ftm_mode_faultm>0"
            description="Fault Input %(inp) Enable and Filter"
            toolTip="Enables the fault input.\n
                     This field is write protected. It can be written only when MODE[WPDIS] = 1."
            typeName="FtmFault%(inp)Mode"
         >
            <choice value="0,0" name="Fault input disabled"             enum="Disabled"  />
            <choice value="1,0" name="Fault input enabled"              enum="Direct"    />
            <choice value="1,1" name="Fault input enabled with filter"  enum="Filtered"  />
         </choiceOption>

         <binaryOption key="ftm_fltpol_flt%(inp)pol" condition="ftm_fltpol_flt%(inp)pol_present"
            hidden="true"
            enabledBy="ftm_fltctrl_fault%(inp)en>0"
            description="Fault Input %(inp) Polarity"
            toolTip="Defines the polarity of the fault input.\n
                     This field is write protected. It can be written only when MODE[WPDIS] = 1."
            typeName="FtmFault%(inp)Polarity"
         >
            <choice value="0" name="Active High" enum="ActiveHigh" />
            <choice value="1" name="Active Low" enum="ActiveLow"   />
         </binaryOption>

         <if condition="SignalExists(&quot;$(_NAME)_FLT%(inp)&quot;)" >
            <title description="Fault Input %(inp)" />
            <aliasOption key="ftm_fltctrl_fault%(inp)en" optional="true" locked="false" />
            <aliasOption key="ftm_fltpol_flt%(inp)pol"   optional="true" locked="false" />
         </if>
      </for>

   </categoryOption>

   <choiceOption key="ftm_filter_chnfval" condition="ftm_filter_ch0fval_present"
      hidden="true"
      description="Channel Input Filter"
      typeName="FtmInputFilter"
      valueFormat="(%s)"
      enumType="uint8_t"
      toolTip="Selects the filter value for the channel input" >
      <choice value="0"  name="Filter Disabled"  enum="Disabled" isDefault="true" />
      <choice value="1"  name="1 Clock cycle "   enum="1_clock"   />
      <choice value="2"  name="2 Clock cycles"   enum="2_clocks"  />
      <choice value="3"  name="3 Clock cycles"   enum="3_clocks"  />
      <choice value="4"  name="4 Clock cycles"   enum="4_clocks"  />
      <choice value="5"  name="5 Clock cycles"   enum="5_clocks"  />
      <choice value="6"  name="6 Clock cycles"   enum="6_clocks"  />
      <choice value="7"  name="7 Clock cycles"   enum="7_clocks"  />
      <choice value="8"  name="8 Clock cycles"   enum="8_clocks"  />
      <choice value="9"  name="9 Clock cycles"   enum="9_clocks"  />
      <choice value="10" name="10 Clock cycles"  enum="10_clocks" />
      <choice value="11" name="11 Clock cycles"  enum="11_clocks" />
      <choice value="12" name="12 Clock cycles"  enum="12_clocks" />
      <choice value="13" name="13 Clock cycles"  enum="13_clocks" />
      <choice value="14" name="14 Clock cycles"  enum="14_clocks" />
      <choice value="15" name="15 Clock cycles"  enum="15_clocks" />
   </choiceOption>

<!--  **************** Channels **************** -->

   <categoryOption key="Channels" description="Channel Configuration"
      hiddenBy="mode==(None,Quad)"
   >
   <for keys="ch" dim="NumChannels" >

      <equation key="channelPair%(ch)" value="=&quot;%(ch) &amp; &quot;+ToString(%(ch)+1)" />

      <binaryOption key="channelPairing%(ch)"
         hiddenBy="!Exists(ftm_combine_decap0_present)||((%(ch)&amp;1)==1)"
         description="=&quot;Channel &quot;+channelPair%(ch)+&quot; Pairing&quot;"
         toolTip="This allows the paired channels for operate in Combine or Dueal edge modes"
      >
         <choice value="0" name="=&quot;Channels &quot;+channelPair%(ch)+&quot; operate independently&quot;"
            toolTip="Operation in \n
               - Input capture\n
               - Output compare\n
               - Edge or Centre aligned PWM"
         />
         <choice value="1" name="=&quot;Channels &quot;+channelPair%(ch)+&quot; are paired&quot;"
            toolTip="Operation in \n
               - Dual-edge Input capture\n
               - Output compare\n
               - Combined PWM"
         />
      </binaryOption>
   </for>

   <for keys="ch" dim="NumChannels" >

      <if condition="((%(ch)&amp;1)==0)" >
         <!-- Even channel -->
         <!-- Indicates basic operation of channel individually controlled I/C, O/C. PWM -->
         <binaryOption key="combineMode%(ch)"
            ref="Exists(ftm_combine_decap0_present)&amp;&amp;channelPairing%(ch)"
            hidden="true"
            locked="true"
            derived="true" >
            <choice value="Simple mode"   name="Simple mode" />
            <choice value="Combined mode" name="Combined mode" />
         </binaryOption>
         <title description="Channel %(ch)"                           hiddenBy="combineMode%(ch)" />
         <title description="=&quot;Channels &quot;+channelPair%(ch)" hiddenBy="!combineMode%(ch)" />
      <else />
         <!-- Odd channel -->
         <!-- Indicate basic operation of channel individually controlled I/C, O/C. PWM -->
         <binaryOption key="combineMode%(ch)"
            ref="=&quot;combineMode&quot;+ToString(%(ch)-1)"
            hidden="true"
            locked="true"
            derived="true" >
            <choice value="Simple mode"   name="Simple mode" />
            <choice value="Combined mode" name="Combined mode" />
         </binaryOption>
         <title description="Channel %(ch)"                           hiddenBy="combineMode%(ch)" />
      </if>

      <!-- All channels when not paired -->
      <choiceOption name="ftm_cnsc_mode[%(ch)]" key="ftm_cnsc_mode_independent[%(ch)]"
         hiddenBy="!enablePeripheralSupport||combineMode%(ch)"
         valueFormat="FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
         enumType="uint16_t"
         typeName="FtmChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (PWM/Input capture/Output compare)" >
         <!--              +......... MS(B:A)  -->
         <!--              |    +.... ELS(B:A) -->
         <!--              |    |              -->
         <!--              v    v              -->
          <choice value="0b00,0b00"  name="Channel Disabled"                    enum="Disabled"                 />
          <choice value="0b00,0b01"  name="Input Capture Rising-edge"           enum="InputCaptureRisingEdge"   />
          <choice value="0b00,0b10"  name="Input Capture Falling-edge"          enum="InputCaptureFallingEdge"  />
          <choice value="0b00,0b11"  name="Input Capture Either-edge"           enum="InputCaptureEitherEdge"   />
          <choice value="0b01,0b00"  name="Output Compare No action"            enum="OutputCompare"            />
          <choice value="0b01,0b01"  name="Output Compare Toggle"               enum="OutputCompareToggle"      />
          <choice value="0b01,0b10"  name="Output Compare Clear"                enum="OutputCompareClear"       />
          <choice value="0b01,0b11"  name="Output Compare Set"                  enum="OutputCompareSet"         />
          <choice value="0b10,0b10"  name="Pwm High-true Pulses (Edge/Centre)"  enum="PwmHighTruePulses"        />
          <choice value="0b10,0b01"  name="Pwm Low-true Pulses (Edge/Centre)"   enum="PwmLowTruePulses"         />
      </choiceOption>

      <!-- Even channels when paired -->
      <choiceOption name="ftm_cnsc_mode[%(ch)]" key="ftm_cnsc_mode_combined[%(ch)]" condition="((%(ch)&amp;1)==0)"
         target="decap[%(ch)];combine[%(ch)]"
         hiddenBy="!enablePeripheralSupport||!combineMode%(ch)"
         valueFormat="(FTM_COMBINE_DECAPEN0(%s)&lt;&lt;8),(FTM_COMBINE_COMBINE0(%s)&lt;&lt;8),FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
         enumType="uint16_t"
         enumGuard="defined(FTM_COMBINE_DECAPEN0)&amp;&amp;defined(FTM_COMBINE_COMBINE0)"
         typeName="FtmCombinedChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (Combined PWM or Dual-edge capture)"
         >
         <!--            +................................... DECAPEN      -->
         <!--            | +................................. COMBINE      -->
         <!--            | |   +............................. MS(B:A)      -->
         <!--            | |   |    +........................ ELS(B:A)     -->
         <!--            | |   |    |          +............. decap        -->
         <!--            | |   |    |          |       +....  combine      -->
         <!--            | |   |    |          |       |                   -->
         <!--            v v   v    v          v       v                   -->
          <choice value="0,0,0b00,0b00"  ref="false ; false "  name="Channel Pair Disabled"                      enum="Disabled"                                />
          <!-- 1-2 ................ -->
          <choice value="0,1,0b00,0b10"  ref="false ; true  "  name="Combined PWM Positive-pulse"                enum="CombinePositivePulse"                    />
          <choice value="0,1,0b00,0b01"  ref="false ; true  "  name="Combine PWM Negative-pulse"                 enum="CombineNegativePulse"                    />
          <!-- 3-8 ................ -->
          <choice value="1,0,0b00,0b01"  ref="true  ; false "  name="Dual-edge Capture One-Shot Rising-edge"     enum="DualEdgeCaptureOneShotRisingEdge"        />
          <choice value="1,0,0b01,0b01"  ref="true  ; false "  name="Dual-edge Capture Continuous Rising-edge"   enum="DualEdgeCaptureContinuousRisingEdge"     />
          <choice value="1,0,0b00,0b10"  ref="true  ; false "  name="Dual-edge Capture One-Shot Falling-edge"    enum="DualEdgeCaptureOneShotFallingEdge"       />
          <choice value="1,0,0b01,0b10"  ref="true  ; false "  name="Dual-edge Capture Continuous Falling-edge"  enum="DualEdgeCaptureContinuousFallingEdge"    />
          <choice value="1,0,0b00,0b11"  ref="true  ; false "  name="Dual-edge Capture One-Shot Either-edge"     enum="DualEdgeCaptureOneShotEitherEdge"        />
          <choice value="1,0,0b01,0b11"  ref="true  ; false "  name="Dual-edge Capture Continuous Either-edge"   enum="DualEdgeCaptureContinuousEitherEdge"     />
      </choiceOption>

      <!-- Odd channels when paired -->
      <choiceOption key="ftm_cnsc_secondEdge[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="ftm_cnsc_mode_combined[%(ch)-1]&lt;3"
         valueFormat="FTM_CnSC_ELS(%s)"
         description="Seconds channel Capture Polarity"
         typeName="FtmSecondEdge"
         disabledValue="0b00"
         toolTip="Polarity for capturing the second edge in Dual-edge capture mode (2nd event/channel)"
         >
         <!--              +...... ELS(B:A)   -->
         <!--              |                  -->
         <!--              v                  -->
          <choice value="0b00" name="Not used"             enum="Disabled"    />
          <choice value="0b01" name="Capture Rising-edge"  enum="RisingEdge"  />
          <choice value="0b10" name="Capture Falling-edge" enum="FallingEdge" />
          <choice value="0b11" name="Capture Either-edge"  enum="EitherEdge"  />
      </choiceOption>

      <!-- Odd channels when paired -->
      <choiceOption key="ftm_cnsc_secondOutput[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="ftm_cnsc_mode_combined[%(ch)-1]!=(1,2)"
         valueFormat="FTM_CnSC_ELS(%s)"
         description="Second channel Output Control"
         typeName="FtmSecondEdge"
         disabledValue="0b00"
         toolTip="Controls the functioning of the output of the second channel in a pair"
         >
         <!--              +...... ELS(B:A)   -->
         <!--              |                  -->
         <!--              v                  -->
         <choice value="0b00" name="Single output"         enum="Single"
            toolTip="The pin associated with the second channel is not controlled by the FTM"
          />
         <choice value="0b01" name="Dual outputs"          enum="Dual"
            toolTip="The output of the second channel is the same as the first channel"
         />
         <choice value="0b01" name="Complementary outputs" enum="Complementary"
            toolTip="The output of the second channel is the complement of the first channel"
         />
      </choiceOption>

      <!-- Even channel -->
      <binaryOption key="inputMode[%(ch)]" condition="((%(ch)&amp;1)==0)"
         ref="(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))||(ftm_cnsc_mode_combined[%(ch)]>=3)"
         hidden="true"
         description="Input mode"
         toolTip="One of the input modes (I/C)"
         locked="true"
         derived="true"
      >
         <choice  value="false" name="-"       />
         <choice  value="true"  name="Input"   />
      </binaryOption>

      <!-- Odd channel -->
      <binaryOption key="inputMode[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         ref="(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))||(ftm_cnsc_mode_combined[%(ch)-1]>=3)"
         hidden="true"
         description="Input mode"
         toolTip="One of the input modes (I/C)"
         locked="true"
         derived="true"
      >
         <choice  value="false" name="-"       />
         <choice  value="true"  name="Input"   />
      </binaryOption>

      <!-- Even channel -->
      <binaryOption key="outputMode[%(ch)]" condition="((%(ch)&amp;1)==0)"
         ref="(ftm_cnsc_mode_independent[%(ch)]>=5)||(ftm_cnsc_mode_combined[%(ch)]==(1,2))"
         hidden="true"
         description="Output mode"
         toolTip="One of the output modes (O/C, PWM)"
         locked="true"
         derived="true"
      >
         <choice value="false" name="-"      />
         <choice value="true"  name="Output" />
      </binaryOption>

      <!-- Odd channel -->
      <binaryOption key="outputMode[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         ref="(ftm_cnsc_mode_independent[%(ch)]>=5)||(ftm_cnsc_secondOutput[%(ch)]==(1,2))"
         hidden="true"
         description="Output mode"
         toolTip="One of the output modes (O/C, PWM)"
         locked="true"
         derived="true"
      >
         <choice  value="false" name="-"       />
         <choice  value="true"  name="Output"   />
      </binaryOption>

      <binaryOption key="combine[%(ch)]" condition="((%(ch)&amp;1)==0)"
         description="Combined PWM output mode"
         hidden="true"
         toolTip="Combines a pair of channels to generate a PWM signal "
         locked="true"
         derived="true"
      >
         <choice value="false" name="-" />
         <choice value="true"  name="Combined PWM"  />
      </binaryOption>

      <binaryOption key="decap[%(ch)]" condition="((%(ch)&amp;1)==0)"
         description="Dual capture mode"
         hidden="true"
         toolTip="Combines a pair of channels to allow capturing of a pair of consecutive events"
         locked="true"
         derived="true"
      >
         <choice value="false" name="-" />
         <choice value="true"  name="Dual Capture"  />
      </binaryOption>

      <binaryOption key="Ch%(ch)PinInUse"
         ref="outputMode[%(ch)]||inputMode[%(ch)]"
         hidden="true"
         description="Pin used by FTM"
         toolTip="This controls the pin use as output or input"
         locked="true"
         derived="true"
      >
         <choice value="false" name="-" />
         <choice value="true"  name="Pin in use"  />
      </binaryOption>

      <if condition="((%(ch)&amp;1)==0)" >
         <!-- Even channels -->

         <choiceOption key="ftm_cnsc_action[%(ch)]"
            condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
            hiddenBy="((ftm_cnsc_mode_independent[%(ch)]==0)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)]==0))"
            valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
            enumType="uint8_t"
            typeName="FtmChannelAction"
            description="Action on Channel %(ch) Event"
            toolTip="Enable interrupt or DMA on channel event" >
             <choice value="0,0" name="No action"          enum="None"  />
             <choice value="1,0" name="Interrupt Request"  enum="Interrupt"   />
             <choice value="1,1" name="DMA request"        enum="Dma"   />
         </choiceOption>

         <binaryOption key="ftm_cnsc_action[%(ch)]"
            condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
            hiddenBy="!irqHandlingMethod||((ftm_cnsc_mode_independent[%(ch)]==0)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)]==0))"
            valueFormat="FTM_CnSC_CHIE(%s)"
            enumType="uint8_t"
            typeName="FtmChannelAction"
            description="Action on Channel %(ch) Event"
            toolTip="Enable interrupt on channel event" >
             <choice value="0" name="No action"              enum="None"             />
             <choice value="1" name="Interrupt request"      enum="Interrupt"        />
         </binaryOption>

      <else />
         <!-- Odd channel -->
         <choiceOption key="ftm_cnsc_action[%(ch)]"
            condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
            hiddenBy="((ftm_cnsc_mode_independent[%(ch)]==0) &amp;&amp;(ftm_cnsc_mode_combined[%(ch)-1]==0))"
            valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
            enumType="uint8_t"
            typeName="FtmChannelAction"
            description="Action on Channel %(ch) Event"
            toolTip="Enable interrupt or DMA on channel event" >
             <choice value="0,0" name="No action"          enum="None"  />
             <choice value="1,0" name="Interrupt Request"  enum="Interrupt"   />
             <choice value="1,1" name="DMA request"        enum="Dma"   />
         </choiceOption>

         <binaryOption key="ftm_cnsc_action[%(ch)]"
            condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
            hiddenBy="!irqHandlingMethod||((ftm_cnsc_mode_independent[%(ch)]==0)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)-1]==0))"
            valueFormat="FTM_CnSC_CHIE(%s)"
            enumType="uint8_t"
            typeName="FtmChannelAction"
            description="Action on Channel %(ch) Event"
            toolTip="Enable interrupt on channel event" >
             <choice value="0" name="No action"              enum="None"             />
             <choice value="1" name="Interrupt request"      enum="Interrupt"        />
         </binaryOption>

      </if>

      <choiceOption key="ftm_filter_ch%(ch)fval" condition="ftm_filter_ch%(ch)fval_present"
         derivedFrom="ftm_filter_chnfval"
         hiddenBy="!inputMode[%(ch)]" >
      </choiceOption>

      <floatOption key="ftm_filter_ch%(ch)_delay" condition="ftm_filter_ch%(ch)fval_present"
         description="Channel Input Filter Delay"
         toolTip="Calculated delay"
         hiddenBy="!inputMode[%(ch)]"
         ref="(4.0*ftm_filter_ch%(ch)fval)/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <binaryOption key="ftm_cnsc_icrst[%(ch)]" condition="ftm_cnsc_icrst_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="FTM_CnSC_ICRST(%s)"
         typeName="FtmChannelReset"
         enumType="uint8_t"
         description="Reset counter on channel IC event"
         toolTip="Enables the channel IC event to reset the shared counter" >
         <choice value="0" name="Disabled" enum="Disabled" />
         <choice value="1" name="Enabled"  enum="Enabled"  />
      </binaryOption>

      <!-- Even channel -->
      <intOption key="ftm_cnv[%(ch)]" condition="((%(ch)&amp;1)==0)"
         hiddenBy="(ftm_cnsc_mode_independent[%(ch)]&lt;4)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)]!=(1,2))"
         valueFormat="%s_ticks"
         typeName="Ticks &amp;"
         units="ticks"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod" />

      <!-- Even channel -->
      <floatOption key="ftm_cnvEventTime[%(ch)]" condition="((%(ch)&amp;1)==0)"
         hiddenBy="(ftm_cnsc_mode_independent[%(ch)]&lt;4)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)]!=(1,2))"
         ref="ftm_cnv[%(ch)]*clockPeriod"
         valueFormat="%s_s"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value, converted to ticks, is compared against the main counter"
         value="0" min="0" max="ftm_mod*clockPeriod" />

      <!-- Odd channel -->
      <intOption key="ftm_cnv[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="(ftm_cnsc_mode_independent[%(ch)]&lt;4)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)-1]!=(1,2))"
         valueFormat="%s_ticks"
         typeName="Ticks &amp;"
         units="ticks"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod" />

      <!-- Odd channel -->
      <floatOption key="ftm_cnvEventTime[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="(ftm_cnsc_mode_independent[%(ch)]&lt;4)&amp;&amp;(ftm_cnsc_mode_combined[%(ch)-1]!=(1,2))"
         ref="ftm_cnv[%(ch)]*clockPeriod"
         valueFormat="%s_s"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value, converted to ticks, is compared against the main counter"
         value="0" min="0" max="ftm_mod*clockPeriod" />

      <floatOption key="ftm_cnvHighTime[%(ch)]"
         hiddenBy="ftm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="(ftm_sc_cpwms?2.0:1.0)*(ftm_cnv[%(ch)])*clockPeriod"
         valueFormat="%s_s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="ftm_cnvDutyCycle[%(ch)]"
         hiddenBy="ftm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="ftm_cnvHighTime[%(ch)]/ftm_modPeriod"
         valueFormat="%s_s"
         units="percent"
         description="Output duty cycle as pecentage"
         toolTip="Calculated duty cycle" />

      <floatOption key="ftm_pwmHighTime[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="ftm_cnsc_mode_combined[%(ch)-1]!=(1,2)"
         locked="true"
         derived="true"
         ref="(ftm_cnv[%(ch)]-ftm_cnv[%(ch)-1])*clockPeriod"
         valueFormat="%s_s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="ftm_pwmDutyCycle[%(ch)]" condition="((%(ch)&amp;1)!=0)"
         hiddenBy="ftm_cnsc_mode_combined[%(ch)-1]!=(1,2)"
         locked="true"
         derived="true"
         ref="ftm_pwmHighTime[%(ch)]/ftm_modPeriod"
         valueFormat="%s_s"
         units="percent"
         description="Output duty cycle as pecentage"
         toolTip="Calculated duty cycle" />







   </for>
   </categoryOption>

   <!-- ************* Quadrature decoder ****************** -->

   <categoryOption key="quadDecoder"  description="Quadrature decoder"
      hiddenBy="mode!=Quad"
   >
      <binaryOption key="ftm_qdctrl_quadmode" condition="ftm_qdctrl_quadmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmQuadratureMode"
         description="Quadrature decoding mode"
         toolTip="Determines how the inputs control the counting sequence" >
         <choice value="0" name="Phase-AB Mode"         enum="Phase_AB_Mode" />
         <choice value="1" name="Count-Direction Mode"  enum="Count_Direction_Mode"  />
      </binaryOption>

      <title name="Channel A" description="Channel A" condition="ftm_qdctrl_phapol_present" />

      <binaryOption key="ftm_qdctrl_phapol" condition="ftm_qdctrl_phapol_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPhaseAPolarity"
         description="Polarity of Phase A input"
         toolTip="Polarity of Phase A input" >
         <choice value="0" name="Active High" enum="ActiveHigh" />
         <choice value="1" name="Active Low"  enum="ActiveLow"  />
      </binaryOption>

      <choiceOption key="ftm_qdfilter_a" condition="ftm_qdctrl_phafltren_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="(FTM_QDCTRL_PHAFLTREN(%s)&lt;&lt;8),FTM_FILTER_CH0FVAL(%s)"
         enumType="uint16_t"
         typeName="FtmPhaseAFilter"
         description="Filtering on Phase A input"
         toolTip="Filtering on Phase A input" >
         <choice value="0,0"  name="No Filter"      enum="Disabled" />
         <choice value="1,1"  name="1 clock cycle"  enum="1_Clock"  />
         <choice value="1,2"  name="2 clock cycle"  enum="2_Clock"  />
         <choice value="1,3"  name="3 clock cycle"  enum="3_Clock"  />
         <choice value="1,4"  name="4 clock cycle"  enum="4_Clock"  />
         <choice value="1,5"  name="5 clock cycle"  enum="5_Clock"  />
         <choice value="1,6"  name="6 clock cycle"  enum="6_Clock"  />
         <choice value="1,7"  name="7 clock cycle"  enum="7_Clock"  />
         <choice value="1,8"  name="8 clock cycle"  enum="8_Clock"  />
         <choice value="1,9"  name="9 clock cycle"  enum="9_Clock"  />
         <choice value="1,10" name="10 clock cycle" enum="10_Clock" />
         <choice value="1,11" name="11 clock cycle" enum="11_Clock" />
         <choice value="1,12" name="12 clock cycle" enum="12_Clock" />
         <choice value="1,13" name="13 clock cycle" enum="13_Clock" />
         <choice value="1,14" name="14 clock cycle" enum="14_Clock" />
         <choice value="1,15" name="15 clock cycle" enum="15_Clock" />
      </choiceOption>

      <title name="Channel B" description="Channel B" condition="ftm_qdctrl_phbpol_present" />

      <binaryOption key="ftm_qdctrl_phbpol" condition="ftm_qdctrl_phbpol_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmPhaseBPolarity"
         description="Polarity of Phase B input"
         toolTip="Polarity of Phase B input" >
         <choice value="0" name="Active High" enum="ActiveHigh" />
         <choice value="1" name="Active Low"  enum="ActiveLow"  />
      </binaryOption>

      <choiceOption key="ftm_qdfilter_b" condition="ftm_qdctrl_phbfltren_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="(FTM_QDCTRL_PHBFLTREN(%s)&lt;&lt;8),FTM_FILTER_CH1FVAL(%s)"
         enumType="uint16_t"
         typeName="FtmPhaseBFilter"
         description="Filtering on Phase B input"
         toolTip="Filtering on Phase B input" >
         <choice value="0,0"  name="No Filter"      enum="Disabled" />
         <choice value="1,1"  name="1 clock cycle"  enum="1_Clock"  />
         <choice value="1,2"  name="2 clock cycle"  enum="2_Clock"  />
         <choice value="1,3"  name="3 clock cycle"  enum="3_Clock"  />
         <choice value="1,4"  name="4 clock cycle"  enum="4_Clock"  />
         <choice value="1,5"  name="5 clock cycle"  enum="5_Clock"  />
         <choice value="1,6"  name="6 clock cycle"  enum="6_Clock"  />
         <choice value="1,7"  name="7 clock cycle"  enum="7_Clock"  />
         <choice value="1,8"  name="8 clock cycle"  enum="8_Clock"  />
         <choice value="1,9"  name="9 clock cycle"  enum="9_Clock"  />
         <choice value="1,10" name="10 clock cycle" enum="10_Clock" />
         <choice value="1,11" name="11 clock cycle" enum="11_Clock" />
         <choice value="1,12" name="12 clock cycle" enum="12_Clock" />
         <choice value="1,13" name="13 clock cycle" enum="13_Clock" />
         <choice value="1,14" name="14 clock cycle" enum="14_Clock" />
         <choice value="1,15" name="15 clock cycle" enum="15_Clock" />
      </choiceOption>

   </categoryOption>

<!-- Info class members-->

   <initialValueTemplate variables="minimumResolution"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumResolution  = $(?check_minimums:$(minimumResolution):0);\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate variables="minimumInterval"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t minimumInterval  = $(?check_minimums:$(minimumInterval):0);\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate variables="ftmExternalClock"
   ><![CDATA[
      \t// %description
      \tstatic constexpr uint32_t ftmExternalClock  = $(ftmExternalClock);\n\n
   ]]></initialValueTemplate>

   <setTemplate key="/$(_BASENAME)/static_functions" namespace="all"
      discardRepeats="true"
      variables="ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Enables clock to peripheral and configures all pins.
      \t * Configures main operating settings for timer.
      \t *
      %paramDescription
      \t */
      \tstatic void configure(
      %params) {
      \t
      \t   // Enable clock to peripheral
      \t   enable();
      \t
      \t   // Disable timer to change settings
      \t   %register=0;
      \t
      \t   // Make sure write has completed (disabled)
      \t   (void)(%register);
      \t
      \t   // Write new value
      \t   ftm->SC = %paramExpression;
      \t}\n\n
   ]]></setTemplate>

<!--  ========== Static/Non-Static Methods =============================== -->
   <for  keys  ="  k                   : static    : const    : getInputClockFrequency         : channel : Ftm       : isStatic : namespace"
         values=" non_static_functions : ''        : ' const' : getInputClockFrequencyVirtual  : CHANNEL : FtmBase   : false    : all;
                  static_functions     : 'static ' : ''       : 'Info::getInputClockFrequency' : channel : OwningFtm : true     : forceInfo
   " >
      <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
         discardRepeats="true"
         variables="ftm_sc_clks,ftm_sc_ps"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask0);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t *
         %paramDescription
         \t */
         \t%(static)void selectClock(
         %params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         \t
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         \t
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         \t
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></setTemplate>

      <for keys="  f            :  n"
         values=" ftm_sc_cpwms  : Mode;
                  ftm_sc_clks   : ClockSource;
                  ftm_sc_ps     : Prescaler" >
         <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);

            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;

            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);

            \t   // Write new value
            \t   %register = %registerName;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)(%register&~%mask);
            \t}\n\n
         ]]></setTemplate>
      </for>

      <for keys="  f           :  n"
         values=" ftm_mod      : CounterMaximumValue" >
         <setTemplate key="/$(_BASENAME)/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t * This value is write-buffered and updated by CNTIN synchronisation
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Write new value
            \t   %register = %paramExpression;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)%register;
            \t}\n\n
         ]]></setTemplate>
      </for>

      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Calculate FTM timing parameters to achieve a given period
         \t *
         \t * @param[in]    period  Period in seconds
         \t * @param[inout] sc      Proposed FTM.SC value (must include CLKS, CPWMS fields)
         \t *                       PS field is updated
         \t * @param[out]   mod     Calculated FTM.MOD values
         \t *
         \t * @return E_NO_ERROR   Success!!
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
         \t * @return E_TOO_LARGE  Requested period is too large
         \t */
         \t%(static)ErrorCode calculateTimingParameters(Seconds period, uint8_t &sc, uint16_t &mod)%(const) {
         \t
         \t   float inputClock = %(getInputClockFrequency)((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
         \t   unsigned prescaleFactor=1;
         \t   unsigned prescalerValue=0;
         \t
         \t   // Check if CPWMS is set (affects period calculation)
         \t   bool centreAligned = (sc&FTM_SC_CPWMS_MASK);
         \t
         \t   constexpr uint32_t maxModValue = FTM_MOD_MOD_MASK;
         \t
         \t   while (prescalerValue<=7) {
         \t      float clock    = inputClock/prescaleFactor;
         \t      float modValueF = period*clock;
         \t      if (centreAligned) {
         \t         // PeriodInTicks = 2*MOD
         \t         modValueF = modValueF/2;
         \t      }
         \t      else {
         \t         // PeriodInTicks = MOD+1
         \t         modValueF = modValueF - 1;
         \t      }
         \t      unsigned modValue = round(modValueF);\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t      if constexpr (Info::minimumResolution>0) {
         \t         if (modValue < Info::minimumResolution) {
         \t            usbdm_assert(false, "Interval is too short");
         \t            // Too short a period for minimum resolution
         \t            return setErrorCode(E_TOO_SMALL);
         \t         }
         \t      }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t      if (modValue <= maxModValue) {
         \t         sc   = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
         \t         mod  = modValue;
         \t         return E_NO_ERROR;
         \t      }
         \t      prescalerValue++;
         \t      prescaleFactor <<= 1;
         \t   }
         \t   // Too long a period
         \t   usbdm_assert(false, "Interval is too long");
         \t   return setErrorCode(E_TOO_LARGE);
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Set period
         \t *
         \t * @param[in] period   Period in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note The counter load value (CNTIN) is cleared
         \t * @note The counter modulo value (MOD) is modified to obtain the requested period
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setPeriod(Seconds period)%(const) {
         \t
         \t   uint16_t modValue = 0;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   ErrorCode rc = calculateTimingParameters(period, sc, modValue);
         \t
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC = 0;
         \t
         \t   // Configure for modulo operation
         \t   ftm->MOD   = modValue;
         \t
         \t   // Clear counter
         \t   ftm->CNT   = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Set maximum interval for input-capture or output compare.
         \t * Input Capture and Output Compare will be able to operate over
         \t * at least this period without overflow.
         \t *
         \t * @param[in] interval Interval in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note FTM counter is configured for free-running mode i.e. 0-65535
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setMaximumInterval(Seconds interval)%(const) {
         \t
         \t   uint16_t       modValue;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   ErrorCode rc = calculateTimingParameters(interval, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC = 0;
         \t
         \t   // Configure for free-running mode
         \t   // This is the usual value for IC or OC set-up
         \t   ftm->MOD   = 0_ticks;
         \t
         \t   // Clear counter
         \t   ftm->CNT   = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Get frequency of timer tick
         \t *
         \t * @return Timer frequency in Hz
         \t */
         \t%(static)float getTickFrequencyAsFloat()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   float prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}
         \t
         \t/**
         \t * Get clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz (may underflow)
         \t */
         \t%(static)uint32_t getTickFrequencyAsInt()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   int prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Convert time in microseconds to time in ticks
         \t *
         \t * @param[in] time Time in microseconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t * @note Will set error code if calculated value is less the Timer minimum resolution
         \t */
         \t%(static)Ticks convertMicrosecondsToTicks(int time)%(const) {
         \t
         \t   // Calculate period
         \t   uint32_t tickRate = getTickFrequencyAsInt();
         \t   uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if constexpr (Info::minimumInterval>0) {
         \t      if (rv < Info::minimumInterval) {
         \t         // Attempt to set too short a period
         \t         setErrorCode(E_TOO_SMALL);
         \t      }
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Converts time in seconds to time in ticks
         \t *
         \t * @param[in] seconds Time interval in seconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
         \t * @note Will set error code if calculated value is less the minimum resolution
         \t */
         \t%(static)Ticks convertSecondsToTicks(Seconds seconds)%(const) {
         \t
         \t   // Calculate period
         \t   float    tickRate = getTickFrequencyAsFloat();
         \t   uint64_t rv       = rintf((float)seconds*tickRate);
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if (rv < Info::minimumInterval) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in microseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in microseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMicroseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in milliseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in milliseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMilliseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in seconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in seconds
         \t */
         \t%(static)Seconds convertTicksToSeconds(Ticks timeInTicks)%(const) {
         \t   return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
         \t}
         \t/**
         \t * Get Timer count
         \t *
         \t * @return Timer count value
         \t */
         \t%(static)uint16_t getTime()%(const) {
         \t   return ftm->CNT;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Reset counter to initial value
         \t */
         \t%(static)void resetTime()%(const) {
         \t   // Note: writing ANY value loads CNT from CNTIN
         \t   ftm->CNT = 0;
         \t}
         \t
         \t/**
         \t * Get timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t */
         \t%(static)unsigned getInterruptFlags()%(const) {
         \t   return ftm->STATUS;
         \t}
         \t
         \t/**
         \t * Clear selected timer event flags
         \t *
         \t * @param channelMask Mask indicating which channel flags to clear
         \t *                    There is one bit for each channel
         \t *
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)void clearSelectedInterruptFlags(uint32_t channelMask)%(const) {
         \t   (void)ftm->STATUS;
         \t   ftm->STATUS = ~channelMask;
         \t}
         \t
         \t/**
         \t * Clear timer overflow event flag
         \t */
         \t%(static)void clearOverflowInterruptFlag()%(const) {
         \t   // Clear TOI flag (w0c)
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
         \t}
         \t
         \t/**
         \t * Get and clear timer event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t *
         \t * @note Only flags captured in the return value are cleared
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)unsigned getAndClearInterruptFlags()%(const) {
         \t   // Note requires read and write zero to clear flags
         \t   // so only flags captured in status are cleared
         \t   unsigned status = ftm->STATUS;
         \t   ftm->STATUS = ~status;
         \t   return status;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" discardRepeats="true" condition="ftm_exttrig_inittrigen_present" ><![CDATA[
         \t/**
         \t * Enables/disable external trigger generation by a channel comparison or initialisation event
         \t *
         \t * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
         \t * @param[in] enable             Whether to enable/disable the specified trigger
         \t */
         \t%(static)void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true)%(const) {
         \t   if (enable) {
         \t      ftm->EXTTRIG = ftm->EXTTRIG | ftmExternalTrigger;
         \t   }
         \t   else {
         \t      ftm->EXTTRIG = ftm->EXTTRIG & ~ftmExternalTrigger;
         \t   }
         \t}
         \t
         \t/**
         \t * Enables multiple external trigger generation on a channel comparison or initialisation event
         \t *
         \t * @param[in] externalTriggers Indicates the events to cause the external trigger. \n
         \t *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
         \t * @param[in] enable           Whether to enable/disable the specified triggers
         \t */
         \t%(static)void enableExternalTriggers(int externalTriggers, bool enable=true)%(const) {
         \t   enableExternalTrigger(FtmExternalTrigger(externalTriggers), enable);
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Enable/disable Timer Overflow interrupts
         \t */
         \t%(static)void enableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC | FTM_SC_TOIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable Timer Overflow interrupts
         \t */
         \t%(static)void disableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOIE_MASK;
         \t}
         \t\n
      ]]></template>

      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" discardRepeats="true" condition="ftm_mode_faultie_present" ><![CDATA[
         \t/**
         \t * Enable fault interrupts
         \t */
         \t%(static)void enableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE | FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable fault interrupts
         \t */
         \t%(static)void disableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE & ~FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t *  Disables fault detection input
         \t *
         \t *  @tparam inputNum        Number of fault input to enable (0..3)
         \t */
         \ttemplate<int inputNum>
         \t%(static)void disableFault()%(const) {
         \t   static_assert(inputNum<=4, "Illegal fault channel");
         \t
         \t   // Enable fault on channel
         \t   ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<inputNum);
         \t}
         \t
         \t/**
         \t *  Enables fault detection input
         \t *
         \t *  @tparam inputNum           Number of fault input to enable (0..3)
         \t *
         \t *  @param[in]  polarity       Polarity of fault input
         \t *  @param[in]  filterEnable   Whether to enable filtering on the fault input
         \t *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
         \t *
         \t *  NOTE - the filter delay is shared by all inputs
         \t */
         public:
         \ttemplate<uint8_t inputNum>
         \t%(static)void enableFault(
         \t      Polarity polarity     = ActiveHigh,
         \t      bool     filterEnable = false,
         \t      uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1))%(const) {
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" condition="/PCR/_present&amp;&amp;ftm_mode_faultie_present" codeGenCondition="%(isStatic)" ><![CDATA[
         #ifdef DEBUG_BUILD
         \t   static_assert((inputNum<Info::InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex != pinIndex::UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex != pinIndex::INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
         \t   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].pinIndex == pinIndex::UNMAPPED_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit == INVALID_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit >= 0), "Pcr_T: Illegal signal used for fault");
         #endif
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" condition="/PCR/_present&amp;&amp;ftm_mode_faultie_present" ><![CDATA[
         \t   PcrTable_T<typename Info::InfoFAULT, inputNum>::setPCR();
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" discardRepeats="true" condition="ftm_mode_faultie_present" ><![CDATA[
         \t   if (polarity) {
         \t      // Set active high
         \t      ftm->FLTPOL = ftm->FLTPOL & ~(1<<inputNum);
         \t   }
         \t   else {
         \t      // Set active low
         \t      ftm->FLTPOL = ftm->FLTPOL | (1<<inputNum);
         \t   }
         \t   if (filterEnable) {
         \t      // Enable filter & set filter delay
         \t      ftm->FLTCTRL = ((ftm->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
         \t   }
         \t   else {
         \t      // Disable filter
         \t      ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
         \t   }
         \t   // Enable fault input
         \t   ftm->FLTCTRL = ftm->FLTCTRL | (1<<inputNum);
         \t   // Enable fault mode (All channels, manual)
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_FAULTM(2);
         \t}\n\n
      ]]></template>

      <template key="/$(_BASENAME)/%(k)" namespace="%(namespace)" discardRepeats="true"
         variables="ftm_pol_pol" ><![CDATA[
         \t/**
         \t * Set polarity of all channels
         \t *
         \t * @param channelMask   Bit mask 0 => active-high, 1 => active-low
         \t */
         \t%(static) void setPolarity(uint32_t channelMask)%(const) {
         \t   ftm->POL = channelMask;
         \t}
         \t
         \t/**
         \t * Set polarity of selected channel
         \t *
         \t * @param ftmPolarity  Channel polarity to set
         \t */
         \t%(static)void setPolarity(FtmPolarity ftmPolarity)%(const) {
         \t      uint8_t temp = ftm->POL;
         \t      temp |= ftmPolarity;
         \t      temp &= ftmPolarity>>8;
         \t      ftm->POL = temp;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
         \t/*
         \t * *****************************************************************
         \t *          Channel functions
         \t * *****************************************************************
         \t */
         \t/**
         \t * Set PWM duty cycle.
         \t * Higher precision float version
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage (float)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(float dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*ftm->MOD)/100.0f);
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*(ftm->MOD+1))/100.0f);
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM duty cycle
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(int dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*ftm->MOD)/100;
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*(ftm->MOD+1))/100;
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM high time in ticks
         \t * Assumes value is less than period
         \t *
         \t * @param[in] highTime   PWM high time in ticks
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t * @return E_TOO_LARGE on success
         \t *
         \t * @note The actual CnV register update may be delayed by the register synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Ticks highTime, int channel)%(const) {
         \t
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      // In CPWM the pulse width is doubled
         \t      highTime = Ticks((highTime+1_ticks)/2U);
         \t   }
         #ifdef DEBUG_BUILD
         \t   if ((unsigned)highTime > ftm->MOD) {
         \t      return setErrorCode(E_TOO_LARGE);
         \t   }
         #endif
         \t   ftm->CONTROLS[channel].CnV  = (unsigned)highTime;
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Get Timer event time
         \t *
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return Absolute time of last event in ticks i.e. value from timer event register
         \t */
         \t%(static)Ticks getEventTime(int channel)%(const) {
         \t   return Ticks(ftm->CONTROLS[channel].CnV);
         \t}
         \t
         \t/**
         \t * Set Timer event time
         \t *
         \t * This value is write-buffered and updated by Cnv synchronisation.
         \t *
         \t * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
         \t * @param[in] channel    Timer channel
         \t */
         \t%(static)void setEventTime(Ticks eventTime, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = (unsigned)eventTime;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current event time
         \t *
         \t * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setDeltaEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CONTROLS[channel].CnV + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current timer count value
         \t *
         \t * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setRelativeEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CNT + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set PWM high time in seconds
         \t *
         \t * @param[in] highTime   PWM high time in seconds
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t *
         \t * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Seconds highTime, int channel)%(const) {
         \t   return setHighTime(convertSecondsToTicks(highTime), channel);
         \t}
         \t
         \t/**
         \t * Set initial state for channels outputs
         \t *
         \t * @param initialValue  Bit mask value for channels
         \t */
         \t%(static)void setOutputInitialValue(uint32_t initialValue)%(const) {
         \t   ftm->OUTINIT = initialValue;
         \t}
         \t
         \t/**
         \t * Set output mask for channels outputs
         \t *
         \t * The mask of a channel determines if its output responds, that is,
         \t * it is masked or not, when a match occurs
         \t * This value is write-buffered and updated by PWM synchronisation.
         \t *
         \t * @param maskValue  Bit mask value 0 => not masked, 1 => masked
         \t */
         \t%(static)void setOutputMaskValue(uint32_t maskValue)%(const) {
         \t   ftm->OUTMASK = maskValue;
         \t}
         \t
         \t/**
         \t * Set inverting control
         \t *
         \t * This controls when the channel (n) and (n+1) outputs are exchanged.
         \t * Each bit enables the inverting operation for the corresponding channels pair.
         \t * This value is write-buffered and updated by INVCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
         \t */
         \t%(static)void setInvertedChannelPairs(uint32_t enableMask)%(const) {
         \t   ftm->INVCTRL = enableMask;
         \t}
         \t
         \t/**
         \t * Force channel outputs
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
         \t * @param outputMask  Bit mask for values to be forced to selected channels
         \t */
         \t%(static)void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask)%(const) {
         \t   ftm->SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
         \t}
         \t
         \t/**
         \t * Force channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be forced
         \t * @param value    Value to be forced on that channel
         \t */
         \t%(static)void forceChannelOutput(uint32_t channel, bool value)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOCV_SHIFT  = 8;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t   uint32_t valueMask   = 1<<(channel+FTM_SWOCTRL_CHxOCV_SHIFT);
         \t
         \t   // Set control bit + insert control value
         \t   ftm->SWOCTRL = (ftm->SWOCTRL&~valueMask) | (channelMask | (value?valueMask:0));
         \t}
         \t
         \t/**
         \t * Release forced channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be released
         \t */
         \t%(static)void releaseChannelOutput(uint32_t channel)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t
         \t   // Release control bit
         \t   ftm->SWOCTRL = ftm->SWOCTRL & ~channelMask;
         \t}
         \t
         \t/**
         \t * Set current value of channel outputs.\n
         \t * This value is overwritten by the next channel action.
         \t *
         \t * @param channelValueMask Mask indicating desired channel outputs
         \t */
         \t%(static)void setChanelOutputs(uint32_t channelValueMask)%(const) {
         \t   ftm->OUTINIT = channelValueMask;
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_INIT_MASK;
         \t}\n
      ]]></template>

<!-- ================== Channel Functions ================== -->

   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true"
      variables="ftm_cnsc_action[]"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void setAction(%params)%(const) {
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t           (ftm->CONTROLS[%(channel)].CnSC & ~%mask) | %paramExpression;
      \t   }\n\n
   ]]></template>

   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true" ><![CDATA[
      \t   /**
      \t    * Configure channel.
      \t    * No affect on shared settings of owning Timer
      \t    *
      \t    * @param[in] ftmChannelMode    Mode of operation for channel
      \t    * @param[in] ftmChannelAction  Whether to enable the interrupt or DMA function on this channel
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void configure(
      \t         FtmChannelMode    ftmChannelMode,
      \t         FtmChannelAction  ftmChannelAction = FtmChannelAction_None)%(const) {
      \t
      \t      ftm->CONTROLS[%(channel)].CnSC = ftmChannelMode|ftmChannelAction;
      \t   }
      \t
      \t   /**
      \t    * Disables timer channel (sets mode to FtmChannelMode_Disabled)
      \t    */
      \t   %(static) void disable()%(const) {
      \t      setMode(FtmChannelMode_Disabled);
      \t   }
      \t
      \t   /**
      \t    * Get channel mode.
      \t    *
      \t    * @return Current mode of operation for the channel
      \t    */
      \t   %(static) FtmChannelMode getMode()%(const) {
      \t      return static_cast<FtmChannelMode>(ftm->CONTROLS[%(channel)].CnSC &
      \t            (FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK));
      \t   }
      \t
      \t   /**
      \t    * Set channel mode
      \t    *
      \t    * @param[in] ftmChannelMode      Mode of operation for channel
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static) void setMode(FtmChannelMode ftmChannelMode)%(const) {
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t            (ftm->CONTROLS[%(channel)].CnSC & ~(FTM_CnSC_MS_MASK|FTM_CnSC_ELS_MASK))|ftmChannelMode;
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in ticks.
      \t    * Assumes value is less than period
      \t    *
      \t    * @param[in] highTime   PWM high time in ticks
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Ticks highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in seconds.
      \t    * Higher precision float version
      \t    *
      \t    * @param[in] highTime   PWM high time in seconds
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Seconds highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t   /**
      \t    * Set PWM duty cycle.
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDutyCycle(int dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDutyCycle(float dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setDeltaEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setDeltaEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time relative to current timer count value.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setRelativeEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setRelativeEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Absolute Timer event time.
      \t    *
      \t    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
      \t    *
      \t    * @note The actual CnV register update will be delayed by the register synchronisation mechanism
      \t    */
      \t   %(static) void setEventTime(Ticks eventTime)%(const) {
      \t      %(Ftm)::setEventTime(eventTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Absolute Timer event time.
      \t    *
      \t    * @return Absolute time of last event in ticks i.e. value from timer event register
      \t    */
      \t   %(static) Ticks getEventTime()%(const) {
      \t      return %(Ftm)::getEventTime(%(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Timer interrupt/event flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    */
      \t   %(static) bool getInterruptFlag()%(const) {
      \t      return (ftm->STATUS&CHANNEL_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Get and Clear Timer channel interrupt flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    *
      \t    * @note Only flags captured in the return value are cleared
      \t    */
      \t   %(static) bool getAndClearInterruptFlag()%(const) {
      \t      // Note - requires read and write zero to clear flags
      \t      // so only flags captured in status are cleared
      \t      bool status = (ftm->STATUS&CHANNEL_MASK) != 0;
      \t      ftm->STATUS = ~CHANNEL_MASK;
      \t      return status;
      \t   }
      \t
      \t   /**
      \t    * Clear interrupt flag on channel.
      \t    */
      \t   %(static) void clearInterruptFlag()%(const) {
      \t      // Note - requires read and write zero to clear flag
      \t      ftm->CONTROLS[CHANNEL].CnSC = ftm->CONTROLS[CHANNEL].CnSC & ~FTM_CnSC_CHF_MASK;
      \t   }
      \t
      \t   /**
      \t    * Force channel output.
      \t    *
      \t    * This enables software control of channel output and
      \t    * defines the value forced to the channel output.
      \t    * This value is write-buffered and updated by SWOCTRL synchronisation.
      \t    *
      \t    * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
      \t    */
      \t   %(static) void forceChannelOutput(FtmChannelForce ftmChannelForce)%(const) {
      \t      static const uint32_t MASK = ((1<<%(channel))|(1<<(%(channel)+8)));
      \t      ftm->SWOCTRL = ((ftm->SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      \t   }\n\n
   ]]></template>
   <template key="/$(_BASENAME)_CHANNEL/%(k)" namespace="all" discardRepeats="true"
      variables="ftm_pol_pol0" ><![CDATA[
      \t   /**
      \t    * Set polarity of channels.
      \t    *
      \t    * @param polarity Polarity to set
      \t    */
      \t   %(static) void setPolarity(Polarity polarity)%(const) {
      \t      if (polarity == ActiveHigh) {
      \t         ftm->POL = ftm->POL & ~CHANNEL_MASK;
      \t      }
      \t      else {
      \t         ftm->POL = ftm->POL | CHANNEL_MASK;
      \t      }
      \t   }\n\n
      ]]></template>
   </for>

   <clockCodeTemplate variable="ftm_sc_clks"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      %paramDescription
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!-- ========== CommonInfo class =============================== -->

   <template namespace="usbdm" condition="$(_instance)==0" ><![CDATA[
      class $(_Baseclass)CommonInfo {
      \t
      public:
      \t\n
   ]]></template>

   <template namespace="usbdm" codeGenCondition="/$(_BASENAME)/irqHandlingMethod" condition="$(_instance)==0" >
   ><![CDATA[
      \t/**
      \t * Type definition for overflow and fault call-back.
      \t */
      \ttypedef void (*CallbackFunction)();
      \t
      \t/**
      \t * Callback to catch unhandled overflow and fault call-back.
      \t */
      \tstatic void unhandledCallback() {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t
      \t/**
      \t * Type definition for channel event call-back
      \t *
      \t * @param mask Mask identifying channel
      \t */
      \ttypedef void (*ChannelCallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled channel event call-back
      \t *
      \t * @param mask Mask identifying channel
      \t */
      \tstatic void unhandledChannelCallback(uint8_t mask) {
      \t   (void)mask;
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}\n\n
   ]]></template>

   <template namespace="usbdm" condition="$(_instance)==0" ><![CDATA[
      }; // FtmCommonInfo
      \t\n
   ]]></template>

<!-- ========== BasicInfo class =============================== -->
   <template namespace="usbdm" ><![CDATA[
      class $(_Class)BasicInfo : public FtmCommonInfo {
      \t
      public:
      \t\n
   ]]></template>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></initialValueTemplate>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for Channel Fault and timer overflow */
      \tstatic CallbackFunction sCallback;
      \t
      \t/**
      \t * Overflow IRQ handler (if individually available)
      \t */
      \tstatic void overflowIrqHandler() {
      \t   // Clear TOI flag
      \t   ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
      \t   sCallback();
      \t}
      \t\n
   ]]></template>

   <template codeGenCondition="irqHandlingMethod" condition="ftm_fms_faultf_present" >
   <![CDATA[
      \t/**
      \t * Fault IRQ handler (if individually available)
      \t */
      \tstatic void faultIrqHandler() {
      \t   ftm->FMS = ftm->FMS & ~FTM_FMS_FAULTF_MASK;
      \t   sCallback();
      \t}
      \t\n
   ]]></template>

   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for Channel Fault and timer overflow */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallback = $(_Class)Info::unhandledCallback;
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Callback table for programmatically set channel call-backs
      \t */
      \tstatic ChannelCallbackFunction channelCallbacks[irqCount];
      \t
      \t/**
      \t * Common IRQ handler
      \t */
      \tstatic void irqHandler() {
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="ftm_fms_faultf_present" >
   <![CDATA[
      \t   if ((ftm->MODE&FTM_MODE_FAULTIE_MASK) && (ftm->FMS&FTM_FMS_FAULTF_MASK)) {
      \t      ftm->FMS = ftm->FMS & ~FTM_FMS_FAULTF_MASK;
      \t      sCallback();
      \t      return;
      \t   }\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="!ftm_status_ch0f_present" >
   <![CDATA[
      \t   if ((ftm->SC&(FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) == (FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) {
      \t      // Clear TOI flag
      \t      ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
      \t      sCallback();
      \t      return;
      \t   }
      \t   // Call shared handler (0 param indicates polling required as no shared status register)
      \t   channelCallbacks[0](0);
      \t
      \t   // Get status from channels
      \t   //uint32_t status = 0;
      \t   //uint32_t mask   = 0b01;
      \t   //for (unsigned channel=0; channel<NumChannels; channel++) {
      \t   //   if ((ftm->CONTROLS[channel].CnSC&FTM_CnSC_CHF_MASK)!=0) {
      \t   //      status |= mask;
      \t   //      // Clear channel flag (w0c register if read first)
      \t   //      ftm->CONTROLS[channel].CnSC = ftm->CONTROLS[channel].CnSC & ~FTM_CnSC_CHF_MASK;
      \t   //   }
      \t   //   mask <<= 1;
      \t   //}
      \t   //if (status) {
      \t   //   // Call shared handler
      \t   //   channelCallbacks[0](0);
      \t   //}
      \t}
      \t\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" condition="ftm_status_ch0f_present" >
   <![CDATA[
      \t   if ((ftm->SC&(FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) == (FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) {
      \t      // Clear TOI flag
      \t      ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
      \t      sCallback();
      \t      return;
      \t   }
      \t   // Get status for channels
      \t   uint32_t status = ftm->STATUS;
      \t   if (status) {
      \t      // Call shared handler
      \t      channelCallbacks[0](status);
      \t      // Clear flags for channel events being handled (w0c register if read first)
      \t      ftm->STATUS = ~status;
      \t   }
      \t}
      \t\n
   ]]></template>

   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Callback table for programmatically set handlers for $(_Class)
      \t */
      \t$(_Class)Info::ChannelCallbackFunction $(_Class)Info::channelCallbacks[] = {\n\n
   ]]></template>
   <for keys="ch" dim="NumChannelVectors" >
      <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
         \t   $(_Class)Info::unhandledChannelCallback,\n
      ]]></template>
   </for>
   <template namespace="all" key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t};\n\n
   ]]></template>

<!--  ========== Init class =============================== -->

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * //
      \t * // $(_NAME) call-back
      \t * //
      \t * // @param status  Status reflecting active inputs
      \t * //
      \t * void $(_name)Callback() {
      \t *    ...
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_Class)Init {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmMode_Freerunning,           // Alignment and whether interval or free-running mode
      \t *    FtmOverflowInterrupt_Disabled, // Overflow Interrupt
      \t *    NvicPriority_Normal,           // IRQ level for this peripheral
      \t *    FtmClockSource_SystemClock,    // Clock Source
      \t *
      \t *    // Either
      \t *    FtmPrescale_DivBy16,           // Clock prescaler
      \t *    3000_ticks,                    // Counter modulo (mod) value
      \t *    // OR
      \t *    100_ms,                        // Timer period or minimum interval in seconds
      \t *
      \t *    FtmInitialValue(0xf),          // Channel Output Initialization Value
      \t *    FtmPolarity_Ch0_ActiveLow,     // Channel polarity - Make channel 0 active-low
      \t *    FtmPolarity_Ch3_ActiveLow,     // Channel polarity - Make channel 3 active-low
      \t *
      \t *    $(_name)Callback,              // Call-back to execute on event - call-back function name
      \t *    NvicPriority_Low,              // Priority for interrupt - Low
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_Class)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!--   Init class Member variables -->

   <initialValueTemplate namespace="usbdm" variables="irqHandlingMethod" codeGenCondition="irqHandlingMethod"
    ><![CDATA[
      \t   // Shared overflow or fault interrupt call-back
      \t   %params = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   // Shared channel interrupt call-back
      \t   ChannelCallbackFunction channelCallbackFunction = nullptr;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_sc_action,ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps"
   ><![CDATA[
      \t   // Status And Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_mod"
   ><![CDATA[
      \t   // %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables= "ftm_modPeriod"
    ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = 0_s;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_mode_pwmsync,ftm_mode_wpdis,ftm_mode_ftmen"
   ><![CDATA[
      \t   // Mode register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables= "ftm_deadtime_dtps,ftm_deadtime_dtval"
    ><![CDATA[
      \t   // %description0 and %description1
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables= "ftm_outinit_choi"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables= "ftm_pol_pol"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables= "ftm_exttrig_trig"
    ><![CDATA[
      \t   // %description
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate >

<!--  Init class Constructors -->

   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for shared channel interrupt call-back
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param callback Shared channel interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(ChannelCallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->channelCallbackFunction = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for overflow and fault interrupt call-back
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param callback Overflow and fault interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(CallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->callbackFunction = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t   %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_pol_pol"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      // Mark channels as active-low
      \t      %registerName |= %paramExpression;
      \t      %registerName &= ~(%paramExpression>>8);
      \t   }
      \t\n
   ]]></constructorTemplate>

   <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_outinit_choi"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }
      \t\n
   ]]></constructorTemplate>

   <for keys="r" values="ftm_sc_action;ftm_sc_cpwms;ftm_sc_clks;
                         ftm_mode_pwmsync;ftm_mode_wpdis;ftm_mode_init;ftm_mode_ftmen" >
      <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_deadtime_dtps, ftm_deadtime_dtval"
      linePadding="xxx"
      params=",ticks"
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 and %description1
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(
         %params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_exttrig_trig"
      linePadding="xxx"
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName |= %paramExpression;
         \t   }
         \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_sc_ps, ftm_mod"
      params=",mod_ticks"
      linePadding="xxx"
      nonDefaultParams="2"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description0 and %description1
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(
      %params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0    = (%registerName0&~%mask0) | %paramName0;
      \t      %registerName1   = %paramName1;
      \t   }
      \t\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      nonDefaultParams="2"
      variables="ftm_modPeriod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      mod   = 0;
      \t      %registerName = %paramExpression;
      \t   }
      \t\n
   ]]></constructorTemplate>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}; // class $(_Class)BasicInfo::Init\n\n
   ]]></template>

<!--  Init class Configure method -->

   <template key="/$(_BASENAME)/InitMethod" namespace="all" codeGenCondition="enablePeripheralSupport"  discardRepeats="true" ><![CDATA[
      \t/**
      \t * Configure FTM from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const typename Info::Init &init) {
      \t
      \t   return Info::template configure<FtmBase_T<Info>>(init);
      \t}\n\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure FTM from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \ttemplate <class FTM>
      \tstatic ErrorCode configure(const Init &init) {
      \t
      \t   // Enable peripheral clock
      \t   enableClock();\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t
      \t   setCallbacks(init);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   uint8_t  sc    = init.sc;
      \t   uint16_t mod   = init.mod;
      \t
      \t   if (init.modperiod != 0) {
      \t
      \t      // Calculate sc.ps, mod (assumes cntin=0 or non-existent)
      \t      ErrorCode rc = FTM::calculateTimingParameters(init.modperiod, sc, mod);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }\n
      \t   }
      \t   // Disable timer to change clock (unable to switch directly between clock sources)
      \t   ftm->SC  = 0;
      \t
      \t   // End value for counter
      \t   ftm->MOD = mod;
      \t
      \t   // Restart counter
      \t   ftm->CNT = 0;
      \t
      \t   // Configure timer
      \t   ftm->SC  = sc;\n
   ]]></template>
   <for keys="var" values="ftm_mode_faultie;ftm_outinit_choi;ftm_pol_pol;ftm_deadtime;ftm_exttrig_trig" >
      <setTemplate variables="%(var)" codeGenCondition="enablePeripheralSupport" ><![CDATA[
         \t
         \t   // %description (%(var))
         \t   ftm->%registerNAME = init.%registerName;\n
      ]]></setTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!--  Default Initialisation value -->

   <initialValueTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
         ftm_sc_cpwms,
         ftm_sc_action,
         ftm_sc_clks,
         ftm_sc_ps,
         ftm_mod,
         ftm_mode_wpdis,
         ftm_mode_init,
         ftm_outinit_choi,
         ftm_pol_pol,
         ftm_exttrig_trig"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression\n
      \t};
      \t\n
   ]]>
   </initialValueTemplate>

<!--   ========== FTM Fault Init class =============================== -->

   <template key="fault_init_description" namespace="all" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Class) Fault handling
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::FaultInit faultInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmFaultMode_EvenChannelsManualFaultClearing , // Fault Control Mode - Even channels with manual fault clearing
      \t *    FtmFaultInterrupt_Disabled ,                   // Fault Interrupt Enable - Disabled
      \t *    FtmFaultFilter_4_clocks,                       // Fault Input Filter - 4 Clock cycles
      \t *    FtmFault0Mode_Disabled ,                       // Fault Input 0 Enable and Filter - Fault input disabled
      \t *    FtmFault0Polarity_ActiveHigh,                  // Fault Input 0 Polarity - Active High
      \t *    FtmFault1Mode_Filtered ,                       // Fault Input 1 Enable and Filter - Fault input enabled with filter
      \t *    FtmFault1Polarity_ActiveHigh,                  // Fault Input 1 Polarity - Active High
      \t *    FtmFault2Mode_Direct ,                         // Fault Input 2 Enable and Filter - Fault input enabled
      \t *    FtmFault2Polarity_ActiveLow,                   // Fault Input 2 Polarity - Active Low
      \t *    FtmFault3Mode_Direct ,                         // Fault Input 3 Enable and Filter - Fault input enabled
      \t *    FtmFault3Polarity_ActiveHigh,                  // Fault Input 3 Polarity - Active High
      \t *
      \t *    // Inherit default value
      \t *    $(_Class)::DefaultFaultInitValue
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configureFaultHandling(faultInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" condition="ftm_fltctrl_ffval"
   ><![CDATA[
$(fault_init_description)
      \tclass FaultInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr FaultInit(const FaultInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr FaultInit() = default;
      \t\n
   ]]></template>

<!-- InitFault Member variables -->

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_mode_faultm,ftm_mode_faultie,ftm_mode_pwmsync,ftm_mode_wpdis,ftm_mode_ftmen"
   ><![CDATA[
      \t   // Mode register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_fltctrl_ffval,ftm_fltctrl_fault0en"
   ><![CDATA[
      \t   // Fault Control register
      \t   uint16_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_fltpol_flt0pol"
   ><![CDATA[
      \t   // Fault Input Polarity register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate
   >

<!-- InitFault Configure methods -->

   <template codeGenCondition="enablePeripheralSupport" condition="ftm_fltctrl_ffval" ><![CDATA[
      \t/**
      \t * Configure fault handling from values specified in faultInit
      \t *
      \t * @param faultInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configureFaultHandling(const FaultInit &faultInit) {
      \t
      \t   ftm->FLTCTRL = faultInit.fltctrl;
      \t   ftm->FLTPOL  = faultInit.fltpol;
      \t   ftm->MODE    = (ftm->MODE&~(FTM_MODE_FAULTIE_MASK|FTM_MODE_FAULTM_MASK)) | faultInit.mode;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!--  Constructors -->

   <for keys="r" values="ftm_mode_faultm;ftm_mode_faultie;ftm_fltctrl_ffval" >
      <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr FaultInit(%params, Types... rest) : FaultInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   <for keys="pin" dim="8" >
      <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="ftm_fltctrl_fault%(pin)en,ftm_fltpol_flt%(pin)pol"
         linePadding="xxx"
         tooltipPadding="x*xxxxxxxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr FaultInit(
         %params, Types... rest) : FaultInit(rest...) {
         \t
         \t      %registerName0 = (%registerName0&~%mask0) | %paramName0;
         \t      %registerName1 = (%registerName1&~%mask1) | %paramName1;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

<!--  Fault Init value -->

   <initialValueTemplate codeGenCondition="enablePeripheralSupport"
      condition="SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT3&quot;)"
      separator=","
      terminator=","
      variables=",
         ftm_mode_faultm,
         ftm_mode_faultie,
         ftm_mode_ffval,
         ftm_fltctrl_ffval"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr FaultInit DefaultFaultInitValue = {%initExpression\n
   ]]></initialValueTemplate>

   <for keys="inp" dim="4" >
      <initialValueTemplate codeGenCondition="enablePeripheralSupport"
         condition="SignalExists(&quot;$(_NAME)_FLT%(inp)&quot;)"
         separator=","
         terminator=","
         variables="
            ftm_fltctrl_fault%(inp)en,
            ftm_fltpol_flt%(inp)pol"
      ><![CDATA[
         %initExpression\n
      ]]></initialValueTemplate>
   </for>

   <template codeGenCondition="enablePeripheralSupport"
      condition="SignalExists(&quot;$(_NAME)_FLT0&quot;)||SignalExists(&quot;$(_NAME)_FLT1&quot;)||SignalExists(&quot;$(_NAME)_FLT2&quot;)||SignalExists(&quot;$(_NAME)_FLT3&quot;)"
   >
   <![CDATA[
      \t};
      \t\n
   ]]>
   </template>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" condition="ftm_fltctrl_ffval" ><![CDATA[
      \t}; // class  $(_Class)BasicInfo::FaultInit\n\n
   ]]></template>

<!--   ========== ChannelInit class =============================== -->

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Class)Channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::ChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmChannelNum_3,            // Channel to initialise (may be unused if specifically provided as parameter)
      \t *    FtmChannelMode_Disabled ,   // Channel Mode - Disabled
      \t *    FtmChannelAction_None ,     // Action on Channel Event - No action
      \t *    FtmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
      \t *    0_ticks,                    // Output Compare Event time
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[FtmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configure(channelInit)
      \t * @endcode
      \t */
      \tclass ChannelInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]></template>

<!-- ChannelInit Class Member variables -->

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_cnv[]"
   ><![CDATA[
      \t   // %description
      \t   uint16_t %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_cnsc_mode_independent[]"
   ><![CDATA[
      \t   // Channel Status And Control Register
      \t   uint8_t cnsc = 0;
      \t\n
   ]]></initialValueTemplate>

   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      condition="ftm_combine_comb0_present"
   ><![CDATA[
      \t   // Function For Linked Channels
      \t   uint8_t combine = 0;
      \t\n
   ]]></template>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_channel_number"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_None;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_filter_ch0fval"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Disabled;\n\n
   ]]></initialValueTemplate>

<!-- ChannelInit Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" namespace="all" codeGenCondition="enablePeripheralSupport"  discardRepeats="true" ><![CDATA[
      \t/**
      \t * Configure FTM channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values for channel
      \t */
      \tstatic ErrorCode configure(const typename Info::ChannelInit &channelInit) {
      \t
      \t   return Info::configure(channelInit);
      \t}
      \t
      \t/**
      \t * Configure FTM channel from values specified in channelInit
      \t *
      \t * @param channelNum  Select channel to initialise.
      \t *                    This allows applying channelInit to arbitrary channel
      \t * @param channelInit Class containing initialisation values for channel
      \t */
      \tstatic ErrorCode configure(FtmChannelNum ftmChannelNum, const typename Info::ChannelInit &channelInit) {
      \t
      \t   return Info::configure(ftmChannelNum, channelInit);
      \t}\n\n
   ]]></template>

    <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelNum  Select channel to initialise.
      \t *                    This allows applying channelInit to arbitrary channel
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(FtmChannelNum channelNum, const ChannelInit &channelInit) {
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="ftm_combine_combine0_present" ><![CDATA[
      \t   // Configure timer combine mode
      \t   if ((channelNum&0b1) == 0) {
      \t      // Even channel value controls paired channels n,n+1
      \t      const unsigned offset = 4*channelNum;
      \t      const uint32_t mask = 0xFF<<offset;
      \t      ftm->COMBINE = (ftm->COMBINE & ~mask) | (uint32_t(channelInit.combine)<<offset);
      \t   }\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Configure timer channel
      \t   ftm->CONTROLS[channelNum].CnSC = channelInit.cnsc;
      \t   ftm->CONTROLS[channelNum].CnV  = channelInit.cnv;\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="ftm_filter_ch0fval" ><![CDATA[
      \t   ftm->FILTER = (ftm->FILTER & (FTM_FILTER_CH0FVAL_MASK<<(channelNum*4)))|(channelInit.filter<<(channelNum*4));\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const ChannelInit &channelInit) {
      \t   return configure(channelInit.channel, channelInit);
      \t}
      \t\n
   ]]></template>

<!-- ChannelInit Constructors -->

   <for keys="   r                    :  c    "
      values=" ftm_cnsc_action[]      : true  ;
               ftm_cnsc_icrst[]       : true  " >
      <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
         condition="%(c)"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate namespace="usbdm" codeGenCondition="enablePeripheralSupport"
      variables="ftm_cnsc_mode_independent[]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      cnsc    = %paramExpression;
      \t   }
      \t\n
   ]]></constructorTemplate>

   <for keys="r" values="
      ftm_filter_ch0fval;
      ftm_channel_number;
      ftm_cnv[]" >
      <constructorTemplate  namespace="usbdm" codeGenCondition="enablePeripheralSupport"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>
   <template namespace="usbdm" codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}; // class  $(_Class)BasicInfo::ChannelInit\n\n
   ]]></template>

<!--  ChannelInit Default Initialisation value -->

  <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)ChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
  ]]></template>
   <for keys="ch" dim="NumChannels" >
      <initialValueTemplate  codeGenCondition="enablePeripheralSupport"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_mode_independent[%(ch)],
            ftm_cnsc_action[%(ch)],
            ftm_cnsc_icrst[%(ch)],
            ftm_cnv[%(ch)],
            ftm_filter_ch%(ch)fval"
      ><![CDATA[
         \t{
         \t   FtmChannelNum_%(ch),
         %initExpression\n\t},\n
      ]]></initialValueTemplate>
   </for>
  <template  codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \n\t};\n\n
  ]]></template>

<!--  ========== FTM QUAD Init class =============================== -->

   <template key="quad_init_description" namespace="all" condition="ftm_qdctrl_quadmode_present" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of FtmQuadDecoder$(_instance)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const FtmQuadDecoder$(_instance)::QuadInit quadInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmQuadratureMode_Phase_AB_Mode , // Quadrature decoding mode
      \t *    FtmPhaseAPolarity_ActiveHigh ,    // Polarity of Phase A input
      \t *    FtmPhaseBPolarity_ActiveHigh ,    // Polarity of Phase B input
      \t *    FtmPhaseAFilter_Disabled ,        // Filtering on Phase A input
      \t *    FtmPhaseBFilter_Disabled ,        // Filtering on Phase B input
      \t *    FtmOverflowInterrupt_Enabled ,    // Overflow Interrupt
      \t *    NvicPriority_Normal ,             // IRQ level for this peripheral
      \t *    FtmPrescale_DivBy32,              // Clock prescaler
      \t *    ftmCallbak,                       // Timer overflow call-back
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultQuadInitValue
      \t * };
      \t *
      \t * // Initialise FTM from values specified above
      \t * FtmQuadDecoder$(_instance)::configure(ftmInit)
      \t * @endcode
      \t */
   ]]></template>

   <template namespace="usbdm" condition="ftm_qdctrl_quadmode_present" ><![CDATA[
$(quad_init_description)
      \tclass QuadInit {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr QuadInit(const QuadInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr QuadInit() = default;
      \t\n
   ]]></template>

<!-- QUAD Init class Member variables -->

   <setTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod"  condition="ftm_qdctrl_quadmode_present"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   // %description
      \t   %params = nullptr;\n\n
   ]]></setTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_a,ftm_qdfilter_b"
   ><![CDATA[
      \t   // Quad input filter control
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" discardRepeats="true"
      variables="ftm_qdctrl_quadmode"
   ><![CDATA[
      \t   // Quadrature Decoder Control And Status Register
      \t   uint8_t %registerName = FTM_QDCTRL_QUADEN_MASK;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" condition="ftm_qdctrl_quadmode_present"
      variables="ftm_sc_action,ftm_sc_ps"
   ><![CDATA[
      \t   // Status And Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></initialValueTemplate>

   <initialValueTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %paramType_Normal;\n\n
   ]]></initialValueTemplate>

<!-- QUAD Init class Configure method -->

   <template key="/$(_BASENAME)/QuadInitMethod" namespace="all" condition="ftm_qdctrl_quadmode_present" ><![CDATA[
      \t/**
      \t * Configure QuadDecoder from values specified in init
      \t
      \t * @param quadInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const typename Info::QuadInit &quadInit) {
      \t
      \t   // Assertions placed here so only checked if FtmQuadDecoder actually used
      \t   static_assert(Info::InfoQUAD::info[0].gpioBit >= 0, "FtmQuadDecoder PHA is not mapped to a pin - Modify Configure.usbdm");
      \t   static_assert(Info::InfoQUAD::info[1].gpioBit >= 0, "FtmQuadDecoder PHB is not mapped to a pin - Modify Configure.usbdm");
      \t
      \t   // Enable peripheral clock and map pins
      \t   enable();
      \t
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-back if feature enabled and non-null
      \t      if (quadInit.callbackFunction != nullptr) {
      \t         FtmBase_T<Info>::setCallback(quadInit.callbackFunction);
      \t      }
      \t      enableNvicInterrupts(quadInit.irqlevel);
      \t   }
      \t
      \t   // Disable timer to change clock (unable to switch directly between clock sources)
      \t   ftm->SC  = 0;
      \t
      \t   // Start value for counter
      \t   ftm->CNTIN = 0;
      \t
      \t   // End value for counter
      \t   ftm->MOD =0;
      \t
      \t   // Restart counter
      \t   ftm->CNT = 0;
      \t
      \t   // Configure timer
      \t   ftm->FILTER = quadInit.qdfilter;
      \t   ftm->SC     = quadInit.sc;
      \t   ftm->QDCTRL = quadInit.qdctrl;
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!-- QUAD Init class Constructors -->

   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <constructorTemplate namespace="usbdm" codeGenCondition="irqHandlingMethod" condition="ftm_qdctrl_quadmode_present"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></constructorTemplate>

   <for keys="r" values="
      ftm_sc_action;
      ftm_sc_ps;
      ftm_qdctrl_quadmode;
      ftm_qdctrl_phapol;
      ftm_qdctrl_phbpol" >
      <constructorTemplate  namespace="usbdm"  condition="ftm_qdctrl_quadmode_present"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]></constructorTemplate>
   </for>

   <constructorTemplate  namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_a"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      qdctrl   = (qdctrl&~FTM_QDCTRL_PHAFLTREN_MASK) | ((%paramExpression>>8) & FTM_QDCTRL_PHAFLTREN_MASK);
      \t      qdfilter = (qdfilter&~FTM_FILTER_CH0FVAL_MASK) | (%paramExpression&FTM_FILTER_CH0FVAL_MASK);
      \t   }
      \t\n
   ]]></constructorTemplate>

   <constructorTemplate  namespace="usbdm" discardRepeats="true"
      variables="ftm_qdfilter_b"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr QuadInit(%params, Types... rest) : QuadInit(rest...) {
      \t
      \t      qdctrl   = (qdctrl&~FTM_QDCTRL_PHBFLTREN_MASK) | ((%paramExpression>>8) & FTM_QDCTRL_PHBFLTREN_MASK);
      \t      qdfilter = (qdfilter&~FTM_FILTER_CH1FVAL_MASK) | (%paramExpression&FTM_FILTER_CH1FVAL_MASK);
      \t   }
      \t\n
   ]]></constructorTemplate>

   <template namespace="usbdm"  condition="ftm_qdctrl_quadmode_present" ><![CDATA[
      \t};\n\n
   ]]></template>
<!--  Default Initialisation value -->

   <initialValueTemplate  condition="ftm_qdctrl_quadmode_present"
      separator=","
      terminator=","
      variables="
         ftm_qdctrl_quadmode,
         ftm_qdctrl_phapol,
         ftm_qdctrl_phbpol,
         ftm_qdfilter_a,
         ftm_qdfilter_b,
         ftm_sc_action,
         irqLevel,
         ftm_sc_ps"
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)QuadDecoder
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr QuadInit DefaultQuadInitValue = {%initExpression
      \t};\n\n
   ]]></initialValueTemplate>

   <template namespace="usbdm" ><![CDATA[
      }; // class  $(_Class)BasicInfo\n\n
   ]]></template>

<!-- =========================== Set interrupt handlers =========================== -->

   <template  codeGenCondition="irqHandlingMethod" ><![CDATA[
      \t/**
      \t * Set overflow and fault interrupt call-back
      \t *
      \t * @param[in] newCallback Callback function to execute on interrupt.
      \t *                        Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t */
      \tstatic ErrorCode setCallback(CallbackFunction newCallback) {
      \t
      \t   if (newCallback == nullptr) {
      \t      newCallback = unhandledCallback;
      \t   }
      \t   sCallback = newCallback;
      \t   return E_NO_ERROR;
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="!irqHandlingMethod&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setCallbacks(const Init &) {
      \t}
      \t
      \t/**
      \t * Set channel callbacks from ChannelInit structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setChannelCallback(const ChannelInit &) {
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors==1)" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for shared channel call-backs i.e. all channels use same call-back
      \t *
      \t * @param[in] callback Callback function to execute on channel interrupt.
      \t *                     Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note The channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic ErrorCode setChannelCallback(ChannelCallbackFunction callback) {
      \t   if (callback == nullptr) {
      \t      channelCallbacks[0] = unhandledChannelCallback;
      \t      return E_NO_ERROR;
      \t   }
      #ifdef DEBUG_BUILD
      \t   // Callback is shared across all channels. Check if callback already assigned
      \t   if ((channelCallbacks[0] != unhandledChannelCallback) &&
      \t       (channelCallbacks[0] != callback)) {
      \t      return setErrorCode(ErrorCode::E_HANDLER_ALREADY_SET);
      \t   }
      #endif
      \t   channelCallbacks[0] = callback;
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @note Channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic void setCallbacks(const Init &init) {
      \t
      \t   setCallback(init.callbackFunction);
      \t   setChannelCallback(init.channelCallbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(NumChannelVectors>1)" ><![CDATA[
      \t/**
      \t * Set channel call-back function
      \t * Configured for individual channel call-backs
      \t *
      \t * @param[in] irqNum     Index of handler to set call-back for
      \t * @param[in] callback   Callback function to execute on channel interrupt.
      \t *                       Use nullptr to remove callback.
      \t *
      \t * @return E_NO_ERROR            No error
      \t * @return E_HANDLER_ALREADY_SET Handler already set
      \t *
      \t * @note Sevral channel call-backs are provided
      \t */
      \tstatic ErrorCode setChannelCallback(unsigned irqNum, ChannelCallbackFunction callback) {
      \t
      \t   if (irqNum>=irqCount) {
      \t      return setErrorCode(ErrorCode::E_ILLEGAL_PARAM);
      \t   }
      \t   if (callback == nullptr) {
      \t      channelCallbacks[irqNum] = unhandledChannelCallback;
      \t      return ErrorCode::E_NO_ERROR;
      \t   }
      \t   channelCallbacks[irqNum] = callback;
      \t   return ErrorCode::E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \t static void setCallbacks(const Init &init) {
      \t
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.FtmValidate" >
   </validate>

   <projectActionList id = "ftm_common_files" >
      <copy source="Project_Headers/ftm.h"                target="Project_Headers/ftm.h"                overwrite="true" derived="true" />
      <copy source="Snippets/ftm-pwm-example.cpp"         target="Snippets/ftm-pwm-example.cpp"         overwrite="true" derived="true" />
      <copy source="Snippets/ftm-ic-example.cpp"          target="Snippets/ftm-ic-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-oc-example.cpp"          target="Snippets/ftm-oc-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-oc-init-example.cpp"     target="Snippets/ftm-oc-init-example.cpp"     overwrite="true" derived="true" />
      <copy source="Snippets/ftm-servo-example.cpp"       target="Snippets/ftm-servo-example.cpp"       overwrite="true" derived="true" />
      <copy source="Snippets/ftm-quadrature-example.cpp"  target="Snippets/ftm-quadrature-example.cpp"  overwrite="true" derived="true" />
      <copy source="Snippets/neopixel-example.cpp"        target="Snippets/neopixel-example.cpp"        overwrite="true" derived="true" />
   </projectActionList>

   <template key="/$(_BASENAME)/declarations" namespace="all" codeGenCondition="enablePeripheralSupport"
   ><![CDATA[
   /**
    * Class representing $(_NAME)
    */
   class $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};\n\n
   ]]></template>

   <template key="/$(_BASENAME)/quadDeclarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_Class) as Quadrature decoder
   \t */
   \ttypedef $(_Baseclass)QuadDecoder_T<$(_Class)Info> $(_Baseclass)QuadDecoder$(_instance);\n
   ]]></template>

   <!-- ************* Signal mapping ****************** -->

   <category name="Advanced" description="Advanced options">
      <aliasOption key="/SIM/sim_sopt4_$(_Class)clksel"  optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)flt0"    optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)flt1"    optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)flt2"    optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)flt3"    optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)trg0src" optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)trg1src" optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)ch0src"  optional="true" locked="false" />
      <aliasOption key="/SIM/sim_sopt4_$(_Class)ch1src"  optional="true" locked="false" />

      <aliasOption key="/SIM/sim_sopt8_$(_Class)och7src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och6src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och5src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och4src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och3src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och2src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och1src" optional="true" locked="false"/>
      <aliasOption key="/SIM/sim_sopt8_$(_Class)och0src" optional="true" locked="false"/>
   </category>

   <signals enabledBy="enablePeripheralSupport" />
   <signals name="FTM" optional="true" />

</fragment>

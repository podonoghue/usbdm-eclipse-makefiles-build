<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- ftm_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <!-- ____ Class Declaration ________ -->
   <constant key="_basicInfo_declaration" type="String" value='"$(_BasicInfo) : public $(_Baseclass)CommonInfo"' />

   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <constant key="disable_peripheral"      value='"ftm->SC = FTM_SC_CLKS(0);"' type="String"  />

   <equation key="no_initvectors"             value="true"      />
   <equation key="irq_parameters"             value=""  />
   <equation key="irq_dummy_parameters"       value=""  />
   <equation key="irq_call_parameters"        value=""  />
   <equation key="generateDefault"            value="false"         />
   <equation key="configureInStartupDefault"  value="false"         />
   <xi:include href="enablePeripheral.xml"  />

   <!-- ____ Constants ____________ -->

   <template><![CDATA[
      \t//! Number of channels implemented
      \tstatic constexpr unsigned NumChannels = $(_channelCount);

      \t//! Number of channel event vectors implemented
      \tstatic constexpr unsigned NumChannelVectors = $(_hardwareIrqCount);\n\n
   ]]></template>

   <!-- ____ Hidden ________ -->

   <binaryOption key="ftm_sc_tof" condition="ftm_sc_tof_present"
      typeName="FtmOverflowFlag"
      baseType="uint8_t"
      derived="true"
      enumOr="auto"
      hidden="true"
      description="Timer Overflow Flag"
      toolTip="Set by hardware when the FTM counter passes the value in the MOD register.\n
               The TOF bit is cleared by reading the SC register while TOF is set and then\n
               writing a 0 to TOF bit. Writing a 1 to TOF has no effect.\n
               If another overflow occurs between the read and write operations,\n
               the write operation has no effect; therefore, TOF remains set indicating\n
               an overflow has occurred. In this case, a TOF interrupt request is\n
               not lost due to the clearing sequence for a previous TOF." >
      <choice value="0" name="No Overflow"            enum="NoOverflow"  />
      <choice value="1" name="Counter Has Overflowed" enum="CounterHasOverflowed"  />
   </binaryOption>

   <intOption key="ftm_status_status" condition="ftm_status_present"
      typeName="FtmEventStatus"
      baseType='=Exists("ftm_status_tof_present")?"uint16_t":"uint8_t"'
      derived="true"
      hidden="true"
      description="Timer Events"
      toolTip="The STATUS register contains a copy of the CHnF status flag \n
               from the CnSC for each FTM channel. (May also include SC[TOF])"
   />

   <!-- ____ Main Configuration ________ -->

   <title description="Main configuration"/>

   <choiceOption key="mode"
      enabledBy="enablePeripheralSupport"
      target="ftm_sc_cpwms"
      description="Main operating mode for FTM"
      toolTip="Main Mode"
      disabledValue="0" >
      <choice value="0" ref="0" name="Disabled"     />
      <choice value="1" ref="0" name="Left aligned"
         toolTip="Left aligned (counter runs [0...mod]),  supports:\n
                 - Input capture\n
                 - Dual-edge capture\n
                 - Output compare\n
                 - Edge-aligned PWM\n
                 - Combined PWM"       />
      <choice value="2" ref="1" name="Centre aligned"
         toolTip="Centre aligned (counter runs [(0...mod...0)]), supports:\n
          - Centre-aligned PWM"
      />
      <choice value="3" ref="0" name="Quadrature decoder" condition="ftm_qdctrl_quaden_present"
         toolTip="Quadrature Decode (counter clocked by decoder), supports:\n
          - Quadrature decode using two channels"
      />
      <choice value="0" ref="0" name="Disabled" enabledBy="false" />
   </choiceOption>

   <constant key="None"    value="0"   type="Long" />
   <constant key="Left"    value="1"   type="Long" />
   <constant key="Centre"  value="2"   type="Long" />
   <constant key="Quad"    value="3"   type="Long" />

   <binaryOption key="ftm_sc_cpwms"
      hiddenBy="(mode==(None))"
      locked="true"
      enumOr="auto"
      enabledBy="enablePeripheralSupport"
      typeName="FtmCountMode"
      baseType="uint8_t"
      description="Counting mode"
      toolTip="Counting Mode" >
      <choice value="0" name="Left-aligned (count up)"        toolTip="Left-aligned   (0...mod)"     enum="LeftAligned"    />
      <choice value="1" name="Centre-aligned (count up-down)" toolTip="Centre-aligned (0...mod...0)" enum="CentreAligned"  />
   </binaryOption>

   <!-- ____ Main Counter ________ -->
   <title description="Main Counter" />

   <!-- MCG clock -->
   <choiceOption key="ftmClockConfig" condition="/MCG/_present"
      description="Clock configuration"
      target="system_bus_clock"
      toolTip="Selects the clock configuration used for calculations if System clock is chosen as clock source" >
      <choice value="0" name="@/MCG/ClockConfig[0]" ref="/SIM/system_bus_clock[0]"  isDefault="true" />
      <choice value="1" name="@/MCG/ClockConfig[1]" ref="/SIM/system_bus_clock[1]"  />
      <choice value="2" name="@/MCG/ClockConfig[2]" ref="/SIM/system_bus_clock[2]"  />
      <choice value="3" name="@/MCG/ClockConfig[3]" ref="/SIM/system_bus_clock[3]"  />
   </choiceOption>

   <intOption key="system_bus_clock" condition="/MCG/_present"
      locked="true"
      derived="true"
      description="System Bus Clock"
      toolTip="Based on selected clock configuration"
      units="Hz"
      />

   <choiceOption key="ftm_sc_clks" condition="/MCG/_present"
      enabledBy="enablePeripheralSupport"
      description="Clock Source"
      typeName="FtmClockSource"
      baseType="uint8_t"
      enumOr="auto"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module" >
      <choice value="0" name="Disabled"              enum="Disabled"            ref="disabled"                       code="0"                 />
      <choice value="1" name="System clock"          enum="SystemClock"         ref="system_bus_clock"               code="SystemBusClock"    isDefault="true" />
      <choice value="2" name="Fixed frequency clock" enum="FixedFrequencyClock" ref="/MCG/system_mcgffclk_clock[0]"  code="SystemMcgFFClock"  />
      <choice value="3" name="External clock"        enum="ExternalClock"       ref="/SIM/$(_name)ExternalClock"     code="SimInfo::get$(_Class)ExternalClockFrequency()" condition="/SIM/$(_name)ExternalClock"  />
   </choiceOption>

   <!-- ICS clock -->
   <choiceOption key="ftmClockConfig" condition="/ICS/_present"
      description="Clock configuration"
      target="system_timer_clock"
      toolTip="Selects the clock configuration used for calculations if System timer clock is chosen as clock source" >
      <choice value="0" name="@/ICS/ClockConfig[0]" ref="/SIM/system_timer_clock[0]"  isDefault="true" />
      <choice value="1" name="@/ICS/ClockConfig[1]" ref="/SIM/system_timer_clock[1]"  />
      <choice value="2" name="@/ICS/ClockConfig[2]" ref="/SIM/system_timer_clock[2]"  />
      <choice value="3" name="@/ICS/ClockConfig[3]" ref="/SIM/system_timer_clock[3]"  />
   </choiceOption>

   <intOption key="system_timer_clock" condition="/ICS/_present"
      locked="true"
      derived="true"
      description="System Timer Clock"
      toolTip="Based on selected clock configuration"
      units="Hz"
      />

   <choiceOption key="ftm_sc_clks"  condition="/ICS/_present"
      enabledBy="enablePeripheralSupport"
      description="Clock source"
      typeName="FtmClockSource"
      enumOr="auto"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module" >
      <choice value="0" name="Disabled"                     enum="Disabled"            ref="disabled"                       code="0"                   />
      <choice value="1" name="System timer clock"           enum="SystemTimerClock"    ref="system_timer_clock"             code="SystemTimerClock"    isDefault="true" />
      <choice value="2" name="Fixed frequency clock"        enum="FixedFrequencyClock" ref="/ICS/system_icsffclk_clock[0]"  code="SystemIcsFFClock"    />
      <choice value="3" name="External clock"               enum="ExternalClock"       ref="/SIM/$(_name)ExternalClock"     code="SimInfo::get$(_Class)ExternalClockFrequency()"  />
   </choiceOption>

   <binaryOption key="externalClockUsed"
      ref="ftm_sc_clks == 3"
      derived="true"
      locked="true"
      hidden="true" >
      <choice value="0" name="External clock unused" />
      <choice value="1" name="External clock used"   />
   </binaryOption>

   <intOption key="inputClockFrequency"
      enabledBy="enablePeripheralSupport"
      locked="true"
      description="Frequency of input clock to timer"
      toolTip="This is the main clock for the Timer Counter"
      derived="true"
      units="Hz"/>

   <choiceOption key="ftm_sc_ps"
      hiddenBy="(mode==(None))"
      enabledBy="enablePeripheralSupport"
      description="Counter clock prescaler"
      typeName="FtmPrescale"
      enumOr="auto"
      baseType="uint8_t"
      target="clock"
      toolTip="Selects the prescaler for the module" >
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"        enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="(inputClockFrequency)/2."   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="(inputClockFrequency)/4."   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="(inputClockFrequency)/8."   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="(inputClockFrequency)/16."  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="(inputClockFrequency)/32."  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="(inputClockFrequency)/64."  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="(inputClockFrequency)/128." enum="DivBy128" />
   </choiceOption>

   <floatOption key="clock"
      hiddenBy="mode==(None,Quad)"
      description="Counter tick rate"
      toolTip="The tick rate of the main counter"
      derived="true"
      locked="true"
      units="Hz"
    />

   <floatOption key="clockPeriod"
      hidden="true"
      ref="(1.0/clock)"
      locked="true"
      derived="true"
   />

   <binaryOption key="freeRunningCounter"
      hiddenBy="mode!=(Left,Quad)"
      enabledBy="!(mode!=(Left,Quad))"
      description="Counter free-running"
      toolTip="Forces the full range for counter [0..65535]\n
               This is usually convenient for input-capture operations\n
               making use of modulo-16 calculations with counter roll-overs"
      name="freeRunning" >
      <choice value="0" name="Period mode"       />
      <choice value="1" name="Free-running mode" />
   </binaryOption>

   <intOption key="ftm_mod_mod"
      hiddenBy="mode==(None)"
      enabledBy="!freeRunningCounter"
      description="End value for counter"
      toolTip="The timer counts from 0 to this value"
      valueFormat="%s"
      baseType="uint16_t"
      units="ticks"
      value="65535" min="0" max="65535" />

   <intOption key="ftm_cnt_count" condition="ftm_cnt_count_present"
      hidden="true"
      locked="true"
      derived="true"
      description="Main counter (writing any value clears counter)"
      toolTip="Main counter for Timer"
      baseType="uint16_t"
      units="ticks"
      value="0" />

   <intOption key="ftm_cntin" condition="ftm_cntin_present"
      hidden="true"
      locked="true"
      derived="true"
      description="Start value for counter (assumed always 0)"
      toolTip="Determines the value loaded to the FTM counter on overflow or reset"
      valueFormat="%s"
      baseType="uint16_t"
      units="ticks"
      value="0" min="0" max="65535" />

   <floatOption key="ftm_modPeriod"
      enabledBy="inputClockFrequency!=0"
      hiddenBy="mode==(None,Quad)"
      ref="clockPeriod*(ftm_sc_cpwms?(2*(ftm_mod_mod)):(ftm_mod_mod+1))"
      unlockedBy="!freeRunningCounter"
      description="Period or minimum interval of timer"
      toolTip="In left-aligned or centre-aligned this is the period of the timer\n
               In free-running mode it is the minimum interval"
      derived="true"
      units="s"
      min="0"
      max="clockPeriod*(ftm_sc_cpwms?(2*(65535)):(65535+1))"
      />

   <choiceOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;ftm_sc_dma_present"
      hiddenBy="mode==(None)"
      valueFormat="FTM_SC_TOIE(%s),FTM_SC_DMA(%s)"
      typeName="FtmOverflowAction"
      baseType="uint16_t"
      enumOr="auto"
      description="Action on Counter overflow"
      toolTip="Enable interrupt and/or DMA on counter overflow" >
       <choice value="0,0" name="No action"                    enum="None"             />
       <choice value="0,1" name="DMA request"                  enum="Dma"              />
       <choice value="1,0" name="Interrupt request"            enum="Interrupt"        enabledBy="irqHandlingMethod" />
       <choice value="1,1" name="Interrupt and DMA request"    enum="InterruptAndDma"  enabledBy="irqHandlingMethod" />
   </choiceOption>

   <binaryOption key="ftm_sc_action" condition="ftm_sc_toie_present&amp;&amp;!ftm_sc_dma_present"
      hiddenBy="mode==(None)"
      enabledBy="irqHandlingMethod"
      valueFormat="FTM_SC_TOIE(%s)"
      baseType="uint8_t"
      enumOr="auto"
      typeName="FtmOverflowAction"
      description="Action on Counter overflow"
      toolTip="Enable interrupt on counter overflow" >
      <choice value="0" name="No action"          enum="None"       />
      <choice value="1" name="Overflow Interrupt" enum="Interrupt"  />
   </binaryOption>

   <choiceOption key="ftm_channel_number"
      hidden="true"
      derived="true"
      baseType="uint8_t"
      valueFormat="%s"
      typeName="FtmChannelNum"
      description="Channel Number"
      toolTip="Selects a channel" >
      <choiceExpansion value="%(ch)" name="Channel %(ch)" enum="%(ch)" keys="ch" dim="8" />
      <choice value="(uint8_t(-1))" name="No Channel"     enum="None" />
   </choiceOption>

   <!--
      COMBINE0+DECAPEN0 controlled by extended mode
      COMP0, DECAP0, DTEN0, SYNCEN0, FAULTEN0  -->

   <!-- ____ INVCTRL __________________ -->

   <choiceOption key="ftm_invctrl_inven"
      condition="/FTM0/ftm_invctrl_present||/FTM1/ftm_invctrl_present||
                 /FTM2/ftm_invctrl_present||/FTM3/ftm_invctrl_present"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="FtmInvertChannelPair"
      description="Channel Output Control"
      toolTip="Selects the inverting operation for the corresponding paired channels\n
               These bits control the inversion (swapping) of paired channel outputs.\n
               This register has a write buffer. (See INVC,SYNCMODE,SWINVC,HWINVC,SWSYNC,TRIGn)\n
               This bit is updated by the INVCTRL Register Synchronisation." >
      <choice name="No outputs inverted"  value="0" enum="Normal" />
      <choiceExpansion name='="Invert Ch"+ToString(2*%(ch))+"/Ch"+ToString(2*%(ch)+1)+" outputs"'
                        value="1U&lt;&lt;%(ch)" enum='=ToString(2*%(ch))+"_"+ToString(2*%(ch)+1)+"_Inverted"' dim="4" keys="ch" />
   </choiceOption >

   <!--  ____ Hidden info ________________ -->

   <category hidden="true">

   <!-- ____ Independent Channels ________________ -->

   <for keys="ch" dim="=_channelCount" >

      <choiceOption key="ftm_cnsc_mode_independent[%(ch)]"
         signal="$(_NAME)_CH%(ch)"
         enabledBy="enablePeripheralSupport&amp;&amp;!channelPairing[%(ch)&amp;0b1110]"
         valueFormat="FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
         baseType="uint16_t"
         typeName="FtmChannelMode"
         description="Channel Mode"
         toolTip="Determines channel operation (PWM/Input capture/Output compare)" >
         <!--              +......... MS(B:A)  -->
         <!--              |    +.... ELS(B:A) -->
         <!--              |    |              -->
         <!--              v    v              -->
          <choice value="0b00,0b00"  name="Channel Disabled"                    enum="Disabled"                 />
          <!-- 1-3 -->
          <choice value="0b00,0b01"  name="Input Capture Rising-edge"           enum="InputCaptureRisingEdge"   />
          <choice value="0b00,0b10"  name="Input Capture Falling-edge"          enum="InputCaptureFallingEdge"  />
          <choice value="0b00,0b11"  name="Input Capture Either-edge"           enum="InputCaptureEitherEdge"   />
          <!-- 4-7 -->
          <choice value="0b01,0b00"  name="Software Compare (pin unused)"       enum="OutputCompare"            />
          <choice value="0b01,0b01"  name="Output Compare Toggle"               enum="OutputCompareToggle"      />
          <choice value="0b01,0b10"  name="Output Compare Clear"                enum="OutputCompareClear"       />
          <choice value="0b01,0b11"  name="Output Compare Set"                  enum="OutputCompareSet"         />
          <!-- 8-9 -->
          <choice value="0b10,0b10"  name="Pwm High-true Pulses (Edge/Centre)"  enum="PwmHighTruePulses"        />
          <choice value="0b10,0b01"  name="Pwm Low-true Pulses (Edge/Centre)"   enum="PwmLowTruePulses"         />
      </choiceOption>

      <choiceOption key="ftm_cnsc_action_independent[%(ch)]" condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]!=0)"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]!=0)"
         valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
         baseType="uint16_t"
         typeName="FtmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="ftm_cnsc_action_independent[%(ch)]" condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]!=0)"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="FTM_CnSC_CHIE(%s)"
         baseType="uint16_t"
         typeName="FtmChannelAction"
         description="Action on Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <choiceOption key="ftm_filter_fval_independent[%(ch)]" condition="ftm_filter_ch%(ch)fval_present"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         description="Channel Input Filter"
         typeName="FtmInputFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel input" >
         <choice          value="0"         name="Filter Disabled"                        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="ftm_filter_fval_delay_independent[%(ch)]" condition="ftm_filter_fval_independent[%(ch)]"
         hiddenBy="!(ftm_filter_fval_independent[%(ch)]>0)"
         enabledBy="(ftm_filter_fval_independent[%(ch)]>0)"
         description="Channel Input Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*ftm_filter_fval_independent[%(ch)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <binaryOption key="ftm_cnsc_icrst_independent[%(ch)]" condition="ftm_cnsc_icrst_present"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]==(1,2,3))"
         valueFormat="FTM_CnSC_ICRST(%s)"
         typeName="FtmChannelReset"
         baseType="uint16_t"
         description="Reset counter on channel IC event"
         toolTip="FTM counter reset is driven by the selected event of the channel\n
                  in the Input Capture mode.\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1." >
         <choice value="0" name="Disabled" enum="Disabled" />
         <choice value="1" name="Enabled"  enum="CounterReset"  />
      </binaryOption>

      <intOption key="ftm_cnv_independent[%(ch)]"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]>=4)"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]>=4)"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Output Compare Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod_mod" />

      <floatOption key="ftm_cnvEventTime_independent[%(ch)]"
         hiddenBy="!(ftm_cnsc_mode_independent[%(ch)]>=4)"
         enabledBy="(ftm_cnsc_mode_independent[%(ch)]>=4)"
         ref="ftm_cnv_independent[%(ch)]*clockPeriod"
         valueFormat="%s"
         derived="true"
         units="s"
         description="Output Compare Event time in seconds"
         toolTip="This value, converted to ticks, is compared against the main counter"
         value="0" min="0" max="ftm_mod_mod*clockPeriod" />

      <floatOption key="ftm_cnvHighTime_independent[%(ch)]"
         hiddenBy="ftm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="(ftm_cnsc_mode_independent[%(ch)]==8)?
            (ftm_sc_cpwms?2.0:1.0)*(ftm_cnv_independent[%(ch)])*clockPeriod:
            (ftm_sc_cpwms?2.0:1.0)*(ftm_mod_mod-ftm_cnv_independent[%(ch)])*clockPeriod"
         valueFormat="%s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="ftm_cnvDutyCycle_independent[%(ch)]"
         hiddenBy="ftm_cnsc_mode_independent[%(ch)]!=(8,9)"
         locked="true"
         derived="true"
         ref="ftm_cnvHighTime_independent[%(ch)]/ftm_modPeriod"
         valueFormat="%s"
         units="percent"
         description="Output duty cycle as percentage"
         toolTip="Calculated duty cycle" />
   </for>

<if condition="ftm_combine_present">

   <!-- ____ Paired Channels ________________ -->

   <!-- Odd channels when paired - Dual-edge Capture or PWM
        This combines the two separate sets of values from:
        - ftm_cnsc_secondEdge[%(oddCh)]
        - ftm_cnsc_secondOutput[%(oddCh)]
   -->
   <choiceOption key="ftm_cnsc_mode_odd[1]"
      derived="true"
      valueFormat="FTM_CnSC_ELS(%s)"
      description="Odd channel mode"
      typeName="FtmOddChannelMode"
      baseType="uint16_t"
      disabledValue="0b00"
      toolTip="Behaviour of second channel when channels are paired"
      >
      <!--              +...... ELS(B:A)
                        |
                        v                  -->
       <choice value="0b00" name="Pin Disabled"         enum="Disabled"
          toolTip="The pin associated with the second channel is not used by the FTM" />
        <!-- = ftm_cnsc_secondEdge -->
       <choice value="0b01" name="Capture Rising-edge"   enum="RisingEdge"
         toolTip="Odd channel captures CNV on next rising edge of channel input" />
       <choice value="0b10" name="Capture Falling-edge"  enum="FallingEdge"
         toolTip="Odd channel captures CNV on next falling edge of channel input" />
       <choice value="0b11" name="Capture Either-edge"   enum="EitherEdge"
         toolTip="Odd channel captures CNV on next rising or falling edge of channel input" />
        <!-- = ftm_cnsc_secondOutput -->
       <choice value="0b01" name="Pin controlled by FTM"  enum="Enabled"
         toolTip="The pin associated with the second channel is controlled by the FTM" />
   </choiceOption>

   <for keys="    Num : evenCh : oddCh"
        values="   0  :   0  :   1;
                   1  :   2  :   3;
                   2  :   4  :   5;
                   3  :   6  :   7" >

      <if condition="=%(evenCh) >=_channelCount">
         <break/>
      </if>

      <!-- Even channels when paired -->
      <choiceOption key="ftm_cnsc_mode_even[%(evenCh)]"
         signal="$(_NAME)_CH%(evenCh)"
         enabledBy="enablePeripheralSupport&amp;&amp;channelPairing[%(evenCh)]"
         valueFormat="(FTM_COMBINE_DECAPEN0(%s)&lt;&lt;8),(FTM_COMBINE_COMBINE0(%s)&lt;&lt;8),FTM_CnSC_MS(%s),FTM_CnSC_ELS(%s)"
         baseType="uint16_t"
         typeName="FtmEvenChannelMode"
         description="Paired Channels Mode"
         toolTip="Determines channel operation (Combined PWM or Dual-edge capture)"
         >
         <!--            +.............. DECAPEN
                         | +............ COMBINE
                         | |   +........ MS(B:A)
                         | |   |    +... ELS(B:A)
                         | |   |    |
                         v v   v    v                 -->
          <choice value="0,0,0b00,0b00" name="Channel Pair Disabled"                      enum="Disabled"                                />
          <!-- 1-2 ................ -->
          <choice value="0,1,0b00,0b10" name="Combined PWM Positive-pulse"                enum="CombinePositivePulse"                    />
          <choice value="0,1,0b00,0b01" name="Combine PWM Negative-pulse"                 enum="CombineNegativePulse"                    />
          <!-- 3-8 ................ -->
          <choice value="1,0,0b00,0b01" name="Dual-edge Capture One-Shot Rising-edge"     enum="DualEdgeCaptureOneShotRisingEdge"        />
          <choice value="1,0,0b01,0b01" name="Dual-edge Capture Continuous Rising-edge"   enum="DualEdgeCaptureContinuousRisingEdge"     />
          <choice value="1,0,0b00,0b10" name="Dual-edge Capture One-Shot Falling-edge"    enum="DualEdgeCaptureOneShotFallingEdge"       />
          <choice value="1,0,0b01,0b10" name="Dual-edge Capture Continuous Falling-edge"  enum="DualEdgeCaptureContinuousFallingEdge"    />
          <choice value="1,0,0b00,0b11" name="Dual-edge Capture One-Shot Either-edge"     enum="DualEdgeCaptureOneShotEitherEdge"        />
          <choice value="1,0,0b01,0b11" name="Dual-edge Capture Continuous Either-edge"   enum="DualEdgeCaptureContinuousEitherEdge"     />
      </choiceOption>

      <variable key="_combined_pwm%(Num)"          type="Boolean" expression="ftm_cnsc_mode_even[%(evenCh)]==(1,2)"   />
      <variable key="_dual_edge_capture%(Num)"     type="Boolean" expression="ftm_cnsc_mode_even[%(evenCh)]!=(0,1,2)" />
      <variable key="_dual_edge_continuous%(Num)"  type="Boolean" expression="ftm_cnsc_mode_even[%(evenCh)]==(4,6,8)" />

      <!-- Odd channels when paired - PWM -->
      <choiceOption key="ftm_cnsc_secondOutput[%(oddCh)]"
         signal="$(_NAME)_CH%(oddCh)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         valueFormat="FTM_CnSC_ELS(%s)"
         description="Odd channel Output Control"
         typeName="FtmOddChannelMode"
         disabledValue="0b00"
         toolTip="Controls the functioning of the output of the second channel in a pair"
         >
         <!--              +...... ELS(B:A)
                           |
                           v                  -->
         <choice value="0b00" name="Pin Disabled"           enum="Disabled"
            toolTip="The pin associated with the second channel is not controlled by the FTM"
          />
         <choice value="0b01" name="Pin controlled by FTM"  enum="Enabled"
            toolTip="The pin associated with the second channel is controlled by the FTM"
         />
      </choiceOption>

      <!-- Odd channels when paired - Dual-edge Capture -->
      <choiceOption key="ftm_cnsc_secondEdge[%(oddCh)]"
         signal="$(_NAME)_CH%(oddCh)"
         hiddenBy="!_dual_edge_capture%(Num)"
         enabledBy="_dual_edge_capture%(Num)"
         valueFormat="FTM_CnSC_ELS(%s)"
         description="Odd channel Capture Polarity"
         typeName="FtmOddChannelMode"
         disabledValue="0b00"
         toolTip="Polarity for capturing the second edge in Dual-edge capture mode (2nd event/channel)"
         >
         <!--              +...... ELS(B:A)
                           |
                           v                  -->
          <choice value="0b00" name="Not used"             enum="Disabled"    />
          <choice value="0b01" name="Capture Rising-edge"  enum="RisingEdge"  />
          <choice value="0b10" name="Capture Falling-edge" enum="FallingEdge" />
          <choice value="0b11" name="Capture Either-edge"  enum="EitherEdge"  />
      </choiceOption>

      <intOption key="ftm_cnv_paired[%(evenCh)]"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Even channel O/C Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod_mod" />

      <intOption key="ftm_cnv_paired[%(oddCh)]"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         valueFormat="%s"
         baseType="uint16_t"
         units="ticks"
         description="Odd channel O/C Event time in ticks"
         toolTip="This value is compared against the main counter"
         value="0" min="0" max="ftm_mod_mod" />

      <floatOption key="ftm_pwmHighTime[%(evenCh)]"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         locked="true"
         derived="true"
         ref="(ftm_cnv_paired[%(oddCh)]-ftm_cnv_paired[%(evenCh)])*clockPeriod"
         valueFormat="%s"
         units="s"
         description="Output high-time in seconds"
         toolTip="Calculated high-time" />

      <floatOption key="ftm_pwmDutyCycle[%(evenCh)]"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         locked="true"
         derived="true"
         ref="ftm_pwmHighTime[%(evenCh)]/ftm_modPeriod"
         valueFormat="%s"
         units="percent"
         description="Output duty cycle as pecentage"
         toolTip="Calculated duty cycle" />

      <!-- COMBINE.DECAP
           Note: Not sensible to initialise when used as a flag for one-shot mode -->
      <binaryOption key="ftm_combine_decap%(Num)"
         hiddenBy="!_dual_edge_continuous%(Num)"
         enabledBy="_dual_edge_continuous%(Num)"
         typeName="FtmSecondEventAction"
         baseType="uint8_t"
         description="Action on Odd channel (Ch%(oddCh)) event"
         toolTip="Enables the capture of the FTM counter value on odd channel events.\n
                  In dual edge capture one-shot mode, this bit is cleared automatically\n
                  by hardware when the capture occurs." >
         <choice value="0" name="NoCapture"          enum="NoCapture"                  />
         <choice value="1" name="Capture 2nd event"  enum="CaptureOnEvent"   />
      </binaryOption>

      <!-- COMBINE.COMP -->
      <binaryOption key="ftm_combine_comp%(Num)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         typeName="FtmComplementChannel"
         baseType="uint8_t"
         description="Paired Channels Complementary Enable"
         toolTip="Enables Complementary mode for the paired channels.\n
                  In Complementary mode the channel (n+1) output is the inverse of the channel (n) output.\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1." >
         <choice value="0"  name="Disabled"               enum="Normal" />
         <choice value="1"  name="Complementary outputs"  enum="Complementary" />
      </binaryOption>

      <!-- COMBINE.FAULTEN -->
      <binaryOption key="ftm_combine_faulten%(Num)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         typeName="FtmFaultControl"
         baseType="uint8_t"
         description="Paired Channels Fault Control Enable"
         toolTip="Enables the fault control of the channel pair.\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1."
      >
         <choice value="0"  name="Disabled"                  enum="Normal"      />
         <choice value="1"  name="Disable outputs on fault"  enum="DisabledOnFault" />
      </binaryOption>

      <!-- COMBINE.DTEN -->
      <binaryOption key="ftm_combine_dten%(Num)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         typeName="FtmDeadtime"
         baseType="uint8_t"
         description="Paired Channels Deadtime Enable"
         toolTip="Enables the deadtime insertion in the channels (n) and (n+1).\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1."
      >
         <choice value="0"  name="Disabled"           enum="Disabled"      />
         <choice value="1"  name="Deadtime inserted"  enum="Inserted" />
      </binaryOption>

      <!-- COMBINE.SYNCEN -->
      <binaryOption key="ftm_combine_syncen%(Num)"
         hiddenBy="!_combined_pwm%(Num)"
         enabledBy="_combined_pwm%(Num)"
         typeName="FtmSyncEnable"
         baseType="uint8_t"
         description="Paired Channels Synchronization Enable"
         toolTip="Enables PWM synchronization of registers C(n)V and C(n+1)V."
      >
         <choice value="0"  name="Disabled"          enum="Disabled"      />
         <choice value="1"  name="PWM Synchronised"  enum="Synchronised" />
      </binaryOption>

      <!-- Even channel -->
      <choiceOption key="ftm_cnsc_action_paired[%(evenCh)]" condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
         baseType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Even Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="ftm_cnsc_action_paired[%(evenCh)]" condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="FTM_CnSC_CHIE(%s)"
         baseType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Even Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <!-- Odd channel -->
      <choiceOption key="ftm_cnsc_action_paired[%(oddCh)]" condition="ftm_cnsc_chie_present&amp;&amp;ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         valueFormat="FTM_CnSC_CHIE(%s),FTM_CnSC_DMA(%s)"
         baseType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Odd Channel Event"
         toolTip="Enable interrupt or DMA on channel event" >
          <choice value="0,0" name="No action"          enum="None"      />
          <choice value="1,1" name="DMA request"        enum="Dma"       />
          <choice value="1,0" name="Interrupt Request"  enum="Interrupt" enabledBy="irqHandlingMethod"  />
      </choiceOption>

      <binaryOption key="ftm_cnsc_action_paired[%(oddCh)]" condition="ftm_cnsc_chie_present&amp;&amp;!ftm_cnsc_dma_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         enabledBy="(ftm_cnsc_mode_even[%(evenCh)]!=0)&amp;&amp;irqHandlingMethod"
         valueFormat="FTM_CnSC_CHIE(%s)"
         baseType="uint8_t"
         typeName="FtmChannelAction"
         description="Action on Odd Channel Event"
         toolTip="Enable interrupt on channel event" >
          <choice value="0" name="No action"              enum="None"        />
          <choice value="1" name="Interrupt request"      enum="Interrupt"   />
      </binaryOption>

      <!-- FILTER.FVAL -->

      <choiceOption key="ftm_filter_fval_paired[%(evenCh)]" condition="ftm_filter_ch%(evenCh)fval_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]>=3)"
         enabledBy="ftm_cnsc_mode_even[%(evenCh)]>=3"
         description="Even Channel Input Filter"
         typeName="FtmInputFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel input" >
         <choice          value="0"         name="Filter Disabled"        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="ftm_filter_fval_delay_paired[%(evenCh)]" condition="ftm_filter_fval_paired[%(evenCh)]"
         hiddenBy="!(ftm_filter_fval_paired[%(evenCh)]>0)"
         enabledBy="ftm_filter_fval_paired[%(evenCh)]>0"
         description="Even Channel Input Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*ftm_filter_fval_paired[%(evenCh)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <choiceOption key="ftm_filter_fval_paired[%(oddCh)]" condition="ftm_filter_ch%(oddCh)fval_present"
         hiddenBy="!(ftm_cnsc_secondEdge[%(oddCh)]>0)"
         enabledBy="ftm_cnsc_secondEdge[%(oddCh)]>0"
         description="Odd Channel Input Filter"
         typeName="FtmInputFilter"
         valueFormat="(%s)"
         baseType="uint8_t"
         toolTip="Selects the filter value for the channel input" >
         <choice          value="0"         name="Filter Disabled"        enum="Disabled" isDefault="true" />
         <choiceExpansion value="%(cycles)" name='=ToString(4*%(cycles))+" clock cycles"' enum='=ToString(4*%(cycles))+"_clocks"' keys="cycles" dim="1,15" />
      </choiceOption>

      <floatOption key="ftm_filter_fval_delay_paired[%(oddCh)]" condition="ftm_filter_fval_paired[%(oddCh)]"
         hiddenBy="!(ftm_filter_fval_paired[%(oddCh)]>0)"
         enabledBy="ftm_filter_fval_paired[%(oddCh)]>0"
         description="Odd Channel Input Filter Delay"
         toolTip="Calculated delay"
         ref="(4.0*ftm_filter_fval_paired[%(oddCh)])/inputClockFrequency"
         derived="true"
         locked="true"
         units="s"
         min="0.0"
      />

      <binaryOption key="ftm_cnsc_icrst_paired[%(oddCh)]" condition="ftm_cnsc_icrst_present"
         hiddenBy="!(ftm_cnsc_mode_even[%(evenCh)]>=3)"
         enabledBy="ftm_cnsc_mode_even[%(evenCh)]>=3"
         valueFormat="FTM_CnSC_ICRST(%s)"
         typeName="FtmChannelReset"
         baseType="uint8_t"
         description="Reset counter on 2nd IC event"
         toolTip="Enables the channel IC event to reset the shared counter" >
         <choice value="0" name="Disabled"                   enum="Disabled" />
         <choice value="1" name="Counter is reset on event"  enum="CounterReset"  />
      </binaryOption>

   </for>
</if>
   </category>

<!--  ____  Channel Configuration  ________________ -->

   <categoryOption key="Channels" description="Channel Configuration" hiddenBy="mode==(None,Quad)" >

      <for keys="    Num : evenCh : oddCh"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <if condition="=%(evenCh) >=_channelCount">
            <break/>
         </if>

         <constant key="channelPairing[%(evenCh)]" value="false" condition="!ftm_combine_combine%(Num)_present" type="Boolean"/>

         <binaryOption key="channelPairing[%(evenCh)]" condition="ftm_combine_combine%(Num)_present"
            enabledBy="mode==Left"
            description="Channel %(evenCh) &amp; %(oddCh) Pairing"
            toolTip="This allows the paired channels to operate in Combine or Dual edge modes" >

            <choice value="0" name="Channels %(evenCh) &amp; %(oddCh) operate independently"
               toolTip="Operation in \n
                  - Input capture\n
                  - Output compare\n
                  - Edge or Centre aligned PWM"
            />
            <choice value="1" name="Channels %(evenCh) &amp; %(oddCh) are paired"
               toolTip="Operation in \n
                  - Dual-edge Input capture\n
                  - Combined PWM"
            />
         </binaryOption>

      <!-- ... Calculation of pin use (in independent and paired modes) .... -->

      <if condition="ftm_combine_present">
         <!-- Even channel -->
         <variable key="inputModeCh%(evenCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(evenCh)]==(1,2,3))||(ftm_cnsc_mode_even[%(evenCh)]>=3)" />

         <!-- Odd channel -->
         <variable key="inputModeCh%(oddCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(oddCh)]==(1,2,3))||(ftm_cnsc_mode_even[%(evenCh)]>=3)" />

         <!-- Even channel -->
         <variable key="outputModeCh%(evenCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(evenCh)]>=4)||(ftm_cnsc_mode_even[%(evenCh)]==(1,2))" />

         <!-- Odd channel -->
         <variable key="outputModeCh%(oddCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(oddCh)]>=4)||(ftm_cnsc_secondOutput[%(oddCh)]==1)" />
      <else/>
         <!-- Even channel -->
         <variable key="inputModeCh%(evenCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(evenCh)]==(1,2,3))" />

         <!-- Odd channel -->
         <variable key="inputModeCh%(oddCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(oddCh)]==(1,2,3))" />

         <!-- Even channel -->
         <variable key="outputModeCh%(evenCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(evenCh)]>=4)" />

         <!-- Odd channel -->
         <variable key="outputModeCh%(oddCh)" type="Boolean"
            expression="(ftm_cnsc_mode_independent[%(oddCh)]>=4)" />
      </if>

      <!-- Even channel -->
      <variable key="Ch%(oddCh)PinInUse" type="Boolean"
         expression="outputModeCh%(oddCh)||inputModeCh%(oddCh)" />

      <!-- Odd channel -->
      <variable key="Ch%(evenCh)PinInUse" type="Boolean"
         expression="outputModeCh%(evenCh)||inputModeCh%(evenCh)" />

      </for>

      <for keys="    Num : evenCh : oddCh"
           values="   0  :   0  :   1;
                      1  :   2  :   3;
                      2  :   4  :   5;
                      3  :   6  :   7" >
         <if condition="=%(evenCh) >=_channelCount">
            <break/>
         </if>

         <list name="*" hiddenBy="channelPairing[%(evenCh)]" >
            <!-- Independent channels -->

            <!-- Even channels -->
            <title description="Channel %(evenCh)" />

            <aliasOption key="ftm_cnsc_mode_independent[%(evenCh)]"         locked="false" />
            <aliasOption key="ftm_cnsc_action_independent[%(evenCh)]"       locked="false" />
            <aliasOption key="ftm_filter_fval_independent[%(evenCh)]"       locked="false" optional="discard" />
            <aliasOption key="ftm_filter_fval_delay_independent[%(evenCh)]"                optional="discard" />
            <aliasOption key="ftm_cnsc_icrst_independent[%(evenCh)]"        locked="false" optional="discard" />
            <aliasOption key="ftm_cnv_independent[%(evenCh)]"               locked="false" />
            <aliasOption key="ftm_cnvEventTime_independent[%(evenCh)]"      locked="false" />
            <aliasOption key="ftm_cnvHighTime_independent[%(evenCh)]"       locked="false" />
            <aliasOption key="ftm_cnvDutyCycle_independent[%(evenCh)]"      locked="false" />

            <!-- Odd channels -->
            <title description="Channel %(oddCh)" />

            <aliasOption key="ftm_cnsc_mode_independent[%(oddCh)]"         locked="false" />
            <aliasOption key="ftm_cnsc_action_independent[%(oddCh)]"       locked="false" />
            <aliasOption key="ftm_filter_fval_independent[%(oddCh)]"       locked="false" optional="discard" />
            <aliasOption key="ftm_filter_fval_delay_independent[%(oddCh)]"                optional="discard" />
            <aliasOption key="ftm_cnsc_icrst_independent[%(oddCh)]"        locked="false" optional="discard" />

            <aliasOption key="ftm_cnv_independent[%(oddCh)]"               locked="false" />
            <aliasOption key="ftm_cnvEventTime_independent[%(oddCh)]"      locked="false" />
            <aliasOption key="ftm_cnvHighTime_independent[%(oddCh)]"       locked="false" />
            <aliasOption key="ftm_cnvDutyCycle_independent[%(oddCh)]"      locked="false" />
         </list>

<if condition="ftm_combine_present">

         <list name="*" hiddenBy="!channelPairing[%(evenCh)]" condition="ftm_combine_combine%(Num)_present" >

            <!-- Paired channels -->
            <title description="Paired channels %(evenCh) &amp; %(oddCh)" />

            <aliasOption key="ftm_cnsc_mode_even[%(evenCh)]"    locked="false" />
            <aliasOption key="ftm_cnsc_secondEdge[%(oddCh)]"    locked="false" />
            <aliasOption key="ftm_cnsc_secondOutput[%(oddCh)]"  locked="false" />

            <aliasOption key="ftm_cnsc_icrst_paired[%(oddCh)]"  locked="false"  optional="discard" />

            <aliasOption key="ftm_cnv_paired[%(evenCh)]"        locked="false" />
            <aliasOption key="ftm_cnv_paired[%(oddCh)]"         locked="false" />
            <aliasOption key="ftm_pwmHighTime[%(evenCh)]"   />
            <aliasOption key="ftm_pwmDutyCycle[%(evenCh)]"  />

            <!-- Controlled by ftm_cnsc_mode_even
            <aliasOption key="ftm_combine_combine[%(Num)]"  />
            <aliasOption key="ftm_combine_decapen[%(Num)]"  />
            -->
            <aliasOption key="ftm_combine_decap%(Num)"      locked="false" />
            <aliasOption key="ftm_combine_comp%(Num)"       locked="false" />
            <aliasOption key="ftm_combine_faulten%(Num)"    locked="false" />
            <aliasOption key="ftm_combine_dten%(Num)"       locked="false" />
            <aliasOption key="ftm_combine_syncen%(Num)"     locked="false" />

            <aliasOption key="ftm_cnsc_action_paired[%(evenCh)]"  locked="false" />
            <aliasOption key="ftm_cnsc_action_paired[%(oddCh)]"   locked="false" />

            <aliasOption key="ftm_filter_fval_paired[%(evenCh)]"       locked="false" optional="discard" />
            <aliasOption key="ftm_filter_fval_delay_paired[%(evenCh)]"                optional="discard" />
            <aliasOption key="ftm_filter_fval_paired[%(oddCh)]"        locked="false" optional="discard" />
            <aliasOption key="ftm_filter_fval_delay_paired[%(oddCh)]"                 optional="discard" />

            <aliasOption key="ftm_cnsc_icrst_paired[%(ch)]"  locked="false"  optional="discard" />
            <aliasOption key="ftm_cnsc_icrst_paired[%(ch)]"  locked="false"  optional="discard" />
         </list>
</if>
      </for>
   </categoryOption>

   <!-- ____ Run-time Checks ____ -->

   <categoryOption description="Run-time checks" key="runtimeChecks"
      hiddenBy="mode!=(Left,Centre)"
   >

      <binaryOption key="check_minimums"
         enabledBy="enablePeripheralSupport"
         description="Check minimum interval and resolution"
         toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
         <choice value="0" name="No checks done" />
         <choice value="1" name="Do checks"  isDefault="true" />
      </binaryOption>

      <intOption key="minimumInterval"
         enabledBy="check_minimums"
         description="Minimum usable interval in ticks"
         toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
                  when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
         value="20" min="0" max="65535"/>

      <intOption key="minimumResolution"
         enabledBy="check_minimums"
         description="Minimum resolution for PWM interval"
         toolTip="This value is used as a minimum value for the timer period in ticks \n
            so that a reasonable resolution is available for PWM duty-cycle"
         value="100" min="0" max="65535" />
   </categoryOption>

   <!-- ____ Miscellaneous ______________ -->

   <categoryOption key="Miscellaneous" description="Miscellaneous"
      hiddenBy="mode==(None,Quad)"
   >
      <!-- not sensible to initialise these -->
      <!-- binaryOption key="ftm_mode_captest" condition="ftm_mode_captest_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmCaptestMode"
         description="Capture Test Mode Enable" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption -->

      <binaryOption key="ftm_mode_pwmsync" condition="ftm_mode_pwmsync_present"
         hidden="true"
         hiddenBy="ftm_synconf_syncmode"
         enabledBy="enablePeripheralSupport&amp;&amp;!ftm_synconf_syncmode"
         typeName="FtmPwmSyncMode"
         baseType="uint8_t"
         description="PWM Synchronisation Mode"
         toolTip="Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM\n
                  counter synchronisation.\n
                  Only available in legacy PWM synchronisation (SYNCMODE = 0)." >
         <choice name="Unrestricted"  value="0" enum="NoRestrictions"
               toolTip="MOD, CnV, OUTMASK and FTM counter synch may use software or hardware trigger" />
         <choice name="Restricted"    value="1" enum="Restricted"
               toolTip="MOD and CnV use software trigger, OUTMASK and counter synch use hardware trigger" />
      </binaryOption >

      <aliasOption key="ftm_outinit_choi" locked="false" optional="true" />

      <!-- ____ POL ______________ -->

      <!-- choiceOption key="ftm_pol_pol_masks" condition="ftm_pol_present"
         valueFormat="%s"
         hidden="true"
         derived="true"
         typeName="FtmPolarity"
         baseType="uint16_t"
         description="Channel Output Polarity"
         toolTip="Bitmask defining the active-low channel outputs (1=ActiveLow).\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1." >
         <choiceExpansion name="Ch%(ch) Active-low"  enum="Ch%(ch)ActiveLow"  value='=Format("0x%04XU",0xFF00+(1&lt;&lt;(%(ch))))'            keys="ch" dim="8"/>
         <choice          name="All Active-low"      enum="AllActiveLow"      value='0xFFFFU' />
         <choiceExpansion name="Ch%(ch) Active-high" enum="Ch%(ch)ActiveHigh" value='=Format("0x%04XU",0xFF00^(1&lt;&lt;(%(ch)+8)))' keys="ch" dim="8"/>
         <choice          name="All Active-high"     enum="AllActiveHigh"     value='0x0000U' />
      <choiceOption -->

      <bitmaskOption key="ftm_pol_pol" condition="ftm_pol_present"
         enabledBy="enablePeripheralSupport"
         valueFormat="%s"
         typeName="FtmPolarity"
         baseType="uint16_t"
         description="Channel Output Polarity"
         toolTip="Bitmask defining the active-low channel outputs (1=ActiveLow).\n
                  This field is write protected. It can be written only when MODE[WPDIS] = 1."
         value="0"
         generateOperators="true"
         bitDescription='@SignalList("^(FTM\d_CH\d)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","$4")'
         bitList="Ch%iActiveLow"
         bitmask="=(1&lt;&lt;_channelCount)-1" />

      <!-- ____ MODE ______________ -->

      <binaryOption key="ftm_mode_wpdis" condition="ftm_mode_wpdis_present"
         locked="true"
         enabledBy="enablePeripheralSupport"
         baseType="uint8_t"
         typeName="FtmWriteProtect"
         description="Write Protection Disable"
         toolTip="This value is applied after main FTM configuration" >
         <choice name="Write protection is enabled."    value="0" enum="Enabled"  />
         <choice name="Write protection is disabled"    value="1" enum="Disabled" isDefault="true" />
      </binaryOption >

      <binaryOption key="ftm_mode_ftmen" condition="ftm_mode_ftmen_present"
         locked="true"
         enabledBy="enablePeripheralSupport"
         baseType="uint8_t"
         typeName="FtmRegisterSet"
         description="FTM Mode Enable"
         toolTip="This field is write protected. It can be written only when MODE[WPDIS] = 1" >
         <choice name="TPM registers only available"  value="0" enum="ftmRegistersOnly" />
         <choice name="All registers available"       value="1" enum="AllRegisters"     isDefault="true" />
      </binaryOption >

      <!-- ____ CONF ______________ -->

      <choiceOption key="ftm_conf_bdmmode" condition="ftm_conf_bdmmode_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmBdmmode"
         baseType="uint16_t"
         description="Behaviour in BDM Mode"
         toolTip="Selects the FTM behavior in Debug mode.">
         <choice name="Stopped, outputs functional"            value="0" enum="Stopped_OutputsFunctional" />
         <choice name="Stopped, outputs forced to safe value"  value="1" enum="Stopped_OutputsSafeValue"  />
         <choice name="Stopped, outputs frozen"                value="2" enum="Stopped_OutputsFrozen"     />
         <choice name="Functioning"                            value="3" enum="Functioning"               />
      </choiceOption >

      <intOption key="ftm_conf_numtof" condition="ftm_conf_numtof_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmOverflowDivider"
         baseType="uint16_t"
         description="TOF Frequency"
         toolTip="Selects the ratio between counter overflows and the number of times the TOF bit is set.\n
                  The TOF is set for the 1st overflow and then ignored for N further overflows."
         min="0" max="31"
         value="0"
      />

      <!-- ____ Global timebase ______________ -->

      <title description="Global timebase" condition="ftm_conf_gtbeout_present||ftm_conf_gtbeen_present" />

      <binaryOption key="ftm_conf_gtbeout" condition="ftm_conf_gtbeout_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmGlobalTimebaseOutput"
         baseType="uint16_t"
         description="Global Time Base Output"
         toolTip="Enables the global time base signal generation to other FTMs" >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

      <binaryOption key="ftm_conf_gtbeen" condition="ftm_conf_gtbeen_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmGlobalExternalTimebase"
         baseType="uint16_t"
         description="External Global Time Base Enable"
         toolTip="Configures the FTM to use an external global time base signal that is generated by another FTM." >
         <choice name="Disabled"    value="0" enum="Disabled"/>
         <choice name="Enabled"     value="1" enum="Enabled"/>
      </binaryOption >

   </categoryOption>

   <!-- ____ SWOCTRL __________________ -->

   <!-- Not sensible to configure statically -->
   <choiceOption key="ftm_swoctrl_chNocv"
      condition="/FTM0/ftm_swoctrl_ch0oc_present||/FTM1/ftm_swoctrl_ch0oc_present||
                 /FTM2/ftm_swoctrl_ch0oc_present||/FTM3/ftm_swoctrl_ch0oc_present"
      hidden="true"
      valueFormat="%s"
      enabledBy="enablePeripheralSupport"
      typeName="FtmForceOutput"
      description="Channel Output Control"
      toolTip="Enables and selects value to force to channel output\n
               Each value controls an individual bit\n
               Non-conflicting values may be ORed together to affect multiple bits" >
      <choice          name="No outputs forced"      enum="NotForced" value="0" />
      <choiceExpansion name="Force Ch%(ch) output 0" enum="Ch%(ch)Forced0" value='=Format("0x%04X", (1&lt;&lt;(%(ch)+8))|(0&lt;&lt;%(ch)))' dim="8" keys="ch" />
      <choiceExpansion name="Force Ch%(ch) output 1" enum="Ch%(ch)Forced1" value='=Format("0x%04X", (1&lt;&lt;(%(ch)+8))|(1&lt;&lt;%(ch)))' dim="8" keys="ch" />
   </choiceOption >

  <!-- ____ PWM synchronisation ________________ -->

   <categoryOption key="synchronisationConfiguration"
      description="Synchronisation Configuration"
      hiddenBy="mode!=(Left,Centre)" toolTip="Only applies in combine mode" >

      <aliasOption key="ftm_synconf_syncmode"   locked="false" optional="true" />
      <aliasOption key="ftm_mode_pwmsync"       locked="false" optional="true" />
      <aliasOption key="ftm_sync_reinit"        locked="false" optional="true" />
      <aliasOption key="ftm_sync_trig"          locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwtrigmode" locked="false" optional="true" />

      <title description="Load Points" condition="ftm_sync_cntmin_present||ftm_sync_cntmax_present" />
      <aliasOption key="ftm_sync_cntmin" locked="false" optional="true" />
      <aliasOption key="ftm_sync_cntmax" locked="false" optional="true" />

      <title description="Synchronisation" condition="ftm_synconf_present" />
      <aliasOption key="ftm_synconf_cntinc"   locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swwrbuf"  locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwwrbuf"  locked="false" optional="true" />
      <aliasOption key="ftm_sync_synchom"     locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swom"     locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwom"     locked="false" optional="true" />
      <aliasOption key="ftm_synconf_invc"     locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swinvc"   locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwinvc"   locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swoc"     locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swsoc"    locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwsoc"    locked="false" optional="true" />
      <aliasOption key="ftm_synconf_swrstcnt" locked="false" optional="true" />
      <aliasOption key="ftm_synconf_hwrstcnt" locked="false" optional="true" />
   </categoryOption>

   <categoryOption key="triggerGeneration" description="Trigger Generation"
      hiddenBy="mode!=(Left,Centre)" toolTip="Only applies in combine mode" >

      <choiceOption key="ftm_exttrig_trig_enum" condition="ftm_exttrig_inittrigen_present"
         derived="true"
         valueFormat="%s"
         typeName="FtmExternalTrigger"
         baseType="uint8_t"
         generateOperators="true"
         enumOr="true"
         description="External Trigger Enable"
         toolTip="Bitmask enabling generation of the external trigger when the FTM\n
                  counter is equal to a channel CnV register or CNTIN" >
         <choiceExpansion enum="OnCh%(ch)Match"  name="Trigger when CNT == Ch%(ch)" value='1&lt;&lt;%(b)' keys="ch:b" values="0:2;1:3;2:4;3:5;4:0;5:1"/>
         <choice          enum="OnCntinMatch"    name="Trigger when CNT == CNTIN"   value='1&lt;&lt;6'   />
      </choiceOption >

<!-- 
   
      <equation key="triggerChannels" value="" />
      <for keys="ch" values="2;3;4;5;0;1" >
         <equation key="triggerChannels"
            condition="ftm_exttrig_ch%(ch)trig_present"
            value='=triggerChannels+"Ch%(ch),"'
          />
         <equation key="triggerChannels"
            condition="!ftm_exttrig_ch%(ch)trig_present"
            value='=triggerChannels+","'
          />
      </for>

      <equation key="triggerChannels"
         condition="ftm_exttrig_inittrigen_present"
         value='=triggerChannels+"Cntin"' />

      <printVar key="triggerChannels" />

      <bitmaskOption key="ftm_exttrig_trig" condition="ftm_exttrig_inittrigen_present"
         enabledBy="enablePeripheralSupport"
         description="External Trigger Enable"
         toolTip="Bitmask enabling generation of the external trigger when the FTM\n
                  counter is equal to a channel CnV register or CNTIN"
         valueFormat="%s"
         generateAsConstants="true"
         typeName="FtmExternalTrigger"
         baseType="uint8_t"
         generateEnum="false"
         value="0"
         bitmask="0"
         bitList="=triggerChannels"
         bitDescription='\@SignalDescription("$(_NAME)_"+ToUpperCase("%n"),"^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","Trigger on $4")'
         />
         
-->
   <bitfieldOption key="ftm_exttrig_trig" condition="ftm_exttrig_inittrigen_present"
         enabledBy="enablePeripheralSupport"
         description="External Trigger Enable"
         toolTip="Bitmask enabling generation of the external trigger when the FTM\n
                  counter is equal to a channel CnV register or CNTIN"
         valueFormat="%s"
         generateOperators="true"
         typeName="FtmExternalTrigger"
         baseType="uint8_t"
         generateEnum="false"
         value="0"
         bitmask="0" >
         
      <bitFieldExpansion 
            name="OnCh%(ch)Match"
            bit="%(bit)" 
            description='@SignalDescription("$(_NAME)_CH%(ch)","^(.*?)\|(.*?)\|(.*?)\|(.*?)\|(.*?)$","Trigger when CNT = CH%(ch) - $4")'
            condition='SignalExists("$(_NAME)_CH%(ch)")' 
            signal="$(_NAME)_CH%(ch)"
            keys="ch:bit" 
            values="2:0; 3:1; 4:2; 5:3; 0:4; 1:5" />
      <bitField name="OnCntinMatch" bit="6" description="Trigger on CNT = CNTIN" />
   </bitfieldOption>
   
   </categoryOption>

   <!-- ************* DEADTIME ****************** -->

   <categoryOption key="deadTime" description="Deadtime" condition="ftm_deadtime_present"
      toolTip="Dead-time insertion"
      hiddenBy="mode==(None,Quad)"
      >

      <choiceOption key="ftm_deadtime_dtps" condition="ftm_deadtime_dtps_present"
         enabledBy="enablePeripheralSupport"
         typeName="FtmDeadtimePrescale"
         baseType="uint8_t"
         description="Dead-time Prescaler Value"
         toolTip="Scale value for dead-time" >
         <choice name="Divide by 1"   value="0" enum="DivideBy1"/>
         <choice name="Divide by 4"   value="2" enum="DivideBy4"/>
         <choice name="Divide by 16"  value="3" enum="DivideBy16"/>
      </choiceOption >

      <intOption key="ftm_deadtime_dtval" condition="ftm_deadtime_dtval_present"
         enabledBy="enablePeripheralSupport"
         units="ticks"
         baseType="uint8_t"
         description="Dead-time Value"
         toolTip="This tick value is scaled by the dead-time prescaler"
         min="0" max="0x3F"
      />

      <timeOption key="ftm_deadtime" condition="ftm_deadtime_dtval_present"
         ref="ftm_deadtime_dtval*((ftm_deadtime_dtps==0)?1:((ftm_deadtime_dtps==1)?4:16))"
         periodEquation="ftm_deadtime*((1.0)//SIM/system_bus_clock[0])"
         description="Calculated dead-time"
         toolTip="Dead-time calculated using clock specified in clocking"
         units="ticks"
       />
   </categoryOption>

   <!-- ____ Fault Control __________________ -->
   <constant key="_control" />
   <xi:include href="ftm_fault.xml"/>
   <deleteVariables variables="_control"/>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_control" />
   <xi:include href="ftm_quadrature_decoder.xml"/>
   <deleteVariables variables="_control"/>

   <!-- ____ Info class members ____________ -->

   <variableTemplate variables="minimumResolution"
   ><![CDATA[
      \t// %description
      \t// (%variables)
      \tstatic constexpr uint32_t minimumResolution  = $(?check_minimums:$(minimumResolution):0);\n\n
   ]]></variableTemplate>

   <variableTemplate variables="minimumInterval"
   ><![CDATA[
      \t// %description
      \t// (%variables)
      \tstatic constexpr uint32_t minimumInterval  = $(?check_minimums:$(minimumInterval):0);\n\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)/static_functions" where="all"
      discardRepeats="true"
      variables="ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps"
      nonDefaultParams="2"
   ><![CDATA[
      \t/**
      \t * Enables clock to peripheral and configures all pins.
      \t * Configures main operating settings for timer.
      \t * (%variables)
      \t *
      %paramDescription
      \t */
      \tstatic void configure(%params) {
      \t
      \t   // Enable clock to peripheral
      \t   Info::enable();
      \t
      \t   // Disable timer to change settings
      \t   %register = 0;
      \t
      \t   // Make sure write has completed (disabled)
      \t   (void)(%register);
      \t
      \t   // Write new value
      \t   %register = %paramExpression;
      \t}\n\n
   ]]></variableTemplate>

   <template key="/$(_BASENAME)/static_functions" where="all"
      discardRepeats="true"
   ><![CDATA[
      \t/**
      \t * Truncate Tick value to correct range for modulo calculations.
      \t *
      \t * @param ticks Value to truncate in Ticks
      \t *
      \t * @return Truncated value in Ticks
      \t */
      \tstatic Ticks modulo(const Ticks &ticks) {
      \t
      \t   return Ticks(unsigned(ticks) & FTM_CNT_COUNT_MASK);
      \t}\n\n
   ]]></template>

<!--  ___ Static/Non-Static Methods ______________ -->
   <for  keys="   key                  : static    : const    : getInputClockFrequency         : channel : Ftm       : isStatic : namespace"
         values=" non_static_functions : ''        : ' const' : getInputClockFrequencyVirtual  : CHANNEL : FtmBase   : false    : all;
                  static_functions     : 'static ' : ''       : 'Info::getInputClockFrequency' : channel : OwningFtm : true     : forceInfo
   " >
      <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
         discardRepeats="true"
         variables="ftm_sc_clks,ftm_sc_ps"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t * (%variables)
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask0);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void selectClock(%params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         \t
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         \t
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         \t
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></variableTemplate>

      <for keys="  f            :  n"
         values=" ftm_sc_cpwms  : CountMode;
                  ftm_sc_clks   : ClockSource;
                  ftm_sc_ps     : Prescaler" >
         <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t * (%variables)
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
            \t
            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;
            \t
            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);
            \t
            \t   // Write new value
            \t   %register = %registerName;
            \t}
            \t
            \t/**
            \t * Get %description
            \t *
            %paramDescription
            \t */
            \t%(static)%paramType get%(n)()%(const) {
            \t
            \t   return (%paramType)(%register&~%mask);
            \t}\n\n
         ]]></variableTemplate>
      </for>

      <for keys="  f           :  n"
         values=" ftm_mod_mod  : CounterMaximumValue" >
         <variableTemplate key="/$(_BASENAME)/%(key)" where="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2"
         ><![CDATA[
            \t/**
            \t * Set %description
            \t * This value is write-buffered and updated by CNTIN synchronisation
            \t * (%variables)
            \t *
            %paramDescription
            \t *
            \t * @note This function will affect all channels of the timer.
            \t */
            \t%(static)void set%(n)(%params)%(const) {
            \t
            \t   // Write new value
            \t   %register = %paramExpression;
            \t}
            \t
            \t/**
            \t * Get %description
            \t * (%variables)
            \t *
            %paramDescription
            \t */
            \t%(static)%returnType get%(n)()%(const) {
            \t
            \t   return %returnType(%register);
            \t}\n\n
         ]]></variableTemplate>
      </for>

      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Set period
         \t *
         \t * @param[in] period   Period in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note The counter load value (CNTIN) is cleared
         \t * @note The counter modulo value (MOD) is modified to obtain the requested period
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setPeriod(Seconds period)%(const) {
         \t
         \t   uint16_t modValue = 0;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   float inputClock = %(getInputClockFrequency)((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
         \t   ErrorCode rc = FtmCommonInfo::calculateTimingParameters(inputClock, period, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC  = 0;
         \t
         \t   // Configure for modulo operation
         \t   ftm->MOD = modValue;
         \t
         \t   // Clear counter
         \t   ftm->CNT = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Set maximum interval for input-capture or output compare.
         \t * Input Capture and Output Compare will be able to operate over
         \t * at least this period without overflow.
         \t *
         \t * @param[in] interval Interval in seconds as a float
         \t *
         \t * @return E_NO_ERROR  => success
         \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled).
         \t * @return E_TOO_LARGE  Requested period is too large.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note Adjusts Timer pre-scaler to appropriate value.
         \t * @note Counter is configured for free-running mode i.e. 0-65535
         \t * @note The Timer is stopped while being modified.
         \t * @note The Timer counter is restarted from zero
         \t */
         \t%(static)ErrorCode setMaximumInterval(Seconds interval)%(const) {
         \t
         \t   uint16_t       modValue;
         \t
         \t   uint8_t sc = ftm->SC;
         \t
         \t   float inputClock = %(getInputClockFrequency)((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
         \t   ErrorCode rc = FtmCommonInfo::calculateTimingParameters(inputClock, interval, sc, modValue);
         \t   if (rc != E_NO_ERROR) {
         \t      return rc;
         \t   }
         \t
         \t   // Disable timer to change prescaler and period
         \t   ftm->SC  = 0;
         \t
         \t   // Configure for free-running mode
         \t   // This is the usual value for IC or OC set-up
         \t   ftm->MOD = 0_ticks;
         \t
         \t   // Clear counter
         \t   ftm->CNT = 0;
         \t
         \t   // Set prescale and enable timer
         \t   ftm->SC  = sc;
         \t
         \t   return E_NO_ERROR;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Get frequency of timer tick
         \t *
         \t * @return Timer frequency in Hz
         \t */
         \t%(static)float getTickFrequencyAsFloat()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   float prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}
         \t
         \t/**
         \t * Get clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz (may underflow)
         \t */
         \t%(static)uint32_t getTickFrequencyAsInt()%(const) {
         \t
         \t   // Calculate timer prescale factor
         \t   int prescaleFactor = 1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);
         \t
         \t   return %(getInputClockFrequency)((FtmClockSource)(ftm->SC&FTM_SC_CLKS_MASK))/prescaleFactor;
         \t}\n\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Convert time in microseconds to time in ticks
         \t *
         \t * @param[in] time Time in microseconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t * @note Will set error code if calculated value is less the Timer minimum resolution
         \t */
         \t%(static)Ticks convertMicrosecondsToTicks(int time)%(const) {
         \t
         \t   // Calculate period
         \t   uint32_t tickRate = getTickFrequencyAsInt();
         \t   uint64_t rv       = (static_cast<uint64_t>(time)*tickRate)/1000000;
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if constexpr (Info::minimumInterval>0) {
         \t      if (rv < Info::minimumInterval) {
         \t         // Attempt to set too short a period
         \t         setErrorCode(E_TOO_SMALL);
         \t      }
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Converts time in seconds to time in ticks
         \t *
         \t * @param[in] seconds Time interval in seconds
         \t *
         \t * @return Time in ticks
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value (see setMaximumInterval()). \n
         \t * @note Will set error code if calculated value is less the minimum resolution
         \t */
         \t%(static)Ticks convertSecondsToTicks(Seconds seconds)%(const) {
         \t
         \t   // Calculate period
         \t   float    tickRate = getTickFrequencyAsFloat();
         \t   uint64_t rv       = rintf((float)seconds*tickRate);
         \t   usbdm_assert(rv <= 0xFFFFUL, "Interval is too long");
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   if (rv < Info::minimumInterval) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t   return Ticks(uint32_t(rv));
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in microseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in microseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMicroseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in milliseconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in milliseconds
         \t *
         \t * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
         \t */
         \t%(static)uint32_t convertTicksToMilliseconds(Ticks timeInTicks)%(const) {
         \t
         \t   // Calculate period
         \t   uint64_t rv = (static_cast<uint64_t>((unsigned)timeInTicks)*1000)/getTickFrequencyAsInt();
         #ifdef DEBUG_BUILD
         \t   if (rv > 0xFFFFUL) {
         \t      // Attempt to set too long a period
         \t      setErrorCode(E_TOO_LARGE);
         \t   }
         \t   if (rv == 0) {
         \t      // Attempt to set too short a period
         \t      setErrorCode(E_TOO_SMALL);
         \t   }
         #endif
         \t   return rv;
         \t}
         \t
         \t/**
         \t * Convert time in ticks to time in seconds
         \t *
         \t * @param[in] timeInTicks Time in ticks
         \t *
         \t * @return Time in seconds
         \t */
         \t%(static)Seconds convertTicksToSeconds(Ticks timeInTicks)%(const) {
         \t   return static_cast<float>((unsigned)timeInTicks)/getTickFrequencyAsFloat();
         \t}
         \t/**
         \t * Get Timer count
         \t *
         \t * @return Timer count value
         \t */
         \t%(static)uint16_t getTime()%(const) {
         \t   return ftm->CNT;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Reset counter to initial value
         \t */
         \t%(static)void resetTime()%(const) {
         \t   // Note: writing ANY value loads CNT from CNTIN
         \t   ftm->CNT = 0;
         \t}
         \t
         \t/**
         \t * Get channel event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t */
         \t%(static)unsigned getChannelEventFlags()%(const) {
         \t   return ftm->STATUS;
         \t}
         \t
         \t/**
         \t * Get and clear channel event flags
         \t *
         \t * @return Flags indicating if an event has occurred on a channel
         \t *         There is one bit for each channel
         \t *
         \t * @note Only flags captured in the return value are cleared
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)unsigned getAndClearChannelEventFlags()%(const) {
         \t   // Note requires read and write zero to clear flags
         \t   // so only flags captured in status are cleared
         \t   unsigned status = ftm->STATUS;
         \t   ftm->STATUS = ~status;
         \t   return status;
         \t}
         \t
         \t/**
         \t * Clear selected channels event flags
         \t *
         \t * @param channelMask Mask indicating which channel flags to clear
         \t *                    There is one bit for each channel
         \t *
         \t * @note Flags will not be cleared if the channel is configured for DMA
         \t */
         \t%(static)void clearSelectedChannelEventFlags(uint32_t channelMask)%(const) {
         \t   (void)ftm->STATUS;
         \t   ftm->STATUS = ~channelMask;
         \t}
         \t
         \t/**
         \t * Get and clear timer overflow event flag
         \t */
         \t%(static)bool getAndClearOverflowFlag()%(const) {
         \t   // Clear TOI flag (read & w0c)
         \t   unsigned status = ftm->SC;
         \t   ftm->SC = status & ~FTM_SC_TOF_MASK;
         \t   return bool(status & FTM_SC_TOF_MASK);
         \t}
         \t
         \t/**
         \t * Clear timer overflow event flag
         \t */
         \t%(static)void clearOverflowFlag()%(const) {
         \t   // Clear TOI flag (read & w0c)
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOF_MASK;
         \t}
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" location="%(namespace)" discardRepeats="true" condition="ftm_exttrig_inittrigen_present&amp;&amp;%(isStatic)" ><![CDATA[
         \t/**
         \t * Enables/disable external trigger generation by a channel comparison or initialisation event
         \t *
         \t * @param[in] ftmExternalTrigger Indicates whether to use or ignore the given trigger
         \t *                               Can combine non-conflicting triggers
         \t */
         \t%(static)void enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger)%(const) {
         \t      ftm->EXTTRIG = (ftm->EXTTRIG & (ftmExternalTrigger>>8))|ftmExternalTrigger;
         \t}
         \t
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Enable Timer Overflow interrupts
         \t */
         \t%(static)void enableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC | FTM_SC_TOIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable Timer Overflow interrupts
         \t */
         \t%(static)void disableTimerOverflowInterrupts()%(const) {
         \t   ftm->SC = ftm->SC & ~FTM_SC_TOIE_MASK;
         \t}
         \t\n
      ]]></template>

      <template key="/$(_BASENAME)/%(key)" location="%(namespace)" discardRepeats="true" condition="ftm_mode_faultie_present" ><![CDATA[
         \t/**
         \t * Enable fault interrupts
         \t */
         \t%(static)void enableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE | FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t * Disable fault interrupts
         \t */
         \t%(static)void disableFaultInterrupt()%(const) {
         \t   ftm->MODE = ftm->MODE & ~FTM_MODE_FAULTIE_MASK;
         \t}
         \t
         \t/**
         \t *  Disables fault detection input
         \t *
         \t *  @tparam inputNum        Number of fault input to enable (0..3)
         \t */
         \ttemplate<int inputNum>
         \t%(static)void disableFault()%(const) {
         \t   static_assert(inputNum<=4, "Illegal fault channel");
         \t
         \t   // Enable fault on channel
         \t   ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<inputNum);
         \t}
         \t
         \t/**
         \t *  Enables fault detection input
         \t *
         \t *  @tparam inputNum           Number of fault input to enable (0..3)
         \t *
         \t *  @param[in]  polarity       Polarity of fault input
         \t *  @param[in]  filterEnable   Whether to enable filtering on the fault input
         \t *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
         \t *
         \t *  @note The filter delay is shared by all inputs
         \t */
         public:
         \ttemplate<uint8_t inputNum>
         \t%(static)void enableFault(
         \t      Polarity polarity     = ActiveHigh,
         \t      bool     filterEnable = false,
         \t      uint32_t filterDelay  = FTM_FLTCTRL_FFVAL_MASK>>(FTM_FLTCTRL_FFVAL_SHIFT+1))%(const) {
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" location="%(namespace)" condition="/PCR/_present&amp;&amp;ftm_mode_faultie_present" codeGenCondition="%(isStatic)" ><![CDATA[
         #ifdef DEBUG_BUILD
         \t   static_assert((inputNum<InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
         \t   static_assert((inputNum>=InfoFAULT::numSignals)||(InfoFAULT::info[inputNum].pinIndex != PinIndex::UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
         \t   static_assert((inputNum>=InfoFAULT::numSignals)||(InfoFAULT::info[inputNum].pinIndex != PinIndex::INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
         \t   static_assert((inputNum>=InfoFAULT::numSignals)||(InfoFAULT::info[inputNum].pinIndex == PinIndex::UNMAPPED_PCR)||(InfoFAULT::info[inputNum].pinIndex == PinIndex::INVALID_PCR)||(InfoFAULT::info[inputNum].pinIndex >= PinIndex::MIN_PIN_INDEX), "Pcr_T: Illegal signal used for fault");
         #endif
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" location="%(namespace)" condition="/PCR/_present&amp;&amp;ftm_mode_faultie_present" codeGenCondition="%(isStatic)" ><![CDATA[
         \t   PcrTable_T<InfoFAULT, inputNum>::setPCR();
         \t\n
      ]]></template>
      <template key="/$(_BASENAME)/%(key)" location="%(namespace)" discardRepeats="true" condition="ftm_mode_faultie_present" ><![CDATA[
         \t   if (polarity) {
         \t      // Set active high
         \t      ftm->FLTPOL = ftm->FLTPOL & ~(1<<inputNum);
         \t   }
         \t   else {
         \t      // Set active low
         \t      ftm->FLTPOL = ftm->FLTPOL | (1<<inputNum);
         \t   }
         \t   if (filterEnable) {
         \t      // Enable filter & set filter delay
         \t      ftm->FLTCTRL = ((ftm->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
         \t   }
         \t   else {
         \t      // Disable filter
         \t      ftm->FLTCTRL = ftm->FLTCTRL & ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
         \t   }
         \t   // Enable fault input
         \t   ftm->FLTCTRL = ftm->FLTCTRL | (1<<inputNum);
         \t   // Enable fault mode (All channels, manual)
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_FAULTM(2);
         \t}\n\n
      ]]></template>

      <variableTemplate key="/$(_BASENAME)/%(key)" location="%(namespace)" discardRepeats="true"
         variables="ftm_pol_pol" ><![CDATA[
         \t/**
         \t * Set polarity of all channels
         \t * (%variables)
         \t *
         \t * @param channelMask   Bit mask 0 => active-high, 1 => active-low
         \t *                      This can be created by ORing together FtmPolarity_ChN_ActiveLow values
         \t */
         \t%(static)void setPolarity(uint32_t channelMask)%(const) {
         \t   ftm->POL = channelMask;
         \t}
         \t
         \t/**
         \t * Set polarity of selected channel
         \t *
         \t * @param ftmPolarity  Channel polarity to set
         \t */
         \t%(static)void setPolarity(FtmPolarity ftmPolarity)%(const) {
         \t      ftm->POL= (ftm->POL&(ftmPolarity>>8))|ftmPolarity;
         \t}\n\n
      ]]></variableTemplate>

      <template key="/$(_BASENAME)/%(key)" discardRepeats="true" ><![CDATA[
         \t/*
         \t * *****************************************************************
         \t *          Channel functions
         \t * *****************************************************************
         \t */
         \t\n
      ]]></template>

      <variableTemplate key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true"
         variables="ftm_cnsc_action_independent[], ftm_channel_number"
         nonDefaultParams="2"
      ><![CDATA[
         \t/**
         \t * Set action on event
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void setAction(%params) %(const) {
         \t
         \t   ftm->CONTROLS[ftmChannelNum].CnSC =
         \t      (ftm->CONTROLS[ftmChannelNum].CnSC&~%mask) | ftmChannelAction;
         \t}
         \t\n
      ]]></variableTemplate>

      <template key="/$(_BASENAME)/%(key)" where="all" discardRepeats="true" ><![CDATA[
         \t/**
         \t * Set PWM duty cycle.
         \t * Higher precision float version
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage (float)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(float dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*ftm->MOD)/100.0f);
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = round((dutyCycle*(ftm->MOD+1))/100.0f);
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM duty cycle
         \t *
         \t * @param[in] dutyCycle  Duty-cycle as percentage
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)void setDutyCycle(int dutyCycle, int channel)%(const) {
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*ftm->MOD)/100;
         \t   }
         \t   else {
         \t      ftm->CONTROLS[channel].CnV  = (dutyCycle*(ftm->MOD+1))/100;
         \t   }
         \t}
         \t
         \t/**
         \t * Set PWM high time in ticks
         \t * Assumes value is less than period
         \t *
         \t * @param[in] highTime   PWM high time in ticks
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t * @return E_TOO_LARGE on success
         \t *
         \t * @note The actual CnV register update may be delayed by the Register Synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Ticks highTime, int channel)%(const) {
         \t
         \t   if (ftm->SC&FTM_SC_CPWMS_MASK) {
         \t      // In CPWM the pulse width is doubled
         \t      highTime = Ticks((highTime+1_ticks)/2U);
         \t   }
         #ifdef DEBUG_BUILD
         \t   if ((unsigned)highTime > ftm->MOD) {
         \t      return setErrorCode(E_TOO_LARGE);
         \t   }
         #endif
         \t   ftm->CONTROLS[channel].CnV  = (unsigned)highTime;
         \t   return E_NO_ERROR;
         \t}
         \t
         \t/**
         \t * Get Timer event time
         \t *
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return Absolute time of last event in ticks i.e. value from timer event register
         \t */
         \t%(static)Ticks getEventTime(int channel)%(const) {
         \t   return Ticks(ftm->CONTROLS[channel].CnV);
         \t}
         \t
         \t/**
         \t * Set Timer event time
         \t *
         \t * This value is write-buffered and updated by Cnv synchronisation.
         \t *
         \t * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
         \t * @param[in] channel    Timer channel
         \t */
         \t%(static)void setEventTime(Ticks eventTime, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = (unsigned)eventTime;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current event time
         \t *
         \t * @param[in] offset     Event time in ticks relative to current event time (i.e. Timer channel CnV value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setDeltaEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CONTROLS[channel].CnV + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set Timer event time relative to current timer count value
         \t *
         \t * @param[in] offset     Event time in ticks relative to current time (i.e. Timer CNT value)
         \t * @param[in] channel    Timer channel
         \t *
         \t * @note This value is write-buffered and updated by CnV synchronisation.
         \t */
         \t%(static)void setRelativeEventTime(Ticks offset, int channel)%(const) {
         \t   ftm->CONTROLS[channel].CnV = ftm->CNT + (unsigned)offset;
         \t}
         \t
         \t/**
         \t * Set PWM high time in seconds
         \t *
         \t * @param[in] highTime   PWM high time in seconds
         \t * @param[in] channel    Timer channel
         \t *
         \t * @return E_NO_ERROR on success
         \t *
         \t * @note The actual CnV register update may be delayed by the FTM Register Synchronisation mechanism
         \t */
         \t%(static)ErrorCode setHighTime(Seconds highTime, int channel)%(const) {
         \t   return setHighTime(convertSecondsToTicks(highTime), channel);
         \t}
         \t
         \t/**
         \t * Set initial state for channels outputs
         \t *
         \t * @param initialValue  Bit mask value for channels
         \t */
         \t%(static)void setOutputInitialValue(uint32_t initialValue)%(const) {
         \t   ftm->OUTINIT = initialValue;
         \t}
         \t
         \t/**
         \t * Set output mask for channels outputs
         \t *
         \t * The mask of a channel determines if its output responds, that is,
         \t * it is masked or not, when a match occurs
         \t * This value is write-buffered and updated by PWM synchronisation.
         \t *
         \t * @param maskValue  Bit mask value 0 => not masked, 1 => masked
         \t */
         \t%(static)void setOutputMaskValue(uint32_t maskValue)%(const) {
         \t   ftm->OUTMASK = maskValue;
         \t}
         \t
         \t/**
         \t * Set inverting control
         \t *
         \t * This controls when the channel (n) and (n+1) outputs are exchanged.
         \t * Each bit enables the inverting operation for the corresponding channels pair.
         \t * This value is write-buffered and updated by INVCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels (combination of FtmChannelPair)
         \t */
         \t%(static)void setInvertedChannelPairs(uint32_t enableMask)%(const) {
         \t   ftm->INVCTRL = enableMask;
         \t}
         \t
         \t/**
         \t * Force channel outputs
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param enableMask  Bit mask for channels to be forced: 1 => forced, 0 => released
         \t * @param outputMask  Bit mask for values to be forced to selected channels
         \t */
         \t%(static)void forceChannelOutputs(uint32_t enableMask, uint32_t outputMask)%(const) {
         \t   ftm->SWOCTRL = (enableMask&0xFF)|((outputMask<<8)&0xFF00);
         \t}
         \t
         \t/**
         \t * Force channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be forced
         \t * @param value    Value to be forced on that channel
         \t */
         \t%(static)void forceChannelOutput(uint32_t channel, bool value)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOCV_SHIFT  = 8;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t   uint32_t valueMask   = 1<<(channel+FTM_SWOCTRL_CHxOCV_SHIFT);
         \t
         \t   // Set control bit + insert control value
         \t   ftm->SWOCTRL = (ftm->SWOCTRL&~valueMask) | (channelMask | (value?valueMask:0));
         \t}
         \t
         \t/**
         \t * Release forced channel output
         \t *
         \t * This enables software control of channel output and
         \t * defines the value forced to the channel output.
         \t * This value is write-buffered and updated by SWOCTRL synchronisation.
         \t *
         \t * @param channel  Number of channel to be released
         \t */
         \t%(static)void releaseChannelOutput(uint32_t channel)%(const) {
         \t   static constexpr unsigned FTM_SWOCTRL_CHxOC_SHIFT   = 0;
         \t
         \t   uint32_t channelMask = 1<<(channel+FTM_SWOCTRL_CHxOC_SHIFT);
         \t
         \t   // Release control bit
         \t   ftm->SWOCTRL = ftm->SWOCTRL & ~channelMask;
         \t}
         \t
         \t/**
         \t * Set current value of channel outputs.\n
         \t * This value is overwritten by the next channel action.
         \t *
         \t * @param channelValueMask Mask indicating desired channel outputs
         \t */
         \t%(static)void setChanelOutputs(uint32_t channelValueMask)%(const) {
         \t   ftm->OUTINIT = channelValueMask;
         \t   ftm->MODE    = ftm->MODE | FTM_MODE_INIT_MASK;
         \t}\n
      ]]></template>

   <!-- ___ Channel Functions __________________ -->

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="ftm_cnsc_action_independent[]"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    * (%variables)
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void setAction(%params)%(const) {
      \t
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t           (ftm->CONTROLS[%(channel)].CnSC & ~%mask) | %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="ftm_cnsc_mode_independent[], ftm_cnsc_action_independent[]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t
      \t   /**
      \t    * Set %description
      \t    * (%variables)
      \t    *
      %paramDescription
      \t
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void configure(%params)%(const) {
      \t
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t           (ftm->CONTROLS[%(channel)].CnSC & ~%mask) | %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="ftm_cnsc_mode_independent[]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Disables timer channel (sets mode to FtmChannelMode_Disabled)
      \t    */
      \t   %(static)void disable()%(const) {
      \t      setMode(FtmChannelMode_Disabled);
      \t   }
      \t
      \t   /**
      \t    * Get channel mode.
      \t    *
      \t    * @return Current mode of operation for the channel
      \t    */
      \t   %(static) %returnType getMode()%(const) {
      \t      return %returnType(ftm->CONTROLS[%(channel)].CnSC & %mask);
      \t   }
      \t
      \t   /**
      \t    * Set channel mode
      \t    *
      %paramDescription
      \t    *
      \t    * @note This method has the side-effect of clearing the register update synchronisation i.e.
      \t    *       pending CnV register updates are discarded.
      \t    */
      \t   %(static)void setMode(%params)%(const) {
      \t      ftm->CONTROLS[%(channel)].CnSC =
      \t            (ftm->CONTROLS[%(channel)].CnSC & ~%mask)|%paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true"
      variables="ftm_pol_pol" ><![CDATA[
      \t   /**
      \t    * Set polarity of channels.
      \t    * (%variables)
      \t    *
      \t    * @param active Polarity to set
      \t    */
      \t   %(static)void setPolarity(Polarity active)%(const) {
      \t      if (active == ActiveHigh) {
      \t         ftm->POL = ftm->POL & ~CHANNEL_MASK;
      \t      }
      \t      else {
      \t         ftm->POL = ftm->POL | CHANNEL_MASK;
      \t      }
      \t   }\n\n
      ]]></variableTemplate>

   <template key="/$(_BASENAME)_CHANNEL/%(key)" where="all" discardRepeats="true" ><![CDATA[
      \t   /**
      \t    * Set PWM high time in ticks.
      \t    * Assumes value is less than period
      \t    *
      \t    * @param[in] highTime   PWM high time in ticks
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Ticks highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM high time in seconds.
      \t    * Higher precision float version
      \t    *
      \t    * @param[in] highTime   PWM high time in seconds
      \t    *
      \t    * @return E_NO_ERROR on success
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static) ErrorCode setHighTime(Seconds highTime)%(const) {
      \t      return %(Ftm)::setHighTime(highTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle.
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDutyCycle(int dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set PWM duty cycle
      \t    *
      \t    * @param[in] dutyCycle  Duty-cycle as percentage
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDutyCycle(float dutyCycle)%(const) {
      \t      %(Ftm)::setDutyCycle(dutyCycle, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current event time (i.e. Timer channel CnV value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setDeltaEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setDeltaEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Timer event time relative to current timer count value.
      \t    *
      \t    * @param[in] offset  Event time in ticks relative to current time (i.e. Timer CNT value)
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setRelativeEventTime(Ticks offset)%(const) {
      \t      %(Ftm)::setRelativeEventTime(offset, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Set Absolute Timer event time.
      \t    *
      \t    * @param[in] eventTime  Absolute event time in ticks i.e. value to use as timer comparison value
      \t    *
      \t    * @note The actual CnV register update will be delayed by the Register Synchronisation mechanism
      \t    */
      \t   %(static)void setEventTime(Ticks eventTime)%(const) {
      \t      %(Ftm)::setEventTime(eventTime, %(channel));
      \t   }
      \t
      \t   /**
      \t    * Get Absolute Timer event time.
      \t    *
      \t    * @return Absolute time of last event in ticks i.e. value from timer event register
      \t    */
      \t   %(static) Ticks getEventTime()%(const) {
      \t      return %(Ftm)::getEventTime(%(channel));
      \t   }
      \t
      \t   /**
      \t    * Get channel event flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    */
      \t   %(static) bool getEventFlag()%(const) {
      \t      return (ftm->CONTROLS[%(channel)].CnSC&FTM_CnSC_CHF_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Get and Clear channel event flag.
      \t    *
      \t    * @return true  Indicates an event has occurred on a channel
      \t    * @return false Indicates no event has occurred on a channel since last polled
      \t    *
      \t    * @note Only flags captured in the return value are cleared
      \t    */
      \t   %(static) bool getAndClearEventFlag()%(const) {
      \t      // Note - requires read and write zero to clear flags
      \t      uint8_t cnsc = ftm->CONTROLS[%(channel)].CnSC;
      \t      ftm->CONTROLS[%(channel)].CnSC = cnsc&~FTM_CnSC_CHF_MASK;
      \t      return (cnsc&FTM_CnSC_CHF_MASK) != 0;
      \t   }
      \t
      \t   /**
      \t    * Clear channel event flag
      \t    */
      \t   %(static)void clearEventFlag()%(const) {
      \t      // Note - requires read and write zero to clear flag
      \t      ftm->CONTROLS[%(channel)].CnSC = ftm->CONTROLS[%(channel)].CnSC & ~FTM_CnSC_CHF_MASK;
      \t   }
      \t
      \t   /**
      \t    * Force channel output.
      \t    *
      \t    * This enables software control of channel output and
      \t    * defines the value forced to the channel output.
      \t    * This value is write-buffered and updated by SWOCTRL synchronisation.
      \t    *
      \t    * @param ftmChannelForce  Select control of pin. One of FtmChannelForce_Low/High/Release
      \t    */
      \t   %(static)void forceChannelOutput(FtmChannelForce ftmChannelForce)%(const) {
      \t      static const uint32_t MASK = ((1<<%(channel))|(1<<(%(channel)+8)));
      \t      ftm->SWOCTRL = ((ftm->SWOCTRL & ~MASK)) | (ftmChannelForce & MASK);
      \t   }\n\n
   ]]></template>
</for>

   <clockCodeTemplate variable="ftm_sc_clks"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      %paramDescription
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency(%params) {
      \t
      \t   switch(%paramExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!-- ___ CommonInfo class ______________ -->

   <template where="commonInfo" condition="!/$(_basename)_common_info_done" ><![CDATA[
      \t/**
      \t * Calculate FTM timing parameters to achieve a given period
      \t *
      \t * @param[in]    inputClock Input clock to Timer
      \t * @param[in]    period     Period in seconds
      \t * @param[inout] sc         Proposed FTM.SC value (must include CPWMS fields)
      \t *                          PS field is updated
      \t * @param[out]   mod        Calculated FTM.MOD values
      \t *
      \t * @return E_NO_ERROR   Success!!
      \t * @return E_TOO_SMALL  Requested period is too small for resolution (required resolution check to be enabled)
      \t * @return E_TOO_LARGE  Requested period is too large
      \t */
      \tstatic ErrorCode calculateTimingParameters(float inputClock, Seconds period, uint8_t &sc, uint16_t &mod) {
      \t
      \t   unsigned prescaleFactor=1;
      \t   unsigned prescalerValue=0;
      \t
      \t   // Check if CPWMS is set (affects period calculation)
      \t   bool centreAligned = (sc&FTM_SC_CPWMS_MASK);
      \t
      \t   constexpr uint32_t maxModValue = FTM_MOD_MOD_MASK;
      \t
      \t   while (prescalerValue<=7) {
      \t      float clock    = inputClock/prescaleFactor;
      \t      float modValueF = period*clock;
      \t      if (centreAligned) {
      \t         // PeriodInTicks = 2*MOD
      \t         modValueF = modValueF/2;
      \t      }
      \t      else {
      \t         // PeriodInTicks = MOD+1
      \t         modValueF = modValueF - 1;
      \t      }
      \t      unsigned modValue = round(modValueF);
      \t      if (modValue <= maxModValue) {
      \t         sc   = (sc&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
      \t         mod  = modValue;
      \t         return E_NO_ERROR;
      \t      }
      \t      prescalerValue++;
      \t      prescaleFactor <<= 1;
      \t   }
      \t   // Too long a period
      \t   usbdm_assert(false, "Interval is too long");
      \t   return setErrorCode(E_TOO_LARGE);
      \t}
      \t\n
   ]]></template>

   <constant key="/$(_basename)_common_info_done" condition="!/$(_basename)_common_info_done" />

<!--  ___ Init class ______________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * //
      \t * // $(_BASENAME) call-back
      \t * //
      \t * // @param status  Status reflecting active inputs
      \t * //
      \t * void $(_basename)Callback() {
      \t *    ...
      \t * }
      \t *
      \t * @code
      \t * static const $(_Class)::Init $(_Baseclass)Init {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmMode_Freerunning,           // Alignment and whether interval or free-running mode
      \t *    FtmOverflowAction_None ,       // Action on Counter overflow - No action
      \t *    NvicPriority_Normal,           // IRQ level for this peripheral
      \t *    FtmClockSource_SystemClock,    // Clock Source
      \t *
      \t *    // Either
      \t *    FtmPrescale_DivBy16,           // Clock prescaler
      \t *    3000_ticks,                    // Counter modulo (mod) value
      \t *    // OR
      \t *    100_ms,                        // Timer period or minimum interval in seconds
      \t *
      \t *    FtmInitialValue(0xf),          // Channel Output Initialisation Value
      \t *    FtmPolarity_Ch0_ActiveLow,     // Channel polarity - Make channel 0 active-low
      \t *    FtmPolarity_Ch3_ActiveLow,     // Channel polarity - Make channel 3 active-low
      \t *
      \t *    $(_name)Callback,              // Call-back to execute on event - call-back function name
      \t *    NvicPriority_Low,              // Priority for interrupt - Low
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultValue
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_Baseclass)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>

<!-- ____ Init class Member variables ________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
    ><![CDATA[
      %multilineDescription
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <for keys=" type        : variables                                         : init    "
       values="%baseType   : ftm_pol_pol                                       : 0       ;
               %baseType   : ftm_mod_mod                                       : 0       ;
               %returnType : ftm_modPeriod                                     : 0_s     ;
               %baseType   : ftm_mode_pwmsync,ftm_mode_wpdis,ftm_mode_ftmen    : 0       ;
               %baseType   : ftm_deadtime_dtps,ftm_deadtime_dtval              : 0       ;
               %baseType   : ftm_exttrig_trig                                  : 0       ;
               %baseType   : ftm_sc_action,ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps  : 0       ;
               %baseType   : ftm_conf_gtbeout,ftm_conf_gtbeen,
                             ftm_conf_bdmmode,ftm_conf_numtof,                 : 0       ">
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="/PCR/nvic_irqLevel"
   ><![CDATA[
      \t   // %description
      \t   %paramType %registerName = %defaultValue;\n\n
   ]]></variableTemplate >

<!-- ____ Init class Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoIrqGuard)"
      variables="irqHandlingMethod"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for overflow and fault interrupt call-back
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      \t    * @param %paramExpression Overflow and fault interrupt call-back to set
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(CallbackFunction %paramExpression, Types... rest) : Init(rest...) {
      \t
      \t      this->callbackFunction = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
    ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t   %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <!-- Bit set/clear in Field -->
   <for keys="r" values="
      ftm_pol_pol;
      ftm_outinit_choi;
      ftm_exttrig_trig" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      // Modify register
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <!-- Exclusive Fields -->
   <for keys="r" values="ftm_sc_action;ftm_sc_cpwms;ftm_sc_clks;
                         ftm_mode_pwmsync;ftm_mode_wpdis;ftm_mode_ftmen;
                         ftm_conf_gtbeout;ftm_conf_gtbeen;ftm_conf_bdmmode;ftm_conf_numtof;
                         ftm_deadtime_dtps, ftm_deadtime_dtval" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
         nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="ftm_sc_ps, ftm_mod_mod"
      params=",mod_ticks"
      linePadding="xxx"
      nonDefaultParams="2"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName0    = (%registerName0&~%mask0) | %paramName0;
      \t      %registerName1   = %paramName1;
      \t   }
      \t\n
   ]]></variableTemplate>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      nonDefaultParams="2"
      variables="ftm_modPeriod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      mod   = 0;
      \t      %registerName = %paramExpression;
      \t   }
      \t\n
   ]]></variableTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t}; // class $(_BasicInfo)::Init\n\n
   ]]></template>

<!-- ____ Init class Configure method ____ -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Configure FTM from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const Init &init) {
      \t
      \t   // Enable peripheral (clock and pins as needed)
      \t   enable();\n
   ]]></template>
   <template codeGenCondition="irqHandlingMethod&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   setCallbacks(init);\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   uint8_t  sc    = init.sc;
      \t   uint16_t mod   = init.mod;
      \t
      \t   if (init.modperiod != 0) {
      \t
      \t      // Calculate sc.ps, mod (assumes cntin=0 or non-existent)
      \t      const float inputClock = getInputClockFrequency((FtmClockSource)(sc&FTM_SC_CLKS_MASK));
      \t      ErrorCode rc = calculateTimingParameters(inputClock, init.modperiod, sc, mod);
      \t      if (rc != E_NO_ERROR) {
      \t         return rc;
      \t      }
      \t      if constexpr (minimumResolution>0) {
      \t         if (mod < minimumResolution) {
      \t            // Too short a period for minimum resolution
      \t            return setErrorCode(E_TOO_SMALL);
      \t         }
      \t      }
      \t   }\n
   ]]></template>
   <for keys=
          " var                                   : statement                          "
   values=" ftm_sc_action,ftm_sc_cpwms,
            ftm_sc_clks,ftm_sc_ps                 : %register = 0                      ;
            ftm_cntin                             : %register = 0                      ;
            ftm_mod_mod                           : %register = mod                    ;
            ftm_cnt_count                         : %register = 0                      ;
            ftm_sc_action,ftm_sc_cpwms,
            ftm_sc_clks,ftm_sc_ps                 : %register = sc                     ;
            ftm_mode_wpdis,ftm_mode_ftmen         : %configRegAssignment               ;
            ftm_pol_pol                           : %configRegAssignment               ;
            ftm_deadtime_dtps,ftm_deadtime_dtval  : %configRegAssignment               ;
            ftm_exttrig_trig                      : %configRegAssignment               ;
            ftm_conf_gtbeout,ftm_conf_gtbeen
            ftm_conf_bdmmode,ftm_conf_numtof      : %configRegAssignment               " >
      <variableTemplate codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)"
         variables="%(var)"
         linePadding="xxx"
      ><![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></template>

<!-- ____ Default Initialisation value ________ -->

   <!--  variableTemplate where="usbdm" codeGenCondition='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(irqHandlerName!="")'
      variables="irqHandlerName"
   ><![CDATA[
      \t/**
      \t * Handler for callback
      \t */
      \textern void $(irqHandlerName)(void);
      \t\n
   ]]>
   </variableTemplate -->
   <variableTemplate codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)"
      separator=","
      terminator=","
      padToComments="50"
      variables="
         ftm_sc_action,ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps,
         ftm_mod_mod,
         ftm_mode_wpdis, ftm_mode_ftmen,
         ftm_pol_pol,
         ftm_deadtime_dtps,ftm_deadtime_dtval,
         ftm_exttrig_trig,
         ftm_conf_gtbeout,ftm_conf_gtbeen,ftm_conf_bdmmode,ftm_conf_numtof,
         irqLevel
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression\n
      \t//  $(irqHandlerName)
      \t};
      \t\n
   ]]>
   </variableTemplate>

<!-- ___ ChannelInit class ______________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of $(_Baseclass)Channel
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::ChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    FtmChannelNum_3,            // Channel to initialise (may be unused if specifically provided as parameter)
      \t *    FtmChannelMode_Disabled ,   // Channel Mode - Disabled
      \t *    FtmChannelAction_None ,     // Action on Channel Event - No action
      \t *    FtmChannelReset_Disabled ,  // Reset counter on channel IC event - Disabled
      \t *    0_ticks,                    // Output Compare Event time
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[FtmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configure(channelInit)
      \t * @endcode
      \t */
      \tclass ChannelInit {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr ChannelInit(const ChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr ChannelInit() = default;
      \t\n
   ]]></template>

   <!-- ____ ChannelInit Class Member variables ________ -->

   <for keys=" type        : variables                         : init                 "
       values="%baseType   : ftm_cnv_independent[]             : 0                    ;
               %baseType   : ftm_cnsc_mode_independent[],
                             ftm_cnsc_action_independent[],
                             ftm_cnsc_icrst_independent[]      : 0                    ;
               %paramType  : ftm_channel_number                : %paramType_None      ;
               %baseType   : ftm_filter_fval_independent[]     : %paramType_Disabled  " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <!-- ____ ChannelInit Constructors ____________ -->

   <for keys="   r   "
      values=" ftm_channel_number;
               ftm_cnsc_mode_independent[];
               ftm_cnsc_action_independent[];
               ftm_cnsc_icrst_independent[];
               ftm_filter_fval_independent[];
               ftm_cnv_independent[]" >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="ftm_cnvDutyCycle_independent[]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr ChannelInit(%params, Types... rest) : ChannelInit(rest...) {
      \t
      \t      cnv   = roundf(10000*%paramExpression);
      \t      cnsc |= 1<<15;
      \t   }
      \t\n
   ]]></variableTemplate>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t}; // class  $(_BasicInfo)::ChannelInit\n\n
   ]]></template>

   <!-- ____ ChannelInit Configure methods ____________ -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const ChannelInit &channelInit) {
      \t   return configure(channelInit.channel, channelInit);
      \t}
      \t
      \t/**
      \t * Configure Channel from values specified in channelInit
      \t *
      \t * @param channelNum  Select channel to initialise.
      \t *                    This allows applying channelInit to arbitrary channel
      \t * @param init        Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(FtmChannelNum channelNum, const ChannelInit &init) {
      \t
      \t   // Disable clock so changes have immediate effect
      \t   uint8_t sc = ftm->SC;
      \t   ftm->SC = 0;
      \t\n
   ]]></template>
   <for keys=
            "  var                          : reg"
      values="
              ftm_cnsc_mode_independent[],
              ftm_cnsc_action_independent[],
              ftm_cnsc_icrst_independent[]  : CnSC    ;
              ftm_cnv_independent[]         : CnV     " >
      <variableTemplate codeGenCondition="enablePeripheralSupport"
         variables="%(var)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   ftm->CONTROLS[channelNum].%(reg) = init.%registerName;
         \t\n
      ]]></variableTemplate>
   </for>
   <variableTemplate codeGenCondition="enablePeripheralSupport"
      variables="ftm_filter_fval_independent[]"
      condition="ftm_filter_fval_independent[]"
      linePadding="xxx"
   ><![CDATA[
      %multilineDescription
      \t   ftm->FILTER = (ftm->FILTER & (FTM_FILTER_CH0FVAL_MASK<<(channelNum*4)))|(init.filter<<(channelNum*4));
      \t\n
   ]]></variableTemplate>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Restore clock
      \t   ftm->SC = sc;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Configure Channel from values specified in channelInit array
      \t *
      \t * @param channelInit Array containing initialisation values
      \t */
      \ttemplate<size_t N>
      \tstatic ErrorCode configure(const ChannelInit (&channelInit)[N]) {
      \t
      \t   ErrorCode rc = E_NO_ERROR;
      \t   for (size_t i=0; i<N; i++) {
      \t      rc = configure(channelInit[i].channel, channelInit[i]);
      \t      if (rc != E_NO_ERROR) {
      \t         break;
      \t      }
      \t   }
      \t   return rc;
      \t}
      \t\n
   ]]></template>

   <!-- ____ ChannelInit Default Initialisation value ____________ -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)ChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr ChannelInit DefaultChannelInitValues[] = {\n
   ]]></template>
   <for keys="ch" dim="=_channelCount" >
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(ftm_cnsc_mode_independent[%(ch)]!=0)"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_mode_independent[%(ch)],
            ftm_cnsc_action_independent[%(ch)],
            fftm_cnsc_icrst_independent[%(ch)],
            ftm_cnv_independent[%(ch)],
            ftm_filter_fval_independent[%(ch)]"
      ><![CDATA[
         \t{
         \t   FtmChannelNum_%(ch),
         %initExpression\n\t},\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \n\t};\n\n
  ]]></template>

<if condition="ftm_combine_present" >
<!--   ___ DualChannelInit class ______________ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t/**
      \t * Class used to do initialisation of a pair of $(_Baseclass)Channels operating in Paired mode
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::DualChannelInit channelInit {
      \t *
      \t *    // Omitted parameters are taken to be zero unless a base value is given
      \t *    // Paired values (i.e. corresponding values for both channels) must be present as pairs
      \t *    FtmChannelNum_0, // and FtmChannelNum_1
      \t *
      \t *    FtmEvenChannelMode_CombinePositivePulse ,   // Even Channel Mode - Combined PWM Positive-pulse
      \t *    FtmOddChannelMode_Enabled ,                 // Odd channel Output Control - Pin controlled by FTM
      \t *    FtmSecondEdge_Disabled ,                    // Odd channel Capture Polarity - Not used
      \t *    100_ticks ,                                 // Even channel O/C Event time in ticks
      \t *    200_ticks ,                                 // Odd channel O/C Event time in ticks
      \t *    FtmChannelAction_None ,                     // Action on Even Channel Event - No action
      \t *    FtmChannelAction_None ,                     // Action on Odd Channel Event - No action
      \t *    FtmInputFilter_Disabled ,                   // Channel 0 Input Filter - Filter Disabled
      \t *    FtmInputFilter_Disabled ,                   // Channel 1 Input Filter - Filter Disabled
      \t *    FtmSecondEventAction_NoCapture ,            // Action on Odd channel event - NoCapture
      \t *    FtmComplementChannel_Complementary ,        // Channel 0/1 Complementary Enable - Complementary outputs
      \t *    FtmFaultControl_Normal ,                    // Channel 0/1 Fault Control Enable - Disabled
      \t *    FtmDeadtime_Disabled ,                      // Channel 0/1 Dead-time Enable - Disabled
      \t *    FtmSyncEnable_Disabled,                     // Channel 0/1 Synchronization Enable - Disabled
      \t *
      \t *    // Optional base value to start with (must be last parameter)
      \t *    $(_Class)::DefaultChannelInitValues[FtmChannelNum_3]
      \t * };
      \t *
      \t * // Initialise $(_NAME) from values specified above
      \t * $(_Class)::configure(channelInit)
      \t * @endcode
      \t */
      \tclass DualChannelInit {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr DualChannelInit(const DualChannelInit &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr DualChannelInit() = default;
      \t\n
   ]]></template>

   <!-- DualChannelInit Class Member variables -->

   <for keys=" type        : variables                           : init                     "
       values="%baseType   : ftm_cnv_paired[0],ftm_cnv_paired[1] : {0,0}                    ;
               uint8_t     : ftm_cnsc_mode_even[0],
                             ftm_cnsc_secondEdge[1],
                             ftm_cnsc_secondOutput[1]            : {0,0}                    " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName[2] = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <for keys=" type        : variables                               : init                 "
       values="%baseType   : ftm_combine_decap0,ftm_combine_comp0,
                             ftm_combine_faulten0,ftm_combine_dten0, : 0                    ;
               %paramType  : ftm_channel_number                      : %paramType_None      ;
               %baseType   : ftm_filter_fval_paired[0],
                             ftm_filter_fval_paired[1]               : %paramType_Disabled  " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx"
      ><![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]></variableTemplate>
   </for>

   <!-- ____ DualChannelInit Constructors ____________ -->

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      variables="ftm_cnsc_mode_even[0]"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName[0] = %paramExpression;
      \t
      \t      // %paramExpression also includes COMBINEx and DECAPENx
      \t      combine = (combine&~(FTM_COMBINE_COMBINE0_MASK|FTM_COMBINE_DECAP0_MASK)) | (ftmEvenChannelMode>>8);
      \t   }
      \t\n
   ]]></variableTemplate>

   <for keys="    r                       : index "
      values="    ftm_channel_number      :       ;
                  ftm_cnsc_mode_odd[1]    : [1]   "    >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(r))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
         \t
         \t      %registerName%(index) = %paramExpression;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <for keys="   reg                                                  : param  "
      values=" ftm_cnsc_action_paired[0],ftm_cnsc_action_paired[1]    : action " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         params="%(param)Even, %(param)Odd"
         variables="%(reg)"
         nonDefaultParams="2"
         linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%(reg))
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName[0]    = (%registerName[0]&~%mask0) | %paramName0;
      \t      %registerName[1]    = (%registerName[1]&~%mask0) | %paramName1;
      \t   }
      \t\n
      ]]></variableTemplate>
   </for>

   <for keys="   reg                               : param  "
      values=" ftm_cnv_paired[0],ftm_cnv_paired[1] : eventTime  " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         params="%(param)Even, %(param)Odd"
         variables="%(reg)"
         nonDefaultParams="2"
         linePadding="xxx"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%(reg))
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
         \t
         \t      %registerName[0] = %paramName0;
         \t      %registerName[1] = %paramName1;
         \t   }
         \t\n
      ]]></variableTemplate>
   </for>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      params="filterEven, filterOdd"
      variables="ftm_filter_fval_paired[0],ftm_filter_fval_paired[1]"
      nonDefaultParams="2"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%variables)
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName = %paramName0 | (%paramName1<<4);
      \t   }
      \t\n
   ]]></variableTemplate>

   <for keys="   var                      : index "
      values=" ftm_combine_decap0         :       ;
               ftm_combine_comp0          :       ;
               ftm_combine_faulten0       :       ;
               ftm_combine_dten0          :       ;
               ftm_combine_syncen0        :       ;
               ftm_cnsc_icrst_paired[1]   : [1]   " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    * (%(var))
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr DualChannelInit(%params, Types... rest) : DualChannelInit(rest...) {
      \t
      \t      %registerName%(index) = (%registerName%(index)&~%mask) | %paramName;
      \t   }
      \t\n
      ]]></variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" ><![CDATA[
      \t}; // class  $(_BasicInfo)::DualChannelInit\n\n
   ]]></template>

   <!-- ____ DualChannelInit Configure methods ____________ -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Configure a pair of channels from values specified in dualChannelInit
      \t *
      \t * @param dualChannelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(const DualChannelInit &dualChannelInit) {
      \t   return configure(dualChannelInit.channel, dualChannelInit);
      \t}
      \t
      \t/**
      \t * Configure a pair of channels from values specified in dualChannelInit
      \t *
      \t * @param channelNum      Select channel to initialise.
      \t *                        This allows applying channelInit to arbitrary channel
      \t * @param dualChannelInit Class containing initialisation values
      \t */
      \tstatic ErrorCode configure(FtmChannelNum channelNum, const DualChannelInit &dualChannelInit) {
      \t
      \t   // Disable clock so changes have immediate effect
      \t   uint8_t sc = ftm->SC;
      \t   ftm->SC = 0;
      \t
      \t   // Even channel value controls paired channels n,n+1
      \t   const unsigned offset = 4*channelNum;
      \t   const uint32_t mask = 0xFF<<offset;
      \t   ftm->COMBINE = (ftm->COMBINE & ~mask) | (uint32_t(dualChannelInit.combine)<<offset);
      \t
      \t   // Configure timer channel
      \t   ftm->CONTROLS[channelNum].CnV    = dualChannelInit.cnv[0];
      \t   ftm->CONTROLS[channelNum+1].CnV  = dualChannelInit.cnv[1];
      \t   ftm->CONTROLS[channelNum].CnSC   = dualChannelInit.cnsc[0];
      \t   ftm->CONTROLS[channelNum+1].CnSC = dualChannelInit.cnsc[1];
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" condition="ftm_filter_fval_independent[]" ><![CDATA[
      \t   ftm->FILTER = (ftm->FILTER & ((FTM_FILTER_CH1FVAL_MASK|FTM_FILTER_CH0FVAL_MASK)<<offset))|
      \t                  (dualChannelInit.filter<<offset);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t   // Restore clock
      \t   ftm->SC = sc;
      \t
      \t   return E_NO_ERROR;
      \t}
      \t
      \t/**
      \t * Configure a pairs of channels from values specified in dualChannelInit array
      \t *
      \t * @param dualChannelInit Array containing initialisation values
      \t */
      \ttemplate<size_t N>
      \tstatic ErrorCode configure(const DualChannelInit (&dualChannelInit)[N]) {
      \t
      \t   ErrorCode rc = E_NO_ERROR;
      \t   for (size_t i=0; i<N; i++) {
      \t      rc = configure(dualChannelInit[i].channel, dualChannelInit[i]);
      \t      if (rc != E_NO_ERROR) {
      \t         break;
      \t      }
      \t   }
      \t   return rc;
      \t}
      \t\n
   ]]></template>

   <!--  DualChannelInit Default Initialisation value -->

   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)DualChannelInit
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr DualChannelInit DefaultDualChannelInitValues[] = {\n
   ]]></template>
   <for keys=   "evenCh : oddCh : pairedCh "
        values= "0      : 1     :   0 ;
                 2      : 3     :   1 ;
                 4      : 5     :   2 ;
                 6      : 7     :   3 " >
      <if condition="=%(evenCh)>=_channelCount">
         <break/>
      </if>
      <!-- Common -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_mode_even[%(evenCh)]"
      ><![CDATA[
         \t{
         \t   FtmChannelNum_%(evenCh), // and FtmChannelNum_%(oddCh)
         %initExpression\n
      ]]></variableTemplate>

      <!-- Combined PWM  -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(ftm_cnsc_mode_even[%(evenCh)]==(1,2))"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_secondOutput[%(oddCh)],
            ftm_cnv_paired[%(evenCh)],
            ftm_cnv_paired[%(oddCh)],

            ftm_combine_decap%(pairedCh),
            ftm_combine_comp%(pairedCh),
            ftm_combine_faulten%(pairedCh),
            ftm_combine_dten%(pairedCh),
            ftm_combine_syncen%(pairedCh)"
      ><![CDATA[
         %initExpression\n
      ]]></variableTemplate>

      <!-- Dual capture -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(ftm_cnsc_mode_even[%(evenCh)]>=3)"
         separator=","
         terminator=","
         variables="
            ftm_cnsc_secondEdge[%(oddCh)],
            ftm_filter_fval_paired[%(evenCh)],
            ftm_filter_fval_paired[%(oddCh)],
            ftm_cnsc_icrst_paired[%(oddCh)]"
      ><![CDATA[
         %initExpression\n
      ]]></variableTemplate>

      <!-- Common -->
      <variableTemplate
         codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;(ftm_cnsc_mode_even[%(evenCh)]!=0)"
         separator=","
         terminator=","
         variables="

            ftm_cnsc_action_paired[%(evenCh)],
            ftm_cnsc_action_paired[%(oddCh)]"
      ><![CDATA[
         %initExpression\n\t},\n
      ]]></variableTemplate>
   </for>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \n\t};\n\n
  ]]></template>
</if>

   <xi:include href="ftm_sync.xml"/>
   <xi:include href="ftm_pwmload.xml"/>

   <!-- ____ Fault __________________ -->
   <constant key="_code" />
   <xi:include href="ftm_fault.xml"/>
   <deleteVariables variables="_code"/>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_code" />
   <xi:include href="ftm_quadrature_decoder.xml"/>
   <deleteVariables variables="_code"/>

<!--  ___ End of class  $(_BasicInfo) ______________ -->

<!-- ___ Set interrupt handlers ___________ -->

   <!-- template  codeGenCondition="!irqHandlingMethod&amp;&amp;enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setCallbacks(const Init &) {
      \t}
      \t\n
   ]]></template>

   <template  codeGenCondition="!irqHandlingMethod&amp;&amp;enablePeripheralSupport" condition="ftm_combine_present" ><![CDATA[
      \t/**
      \t * Set channel callbacks from DualChannelInit structure
      \t *
      \t * @note Dummy routine
      \t */
      \tstatic void setChannelCallback(const DualChannelInit &) {
      \t}
      \t\n
   ]]></template
-->
   <template  codeGenCondition="irqHandlingMethod&amp;&amp;(_hardwareIrqCount==1)" ><![CDATA[
      \t/**
      \t * Set callbacks and IRQ priority from Init structure
      \t *
      \t * @param init Class containing initialisation values
      \t *
      \t * @note Channel callback is shared by all channels of the timer.
      \t *       It is necessary to identify the originating channel in the callback
      \t */
      \tstatic void setCallbacks(const Init &init) {
      \t
      \t   disableNvicInterrupts();
      \t   setCallback(init.callbackFunction);
      \t   enableNvicInterrupt(irqNums[0], init.irqlevel);
      \t}
      \t\n
   ]]></template>

   <!--  Calculate if any channels configured  -->
   <for keys="ch" dim="=_channelCount">
      <if condition="!do_channel_init">
         <!-- 1st time -->
         <equation key="do_channel_init" value='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;((ftm_cnsc_mode_independent[%(ch)]>0)' />
      <else />
         <equation key="do_channel_init" value='=do_channel_init+"||(ftm_cnsc_mode_independent[%(ch)]>0)"' />
      </if>
   </for>
   <equation key="do_channel_init" value='=do_channel_init+")"' />
   <!-- printVar key="do_channel_init" / -->

   <for keys="ch" values="0;2;4;6" condition="ftm_combine_present" >
      <break condition="=%(ch)>=_channelCount" />
      <if condition="!do_dualchannel_init">
         <!-- 1st time -->
         <equation key="do_dualchannel_init" value='enablePeripheralSupport&amp;&amp;(mode!=Quad)&amp;&amp;((ftm_cnsc_mode_even[%(ch)]>0)' />
      <else />
         <equation key="do_dualchannel_init" value='=do_dualchannel_init+"||(ftm_cnsc_mode_even[%(ch)]>0)"' />
      </if>
   </for>
   <equation key="do_dualchannel_init" value='=do_dualchannel_init+")"' condition="ftm_combine_present" />
   <!-- printVar key="do_dualchannel_init" / -->

   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t/**
      \t * Default configuration using settings from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t   // Base configuration for I/C, O/C and PWM
      \t   configure(DefaultInitValue);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport&amp;&amp;(mode==Quad)" ><![CDATA[
      \t   // Configuration for Quadrature decoder
      \t   configure(DefaultQuadInitValue);
      \t\n
   ]]></template>
   <template condition="ftm_sync_present||ftm_synconf_present"
      codeGenCondition="enablePeripheralSupport&amp;&amp;(mode!=Quad)" ><![CDATA[
      \t   // Configuration for synchronisation
      \t   configure(DefaultSyncInitValue);
      \t\n
   ]]></template>
   <template codeGenCondition="=do_channel_init" ><![CDATA[
      \t   // Configuration of individual channels
      \t   configure(DefaultChannelInitValues);
      \t\n
   ]]></template>
   <template codeGenCondition="=do_dualchannel_init" condition="ftm_combine_present" ><![CDATA[
      \t   // Configuration of paired channels
      \t   configure(DefaultDualChannelInitValues);
      \t\n
   ]]></template>
   <template codeGenCondition="enablePeripheralSupport" ><![CDATA[
      \t}
      \t\n
   ]]></template>

   <!-- ____ Getters and Setters __________________ -->
   <xi:include href="ftm_getters_setters.xml"/>

   <!-- ____ Output Initialisation __________________ -->
   <xi:include href="ftm_outinit.xml"/>

   <!-- ____ Common __________________ -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Baseclass)Base_T<$(_Info)> $(_Class);\n
   ]]>
   </template>

   <!-- ____ Quadrature decoder __________________ -->
   <constant key="_declaration" />
   <xi:include href="ftm_quadrature_decoder.xml"/>
   <deleteVariables variables="_declaration"/>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.FtmValidate" >
   </validate>

   <projectActionList id="ftm_common_files" >
      <copy source="Project_Headers/ftm.h"                target="Project_Headers/ftm.h"                overwrite="always" derived="true" />
      <copy source="Snippets/ftm-pwm-example.cpp"         target="Snippets/ftm-pwm-example.cpp"         overwrite="always" derived="true" />
      <copy source="Snippets/ftm-ic-example.cpp"          target="Snippets/ftm-ic-example.cpp"          overwrite="always" derived="true" />
      <copy source="Snippets/ftm-oc-example.cpp"          target="Snippets/ftm-oc-example.cpp"          overwrite="always" derived="true" />
      <copy source="Snippets/ftm-oc-init-example.cpp"     target="Snippets/ftm-oc-init-example.cpp"     overwrite="always" derived="true" />
      <copy source="Snippets/ftm-servo-example.cpp"       target="Snippets/ftm-servo-example.cpp"       overwrite="always" derived="true" />
      <copy source="Snippets/ftm-quadrature-example.cpp"  target="Snippets/ftm-quadrature-example.cpp"  overwrite="always" derived="true" />
      <copy source="Snippets/neopixel-example.cpp"        target="Snippets/neopixel-example.cpp"        overwrite="always" derived="true" />
   </projectActionList>

   <!-- ____ Startup __________________ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "../Project_Headers/$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration __________________ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping __________________ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />
   <signals name="FTM" optional="true" />

</fragment>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- ftm_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <xi:include href="_default_instance.xml"/>

   <binaryOption key="check_minimums" 
      description="Check minimum interval and minimum resolution"
      toolTip="Enables boundary checks of minimum interval and minimum resolution when setting values" >
      <choice value="0" name="No checks done" />
      <choice value="1" name="Do checks"  isDefault="true" />
   </binaryOption>

   <intOption key="minimumInterval" 
      description="Minimum usable interval in ticks"
      toolTip="This value is used as a minimum acceptable value for the timer interval in ticks\n
               when using convertMicrosecondsToTicks() or convertSecondsToTicks()"
      value="20" min="0" max="65535"/>
      
   <intOption key="minimumResolution" 
      description="Minimum resolution for PWM interval"
      toolTip="This value is used as a minimum value for the timer period in ticks \n
         so that a reasonable resolution is available for PWM duty-cycle"
      value="100" min="0" max="65535" />
      
   <intOption key="ftmExternalClock" 
   description="FTM External clock"
      toolTip="Clock frequency of external clock supplied to FTM_CLKIN pin"
      value="0" min="0" units="Hz"/>

   <choiceOption key="ftm_sc_clks" 
      description="Clock Source"
      enumStem="FtmClockSource"
      target="inputClockFrequency"
      toolTip="Selects the clock source for the module">
      <choice value="0" name="Disabled"              ref="disabled"                     code="0"                enum="Disabled"            />
      <choice value="1" name="System clock"          ref="/SIM/system_bus_clock[]"      code="SystemBusClock"   enum="SystemClock"         isDefault="true" />
      <choice value="2" name="Fixed frequency clock" ref="/MCG/system_mcgffclk_clock[]" code="SystemMcgffClock" enum="FixedFrequencyClock" />
      <choice value="3" name="External clock"        ref="ftmExternalClock"             code="ftmExternalClock" enum="ExternalClock"       />
   </choiceOption>
   
   <intOption key="inputClockFrequency" 
      constant="true"
      description="Frequency of input clock to timer"
      toolTip="Determined from timer clock source (ftm_sc_clks)"
      derived="true"
      units="Hz"/>
      
   <choiceOption key="ftm_sc_ps" 
   description="Clock prescaler"
      enumStem="FtmPrescale"
      target="clockFrequency"
      toolTip="Selects the prescaler for the module">
      <choice value="0" name="Divide by 1"   ref="inputClockFrequency"          enum="DivBy1"  isDefault="true" />
      <choice value="1" name="Divide by 2"   ref="inputClockFrequency,(%%/2)"   enum="DivBy2" />
      <choice value="2" name="Divide by 4"   ref="inputClockFrequency,(%%/4)"   enum="DivBy4" />
      <choice value="3" name="Divide by 8"   ref="inputClockFrequency,(%%/8)"   enum="DivBy8" />
      <choice value="4" name="Divide by 16"  ref="inputClockFrequency,(%%/16)"  enum="DivBy16" />
      <choice value="5" name="Divide by 32"  ref="inputClockFrequency,(%%/32)"  enum="DivBy32" />
      <choice value="6" name="Divide by 64"  ref="inputClockFrequency,(%%/64)"  enum="DivBy64" />
      <choice value="7" name="Divide by 128" ref="inputClockFrequency,(%%/128)" enum="DivBy128" />
   </choiceOption>
      
   <intOption key="clockFrequency" 
      constant="true"
      description="Frequency of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="Hz"/>
   
   <floatOption key="clockPeriod" 
      ref="clockFrequency,(1/%%)"
      constant="true"
      description="Period of timer clock"
      toolTip="Determined from timer clock source and prescaler"
      derived="true"
      units="s"/>
      
   <intOption key="ftm_cntin" description="Start value for counter"
      toolTip="The timer counts from this value to ftm_mod"
      typeName="Ticks"
      value="0" min="0" max="65535" />
           
   <intOption key="ftm_mod" description="End value for counter"
      toolTip="The timer counts from ftm_cntin to this value"
      typeName="Ticks"
      value="10000" min="0" max="65535" />
           
   <floatOption key="ftm_mod_period" 
      description="Period of timer"
      toolTip="Period of the timer"
      origin="Clock period * ftm_mod"
      derived="true"
      min="0" units="s"/>
      
   <binaryOption key="ftm_sc_cpwms" 
      enumStem="FtmAlignment"
      description="PWM Alignment"
      toolTip="Alignment of PWM outputs relative to counter roll-over\n
         This configures the counter to operate in Up or Up-Down Counting modes">
      <choice value="0" name="Left-aligned (count up)"        enum="Left"    />
      <choice value="1" name="Centre-aligned (count up-down)" enum="Centre"  />
   </binaryOption>
   
   <binaryOption key="ftm_sc_toie"
      enumStem="FtmOverflowInterrupt"
      description="Overflow Interrupt"
      toolTip="Enables FTM overflow interrupts">
      <choice value="0" name="Interrupt Disabled" enum="Disabled" />
      <choice value="1" name="Interrupt Enabled"  enum="Enabled"  />
   </binaryOption>
   
   <template><![CDATA[
      \t/** Minimum resolution for PWM interval */
      \tstatic constexpr uint32_t minimumResolution=$(?check_minimums:$(minimumResolution):0);
      
      \t/** Minimum usable interval in ticks */      
      \tstatic constexpr uint32_t minimumInterval=$(?check_minimums:$(minimumInterval):0);
      
      \t//! Timer external input frequency
      \tstatic constexpr uint32_t ftmExternalClock =  $(ftmExternalClock);
      
      \t//! Default Timer Modulo
      \tstatic constexpr uint32_t modulo = FTM_MOD_MOD($(ftm_mod));

      \t//! Default value for SC register
      \tstatic constexpr uint32_t sc  = 
      \t    FTM_SC_CPWMS($(ftm_sc_cpwms))| // Centre-Aligned PWM Select
      \t    FTM_SC_CLKS($(ftm_sc_clks))|  // Clock Mode Selection
      \t    FTM_SC_TOIE($(ftm_sc_toie))|  // Timer Overflow Interrupt Enable
      \t    FTM_SC_PS($(ftm_sc_ps));    // Prescale Factor Selection \n\n
   ]]></template>

   <category name="External Triggers" description="External Triggers">
      <bitmaskOption key="ftm_exttrig_trig"   description="External Trigger Enable" 
         toolTip="Enables the generation of the trigger when the FTM counter \n
          is equal to the channel CnV register"
         value="0"
         bitmask="0x3F" 
         bitList="CH2TRIG,CH3TRIG,CH4TRIG,CH5TRIG,CH0TRIG,CH1TRIG," 
         />
      <binaryOption key="ftm_exttrig_inittrigen" description="Initialisation Trigger Enable"
         toolTip="Enables the generation of the trigger when the FTM counter \n
          is equal to the CNTIN register">
         <choice value="0" name="Disabled" />
         <choice value="1" name="Enabled" />
      </binaryOption>
   </category>   
   <template><![CDATA[
      \t//! Default value for EXTTRIG) register
      \tstatic constexpr uint32_t exttrig  = 
      \t    $(ftm_exttrig_trig)|                              // External Trigger Enable
      \t    FTM_EXTTRIG_INITTRIGEN($(ftm_exttrig_inittrigen));    // Initialisation Trigger Enable \n\n
   ]]></template>

   <category name="Advanced" description="Advanced options">
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)clksel"  optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)flt0"    optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)flt1"    optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)flt2"    optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)flt3"    optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)trg0src" optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)trg1src" optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)ch0src"  optional="true" constant="false" />
      <aliasOption key="/SIM/sim_sopt4_ftm$(_instance)ch1src"  optional="true" constant="false" />
   
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och7src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och6src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och5src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och4src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och3src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och2src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och1src" optional="true" constant="false"/>
      <aliasOption key="/SIM/sim_sopt8_ftm$(_instance)och0src" optional="true" constant="false"/>
   </category>

<!-- ========== Methods =============================== -->
   <for  keys  =" k                    : static    : const" 
         values=" non_static_functions : ''        : ' const';
                  static_functions     : 'static ' : ''     
   ">
      <setTemplate key="/FTM/%(k)" namespace="all"
         discardRepeats="true"
         variables="ftm_sc_clks,ftm_sc_ps"
         nonDefaultParams="2" 
      ><![CDATA[
         \t/**
         \t * Stop timer counter.
         \t * This simply disables the counter clock source. \n
         \t * To restart use setClockSource() or configure();
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note A illegal access trap will occur if the timer has not been enabled
         \t */
         \t%(static)void stopCounter()%(const) {
         \t  %register = (%register&~%mask1);
         \t}
         \t
         \t/**
         \t * Set %description0 and %description1
         \t *
         %comments
         \t */
         \t%(static)void selectClock(
         %params)%(const) {
         \t
         \t   // Calculate new SC value
         \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
         
         \t   // Disable timer to change clock (unable to switch directly between clock sources)
         \t   %register=0;
         
         \t   // Make sure write has completed (disabled)
         \t   (void)(%register);
         
         \t   // Write new value
         \t   %register = %registerName;
         \t}\n\n
      ]]></setTemplate>
            
      <for keys="  f           :  n" 
         values=" ftm_sc_clks  : setClockSource;
                  ftm_sc_ps    : setPrescaler;
                  ftm_sc_cpwms : setAlignment">
         <setTemplate key="/FTM/%(k)" namespace="all"
            discardRepeats="true"
            variables="%(f)"
            nonDefaultParams="2" 
         ><![CDATA[
            \t/**
            \t * Set %description
            \t *
            %comments
            \t *
            \t * @note This function will affect all channels of the timer.
            \t * @note The timer will be disabled while making changes.
            \t */
            \t%(static)void %(n)(%params)%(const) {
            \t
            \t   // Calculate new SC value
            \t   uint32_t %registerName = (%register&~%mask)|(%paramExpression);
            
            \t   // Disable timer to change clock (unable to switch directly between clock sources)
            \t   %register=0;
            
            \t   // Make sure write has completed (disabled)
            \t   (void)(%register);
            
            \t   // Write new value
            \t   %register = %registerName;
            \t}\n\n
         ]]></setTemplate>
      </for>
            
      <setTemplate key="/FTM/%(k)" namespace="all"
         discardRepeats="true"
         variables="ftm_mod,ftm_sc_ps"
      ><![CDATA[
         \t/**
         \t * Set maximum value of timer counter.
         \t *
         \t * @param[in] endValue Modulo value in ticks (<65535), 0 = 65536.
         \t * @param[in] suspend  Whether to suspend timer during change.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t * @note The timer may be disabled while making changes.
         \t * @note This value is write-buffered and updated by MOD synchronisation
         \t *       unless suspend is true.
         \t */
         \t%(static)void setCounterMaximumValue(Ticks endValue, bool suspend=false)%(const) {
         \t   uint32_t %registerName1;
         \t   if (suspend) {
         \t      // Disable timer so register changes are immediate
         \t      sc = %register1;
         \t      %register1 = 0;
         \t      (void)(%register1);
         \t   }
         \t   %register0 = (unsigned)endValue;
         \t   if (suspend) {
         \t      %register1 = sc;
         \t   }
         \t}
         \t/**
         \t * Get maximum value of timer counter.
         \t *
         \t * @return Counter modulo value in ticks (<65535), 0 = 65536.
         \t */
         \t%(static)Ticks getCounterMaximumValue()%(const) {
         \t   return Ticks((unsigned)(ftm->MOD));
         \t}\n\n
      ]]></setTemplate>
   
      <setTemplate key="/FTM/%(k)" namespace="all"
         discardRepeats="true"
         variables="ftm_cntin"
      ><![CDATA[
         \t/**
         \t * Set starting value for counter (CNTIN)
         \t *
         \t * This value is write-buffered and updated by CNTIN synchronisation unless suspend is true.
         \t *
         \t * @param[in] startValue  Starting value in ticks (<65535)
         \t * @param[in] suspend     Whether to suspend FTM during change.
         \t *
         \t * @note This function will affect all channels of the timer.
         \t */
         \t%(static)void setCounterStartValue(Ticks startValue, bool suspend=false)%(const) {
         \t   uint32_t sc;
         \t   if (suspend) {
         \t      sc = ftm->SC;
         \t      ftm->SC = 0;
         \t   }
         \t   ftm->CNTIN = (unsigned)startValue;
         \t   if (suspend) {
         \t      ftm->SC = sc;
         \t   }
         \t}
         \t
         \t/**
         \t * Get start value of timer counter.
         \t *
         \t * @return Counter start value in ticks
         \t */
         \t%(static)Ticks getCounterStartValue()%(const) {
         \t   return Ticks((unsigned)(ftm->CNTIN));
         \t}\n\n
      ]]></setTemplate>
   </for>

   <clockCodeTemplate variable="ftm_sc_clks"
      returnFormat="%s"
   ><![CDATA[
      \t/**
      \t * Get %description
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getInputClockFrequency() {
      \t   
      \t   switch(%defaultMaskingExpression) {
      \t      default: return 0;
      %body
      \t   }
      \t}\n\n
   ]]></clockCodeTemplate>

<!-- ========== FTM Init class =============================== -->
   <template><![CDATA[
      \t/**
      \t * Class used to do initialisation of an FTM
      \t *
      \t * This class has a templated constructor that accepts various values:
      \t *
      \t * @note This constructor may be used to create a const instance in ROM
      \t *
      \t * Example:
      \t * @code
      \t * static const Ftm::Init ftmInit {
      \t *    FtmAlignment_Left,
      \t *    FtmClockSource_SystemClock,
      \t *    FtmPrescale_DivBy16,
      \t *    FtmOverflowInterrupt_Disabled,
      \t * };
      \t *
      \t * // Initialise FTM from values specified above
      \t * ftmInit.configure()
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**                               
      \t    * Copy Constructor                  
      \t    */                             
      \t   constexpr Init(const Init &other) = default;
      \t   
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]></template>
   
   <initialValueTemplate 
      variables="ftm_sc_toie,ftm_sc_cpwms,ftm_sc_clks,ftm_sc_ps"
   ><![CDATA[
      \t   /// Status And Control Register
      \t   uint32_t %registerName = 0;\n\n
   ]]></initialValueTemplate>
   <initialValueTemplate 
      variables="ftm_cntin"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>
   <initialValueTemplate 
      variables="ftm_mod"
   ><![CDATA[
      \t   /// %description
      \t   %enumClass %registerName = 0_ticks;\n\n
   ]]></initialValueTemplate>
   
   <setTemplate variables="ftm_sc_clks" ><![CDATA[
      \t   /**
      \t    * Configure FTM from values specified in constructor.
      \t    */
      \t   void configure() const {
      \t
      \t      // Disable timer to change clock (unable to switch directly between clock sources)
      \t      %register=0;
      \t            
      \t      // Make sure write has completed (disabled)
      \t      (void)(%register);\n
   ]]></setTemplate>
   <setTemplate variables="ftm_cntin" ><![CDATA[
      \t
      \t      // %description
      \t      %register = %registerName;\n
   ]]></setTemplate>
   <setTemplate variables="ftm_mod" ><![CDATA[
      \t
      \t      // %description
      \t      %register = %registerName;\n
   ]]></setTemplate>
   <setTemplate variables="ftm_sc_clks" ><![CDATA[
      \t
      \t      // Write new value
      \t      %register = %registerName;\n
   ]]></setTemplate>
   <template><![CDATA[
      \t   }\n\n
   ]]></template>
   
   <for keys="r" values="ftm_sc_toie;ftm_sc_cpwms;ftm_sc_clks;ftm_sc_ps">
      <setTemplate variables="%(r)"
         linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName |= %paramExpression;
         \t   }
         \t\n
      ]]></setTemplate>
   </for>
   
   <setTemplate variables="ftm_cntin, ftm_mod"
      linePadding="xxx" 
      nonDefaultParams="2"
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description0 and %description1 
         \t    *
         \t    * @tparam   Types
         \t    * @param %enumParam0_cntin %tooltip0
         \t    * @param %enumParam1_mod   %tooltip1
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%enumClass0 %enumParam0_cntin, %enumClass1 %enumParam1_mod, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName0 = %enumParam0_cntin;
         \t      %registerName1 = %enumParam1_mod;
         \t   }
         \t\n
   ]]></setTemplate>
   
   <setTemplate variables="ftm_mod"
      linePadding="xxx" 
      ><![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         %comments
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t   
         \t      %registerName = %paramExpression;
         \t   }
         \t\n
   ]]></setTemplate>
   
   <template ><![CDATA[
      \t};\n\n
   ]]></template>

<!-- ========== Misc =============================== -->

   <xi:include href="_irqOption.xml"/>
   
   <xi:include href="_clockOption.xml"/>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.FtmValidate">
   </validate>

   <projectActionList id = "ftm_files" >
      <copy source="Project_Headers/ftm.h"                target="Project_Headers/ftm.h"                overwrite="true" derived="true" />
      <copy source="Snippets/ftm-pwm-example.cpp"         target="Snippets/ftm-pwm-example.cpp"         overwrite="true" derived="true" />
      <copy source="Snippets/ftm-ic-example.cpp"          target="Snippets/ftm-ic-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-oc-example.cpp"          target="Snippets/ftm-oc-example.cpp"          overwrite="true" derived="true" />
      <copy source="Snippets/ftm-servo-example.cpp"       target="Snippets/ftm-servo-example.cpp"       overwrite="true" derived="true" />
      <copy source="Snippets/ftm-quadrature-example.cpp"  target="Snippets/ftm-quadrature-example.cpp"  overwrite="true" derived="true" />
      <copy source="Snippets/neopixel-example.cpp"        target="Snippets/neopixel-example.cpp"        overwrite="true" derived="true" />
   </projectActionList>
         
   <template key="/FTM/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_name)
   \t */
   \ttypedef $(_base_class)Base_T<$(_class)Info> $(_class);\n
   ]]></template>

   <template key="/FTM/quadDeclarations" namespace="all"  ><![CDATA[
   \t/**
   \t * Class representing $(_class) as Quadrature decoder
   \t */
   \ttypedef $(_base_class)QuadDecoder_T<$(_class)Info> $(_base_class)QuadDecoder$(_instance);\n
   ]]></template>

   <signals/>

</fragment>

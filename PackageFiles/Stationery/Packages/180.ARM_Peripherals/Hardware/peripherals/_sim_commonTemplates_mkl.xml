<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- _sim_commonTemplates.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <template namespace="usbdm"><![CDATA[
      \t// Template:sim_commonTemplates_mkl.xml
      \t
      \t#if defined(SIM_SOPT1_RAMSIZE)
      \t/**
      \t * RAM size
      \t */
      \tenum SimRamSize {
      \t   SimRamSize_8KiB    = SIM_SOPT1_RAMSIZE(1),  //!< 8KiB RAM
      \t   SimRamSize_16KiB   = SIM_SOPT1_RAMSIZE(3),  //!< 16KiB RAM
      \t   SimRamSize_24KiB   = SIM_SOPT1_RAMSIZE(4),  //!< 24KiB RAM
      \t   SimRamSize_32KiB   = SIM_SOPT1_RAMSIZE(5),  //!< 32KiB RAM
      \t   SimRamSize_48KiB   = SIM_SOPT1_RAMSIZE(6),  //!< 32KiB RAM
      \t   SimRamSize_64KiB   = SIM_SOPT1_RAMSIZE(7),  //!< 64KiB RAM
      \t   SimRamSize_96KiB   = SIM_SOPT1_RAMSIZE(8),  //!< 96KiB RAM
      \t   SimRamSize_128KiB  = SIM_SOPT1_RAMSIZE(9),  //!< 128KiB RAM
      \t   SimRamSize_256KiB  = SIM_SOPT1_RAMSIZE(11), //!< 256KiB RAM
      \t   SimRamSize_512KiB  = SIM_SOPT1_RAMSIZE(12), //!< 256KiB RAM
      \t   SimRamSize_1024KiB = SIM_SOPT1_RAMSIZE(13), //!< 256KiB RAM
      \t};
      \t#endif
    
      \t#if defined(SIM_SOPT1_OSC32KSEL)
      \t/**
      \t * Selects the ERCLK32K clock source
      \t */
      \tenum SimOsc32kSel {
      \t   SimOsc32kSel_Osc32kClk  = SIM_SOPT1_OSC32KSEL(0), //!< OSC0 operating as 32K oscillator
      \t   SimOsc32kSel_Rtc32kClk  = SIM_SOPT1_OSC32KSEL(2), //!< Rtc32k clock
      \t   SimOsc32kSel_LpoClk     = SIM_SOPT1_OSC32KSEL(3), //!< LPO Clock
      \t};
      \t#endif\n\n
   ]]></template>

   <template><![CDATA[
      \t// Template:sim_common_templates.xml
      \t
      \t#if defined(SIM_SOPT1_RAMSIZE)
      \t/**
      \t * Get RAM size
      \t *
      \t * @return RAM size value
      \t */
      \tstatic SimRamSize getRamSize() {
      \t
      \t   return static_cast<SimRamSize>(sim->SOPT1&SIM_SOPT1_RAMSIZE_MASK);
      \t}
      \t#endif
    
      \t#if defined(SIM_SOPT1_OSC32KSEL)
      \t/**
      \t * Get ERCLK32K clock frequency
      \t *
      \t * @return Clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getErc32kClock() {
      \t
      \t   switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
      \t      default                     : return 0;
      \t      case SimOsc32kSel_Osc32kClk : return RtcInfo::getInternalClock(); //  Osc0Info::getOsc32kClock();
      \t      case SimOsc32kSel_Rtc32kClk : return RtcInfo::getExternalClock(); //  RtcInfo::rtcclk_clock;
      \t      case SimOsc32kSel_LpoClk    : return 1000;
      \t   }
      \t}
    
      \t/**
      \t * Set ERCLK32K clock source
      \t *
      \t * @param simOsc32kSel Clock source
      \t */
      \tstatic void setErc32kClock(SimOsc32kSel simOsc32kSel) {
      \t   sim->SOPT1 = (sim->SOPT1&~SIM_SOPT1_OSC32KSEL_MASK) | simOsc32kSel;
      \t}
      \t#else
      \t/**
      \t * Get ERCLK32K clock frequency
      \t *
      \t * @return Clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getErc32kClock() {
      \t   // No RTC
      \t   return Osc0Info::getOsc32kClock();
      \t}
      \t#endif\n\n
   ]]></template>

   <template><![CDATA[
      \t#if defined(SIM_SOPT1_OSC32KOUT) || defined(SIM_SOPT1_OSC32KSEL)
      \t//! System Options Register 1
      \tstatic constexpr uint32_t sopt1 = 
      \t#if defined(SIM_SOPT1_OSC32KOUT)
      \t   SIM_SOPT1_OSC32KOUT($(sim_sopt1_osc32kout:0)) |    // 32K oscillator clock out pin select
      \t#endif
      \t#if defined(SIM_SOPT1_OSC32KSEL)
      \t   SIM_SOPT1_OSC32KSEL($(sim_sopt1_osc32ksel:0));     // 32K oscillator clock select
      \t#endif
      \t#endif\n\n
   ]]></template>

   <template namespace="usbdm"><![CDATA[    
      \t#if defined(SIM_SOPT2_LPUART0SRC)
      \t/**
      \t * LPUART0 Clock sources
      \t *
      \t * Selects the LPUART0 clock source.
      \t */
      \tenum SimLpuart0ClockSource {
      \t   SimLpuart0ClockSource_Disabled   = SIM_SOPT2_LPUART0SRC(0), //!< Disabled
      \t   SimLpuart0ClockSource_McgPClk    = SIM_SOPT2_LPUART0SRC(1), //!< MCGPCLK = HIRC48M clock
      \t   SimLpuart0ClockSource_OscerClk   = SIM_SOPT2_LPUART0SRC(2), //!< OSCERCLK clock
      \t   SimLpuart0ClockSource_McgIrClk   = SIM_SOPT2_LPUART0SRC(3), //!< MCG Internal Reference clock
      \t};
      \t#endif
         
      \t#if defined(SIM_SOPT2_UART0SRC)
      \t/**
      \t * UART0 Clock sources
      \t *
      \t * Selects the UART0 clock source.
      \t */
      \tenum SimUart0ClockSource {
      \t   SimUart0ClockSource_Disabled   = SIM_SOPT2_UART0SRC(0),   //!< Disabled
      \t   SimUart0ClockSource_Peripheral = SIM_SOPT2_UART0SRC(1),   //!< Peripheral clock (MCGPLLCLK/2 or MCGFLLCLK)
      \t   SimUart0ClockSource_OscerClk   = SIM_SOPT2_UART0SRC(2),   //!< OSCERCLK clock
      \t   SimUart0ClockSource_McgIrClk   = SIM_SOPT2_UART0SRC(3),   //!< MCG Internal Reference clock (MCGIRCLK)
      \t};
      \t#endif
         
      \t#if defined(SIM_SOPT2_TPMSRC)
      \t/**
      \t * TPM Clock sources
      \t */
      \tenum SimTpmClockSource {
      \t   SimTpmClockSource_Disabled   = SIM_SOPT2_TPMSRC(0), //!< Disabled
      \t   SimTpmClockSource_Peripheral = SIM_SOPT2_TPMSRC(1), //!< Peripheral clock (MCGPLLCLK/2 or MCGFLLCLK)
      \t   SimTpmClockSource_OscerClk   = SIM_SOPT2_TPMSRC(2), //!< OSCERCLK clock
      \t   SimTpmClockSource_McgIrClk   = SIM_SOPT2_TPMSRC(3), //!< MCG Internal Reference clock (MCGIRCLK)
      \t};
      \t#endif
      
      \t#if defined(SIM_SOPT2_USBSRC)
      \t/**
      \t * USB full-speed clock sources
      \t */
      \tenum SimUsbFullSpeedClockSource {
      \t   SimUsbFullSpeedClockSource_External   = SIM_SOPT2_USBSRC(0), //!< External bypass clock (USB_CLKIN)
      \t   SimUsbFullSpeedClockSource_Peripheral = SIM_SOPT2_USBSRC(1), //!< Peripheral clock (MCGPLLCLK/2 or MCGFLLCLK)
      \t};
      \t#endif
         
      \t#if defined(SIM_SOPT2_PLLFLLSEL)
      \t/**
      \t * Peripheral Clock sources
      \t */
      \tenum SimPeripheralClockSource {
      \t   SimPeripheralClockSource_McgFll = SIM_SOPT2_PLLFLLSEL(0), //!< MCG FLL Clock
      \t   SimPeripheralClockSource_McgPll = SIM_SOPT2_PLLFLLSEL(1), //!< MCG PLL Clock/2
      \t#if defined(USBPHY0_BasePtr)
      \t   SimPeripheralClockSource_UsbPfd = SIM_SOPT2_PLLFLLSEL(2), //!< USB PFD clock
      \t#endif
      \t#if defined(USB_CLK_RECOVER_IRC_EN_REG_EN_MASK)
      \t   SimPeripheralClockSource_Irc48m = SIM_SOPT2_PLLFLLSEL(3), //!< IRC 48MHz clock
      \t#endif
      \t};
      \t#endif
         
      \t#if defined(SIM_SOPT2_RTCCLKOUTSEL)
      \t/**
      \t * RTC clock out select
      \t * Selects the clock to be output on the RTC_CLKOUT pin.
      \t */
      \tenum RtcClkoutSel {
      \t   RtcClkoutSel_1Hz   = SIM_SOPT2_RTCCLKOUTSEL(0),//!< RTC 1 Hz clock is output on the RTC_CLKOUT pin.
      \t   RtcClkoutSel_32kHz = SIM_SOPT2_RTCCLKOUTSEL(1),//!< RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
      \t};
      \t#endif\n\n
   ]]></template>

   <template><![CDATA[
      \t#ifdef SIM_SOPT2_LPUART0SRC_MASK
      \t/**
      \t * Set LPUART0 input clock source
      \t *
      \t * @param simLpuart0ClockSource Clock source for LPUART
      \t */
      \tstatic void setLpuart0Clock(SimLpuart0ClockSource simLpuart0ClockSource) {
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_LPUART0SRC_MASK) | simLpuart0ClockSource;
      \t}
         
      \t/**
      \t * Get LPUART0 input clock frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getLpuart0Clock() {
      \t   
      \t   switch(sim->SOPT2&SIM_SOPT2_LPUART0SRC_MASK) {
      \t      default:
      \t      case SIM_SOPT2_LPUART0SRC(0): return 0;
      \t      case SIM_SOPT2_LPUART0SRC(1): return getPeripheralClock();
      \t      case SIM_SOPT2_LPUART0SRC(2): return Osc0Info::getOscerClock();
      \t      case SIM_SOPT2_LPUART0SRC(3): return McgInfo::getMcgIrClock();
      \t   }
      \t}
      \t#endif
      
      \t#ifdef SIM_SOPT2_UART0SRC_MASK
      \t/**
      \t * Set UART0 input clock source
      \t *
      \t * @param simUart0ClockSource Clock source for UART
      \t */
      \tstatic void setUart0Clock(SimUart0ClockSource simUart0ClockSource) {
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_UART0SRC_MASK) | simUart0ClockSource;
      \t}
         
      \t/**
      \t * Get UART0 input clock frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic uint32_t getUart0Clock() {
      \t   
      \t   switch(sim->SOPT2&SIM_SOPT2_UART0SRC_MASK) {
      \t      default:
      \t      case SIM_SOPT2_UART0SRC(0): return 0;
      \t      case SIM_SOPT2_UART0SRC(1): return getPeripheralClock();
      \t      case SIM_SOPT2_UART0SRC(2): return Osc0Info::getOscerClock();
      \t      case SIM_SOPT2_UART0SRC(3): return McgInfo::getMcgIrClock();
      \t   }
      \t}
      \t#endif
      
      \t#ifdef SIM_SCGC4_UART1_MASK
      \t/** 
      \t * Get UART1 input clock frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic inline uint32_t getUart1Clock() {
      \t   return $(Uart1Clock);
      \t}
      \t#endif
      
      \t#ifdef SIM_SCGC4_UART2_MASK
      \t/** 
      \t * Get UART2 input clock frequency
      \t *
      \t * @return Clock frequency in Hz
      \t */
      \tstatic inline uint32_t getUart2Clock() {
      \t   return $(Uart2Clock);
      \t}
      \t#endif
      
      \t#ifdef SIM_SOPT2_TPMSRC_MASK
      \t/**
      \t * Set TPM input clock source
      \t *
      \t * @param simTpmClockSource Clock source for TPM
      \t */
      \tstatic void setTpmClock(SimTpmClockSource simTpmClockSource) {
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_TPMSRC_MASK) | simTpmClockSource;
      \t}

      \t/**
      \t * Get TPM input clock frequency
      \t *
      \t * @return TPM input clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getTpmClock() {
      \t   switch(sim->SOPT2&SIM_SOPT2_TPMSRC_MASK) {
      \t      default:
      \t      case SIM_SOPT2_TPMSRC(0): return 0;
      \t      case SIM_SOPT2_TPMSRC(1): return getPeripheralClock();
      \t      case SIM_SOPT2_TPMSRC(2): return Osc0Info::getOscerClock();
      \t      case SIM_SOPT2_TPMSRC(3): return McgInfo::getMcgIrClock();
      \t   }
      \t}
      \t#endif

      \t#if defined(SIM_SOPT2_CLKOUTSEL)      
      \t/**
      \t * Selects the clock to output on the CLKOUT pin.
      \t *
      \t * @param simClkoutSel
      \t */
      \tstatic void setClkout(SimClkoutSel simClkoutSel) {
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_CLKOUTSEL_MASK) | simClkoutSel;
      \t}
      \t#endif
   
      \t#if defined(SIM_SOPT2_PLLFLLSEL_MASK)         
      \t/**
      \t * Set Peripheral clock source
      \t *
      \t * @param simPeripheralClockSource Clock source for peripheral clock
      \t */
      \tstatic void setPeripheralClock(SimPeripheralClockSource simPeripheralClockSource) {
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_PLLFLLSEL_MASK) | simPeripheralClockSource;
      \t}
      \t#endif
      
      \t/**
      \t * Get Peripheral clock frequency
      \t *
      \t * @return Frequency as a uint32_t in Hz
      \t *
      \t * @note If there is a peripheral clock divider then this is the frequency of the undivided peripheral clock
      \t */
      \tstatic uint32_t getPeripheralClock() {
      \t   
      \t#if defined(SIM_SOPT2_PLLFLLSEL_MASK)         
      \t   switch(sim->SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
      \t      default:                     return 0;
      \t      case SimPeripheralClockSource_McgFll : return SystemMcgFllClock;     // FLL clock
      \t      case SimPeripheralClockSource_McgPll : return SystemMcgPllClock/$(mgcpllClockDivider:1);   // PLL derived clock
      \t   }
      \t#elif defined(MCG_MC_HIRCEN_MASK)
      \t   return McgInfo::getMcgPClk();
      \t#else
      \t   return SystemMcgFllClock;
      \t#endif
      \t}\n\n
   ]]></template>
   
   <template><![CDATA[
      \t#ifdef SIM_SOPT2_USBSRC_MASK
      \t/**
      \t * Set USB Full-speed clock source
      \t *
      \t * If the internal clock is selected then the clock divider will be recalculated
      \t *      
      \t * @param simUsbFullSpeedClockSource Clock source for peripheral clock
      \t *
      \t * @return E_NO_ERROR on success
      \t */
      \tstatic ErrorCode setUsbFullSpeedClock(
      \t             SimUsbFullSpeedClockSource simUsbFullSpeedClockSource = SimUsbFullSpeedClockSource_Peripheral) {
      \t
      \t   // Set clock source
      \t   sim->SOPT2 = (sim->SOPT2&~SIM_SOPT2_USBSRC_MASK) | simUsbFullSpeedClockSource;
      \t   return E_NO_ERROR;
      \t}

      \t/**
      \t * Get USB clock frequency
      \t *
      \t * @return Clock frequency as a uint32_t in Hz
      \t */
      \tstatic uint32_t getUsbFullSpeedClock() {
      \t   switch ((sim->SOPT2&SIM_SOPT2_USBSRC_MASK)) {
      \t      default:
      \t      case SimUsbFullSpeedClockSource_External   : return $(/SIM/system_usb_clkin_clock);
      \t      case SimUsbFullSpeedClockSource_Peripheral : return getPeripheralClock();
      \t   }
      \t}
      \t#endif\n\n
   ]]></template>

   <template><![CDATA[
      \t//! System Options Register 2
      \tstatic constexpr uint32_t sopt2 = 
      
      \t#ifdef SIM_SOPT2_TRACECLKSEL
      \t   SIM_SOPT2_TRACECLKSEL($(/SIM/sim_sopt2_traceclksel:0)) |      // Debug trace clock select
      \t#endif
      \t#ifdef SIM_SOPT2_TIMESRC
      \t   SIM_SOPT2_TIMESRC($(/SIM/sim_sopt2_timesrc:0)) |          // IEEE 1588 timestamp clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_RMIISRC
      \t   SIM_SOPT2_RMIISRC($(/SIM/sim_sopt2_rmiisrc:0)) |          // Ethernet RMII clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_SDHCSRC
      \t      SIM_SOPT2_SDHCSRC($(/SIM/sim_sopt2_sdhcsrc:0)) |       // SDHC clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_PTD7PAD
      \t      SIM_SOPT2_PTD7PAD($(/SIM/sim_sopt2_ptd7pad:0)) |       // PTD7 pad drive strength
      \t#endif
      \t#ifdef SIM_SOPT2_FBSL
      \t      SIM_SOPT2_FBSL($(/SIM/sim_sopt2_fbsl:0)) |          // FlexBus security level
      \t#endif
      \t#ifdef SIM_SOPT2_UART0SRC
      \t   SIM_SOPT2_UART0SRC($(/SIM/sim_sopt2_uart0src:0)) |         // UART0 clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_LPUARTSRC
      \t   SIM_SOPT2_LPUARTSRC($(/SIM/sim_sopt2_lpuartsrc:0)) |     // LPUART clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_LPUART0SRC
      \t   SIM_SOPT2_LPUART0SRC($(/SIM/sim_sopt2_lpuart0src:0)) |         // LPUART0 clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_TPMSRC
      \t   SIM_SOPT2_TPMSRC($(/SIM/sim_sopt2_tpmsrc:0)) |        // TPM clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_USBSRC
      \t      SIM_SOPT2_USBSRC($(/SIM/sim_sopt2_usbsrc:0)) |        // USB clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_PLLFLLSEL
      \t      SIM_SOPT2_PLLFLLSEL($(/SIM/sim_sopt2_pllfllsel[0]:0))|      // PLL/FLL clock select
      \t#endif
      \t#ifdef SIM_SOPT2_CLKOUTSEL
      \t      SIM_SOPT2_CLKOUTSEL($(/SIM/sim_sopt2_clkoutsel))|      // CLKOUT pin clock source select
      \t#endif
      \t#ifdef SIM_SOPT2_RTCCLKOUTSEL
      \t      SIM_SOPT2_RTCCLKOUTSEL($(/SIM/sim_sopt2_rtcclkoutsel:0)) |  // RTC clock out select
      \t#endif
      \t      0;\n\n
   ]]></template>

   <template><![CDATA[
      \t//! System Options Register 4
      \tstatic constexpr uint32_t sopt4 = 
      \t#ifdef SIM_SOPT4_TPM2CLKSEL
      \t   SIM_SOPT4_TPM2CLKSEL($(sim_sopt4_tpm2clksel:0))  |   // TPM 2 External Clock Pin Select
      \t#endif
      \t#ifdef SIM_SOPT4_TPM1CLKSEL
      \t   SIM_SOPT4_TPM1CLKSEL($(sim_sopt4_tpm1clksel:0))  |   // TPM 1 External Clock Pin Select
      \t#endif
      \t#ifdef SIM_SOPT4_TPM0CLKSEL
      \t   SIM_SOPT4_TPM0CLKSEL($(sim_sopt4_tpm0clksel:0))  |   // TPM 0 External Clock Pin Select
      \t#endif
      \t#ifdef SIM_SOPT4_TPM2CH0SRC
      \t   SIM_SOPT4_TPM2CH0SRC($(sim_sopt4_tpm2ch0src:0))  |   // TPM 2 channel 0 input capture source select
      \t#endif
      \t#ifdef SIM_SOPT4_TPM1CH0SRC
      \t   SIM_SOPT4_TPM1CH0SRC($(sim_sopt4_tpm1ch0src:0))  |   // TPM 1 channel 0 input capture source select\n\n
      \t#endif
      \t      0;\n\n
   ]]></template>

   <template><![CDATA[
      \t//! System Options Register 5
      \tstatic constexpr uint32_t sopt5 = 
      \t#ifdef SIM_SOPT5_LPUART0ODE
      \t   SIM_SOPT5_LPUART0ODE($(sim_sopt5_lpuart0ode:0)) |        // LPUART 0 Open Drain Enable
      \t#endif
      \t#ifdef SIM_SOPT5_LPUART0TXSRC
      \t   SIM_SOPT5_LPUART0TXSRC($(sim_sopt5_lpuart0txsrc:0)) |      // LPUART 0 transmit data source select
      \t#endif
      \t#ifdef SIM_SOPT5_LPUART0RXSRC
      \t   SIM_SOPT5_LPUART0RXSRC($(sim_sopt5_lpuart0rxsrc:0)) |      // LPUART 0 receive data source select
      \t#endif
      \t#ifdef SIM_SOPT5_UART2ODE
      \t   SIM_SOPT5_UART2ODE($(sim_sopt5_uart2ode:0)) |        // UART 2 Open Drain Enable
      \t#endif
      \t#ifdef SIM_SOPT5_UART1ODE
      \t   SIM_SOPT5_UART1ODE($(sim_sopt5_uart1ode:0)) |        // UART 1 Open Drain Enable
      \t#endif
      \t#ifdef SIM_SOPT5_UART0ODE
      \t   SIM_SOPT5_UART0ODE($(sim_sopt5_uart0ode:0)) |        // UART 0 Open Drain Enable
      \t#endif
      \t#ifdef SIM_SOPT5_UART0TXSRC
      \t   SIM_SOPT5_UART0TXSRC($(sim_sopt5_uart0txsrc:0)) |      // UART 0 transmit data source select
      \t#endif
      \t#ifdef SIM_SOPT5_UART0RXSRC
      \t   SIM_SOPT5_UART0RXSRC($(sim_sopt5_uart0rxsrc:0)) |      // UART 0 receive data source select
      \t#endif
      \t#ifdef SIM_SOPT5_UART1TXSRC
      \t   SIM_SOPT5_UART1TXSRC($(sim_sopt5_uart1txsrc:0)) |      // UART 1 transmit data source select
      \t#endif
      \t#ifdef SIM_SOPT5_UART1RXSRC
      \t   SIM_SOPT5_UART1RXSRC($(sim_sopt5_uart1rxsrc:0)) |      // UART 1 receive data source select
      \t#endif
      \t      0;\n\n
   ]]></template>

   <template><![CDATA[
      \t/**
      \t * Select the ADC0 Trigger source
      \t * 
      \t * If TPM is selected by SimAdc0Trigger then Pre-triggers are TPM channel 0 (A) and channel 1 (B),
      \t * otherwise Pre-trigger 0/1 is determined by this parameter.\n
      \t * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source\n
      \t * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
      \t *
      \t * @param[in] simAdc0TriggerMode Select ADC0 Trigger mode 
      \t * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
      \t */
      \tstatic void setAdc0Triggers(SimAdc0TriggerMode simAdc0TriggerMode, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_External) {
      \t   sim->SOPT7 = (sim->SOPT7&~(SIM_SOPT7_ADC0TRGSEL_MASK|SIM_SOPT7_ADC0ALTTRGEN_MASK))|simAdc0Trigger|simAdc0TriggerMode;
      \t};\n\n
   ]]></template>
   
   <template><![CDATA[
      \t//! System Options Register 7
      \tstatic constexpr uint32_t sopt7 = 
      \t   SIM_SOPT7_ADC0ALTTRGEN($(sim_sopt7_adc0alttrgen)) |    // ADC0 alternate trigger enable
      \t   SIM_SOPT7_ADC0PRETRGSEL($(sim_sopt7_adc0pretrgsel)) |   // ADC0 pretrigger select
      \t   SIM_SOPT7_ADC0TRGSEL($(sim_sopt7_adc0trgsel));       // ADC0 trigger select\n\n
   ]]></template>

   <template><![CDATA[
      \t#ifdef SIM_CLKDIV2_USBDIV_MASK
      \t/**
      \t * Set USB clock divisors to suitable value
      \t */
      \tstatic void setUsbClock() {
      \t   if ((sim->SOPT2&SIM_SOPT2_USBSRC_MASK) != SimUsbFullSpeedClockSource_Peripheral) {
      \t      // Assume MCG clock setting value is suitable
      \t      //sim->CLKDIV2 = clkdiv2;
      \t      return;
      \t   }
      \t   // Try to calculate value
      \t   unsigned inputFreq = getPeripheralClock();
      \t   for (unsigned frac = 0; frac < 2; frac++) {
      \t      for (unsigned div = 0; div < 8; div++) {
      \t         unsigned usbClock = (inputFreq * (frac+1))/(div+1);
      \t         if (usbClock == 48000000) {
      \t            sim->CLKDIV2 = SIM_CLKDIV2_USBFRAC(frac)|SIM_CLKDIV2_USBDIV(div);
      \t         }
      \t      }
      \t   }
      \t}
      \t#endif

      \t/**
      \t * Initialise SIM registers
      \t */
      \tstatic void initRegs() {
      \t#ifdef SIM_SCGC4_USBOTG_MASK
      \t   // The USB interface must be disabled for clock changes to have effect
      \t   sim->SCGC4 = sim->SCGC4 & ~SIM_SCGC4_USBOTG_MASK;
      \t#endif
      \t
      \t#if defined(SIM_SOPT1_OSC32KOUT) || defined(SIM_SOPT1_OSC32KSEL)
      \t   sim->SOPT1 = sopt1;
      \t#endif
      \t   // sim->SOPT2(PLLFLLSEL) may also be altered by MCG clock code
      \t   sim->SOPT2 = sopt2;
      \t   sim->SOPT4 = sopt4;
      \t   sim->SOPT5 = sopt5;
      \t   sim->SOPT7 = sopt7;
      \t
      \t#ifdef SIM_CLKDIV2_USBDIV_MASK
      \t   setUsbClock();
      \t#endif
      \t}\n\n
   ]]></template>
</fragment>

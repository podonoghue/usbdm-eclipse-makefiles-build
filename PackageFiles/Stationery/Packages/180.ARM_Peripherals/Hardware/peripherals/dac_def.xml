<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- Dac_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <constant key="irq_parameters"            type="String"  value="&quot;uint8_t status&quot;"  />
   <constant key="irq_dummy_parameters"      type="String"  value="&quot;uint8_t&quot;"  />
   <constant key="irq_call"                  type="String"  value="&quot;getAndClearStatus()&quot;"  />
   <constant key="generateDefault"           type="Boolean" value="false"         />
   <constant key="configureInStartupDefault" type="Boolean" value="false"         />
   <xi:include href="enablePeripheral.xml"  />
   <title />

<!--
    * General substitutions
    *  $(_NAME)         => e.g FTM2 => FTM2
    *  $(_name)         => e.g FTM2 => ftm2
    *  $(_BASENAME)     => e.g FTM0 => FTM, PTA => PT
    *  $(_basename)     => e.g FTM0 => ftm, PTA => pt
    *  $(_Class)        => e.g FTM2 => Ftm2
    *  $(_Baseclass)    => e.g FTM0 => Ftm
    *  $(_instance)     => e.g FTM0 => 0, PTA => A
-->

<!--
    * Template substitutions
    *
    * <li>%paramExpression            Parameters ORed together e.g. adcPretrigger|adcRefSel
    * <li>%valueExpression            Numeric variable value e.g. 0x3
    * <li>%symbolicExpression[index]  Symbolic formatted value e.g. AdcCompare_Disabled
    * <li>%variable[index]            Variable name /ADC0/adc_sc2_acfe
    * <li>%macro[index](value)        C register macro e.g. ADC_SC2_ACFGT(value)
    * <li>%description[index]         Description from controlVar e.g. Compare Function Enable
    * <li>%shortDescription[index]    Short description from controlVar e.g. Compare Function Enable
    * <li>%tooltip[index]             Tool-tip from controlVar e.g. Each bit disables the GPIO function
    * <li>%params                     Formatted parameter list for function
    * <li>%paramDescription[index]    Tool-tip from controlVar formatted as param description @param ...
    * <li>%paramType[index]           Based on typeName e.g. AdcCompare (or uint32_t)
    * <li>%paramName[index]           Based on typeName with lower-case first letter adcCompare
    * <li>%fieldAssignment            Expression of form '%register <= (%register & ~%mask)|%paramExpression
    * <li>%maskingExpression          Based on variable etc. Similar to (%register&%mask)
    * <li>%mask[index]                From &lt;mask&gt; or deduced from &lt;controlVarName&gt; e.g. "SIM_SOPT_REG_MASK" (_MASK is added)
    * <li>%register[index]            Register associated with variable e.g. adc->APCTL1
    * <li>%registerName[index]        Name of corresponding register (lowercase for Init()) e.g. apctl1
    * <li>%registerNAME[index]        Name of corresponding register (uppercase for Init()) e.g. APCTL1 <br><br>
-->

   <!-- ************* Class Declaration ****************** -->
   <constant key="_class_declaration" type="String"
      value="&quot;$(_Class)Info : public $(_Structname)BasicInfo&quot;" />

   <constant key="disable_peripheral" value = "&quot;dac->C0 = DAC_C0_DACEN(0);&quot;" type="String" />

   <template><![CDATA[
      \t//! Pin number in Info table for DAC output if mapped to a pin
      \tstatic constexpr int outputPin  = 0;\n\n
   ]]></template>

   <!-- ************* C0 ****************** -->

   <binaryOption key="dac_c0_dacen" condition="dac_c0_dacen_present"
      enabledBy="enablePeripheralSupport"
      typeName="DacMode"
      toolTip="Enable for DAC"
      description="Enable" >
      <choice name="DAC is disabled"  value="0" enum="Disabled"/>
      <choice name="DAC is enabled"   value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="dac_c0_dacrfs" condition="dac_c0_dacrfs_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReferenceSelect"
      toolTip="Selects the DAC reference voltage. \n
               The output range is [0..Vselected]"
      description="DAC Reference Select" >
      <choice value="0" name="Vrefh or VrefOut(1.2V)" enum="VrefOut" />
      <choice value="1" name="VddA"                   enum="Vdda"    isDefault="true" />
   </binaryOption>

   <binaryOption key="dac_c0_dactrgsel" condition="dac_c0_dactrgsel_present"
      enabledBy="dac_c0_dacen"
      typeName="DacTriggerSelect"
      toolTip="Selects the DAC Trigger"
      description="DAC Trigger Select" >
      <choice value="0" name="Hardware trigger" enum="Hardware" />
      <choice value="1" name="Software trigger" enum="Software" isDefault="true" />
   </binaryOption>

   <binaryOption key="dac_c0_lpen" condition="dac_c0_lpen_present"
      enabledBy="dac_c0_dacen"
      typeName="DacPower"
      toolTip="Controls power consumption of DAC"
      description="DAC Low Power Control" >
      <choice value="0" name="High-Power mode" enum="High" isDefault="true" />
      <choice value="1" name="Low-Power mode"  enum="Low"  />
   </binaryOption>

   <binaryOption key="dac_c0_dacbwien" condition="dac_c0_dacbwien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacWatermarkAction"
      toolTip="Control whether an interrupt is generated when SR.DACBFWMF is set i.e.\n
               when the DAC buffer read pointer has reached the watermark level."
      description="Buffer Watermark Action" >
      <choice value="0" name="No action" enum="None"       isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt"  />
   </binaryOption>

   <binaryOption key="dac_c0_dacswtrg" condition="dac_c0_dacswtrg_present"
      locked="true"
      enabledBy="enablePeripheralSupport"
      typeName="DacTrigger"
      description="Software Trigger" >
      <choice name="Trigger is not valid"  value="0" enum="TriggerIsNotValid"/>
      <choice name="Trigger is valid"      value="1" enum="TriggerIsValid"/>
   </binaryOption >

   <binaryOption key="dac_c0_dacbtien" condition="dac_c0_dacbtien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReadPtrTopAction"
      toolTip="Control whether an interrupt is generated when SR.DACBFRPTF is set i.e.\n
               when the DAC buffer read pointer is zero."
      description="Read Pointer Top Action" >
      <choice value="0" name="No action" enum="None"      isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt" />
   </binaryOption>

   <binaryOption key="dac_c0_dacbbien" condition="dac_c0_dacbbien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReadPtrBottomAction"
      toolTip="Control whether an interrupt is generated when SR.DACBFRPBF is set i.e. \n
               when the DAC buffer read pointer is equal to buffer upper limit (C2.DACBFUP)"
      description="Read Pointer Bottom Action" >
      <choice value="0" name="No action" enum="None"      isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt" />
   </binaryOption>

   <!-- ************* C1 ****************** -->

   <binaryOption key="dac_c1_dmaen" condition="dac_c1_dmaen_present"
      enabledBy="dac_c0_dacen"
      typeName="DacDma"
      toolTip="When DMA is enabled, DMA requests are generated instead of interrupt requests. \n
               The DMA Done signal clears the DMA request. \n
               The status register flags are still set and are cleared automatically when the DMA completes."
      description="Generate DMA request" >
      <choice value="0" name="DMA is disabled" enum="Enabled" isDefault="true" />
      <choice value="1" name="DMA is enabled"  enum="Disabled" />
   </binaryOption>

   <choiceOption key="dac_c1_buffer_mode" condition="dac_c1_dacbfen_present &amp;&amp; dac_c1_dacbfmd_present"
      enabledBy="dac_c0_dacen"
      valueFormat="DAC_C1_DACBFEN(%s),DAC_C1_DACBFMD(%s)"
      typeName="DacBufferMode"
      toolTip="Modes:\n
               Disabled: The first word of the buffer is used to control the DAC output level.\n
               Normal:   Pointer moves [0..max] and wraps \n
               Swing:    Pointer moves [0..max..0] and repeats \n
               Scan:     Pointer moves [0..max] and stops \n
               Fifo:     DAT array acts as a FIFO \n
               Not all modes are available in all devices."
      description="Buffer operation mode" >
      <choice value="0,0" name="Disabled"           enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Normal"             enum="Normal"    />
      <choice value="1,1" name="One-Time Scan mode" enum="Scan"      condition="!dac_c1_dacbfmd_swing_present &amp;&amp; !dac_c1_dacbfmd_fifo_present" />
      <choice value="1,1" name="Swing mode"         enum="Swing"     condition="dac_c1_dacbfmd_swing_present" />
      <choice value="1,2" name="One-Time Scan mode" enum="Scan"      condition="dac_c1_dacbfmd_swing_present || dac_c1_dacbfmd_fifo_present" />
      <choice value="1,3" name="FIFO mode"          enum="Fifo"      condition="dac_c1_dacbfmd_fifo_present"  />
   </choiceOption>

   <choiceOption key="dac_c1_dacbfwm" condition="dac_c1_dacbfwm_present"
      enabledBy="dac_c0_dacen"
      typeName="DacWaterMark"
      description="Buffer Watermark Select"
      toolTip="Controls when SR[DACBFWMF] is set.\n
               Normal Mode: \n
                 SR[DACBFWMF] will be set when the DAC buffer read pointer reaches this many words away \n
                 from the upper limit (DACBUP). This allows user configuration of the watermark interrupt. \n
               FIFO mode: \n
                 SR[DACBFWMF] will be set when there is a threshold number of entries left in the FIFO.">
      <choice value="0" name="Normal mode: 1 free entry"                enum="Normal_1"      isDefault="true" />
      <choice value="1" name="Normal mode: 2 free entries"              enum="Normal_2"      condition="@dac_data_dim>1" />
      <choice value="2" name="Normal mode: 3 free entries"              enum="Normal_3"      condition="@dac_data_dim>2" />
      <choice value="3" name="Normal mode: 4 free entries"              enum="Normal_4"      condition="@dac_data_dim>3" />
      <choice value="0" name="FIFO threshold: &lt;= 2 full entries"     enum="Fifo2"         condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="1" name="FIFO threshold: &lt;= Max/4 full entries" enum="FifoMaxDiv4"   condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="2" name="FIFO threshold: &lt;= Max/2 full entries" enum="FifoMaxDiv2"   condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="3" name="FIFO threshold: &lt;= Max-2 full entries" enum="FifoMaxMinus2" condition="dac_c1_dacbfmd_fifo_present" />
   </choiceOption>

   <!-- ************* C2 ****************** -->

   <choiceOption key="dac_c2_dacbfrp" condition="dac_c2_dacbfrp_present"
      locked="true"
      enabledBy="enablePeripheralSupport"
      typeName="DacC2Dacbfrp"
      toolTip="In normal mode it keeps the current value of the buffer read pointer.\n
               In FIFO mode it is the FIFO read pointer. \n
               It is writable in FIFO mode. User can configure it to same address to reset FIFO as empty."
      description="Buffer Read Pointer" >
      <choice name="Buffer Pointer"  value="0" enum="BufferPointer"/>
   </choiceOption >

   <choiceOption key="dac_c2_dacbfup" condition="dac_c2_dacbfup_present"
      enabledBy="dac_c0_dacen"
      typeName="DacBufferUpperLimit"
      toolTip="Normal mode\n
               - Selects the upper limit of the DAC buffer. The buffer read pointer cannot exceed it\n
               FIFO mode\n
               - This register becomes the Write_Pointer and its value is initially set to equal\n
                 READ_POINTER automatically and the FIFO status is empty. \n
                 It is writable and the user can configure it to the same address to reset FIFO as empty."
      description="DAC Buffer Upper Limit" >
      <choiceExpansion keys="dac_data" dim="=dac_data_dim" value="%(dac_data)" name="%(dac_data) entries" enum="%(dac_data)" />
      <choice value="15" name="max entries" enum="Max" isDefault="true" />
   </choiceOption>

   <!-- ************* SR ****************** -->

   <binaryOption key="dac_sr_dacbfwmf" condition="dac_sr_dacbfwmf_present"
      enabledBy="dac_c0_dacen"
      description="DAC Buffer Watermark Flag"
      hidden="true"
      typeName="DacWatermarkFlag"
      toolTip="This bit is set if the remaining FIFO data is less than the watermark setting.\n
               It is cleared automatically by writing data into FIFO by DMA or CPU. \n
               Write to this bit is ignored in FIFO mode." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

   <binaryOption key="dac_sr_dacbfrptf" condition="dac_sr_dacbfrptf_present"
      description="DAC Buffer Read Pointer Top Position Flag"
      hidden="true"
      typeName="DacReadPtrTopFlag"
      toolTip="In FIFO mode, it is FIFO nearly empty flag. \n
               It is set when only one data remains in FIFO. \n
               Any DAC trigger does not increase the Read Pointer if this bit is set to \n
               avoid any possible glitch or abrupt change at DAC output. \n
               It is cleared automatically if FIFO is not empty." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

   <binaryOption key="dac_sr_dacbfrpbf" condition="dac_sr_dacbfrpbf_present"
      description="DAC Buffer Read Pointer Bottom Position Flag"
      hidden="true"
      typeName="DacReadPtrBottomFlag"
      toolTip="In FIFO mode, it is FIFO FULL status bit. \n
      It means FIFO read pointer equals Write Pointer because of Write Pointer increase. \n
      If this bit is set, any write to FIFO from either DMA or CPU is ignored by DAC. \n
      It is cleared if there is any DAC trigger making the DAC read pointer increase. \n
      Write to this bit is ignored in FIFO mode." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

<!-- Setters and getters -->

   <variableTemplate codeGenCondition="enableGettersAndSetters"
      variables="dac_c0_dacbwien, dac_c0_dacbtien, dac_c0_dacbbien"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      %paramDescription
      \t */
      \tstatic void setActions(
      %params) {
      \t
      \t   %register = (%register&~%mask) |
      \t               %paramExpression;
      \t}
      \t\n
   ]]></variableTemplate>

   <for keys="field           : get   : set   : genCode                 : name"
        values="
         dac_data_data        : true  : true  : enableGettersAndSetters : Data;
         dac_sr_dacbfwmf      : true  : true  : enableGettersAndSetters : WaterMarkFlag;
         dac_sr_dacbfrptf     : true  : true  : enableGettersAndSetters : ReadPointerTopFlag;
         dac_sr_dacbfrpbf     : true  : true  : enableGettersAndSetters : ReadPointerBottomFlag;
         dac_c0_dacen         : true  : true  : enableGettersAndSetters : Enable;
         dac_c0_dacrfs        : true  : true  : enableGettersAndSetters : Reference;
         dac_c0_dactrgsel     : true  : true  : enableGettersAndSetters : TriggerSelect;
         dac_c0_dacswtrg      : true  : true  : enableGettersAndSetters : Trigger;
         dac_c0_lpen          : true  : true  : enableGettersAndSetters : LowPower;
         dac_c0_dacbwien      : true  : true  : enableGettersAndSetters : WaterMarkAction;
         dac_c0_dacbtien      : true  : true  : enableGettersAndSetters : ReadPointerTopAction;
         dac_c0_dacbbien      : true  : true  : enableGettersAndSetters : ReadPointerBottomAction;
         dac_c1_dmaen         : true  : true  : enableGettersAndSetters : Dma;
         dac_c1_dacbfwm       : true  : true  : enableGettersAndSetters : WaterMark;
         dac_c1_buffer_mode   : true  : true  : enableGettersAndSetters : BufferMode;
         dac_c2_dacbfrp       : true  : true  : enableGettersAndSetters : ReadPointer;
         dac_c2_dacbfup       : true  : true  : enableGettersAndSetters : UpperLimit" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

   <!--   ========== class $(_Structname)BasicInfo =============================== -->

   <template namespace="baseClass" ><![CDATA[
      class $(_Structname)BasicInfo {

      public:\n
   ]]></template>

   <!--   ========== Interrupt handling =============================== -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="irqHandlingMethod"
   ><![CDATA[
       \t//! Common class based callback code has been generated for this class of peripheral
       \tstatic constexpr bool irqHandlerInstalled = %symbolicExpression;
       \t\n
   ]]></variableTemplate>

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo" >
   <![CDATA[
      \t/**
      \t * Type definition for $(_Baseclass) interrupt call back.
      \t */
      \ttypedef void (*CallbackFunction)($(irq_parameters));
      \t
      \t/**
      \t * Callback to catch unhandled interrupt
      \t */
      \tstatic void unhandledCallback($(irq_dummy_parameters)) {
      \t   setAndCheckErrorCode(E_NO_HANDLER);
      \t}
      \t\n
   ]]>
   </template>

   <template codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t/** Callback function for ISR */
      \tstatic CallbackFunction sCallback;
      \t
      \t/**
      \t * Set interrupt callback function.
      \t *
      \t * @param[in]  $(_basename)Callback Callback function to execute on interrupt
      \t *                             Use nullptr to remove callback.
      \t */
      \tstatic void setCallback(CallbackFunction $(_basename)Callback) {
      \t   if ($(_basename)Callback == nullptr) {
      \t      $(_basename)Callback = unhandledCallback;
      \t   }
      \t   // Allow either no handler set yet or removing handler
      \t   usbdm_assert(
      \t         (sCallback == unhandledCallback) || ($(_basename)Callback == unhandledCallback),
      \t         "Handler already set");
      \t   sCallback = $(_basename)Callback;
      \t}
      \t
      \t/**
      \t * Get and clear DAC status
      \t *
      \t * @return DAC status value see DacStatus
      \t */
      \tstatic uint8_t getAndClearStatus() {
      \t   // Get status
      \t   uint8_t status = dac->SR;
      \t
      \t   // Clear set flags
      \t   dac->SR = ~status;
      \t
      \t   // return original status
      \t   return status;
      \t}
      \t
      \t/**
      \t * $(_BASENAME) interrupt handler -  Calls $(_BASENAME) callback
      \t */
      \tstatic void irqHandler() {
      \t
      \t   // Execute call-back
      \t   sCallback($(irq_call));
      \t}
      \t\n
   ]]>
   </template>

   <template key="/HARDWARE/StaticObjects" codeGenCondition="irqHandlingMethod" >
   <![CDATA[
      \t
      \t/**
      \t * Callback for programmatically set handler for $(_Class)
      \t */
      \t$(_Class)Info::CallbackFunction $(_Class)Info::sCallback = $(_Structname)BasicInfo::unhandledCallback;
      \t\n
   ]]>
   </template>

   <!--   ========== DAC Init class =============================== -->

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * ///
      \t * /// $(_NAME) call-back
      \t * ///
      \t * /// @param status  Status reflecting active inputs
      \t * ///
      \t * void $(_name)Callback(uint32_t status) {
      \t *    (void) status;
      \t * }
      \t *
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   DacMode_Enabled ,             // Enable - DAC is enabled
      \t *   DacReferenceSelect_Vdda ,     // DAC Reference Select - VddA
      \t *   DacTriggerSelect_Software ,   // DAC Trigger Select - Software trigger
      \t *   DacPower_High ,               // DAC Low Power Control - High-Power mode
      \t *   DacWatermarkAction_None ,     // DAC Buffer Watermark Interrupt Enable - No action
      \t *   DacReadPtrTopAction_None ,    // DAC Buffer Read Pointer Top Flag Interrupt Enable - No action
      \t *   DacReadPtrBottomAction_None , // DAC Buffer Read Pointer Bottom Flag Interrupt Enable - No action
      \t *   DacDma_Enabled ,              // Generate DMA request - DMA is disabled
      \t *   DacWaterMark_Normal_1 ,       // Buffer Watermark Select - Normal mode: 1 free entry
      \t *   DacBufferMode_Normal ,        // Buffer operation mode - Normal
      \t *   DacC2Dacbfrp_BufferPointer ,  // Buffer Read Pointer - Buffer Pointer
      \t *   DacBufferUpperLimit_Max,      // DAC Buffer Upper Limit - max entries
      \t *
      \t *   $(_name)Callback,                 // Call-back to execute on event - call-back function name
      \t *   NvicPriority_Low,             // Priority for interrupt - Low
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!--   Member variables -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
    ><![CDATA[
      \t   /// %description
      \t   %params = nullptr;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel,irqLevel"
   ><![CDATA[
      \t   /// %description
      \t   %paramType %registerName0 = %defaultValue;
      \t\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dac_c0_dacen,dac_c0_dacrfs,dac_c0_dactrgsel,dac_c0_dacswtrg,dac_c0_lpen,dac_c0_dacbwien,dac_c0_dacbtien,dac_c0_dacbbien"
   ><![CDATA[
      \t   /// Control Register 0
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dac_c1_dmaen,dac_c1_dacbfwm,dac_c1_dacbfmd,dac_c1_dacbfen"
   ><![CDATA[
      \t   /// Control Register 1
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="dac_c2_dacbfrp,dac_c2_dacbfup"
   ><![CDATA[
      \t   /// Control Register 2
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <!--   Constructors -->

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="irqHandlingMethod"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      this->%paramName0 = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
      variables="/PCR/nvic_irqLevel"
      linePadding="xxx"
   ><![CDATA[
      \t   /**
      \t    * Constructor for %description
      \t    *
      \t    * @tparam   Types
      \t    * @param    rest
      \t    *
      %paramDescription
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(%params, Types... rest) : Init(rest...) {
      \t
      \t      %registerName = %paramExpression;
      \t   }\n\n
   ]]></variableTemplate>

   <for keys="r"
      values="
            dac_c0_dacen;
            dac_c0_dacrfs;
            dac_c0_dactrgsel;
            dac_c0_lpen;
            dac_c0_dacbwien;
            dac_c0_dacbtien;
            dac_c0_dacbbien;
            dac_c1_dmaen;
            dac_c1_dacbfwm;
            dac_c1_buffer_mode;
            dac_c2_dacbfrp;
            dac_c2_dacbfup
            " >
      <variableTemplate namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

<!--   Default Initialisation value -->

   <variableTemplate codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            dac_c0_dacen,
            dac_c0_dacrfs,
            dac_c0_dactrgsel,
            dac_c0_lpen,
            dac_c0_dacbwien,
            dac_c0_dacbtien,
            dac_c0_dacbbien,
            dac_c1_dmaen,
            dac_c1_dacbfwm,
            dac_c1_buffer_mode,
            dac_c2_dacbfrp,
            dac_c2_dacbfup
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};
      \t\n
   ]]></variableTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   configure(Info::DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const typename Info::Init &init) {
      \t
      \t   // Enable peripheral clock
      \t   Info::enableClock();
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedIrqInfo"
             condition="/$(_STRUCTNAME)/generateSharedIrqInfo" >   <![CDATA[
      \t   if constexpr (Info::irqHandlerInstalled) {
      \t      // Only set call-backs if feature enabled
      \t      Info::setCallback(init.callbackFunction);
      \t      Info::enableNvicInterrupts(init.irqlevel);
      \t   }
      \t\n
   ]]></template>
   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t   dac->C0    = init.c0;
      \t   dac->C1    = init.c1;
      \t   dac->C2    = init.c2;
      \t}
      \t\n
   ]]>
   </template>

   <template namespace="baseClass" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t}; // class $(_Structname)BasicInfo::Init
      \t\n
   ]]>
   </template>

   <template namespace="baseClass" >
   <![CDATA[
      }; // class $(_Structname)BasicInfo
      \t\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template><![CDATA[
      \t/// Number of Data output registers
      \tstatic constexpr size_t NumDataRegisters = $(dac_data_dim);
      \t\n
   ]]></template>

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base_T<$(_Class)Info> {};
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="dac_files" >
      <copy source="Project_Headers/dac.h"                         target="Project_Headers/dac.h"                         overwrite="true" derived="true" />
      <copy source="Snippets/dac-example.cpp"                      target="Snippets/dac-example.cpp"                      overwrite="true" derived="true" />
      <copy source="Snippets/dac-dma-pdb-example.cpp"              target="Snippets/dac-dma-pdb-example.cpp"              overwrite="true" derived="true" />
      <copy source="Snippets/dac-dma-pitThrottled-example.cpp"     target="Snippets/dac-dma-pitThrottled-example.cpp"     overwrite="true" derived="true" />
      <copy source="Snippets/dac-hardwareTrigger-dma-example.cpp"  target="Snippets/dac-hardwareTrigger-dma-example.cpp"  overwrite="true" derived="true" />
      <copy source="Snippets/dac-hardwareTrigger-example.cpp"      target="Snippets/dac-hardwareTrigger-example.cpp"      overwrite="true" derived="true" />
      <copy source="Snippets/dac-softwareTrigger-example.cpp"      target="Snippets/dac-softwareTrigger-example.cpp"      overwrite="true" derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ************* SIM configuration ****************** -->

   <category name="Advanced" description="SIM configuration">
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>
   <deleteVariables variables="_scgc_clock"  mustExist="false" />

   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</fragment>

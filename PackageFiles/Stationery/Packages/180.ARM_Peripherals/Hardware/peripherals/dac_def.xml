<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- Dac_def.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude">

   <constant key="disable_peripheral" value = '"dac->C0 = DAC_C0_DACEN(0);"' type="String" />

   <!-- ____ Class Declarations ________ -->
   <constant key="_class_declaration" type="String" value='"$(_Info) : public $(_BasicInfo)"' />

   <constant key="definitionsInHeader" value="true" type="Boolean" />

   <!-- ____ Instance control ________ -->
   <constant key="_can_create_instance" value="true" type="Boolean" />

   <equation key="irq_parameters"             value="uint8_t status"  />
   <equation key="irq_dummy_parameters"       value="uint8_t"  />
   <equation key="irq_call_parameters"        value="getAndClearStatus()"  />
   <equation key="generateDefault"            value="false"         />
   <equation key="configureInStartupDefault"  value="false"         />
   <xi:include href="enablePeripheral.xml"  />
   <title />


   <template><![CDATA[
      \t//! Pin number in Info table for DAC output if mapped to a pin
      \tstatic constexpr int outputPin  = 0;\n\n
   ]]></template>

   <!-- _____________ C0 __________________ -->

   <binaryOption key="dac_c0_dacen" condition="dac_c0_dacen_present"
      enabledBy="enablePeripheralSupport"
      typeName="DacMode"
      baseType="uint8_t"
      toolTip="Enable for DAC"
      description="Enable" >
      <choice name="DAC is disabled"  value="0" enum="Disabled"/>
      <choice name="DAC is enabled"   value="1" enum="Enabled"/>
   </binaryOption >

   <binaryOption key="dac_c0_dacrfs" condition="dac_c0_dacrfs_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReferenceSelect"
      baseType="uint8_t"
      toolTip="Selects the DAC reference voltage. \n
               The output range is [0..Vselected]"
      description="DAC Reference Select" >
      <choice value="0" name="Vrefh or VrefOut(1.2V)" enum="VrefOut" />
      <choice value="1" name="VddA"                   enum="Vdda"    isDefault="true" />
   </binaryOption>

   <binaryOption key="dac_c0_dactrgsel" condition="dac_c0_dactrgsel_present"
      enabledBy="dac_c0_dacen"
      typeName="DacTriggerSelect"
      baseType="uint8_t"
      toolTip="Selects the DAC Trigger"
      description="DAC Trigger Select" >
      <choice value="0" name="Hardware trigger" enum="Hardware" />
      <choice value="1" name="Software trigger" enum="Software" isDefault="true" />
   </binaryOption>

   <binaryOption key="dac_c0_lpen" condition="dac_c0_lpen_present"
      enabledBy="dac_c0_dacen"
      typeName="DacPower"
      baseType="uint8_t"
      toolTip="Controls power consumption of DAC"
      description="DAC Low Power Control" >
      <choice value="0" name="High-Power mode" enum="High" isDefault="true" />
      <choice value="1" name="Low-Power mode"  enum="Low"  />
   </binaryOption>

   <binaryOption key="dac_c0_dacbwien" condition="dac_c0_dacbwien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacWatermarkAction"
      baseType="uint8_t"
      toolTip="Control whether an interrupt is generated when SR.DACBFWMF is set i.e.\n
               when the DAC buffer read pointer has reached the watermark level."
      description="Buffer Watermark Action" >
      <choice value="0" name="No action" enum="None"       isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt"  />
   </binaryOption>

   <binaryOption key="dac_c0_dacswtrg" condition="dac_c0_dacswtrg_present"
      derived="true"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="DacTrigger"
      baseType="uint8_t"
      description="Software Trigger" 
      toolTip="This is a write-only field, which always reads 0.\n
               If DAC software trigger is selected and buffer is enabled, writing 1\n
               to this field will advance the buffer read pointer once." >
      <choice name="Trigger not asserted"  value="0" enum="TriggerNotAsserted" />
      <choice name="Trigger asserted"      value="1" enum="TriggerAsserted"    />
   </binaryOption >

   <binaryOption key="dac_c0_dacbtien" condition="dac_c0_dacbtien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReadPtrTopAction"
      baseType="uint8_t"
      toolTip="Control whether an interrupt is generated when SR.DACBFRPTF is set i.e.\n
               when the DAC buffer read pointer is zero."
      description="Read Pointer Top Action" >
      <choice value="0" name="No action" enum="None"      isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt" />
   </binaryOption>

   <binaryOption key="dac_c0_dacbbien" condition="dac_c0_dacbbien_present"
      enabledBy="dac_c0_dacen"
      typeName="DacReadPtrBottomAction"
      baseType="uint8_t"
      toolTip="Control whether an interrupt is generated when SR.DACBFRPBF is set i.e. \n
               when the DAC buffer read pointer is equal to buffer upper limit (C2.DACBFUP)"
      description="Read Pointer Bottom Action" >
      <choice value="0" name="No action" enum="None"      isDefault="true" />
      <choice value="1" name="Interrupt" enum="Interrupt" />
   </binaryOption>

   <!-- _____________ C1 __________________ -->

   <binaryOption key="dac_c1_dmaen" condition="dac_c1_dmaen_present"
      enabledBy="dac_c0_dacen"
      typeName="DacDma"
      baseType="uint8_t"
      toolTip="When DMA is enabled, DMA requests are generated instead of interrupt requests. \n
               The DMA Done signal clears the DMA request. \n
               The status register flags are still set and are cleared automatically when the DMA completes."
      description="Generate DMA request" >
      <choice value="0" name="DMA is disabled" enum="Enabled" isDefault="true" />
      <choice value="1" name="DMA is enabled"  enum="Disabled" />
   </binaryOption>

   <choiceOption key="dac_c1_buffer_mode" condition="dac_c1_dacbfen_present &amp;&amp; dac_c1_dacbfmd_present"
      enabledBy="dac_c0_dacen"
      valueFormat="DAC_C1_DACBFEN(%s),DAC_C1_DACBFMD(%s)"
      typeName="DacBufferMode"
      baseType="uint8_t"
      toolTip="Modes:\n
               Disabled: The first word of the buffer is used to control the DAC output level.\n
               Normal:   Pointer moves [0..max] and wraps \n
               Swing:    Pointer moves [0..max..0] and repeats \n
               Scan:     Pointer moves [0..max] and stops \n
               Fifo:     DAT array acts as a FIFO \n
               Not all modes are available in all devices."
      description="Buffer operation mode" >
      <choice value="0,0" name="Disabled"           enum="Disabled"  isDefault="true" />
      <choice value="1,0" name="Normal"             enum="Normal"    />
      <choice value="1,1" name="One-Time Scan mode" enum="Scan"      condition="!dac_c1_dacbfmd_swing_present &amp;&amp; !dac_c1_dacbfmd_fifo_present" />
      <choice value="1,1" name="Swing mode"         enum="Swing"     condition="dac_c1_dacbfmd_swing_present" />
      <choice value="1,2" name="One-Time Scan mode" enum="Scan"      condition="dac_c1_dacbfmd_swing_present || dac_c1_dacbfmd_fifo_present" />
      <choice value="1,3" name="FIFO mode"          enum="Fifo"      condition="dac_c1_dacbfmd_fifo_present"  />
   </choiceOption>

   <choiceOption key="dac_c1_dacbfwm" condition="dac_c1_dacbfwm_present"
      enabledBy="dac_c1_buffer_mode>1"
      typeName="DacWaterMark"
      baseType="uint8_t"
      description="Buffer Watermark Select"
      toolTip="Controls when SR[DACBFWMF] is set.\n
               Normal Mode: \n
                 SR[DACBFWMF] will be set when the DAC buffer read pointer reaches this many words away \n
                 from the upper limit (DACBUP). This allows user configuration of the watermark interrupt. \n
               FIFO mode: \n
                 SR[DACBFWMF] will be set when there is a threshold number of entries left in the FIFO.">
      <choice value="0" name="Normal mode: 1 free entry"                enum="Normal_1"      enabledBy="dac_c1_buffer_mode>1" isDefault="true" />
      <choice value="1" name="Normal mode: 2 free entries"              enum="Normal_2"      enabledBy="dac_c1_buffer_mode>1" condition="@dac_data_dim>1" />
      <choice value="2" name="Normal mode: 3 free entries"              enum="Normal_3"      enabledBy="dac_c1_buffer_mode>1" condition="@dac_data_dim>2" />
      <choice value="3" name="Normal mode: 4 free entries"              enum="Normal_4"      enabledBy="dac_c1_buffer_mode>1" condition="@dac_data_dim>3" />
      <choice value="4" name="FIFO threshold: &lt;= 2 full entries"     enum="Fifo2"         enabledBy="dac_c1_buffer_mode==4" condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="5" name="FIFO threshold: &lt;= Max/4 full entries" enum="FifoMaxDiv4"   enabledBy="dac_c1_buffer_mode==4" condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="6" name="FIFO threshold: &lt;= Max/2 full entries" enum="FifoMaxDiv2"   enabledBy="dac_c1_buffer_mode==4" condition="dac_c1_dacbfmd_fifo_present" />
      <choice value="7" name="FIFO threshold: &lt;= Max-2 full entries" enum="FifoMaxMinus2" enabledBy="dac_c1_buffer_mode==4" condition="dac_c1_dacbfmd_fifo_present" />
   </choiceOption>

   <!-- _____________ C2 __________________ -->

   <choiceOption key="dac_c2_dacbfrp[0]" condition="dac_c2_dacbfrp_present"
      derived="true"
      hidden="true"
      enabledBy="enablePeripheralSupport"
      typeName="DacWritePtr"
      baseType="uint8_t"
      toolTip="Only applicable in normal mode.\n
               It is the current value of the buffer read pointer."
      description="Buffer Read Pointer" >
      <choiceExpansion keys="dac_data" dim="=dac_data_dim" value="%(dac_data)" name="%(dac_data) entries" enum="%(dac_data)" />
      <choice value="15" name="max entries" enum="Max" isDefault="true" />
   </choiceOption >

   <choiceOption key="dac_c2_dacbfup[0]" condition="dac_c2_dacbfup_present"
      enabledBy="dac_c0_dacen"
      typeName="DacBufferUpperLimit"
      baseType="uint8_t"
      toolTip="Only applicable in Normal mode\n
               Selects the upper limit of the DAC buffer.\n
               The buffer read pointer cannot exceed it."
      description="DAC Buffer Upper Limit" >
      <choiceExpansion keys="dac_data" dim="=dac_data_dim" value="%(dac_data)" name="%(dac_data) entries" enum="%(dac_data)" />
      <choice value="15" name="max entries" enum="Max" isDefault="true" />
   </choiceOption>

   <choiceOption key="dac_c2_dacbfrp[1]" condition="dac_c2_dacbfrp_present&amp;&amp;dac_c1_dacbfmd_fifo_present"
      derived="true"
      hidden="true"
      typeName="DacFifoWritePtr"
      baseType="uint8_t"
      toolTip="Only applicable in FIFO mode. \n
               It is writable in FIFO mode.\n
               User can configure it to same value as the read pointer to reset FIFO as empty."
      description="FIFO Read Pointer" >
      <choiceExpansion keys="dac_data" dim="=dac_data_dim" value="%(dac_data)" name="%(dac_data) entries" enum="%(dac_data)" />
      <choice value="15" name="max entries" enum="Max" isDefault="true" />
   </choiceOption >

   <choiceOption key="dac_c2_dacbfup[1]" condition="dac_c2_dacbfup_present&amp;&amp;dac_c1_dacbfmd_fifo_present"
      derived="true"
      hidden="true"
      typeName="DacFifoReadPtr"
      baseType="uint8_t"
      toolTip="Only applicable in FIFO mode\n
               When the DAC is first configured to FIFO mode this register is set equal to the write pointer automatically.
               It is writable in FIFO mode.\n
               User can configure it to same value as the write pointer to reset FIFO as empty."
      description="FIFO Write pointer" >
      <choiceExpansion keys="dac_data" dim="=dac_data_dim" value="%(dac_data)" name="%(dac_data) entries" enum="%(dac_data)" />
      <choice value="15" name="max entries" enum="Max" isDefault="true" />
   </choiceOption>

   <!-- _____________ SR __________________ -->

   <binaryOption key="dac_sr_dacbfwmf" condition="dac_sr_dacbfwmf_present"
      enabledBy="dac_c0_dacen"
      description="DAC Buffer Watermark Flag"
      hidden="true"
      typeName="DacWatermarkFlag"
      baseType="uint8_t"
      toolTip="This bit is set if the remaining FIFO data is less than the watermark setting.\n
               It is cleared automatically by writing data into FIFO by DMA or CPU. \n
               Write to this bit is ignored in FIFO mode." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

   <binaryOption key="dac_sr_dacbfrptf" condition="dac_sr_dacbfrptf_present"
      description="DAC Buffer Read Pointer Top Position Flag"
      hidden="true"
      typeName="DacReadPtrTopFlag"
      baseType="uint8_t"
      toolTip="In FIFO mode, it is FIFO nearly empty flag. \n
               It is set when only one data remains in FIFO. \n
               Any DAC trigger does not increase the Read Pointer if this bit is set to \n
               avoid any possible glitch or abrupt change at DAC output. \n
               It is cleared automatically if FIFO is not empty." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

   <binaryOption key="dac_sr_dacbfrpbf" condition="dac_sr_dacbfrpbf_present"
      description="DAC Buffer Read Pointer Bottom Position Flag"
      hidden="true"
      typeName="DacReadPtrBottomFlag"
      toolTip="In FIFO mode, it is FIFO FULL status bit. \n
      It means FIFO read pointer equals Write Pointer because of Write Pointer increase. \n
      If this bit is set, any write to FIFO from either DMA or CPU is ignored by DAC. \n
      It is cleared if there is any DAC trigger making the DAC read pointer increase. \n
      Write to this bit is ignored in FIFO mode." >
      <choice value="0" name="NotReached"  enum="NotReached" isDefault="true" />
      <choice value="1" name="Reached"     enum="Reached" />
   </binaryOption>

   <bitfieldOption key="dac_sr"
      derived="true"
      hidden="false" 
      valueFormat="%s"
      enumClass="true"
      baseType="uint8_t"
      typeName="DacStatus"
      description="Status bits from DAC"
      toolTip="Bits masks for the status register" >
      <bitField var="dac_sr_dacbfwmf"  bit="2" condition="dac_sr_dacbfwmf_present" />
      <bitField var="dac_sr_dacbfrptf" bit="1" condition="dac_sr_dacbfrptf_present" />
      <bitField var="dac_sr_dacbfrpbf" bit="0" condition="dac_sr_dacbfrpbf_present" />
   </bitfieldOption>

   <intOption key="dac_data_index" condition="dac_data_dim"
      derived="true"
      hidden="true"
      description="DAC data array index"
      toolTip="Index into the DAC data array"
      baseType="unsigned"
      min="0"
      max="=dac_data_dim"
   />

   <intOption key="dac_data_data[0]" condition="dac_data_data_present"
      derived="true"
      hidden="true"
      description="DAC Data"
      toolTip="When the DAC buffer is not enabled, DATA[0] directly controls the DAC output voltage\n
               When FIFO is enabled DATA[0] writes to the FIFO."
      baseType="uint16_t"
   />

   <intOption key="dac_data_data[1]" condition="dac_data_data_present"
      derived="true"
      hidden="true"
      description="DAC Data array"
      toolTip="When the DAC buffer is enabled and not in FIFO mode, DATA is a 16-word array."
      baseType="uint16_t"
   />

<!-- ====================================================================================================== -->
<!--     START BasicInfo Class      -->
<!-- ====================================================================================================== -->

   <!-- BasicInfo Instance pointer and Constructors  -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t// Pointer to $(_BASENAME) hardware instance
      \tvolatile $(_Type) * const $(_basename);
      \t\n
   ]]></template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Constructor
      \t *
      \t * @param $(_basename) $(_BASENAME) hardware instance
      \t */
      \tconstexpr $(_BasicInfo)(volatile $(_Type) * $(_basename)) : $(_basename)($(_basename)) {
      \t}
      \t\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     START BasicInfo/Info duplicated methods -->
<!-- ====================================================================================================== -->

<for
   keys="   static    : const    : where     : guard                                      "
   values=" ''        : 'const ' : basicInfo : $(_BasicInfoGuard)                         ;
            'static ' : ''       : info      : $(_InfoGuard)                              "  >

   <!-- ____ Getters and Setters ____________ -->

   <for keys="field           : set   : get   : clear : genCode                 : name"
        values="
         dac_sr               : false : true  : false : true                    : Status;
         dac_c0_dacbwien,
         dac_c0_dacbtien,
         dac_c0_dacbbien      : true  : false : false : true                    : Actions;
         dac_sr_dacbfwmf      : false : true  : false : enableGettersAndSetters : WaterMarkFlag;
         dac_sr_dacbfrptf     : false : true  : false : enableGettersAndSetters : ReadPointerTopFlag;
         dac_sr_dacbfrpbf     : false : true  : false : enableGettersAndSetters : ReadPointerBottomFlag;
         dac_c0_dacen         : true  : true  : false : enableGettersAndSetters : Enable;
         dac_c0_dacrfs        : true  : true  : false : enableGettersAndSetters : Reference;
         dac_c0_dactrgsel     : true  : true  : false : enableGettersAndSetters : TriggerSelect;
         dac_c0_dacswtrg      : false : false : w1s   : enableGettersAndSetters : Trigger;
         dac_c0_lpen          : true  : true  : false : enableGettersAndSetters : LowPower;
         dac_c0_dacbwien      : true  : true  : false : enableGettersAndSetters : WaterMarkAction;
         dac_c0_dacbtien      : true  : true  : false : enableGettersAndSetters : ReadPointerTopAction;
         dac_c0_dacbbien      : true  : true  : false : enableGettersAndSetters : ReadPointerBottomAction;
         dac_c1_dmaen         : true  : true  : false : enableGettersAndSetters : Dma;
         dac_c1_dacbfwm       : true  : true  : false : enableGettersAndSetters : WaterMark;
         dac_c1_buffer_mode   : true  : true  : false : enableGettersAndSetters : BufferMode;
         dac_c2_dacbfrp[0]    : false : true  : false : enableGettersAndSetters : BufferReadPointer;
         dac_c2_dacbfup[0]    : true  : true  : false : enableGettersAndSetters : BufferUpperLimit;
         dac_c2_dacbfrp[1]    : true  : true  : false : enableGettersAndSetters : FifoReadPointer;
         dac_c2_dacbfup[1]    : true  : true  : false : enableGettersAndSetters : FifoWritePointer;
         dac_c2_dacbfrp[1],
         dac_c2_dacbfup[1]    : true  : false : false : enableGettersAndSetters : FifoPointers" >
      <variableTemplate location="%(where)" condition="%(set)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition="%(get)" codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)" >
      <![CDATA[
         \t/**
         \t * Get %description
         \t * (%variables)
         \t *
         \t * @return %tooltip
         \t */
         \t%(static)%returnType get%(name)() %(const){
         \t   return %fieldExtract;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="(%variables)"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void clear%(name)(%params) %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%paramExpression;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1cIm"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Clear %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void clear%(name)() %(const){
         \t   // w1c and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition='="w1s"=="%(clear)"' codeGenCondition="%(genCode)&amp;&amp;%(guard)"
         variables="%(field)"
         tooltipPadding="x*x" >
      <![CDATA[
         \t/**
         \t * Set %description
         \t * (%variables)
         \t *
         \t * %tooltip
         \t */
         \t%(static)void set%(name)() %(const){
         \t   // w1s and mixed register
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <for keys="field                     : set   : get   : clear : genCode                 : context              : name"
        values="
         dac_data_index,dac_data_data[1] : true  : true  : false : true                    : %s[%%paramName0]          : Data" >
      <variableTemplate location="%(where)" condition="%(set)" codeGenCondition="%(genCode)&amp;&amp;%(guard)" context="%(context)"
         variables="%(field)"
         nonDefaultParams="2"
         params="index,value" >
      <![CDATA[
         \t/**
         \t * Set %description1
         \t * (%variables)
         \t *
         %paramDescription
         \t */
         \t%(static)void set%(name)(%params) %(const){
         \t   %fieldAssignment1;
         \t}
         \t\n
      ]]>
      </variableTemplate>
      <variableTemplate location="%(where)" condition="%(get)" codeGenCondition="%(genCode)&amp;&amp;%(guard)" context="%(context)"
         variables="%(field)"
         nonDefaultParams="2"
         params="index" >
      <![CDATA[
         \t/**
         \t * Get %description1
         \t * (%variables)
         \t *
         %paramDescription0
         \t *
         \t * @return %tooltip1
         \t */
         \t%(static)%paramType1 get%(name)(%param0) %(const){
         \t   return %fieldExtract1;
         \t}
         \t\n
      ]]>
      </variableTemplate>
   </for>
   
   <variableTemplate location="%(where)" codeGenCondition="%(guard)" context="%s[0]"
      variables="dac_data_data[0]" >
   <![CDATA[
      \t/**
      \t * Set %description0
      \t * (%variables)
      \t *
      %paramDescription
      \t */
      \t%(static)void setData(%params) %(const){
      \t   %fieldAssignment;
      \t}
      \t\n
   ]]>
   </variableTemplate>
   
   <variableTemplate location="%(where)" codeGenCondition="%(guard)" context="%s[0]"
      variables="dac_c2_dacbfrp[1],dac_c2_dacbfup[1]" >
   <![CDATA[
      \t/**
      \t * Clear (empty) FIFO.
      \t */
      \t%(static)void clearFifo() %(const){
      \t   dac->C2 = %macro0(0)|%macro1(0);
      \t}
      \t\n
   ]]>
   </variableTemplate>
</for>

<!-- ====================================================================================================== -->
<!--     START BasicInfo::Init class      -->
<!-- ====================================================================================================== -->
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * static const $(_Class)::Init $(_name)Init {
      \t *
      \t *   // Setup values
      \t *   DacMode_Enabled ,             // Enable - DAC is enabled
      \t *   DacReferenceSelect_Vdda ,     // DAC Reference Select - VddA
      \t *   DacTriggerSelect_Software ,   // DAC Trigger Select - Software trigger
      \t *   DacPower_High ,               // DAC Low Power Control - High-Power mode
      \t *   DacWatermarkAction_None ,     // DAC Buffer Watermark Interrupt Enable - No action
      \t *   DacReadPtrTopAction_None ,    // DAC Buffer Read Pointer Top Flag Interrupt Enable - No action
      \t *   DacReadPtrBottomAction_None , // DAC Buffer Read Pointer Bottom Flag Interrupt Enable - No action
      \t *   DacDma_Enabled ,              // Generate DMA request - DMA is disabled
      \t *   DacWaterMark_Normal_1 ,       // Buffer Watermark Select - Normal mode: 1 free entry
      \t *   DacBufferMode_Normal ,        // Buffer operation mode - Normal
      \t *   DacC2Dacbfrp_BufferPointer ,  // Buffer Read Pointer - Buffer Pointer
      \t *   DacBufferUpperLimit_Max,      // DAC Buffer Upper Limit - max entries
      \t *
      \t *   // Optional base value to start with (must be last parameter)
      \t *   $(_Class)::DefaultInitValue   // Used as base value modified by above
      \t * };
      \t *
      \t * // Initialise $(_Class) from values specified above
      \t * $(_Class)::configure($(_name)Init)
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tprivate:
      \t   /**
      \t    * Prevent implicit parameter conversions
      \t    */
      \t   template <typename... Types>
      \t   constexpr Init(Types...) = delete;
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo::Init class Member variables ________ -->

   <for keys=" type        : variables                                         : init    "
       values="%baseType   : dac_c0_dacen,dac_c0_dacrfs,dac_c0_dactrgsel,
                             dac_c0_lpen,dac_c0_dacbwien,
                             dac_c0_dacbtien,dac_c0_dacbbien                   : 0       ;
               %baseType   : dac_c1_dmaen,dac_c1_dacbfwm,dac_c1_dacbfmd,
                             dac_c1_dacbfen                                    : 0       ;
               %baseType   : dac_c2_dacbfup[0]                                 : 0       ">
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(variables)"
         linePadding="xxx" >
      <![CDATA[
         %multilineDescription
         \t   %(type) %registerName = %(init);\n\n
      ]]>
      </variableTemplate>
   </for>

   <!-- ____ BasicInfo::Init class Constructors ____________ -->

   <for keys="r"
      values="
            dac_c0_dacen;dac_c0_dacrfs;dac_c0_dactrgsel;dac_c0_lpen;
            dac_c0_dacbwien;dac_c0_dacbtien;dac_c0_dacbbien;
            dac_c1_dmaen;dac_c1_dacbfwm;dac_c1_buffer_mode;
            dac_c2_dacbfup[0]
            " >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    * (%variables)
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %constructorFieldAssignment;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}; // class $(_BasicInfo)::Init
      \t\n
   ]]>
   </template>

<!-- ====================================================================================================== -->
<!--     END BasicInfo::Init class      -->
<!-- ====================================================================================================== -->

   <!-- ____ Interrupt handling (only needed when not done in enablePeripheral.xml) _____________ -->

   <template where="info" codeGenCondition="$(_InfoIrqGuard)" >
   <![CDATA[
      \t/**
      \t * Get and clear DAC status
      \t *
      \t * @return DAC status value see DacStatus
      \t */
      \tstatic uint8_t getAndClearStatus() {
      \t   // Get status
      \t   uint8_t status = dac->SR;
      \t
      \t   // Clear set flags
      \t   dac->SR = ~status;
      \t
      \t   // return original status
      \t   return status;
      \t}
      \t\n
   ]]>
   </template>

   <template where="info" codeGenCondition="$(_InfoGuard)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Enable DAC output pin as output.
      \t * Configures all Pin Control Register (PCR) values
      \t */
      \tstatic void setOutput() {
      \t
      \t   //CheckOutputIsMapped<outputPin>::check();
      \t
      \t   using Pcr = PcrTable_T<$(_Info), outputPin>;
      \t
      \t   // Enable and map pin to CMP_OUT
      \t   Pcr::setPCR();
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____ BasicInfo class Configure methods ____ -->

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
      linePadding="xxx" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param $(_basename)           Hardware instance pointer
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(
      \t               volatile $(_Type) *$(_basename),
      \t               const Init    &init) {
      \t
      \t\n
   ]]>
   </template>
   <for keys=
             "  var                                               : statement"
       values=' dac_c0_dacen,dac_c0_dacrfs,dac_c0_dactrgsel,
                dac_c0_lpen,dac_c0_dacbwien,
                dac_c0_dacbtien,dac_c0_dacbbien                   : "%register = init.%registerName;" ;
                dac_c1_dmaen,dac_c1_dacbfwm,dac_c1_dacbfmd,
                dac_c1_dacbfen                                    : "%register = init.%registerName;" ;
                dac_c2_dacbfup[0]                                 : "%register = init.%registerName;" ' >
      <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)"
         variables="%(var)"
         linePadding="xxx" >
      <![CDATA[
         \t
         %multilineDescription
         \t   %(statement);\n
      ]]>
      </variableTemplate>
   </for>
   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t}
      \t\n
   ]]>
   </template>

   <template where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t * This routine does not configure pins or interrupt handlers
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tvoid configure(const Init &init) const {
      \t
      \t   configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

   <variableTemplate where="basicInfo" codeGenCondition="$(_BasicInfoGuard)" 
      variables="dac_data_data[]" >
   <![CDATA[
      \t/**
      \t * Get domain of DAC values
      \t *
      \t * @return Range of DAC e.g. 2^12-1
      \t */
      \tstatic constexpr unsigned getDomain() {
      \t   return %mask;
      \t}
      \t
      \t/**
      \t * Get size of ADC FIFO
      \t *
      \t * @return size in entries
      \t */
      \tstatic constexpr unsigned getBufferSize() {
      \t   return sizeof(DAC_Type::DATA)/sizeof(DAC_Type::DATA[0]);
      \t}
      \t\n
   ]]>
   </variableTemplate>   
   
<!-- ====================================================================================================== -->
<!--     END BasicInfo class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     START Info class      -->
<!-- ====================================================================================================== -->
   <!-- ____ Info constructors ________ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/*
      \t *   Default Constructor
      \t */
      \t$(_Info)() : $(_BasicInfo)($(_basename)) {
      \t   defaultConfigure();
      \t}
      \t
      \t/*
      \t *   Constructor
      \t */
      \t$(_Info)(const Init &init) : $(_BasicInfo)($(_basename)) {
      \t   configure(init);
      \t}
      \t/** Get base address of DAC hardware as uint32_t */
      \tstatic constexpr uint32_t dacBase() { return baseAddress; }
      \t
      \t/** Get base address of DAC.DATA register as uint32_t */
      \tstatic constexpr uint32_t dacData() { return dacBase() + offsetof(DAC_Type, DATA[0]); }
      \t
      \t/** Get base address of DAC.DATA[index] register as uint32_t */
      \tstatic constexpr uint32_t dacData(unsigned index) { return dacBase() + offsetof(DAC_Type, DATA) + index*sizeof(DAC_Type::DATA[0]); }
      \t\n
   ]]>
   </template>

   <!-- Init configure methods -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic void defaultConfigure() {
      \t
      \t   configure(DefaultInitValue);
      \t}
      \t
      \t/**
      \t * Configure $(_BASENAME) from values specified in init
      \t *
      \t * @param init Class containing initialisation values
      \t */
      \tstatic void configure(const Init &init) {
      \t
      \t   // Enable peripheral
      \t   enable();
      \t\n
   ]]>
   </template>
   <template where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount==1)" >
   <![CDATA[
      \t   // Configure call-back
      \t   if (init.callbacks[0] != nullptr) {
      \t      setCallback(init.callbacks[0]);
      \t      enableNvicInterrupts(init.priorities[0]);
      \t   }
      \t\n
   ]]>
   </template>
   <variableTemplate where="info" codeGenCondition="$(_InfoIrqGuard)" condition="=(_hardwareIrqCount>1)"
      variables="irq_enum"
      immediateVariables="_hardwareIrqCount">
   <![CDATA[
      \t   for(int index=0; index<$(_hardwareIrqCount); index++) {
      \t      if (init.callbacks[index] != nullptr) {
      \t         // Configure call-back
      \t         setCallback(%returnType0(index), init.callbacks[index]);
      \t         enableNvicInterrupts(%returnType0(index), init.priorities[index]);
      \t      }
      \t   }
      \t\n
   ]]>
   </variableTemplate>
   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t   $(_BasicInfo)::configure($(_basename), init);
      \t}
      \t\n
   ]]>
   </template>

   <!-- ____  Default Initialisation value ____ -->

   <template where="info" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr $(_BasicInfo)::Init DefaultInitValue = {\n
   ]]>
   </template>
   <!-- Interrupt information -->
<!--
   <for keys="irqName" values="=_hardwareIrqNums">
      <equation key="irqEnum" value='=ReplaceAll("%(irqName)","^(.*?)_(.*)_IRQn$","IrqNum_$2")' />
      <equation key="var"     value='=ReplaceAll("%(irqName)","^(.*?)_(.*)_IRQn$","irqLevel_$2")' />
      <print text="(irqName) = %(irqName)"/>
      <printVar key="irqEnum" />
      <printVar key="var" />
      <variableTemplate where="info" codeGenCondition='$(_InfoIrqGuard)&amp;&amp;!IsZero(@var)'
         variables='=var'
         separator=","
         terminator=","
         padToComments="40"
         immediateVariables="irqEnum" >
      <![CDATA[
         \t   $(irqEnum), %initExpression,
         \t   unhandledCallback,\n
      ]]>
      </variableTemplate>
   </for>
-->
   <variableTemplate where="info" codeGenCondition="$(_InfoGuard)"
      separator=","
      terminator=","
      padToComments="45"
      variables="
            dac_c0_dacen,
            dac_c0_dacrfs,
            dac_c0_dactrgsel,
            dac_c0_lpen,
            dac_c0_dacbwien,
            dac_c0_dacbtien,
            dac_c0_dacbbien,
            dac_c1_dmaen,
            dac_c1_dacbfwm,
            dac_c1_buffer_mode,
            dac_c2_dacbfup[0],
            " >
   <![CDATA[
      \t%initNonZeroValues
      \t};
      \t\n
   ]]>
   </variableTemplate>

   <template where="info" codeGenCondition="$(_InfoGuard)"><![CDATA[
      \t/// Number of Data output registers
      \tstatic constexpr size_t NumDataRegisters = $(dac_data_dim);
      \t\n
   ]]></template>

<!-- ====================================================================================================== -->
<!--     END Info class      -->
<!-- ====================================================================================================== -->
<!-- ====================================================================================================== -->
<!--     Common      -->
<!-- ====================================================================================================== -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="$(_InfoGuard)" >
   <![CDATA[
      \t/**
      \t * Class representing $(_STRUCTNAME) instance
      \t */
      \ttypedef $(_BasicInfo) $(_Structname);
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \ttypedef $(_Info) $(_Class);
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="dac_files" >
      <copy source="Project_Headers/dac.h"                         target="Project_Headers/dac.h"                         overwrite="true" derived="true" />
      <copy source="Snippets/dac-example.cpp"                      target="Snippets/dac-example.cpp"                      overwrite="true" derived="true" />
      <copy source="Snippets/dac-dma-pdb-example.cpp"              target="Snippets/dac-dma-pdb-example.cpp"              overwrite="true" derived="true" />
      <copy source="Snippets/dac-dma-pitThrottled-example.cpp"     target="Snippets/dac-dma-pitThrottled-example.cpp"     overwrite="true" derived="true" />
      <copy source="Snippets/dac-hardwareTrigger-dma-example.cpp"  target="Snippets/dac-hardwareTrigger-dma-example.cpp"  overwrite="true" derived="true" />
      <copy source="Snippets/dac-hardwareTrigger-example.cpp"      target="Snippets/dac-hardwareTrigger-example.cpp"      overwrite="true" derived="true" />
      <copy source="Snippets/dac-softwareTrigger-example.cpp"      target="Snippets/dac-softwareTrigger-example.cpp"      overwrite="true" derived="true" />
   </projectActionList>

   <!-- ____ Startup ____ -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>

   <!-- ____ SIM configuration ____ -->

   <category name="Advanced" description="SIM configuration"
      toolTip="These settings only have effect if the SIM configuration is enabled" >
      <title description="$(_BASENAME) Shared" />
      <for keys="v" values="=/SIM/$(_Baseclass)ExternalItems" condition="/SIM/$(_Baseclass)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
      <title description="$(_NAME) Specific" />
      <aliasOption key="=_scgc_clock" locked="false" condition="_scgc_clock" />
      <for keys="v" values="=/SIM/$(_Class)ExternalItems" condition="/SIM/$(_Class)ExternalItems" >
         <aliasOption key="/SIM/%(v)"           optional="true" locked="false" />
      </for>
   </category>

   <!--  ____ Signal mapping ____ -->
   <signals enabledBy="enablePeripheralSupport" locked="!/PCR/_present" />

</fragment>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- sim_mk65f18.xml -->
<!--
Devices using this peripheral: 
-->
<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="SIM">
   
   <xi:include href="_default_instance.xml"/>

   <!-- Indicates RTC/OSC0 don't share XTAL/EXTAL pins -->
   <constant name="rtcSharesPins" value="false"   derived="true" />
   
   <!-- Oscillator used for OSC0 -->
   <constant name="osc0_peripheral"   value="/OSC0"    derived="true"/>
   
   <!-- Oscillator used for OSC1 = RTC -->
   <constant name="osc32k_peripheral" value="/RTC"     derived="true"/>
   
   <!-- RTC clock in (EXTAL32K) -->
   <constant name="rtc_clkin"         value="/RTC/osc_input_freq" derived="true"/>
   
   <category name="SOPT1" description="RTC signals">
      <choiceOption name="sim_sopt1_osc32ksel" 
         description="ERCLK32K source"
         toolTip="Clock source of External 32k Reference Clock [ERCLK32K]\n
            Used by LPTMR">
         <choice value="0"  name="System oscillator in low range (OSC32KCLK)" />
         <choice value="1"  name="Reserved" />
         <choice value="2"  name="RTC 32kHz clock" isDefault="true" />
         <choice value="3"  name="LPO 1kHz clock" />
      </choiceOption>
      
      <intOption name="system_erclk32k_clock" 
         units="Hz"
	 derived="true"
         description="Frequency of External 32k Reference Clock [ERCLK32K]"
         toolTip="External reference clock available to some peripherals (usually ~32kHz)" 
         origin="Derived from OSC32KCLK, RTCCLK or LPO" 
         value="32768"
         constant="true" />
      
      <template><![CDATA[
         \t//! System Options Register 1
         \tstatic constexpr uint32_t sopt1 = 
         \t#ifdef SIM_SOPT1_OSC32KOUT
         \t   SIM_SOPT1_OSC32KOUT($(sim_sopt1_osc32kout:-1)) |    // 32K oscillator clock out pin select
         \t#endif
         \t   SIM_SOPT1_OSC32KSEL($(sim_sopt1_osc32ksel));     // 32K oscillator clock select\n\n
   
         \t/**
         \t * Get ERCLK32K clock frequency
         \t *
         \t * @return Clock frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getErc32kClock() {
         \t
         \t   switch(sim().SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         \t      default                     : return 0;
         \t      case SIM_SOPT1_OSC32KSEL(0) : return Osc0Info::getOsc32kClock();
         \t      case SIM_SOPT1_OSC32KSEL(2) : return RtcInfo::getExternalClock();
         \t      case SIM_SOPT1_OSC32KSEL(3) : return 1000;
         \t   }
         \t}\n\n
	 
         \t/**
         \t * Set ERCLK32K clock source
         \t *
         \t * @param simOsc32kSel Clock source
         \t */
         \tstatic void setErc32kClock(SimOsc32kSel simOsc32kSel) {
         \t   sim().SOPT1 = (sim().SOPT1&~SIM_SOPT1_OSC32KSEL_MASK) | simOsc32kSel;
         \t}\n\n
      ]]></template>
   </category>
   
   <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Selects the ERCLK32K clock source
         \t */
         \tenum SimOsc32kSel {
         \t   SimOsc32kSel_Osc32kClk  = SIM_SOPT1_OSC32KSEL(0), //!< OSC0 operating as 32K oscillator
         \t   SimOsc32kSel_Rtc32kClk  = SIM_SOPT1_OSC32KSEL(2), //!< Rtc32k clock
         \t   SimOsc32kSel_LpoClk     = SIM_SOPT1_OSC32KSEL(3), //!< LPO Clock
         \t};\n\n   
   ]]></template>

   <category name="SOPT2" description="Clock Gating">
      <binaryOption name="sim_sopt2_rtcclkoutsel" 
         description="RTC clock out select [RTC_CLKOUT pin]"
         toolTip="Clock output on the RTC_CLKOUT pin">
         <choice value="0"  name="RTC 1 Hz clock" />
         <choice value="1"  name="RTC 32kHz clock" isDefault="true" />
      </binaryOption>
      
      <intOption name="rtc_clkout"
         constant="true"
         derived="true"
         units="Hz"
         description="RTC clock out [RTC_CLKOUT pin]"
         toolTip="Clock frequency on the RTC_CLKOUT pin"  />
      
      <aliasOption key="/SIM/sim_sopt2_pllfllsel." constant="false" />
      
      <aliasOption key="/SIM/system_peripheral_clock." />
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Peripheral Clock sources
         \t */
         \tenum SimPeripheralClockSource {
         \t   SimPeripheralClockSource_McgFll = SIM_SOPT2_PLLFLLSEL(0), //!< MCG FLL Clock
         \t   SimPeripheralClockSource_McgPll = SIM_SOPT2_PLLFLLSEL(1), //!< MCG PLL Clock
         \t   SimPeripheralClockSource_UsbPfd = SIM_SOPT2_PLLFLLSEL(2), //!< USB PFD clock
         \t   SimPeripheralClockSource_Irc48m = SIM_SOPT2_PLLFLLSEL(3), //!< IRC 48MHz clock
         \t};\n\n
      ]]></template>
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Selects the clock to output on the CLKOUT pin.
         \t */
         \tenum SimClkoutSel {
         \t   SimClkoutSel_FlexBus   = SIM_SOPT2_CLKOUTSEL(0),  //!< FlexBus
         \t   SimClkoutSel_Reserved1 = SIM_SOPT2_CLKOUTSEL(1),  //!<
         \t   SimClkoutSel_Flash     = SIM_SOPT2_CLKOUTSEL(2),  //!< Flash
         \t   SimClkoutSel_Lpo       = SIM_SOPT2_CLKOUTSEL(3),  //!< LPO (1kHz)
         \t   SimClkoutSel_McgirClk  = SIM_SOPT2_CLKOUTSEL(4),  //!< McgirClk
         \t   SimClkoutSel_RTC       = SIM_SOPT2_CLKOUTSEL(5),  //!< RTC 32.768kHz
         \t   SimClkoutSel_OscerClk0 = SIM_SOPT2_CLKOUTSEL(6),  //!< OscerClk0
         \t   SimClkoutSel_Irc48MHz  = SIM_SOPT2_CLKOUTSEL(7),  //!< IRC 48MHz
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Selects the clock to output on the CLKOUT pin.
         \t *
         \t * @param simClkoutSel
         \t */
         \tstatic void setClkout(SimClkoutSel simClkoutSel) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_CLKOUTSEL_MASK) | simClkoutSel;
         \t}\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Set Peripheral clock source
         \t *
         \t * @param simPeripheralClockSource Clock source for peripheral clock
         \t */
         \tstatic void setPeripheralClock(SimPeripheralClockSource simPeripheralClockSource) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_PLLFLLSEL_MASK) | simPeripheralClockSource;
         \t}\n\n
         
         \t/**
         \t * Get Peripheral clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getPeripheralClock() {
         \t   
         \t   switch(sim().SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
         \t      default:                     return 0;
         \t      case SIM_SOPT2_PLLFLLSEL(0): return SystemMcgFllClock;
         \t      case SIM_SOPT2_PLLFLLSEL(1): return SystemMcgPllClock;
         \t//    case SIM_SOPT2_PLLFLLSEL(2): return UsbPfdClock;
         \t      case SIM_SOPT2_PLLFLLSEL(3): return McgInfo::irc48m_clock;
         \t   }
         \t}\n\n
      ]]></template>
      
      <choiceOption name="sim_sopt2_lpuartsrc" 
         description="LPUART Clock select"
         toolTip="Selects the clock source for the transmit and receive clock\n
	     This is selection is shared by all LPUARTs">
         <choice value="0"  name="Disabled" />
         <choice value="1"  name="Peripheral Clock divided by SIM_CLKDIV3" />
         <choice value="2"  name="OSCERCLK clock" />
         <choice value="3"  name="MCGIRCLK clock"  isDefault="true" />
      </choiceOption>
   
      <intOption name="system_lpuart_clock" 
         derived="true" 
         constant="true"
         units="Hz"
         description="LPUART Clock frequency"
         toolTip="Frequency of clock to LPUART"
         value="0" />
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * LPUART Clock sources
         \t */
         \tenum SimLpuartClockSource {
         \t   SimLpuartClockSource_Disabled   = SIM_SOPT2_LPUARTSRC(0), //!< Disabled
         \t   SimLpuartClockSource_Peripheral = SIM_SOPT2_LPUARTSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
         \t   SimLpuartClockSource_OscerClk   = SIM_SOPT2_LPUARTSRC(2), //!< OSCERCLK clock
         \t   SimLpuartClockSource_McgIrClk   = SIM_SOPT2_LPUARTSRC(3), //!< MCG Internal Reference clock (MCGIRCLK)
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Set LPUART input clock source
         \t *
         \t * @param simLpuartClockSource Clock source for LPUART
         \t */
         \tstatic void setLpuartClock(SimLpuartClockSource simLpuartClockSource) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_LPUARTSRC_MASK) | simLpuartClockSource;
         \t}\n\n
   
         \t/**
         \t * Get LPUART input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getLpuartClock() {
         \t   
         \t   switch(sim().SOPT2&SIM_SOPT2_LPUARTSRC_MASK) {
         \t   default:
         \t   case SIM_SOPT2_LPUARTSRC(0): return 0;
         \t   case SIM_SOPT2_LPUARTSRC(1): return getDividedPeripheralClock();
         \t   case SIM_SOPT2_LPUARTSRC(2): return Osc0Info::getOscerClock();
         \t   case SIM_SOPT2_LPUARTSRC(3): return McgInfo::getMcgIrClock();
         \t   }
         \t}\n\n
      ]]></template>
      
      <stringOption name="Uart0Clock" description="Uart 0 clock" value="SystemCoreClock" constant="true" derived="true" />
      <stringOption name="Uart1Clock" description="Uart 1 clock" value="SystemCoreClock" constant="true" derived="true" />
      <stringOption name="Uart2Clock" description="Uart 2 clock" value="SystemBusClock"  constant="true" derived="true" />
      <stringOption name="Uart3Clock" description="Uart 3 clock" value="SystemBusClock"  constant="true" derived="true" />
      <stringOption name="Uart4Clock" description="Uart 4 clock" value="SystemBusClock"  constant="true" derived="true" />
      
      <template><![CDATA[
         \t/** 
         \t * Get UART0 input clock frequency
         \t *
         \t * @return Clock frequency in Hz
         \t */
         \tstatic inline uint32_t getUart0Clock() {
         \t   return $(Uart0Clock);
         \t}\n\n
         
         \t/** 
         \t * Get UART1 input clock frequency
         \t *
         \t * @return Clock frequency in Hz
         \t */
         \tstatic inline uint32_t getUart1Clock() {
         \t   return $(Uart1Clock);
         \t}\n\n
         
         \t/** 
         \t * Get UART2 input clock frequency
         \t *
         \t * @return Clock frequency in Hz
         \t */
         \tstatic inline uint32_t getUart2Clock() {
         \t   return $(Uart2Clock);
         \t}\n\n
               
         \t/** 
         \t * Get UART3 input clock frequency
         \t *
         \t * @return Clock frequency in Hz
         \t */
         \tstatic inline uint32_t getUart3Clock() {
         \t   return $(Uart3Clock);
         \t}\n\n
         
         \t/** 
         \t * Get UART4 input clock frequency
         \t *
         \t * @return Clock frequency in Hz
         \t */
         \tstatic inline uint32_t getUart4Clock() {
         \t   return $(Uart4Clock);
         \t}\n\n
         
      ]]></template>
      
      <choiceOption name="sim_sopt2_usbsrc" 
         description="USB clock source select"
         toolTip="Selects the source for the USB clock">
         <choice value="0"  name="External bypass clock (USB_CLKIN)" />
         <choice value="1"  name="Peripheral Clock divided by SIM_CLKDIV2" isDefault="true" />
      </choiceOption>
      
      <intOption name="system_usbfs_clock" 
         constant="true"
	 derived="true"
         units="Hz"
         description="USB Full Speed Clock"
         toolTip="Frequency of clock to USB full speed controller"
         value="0" />
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * USB full-speed clock sources
         \t */
         \tenum SimUsbFullSpeedClockSource {
         \t   SimUsbFullSpeedClockSource_McgFll = SIM_SOPT2_USBSRC(0), //!< External bypass clock (USB_CLKIN)
         \t   SimUsbFullSpeedClockSource_McgPll = SIM_SOPT2_USBSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV2
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t#ifdef SIM_SOPT2_USBSRC_MASK
         \t/**
         \t * Set USB Full-speed clock source
         \t *
         \t * @param simUsbFullSpeedClockSource Clock source for peripheral clock
         \t */
         \tstatic void setUsbFullSpeedClock(SimUsbFullSpeedClockSource simUsbFullSpeedClockSource) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_USBSRC_MASK) | simUsbFullSpeedClockSource;
         \t}\n\n
         
         \t/**
         \t * Get USB clock frequency
         \t *
         \t * @return Clock frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getUsbClock() {
         \t   switch ((sim().SOPT2&SIM_SOPT2_USBSRC_MASK)) {
         \t      default:
         \t      case SIM_SOPT2_USBSRC(0): return $(/MCG/system_usb_clkin_clock);
         \t      case SIM_SOPT2_USBSRC(1): return  (getPeripheralClock()*
         \t         (((sim().CLKDIV2&SIM_CLKDIV2_USBFRAC_MASK)>>SIM_CLKDIV2_USBFRAC_SHIFT)+1))/
         \t         (((sim().CLKDIV2&SIM_CLKDIV2_USBDIV_MASK)>>SIM_CLKDIV2_USBDIV_SHIFT)+1);
         \t   }
         \t}
         \t#endif\n\n
      ]]></template>
      
      <choiceOption name="sim_sopt2_tpmsrc" 
         description="TPM Clock source"
         toolTip="Selects the clock source for the TPM counter clock">
         <choice value="0"  name="Disabled" isDefault="true" />
         <choice value="1"  name="Peripheral Clock divided by SIM_CLKDIV3" />
         <choice value="2"  name="OSCERCLK clock" />
         <choice value="3"  name="MCGIRCLK clock" />
      </choiceOption>
      
      <intOption name="system_tpm_clock" 
         constant="true"
	 derived="true"
         units="Hz"
         description="TPM Clock frequency"
         toolTip="Frequency of clock to TPM"
         value="0" />
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * TPM Clock sources
         \t */
         \tenum SimTpmClockSource {
         \t   SimTpmClockSource_Disabled   = SIM_SOPT2_TPMSRC(0), //!< Disabled
         \t   SimTpmClockSource_Peripheral = SIM_SOPT2_TPMSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL] divided by SIM.CLKDIV3
         \t   SimTpmClockSource_OscerClk   = SIM_SOPT2_TPMSRC(2), //!< OSCERCLK clock
         \t   SimTpmClockSource_McgIrClk   = SIM_SOPT2_TPMSRC(3), //!< MCG Internal Reference clock
         \t};\n\n
      ]]></template>
         
      <choiceOption name="sim_sopt2_fbsl" 
         description="FlexBus security level"
         toolTip="This field affects what CPU operations can access off-chip via the FlexBus interface" >
         <choice value="0"  name="All off-chip accesses (instruction and data) are disallowed" />
         <choice value="1"  name="All off-chip accesses (instruction and data) are disallowed" />
         <choice value="2"  name="Off-chip instruction accesses are disallowed. Data accesses are allowed" />
         <choice value="3"  name="Off-chip instruction and data accesses are allowed" />
      </choiceOption>
      
      <choiceOption name="sim_sopt2_sdhcsrc" 
         description="SDHC Clock select"
         toolTip="Selects the clock source for the SDHC clock">
         <choice value="0"  name="Core/system clock"  isDefault="true" />
         <choice value="1"  name="Peripheral Clock" />
         <choice value="2"  name="OSCERCLK clock" />
         <choice value="3"  name="External bypass clock (SDHC0_CLKIN)" />
      </choiceOption>
      
      <intOption name="system_sdhc_clock" 
         constant="true"
         units="Hz"
         description="SDHC Clock frequency (not implemented)"
         toolTip="Frequency of clock to SDHC"
         value="0" />
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * SDHC Clock sources
         \t */
         \tenum SimSdhcClockSource {
         \t   SimSdhcClockSource_System     = SIM_SOPT2_SDHCSRC(0), //!< Core/system clock
         \t   SimSdhcClockSource_Peripheral = SIM_SOPT2_SDHCSRC(1), //!< Peripheral clock selected by SIM.SOPT2[PLLFLLSEL]
         \t   SimSdhcClockSource_OscerClk   = SIM_SOPT2_SDHCSRC(2), //!< OSCERCLK clock
         \t   SimSdhcClockSource_External   = SIM_SOPT2_SDHCSRC(3), //!< External bypass clock (SDHC0_CLKIN)
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Set SDHC input clock source
         \t *
         \t * @param simSdhcClockSource Clock source for SDHC
         \t */
         \tstatic void setSdhcClock(SimSdhcClockSource simSdhcClockSource) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_SDHCSRC_MASK) | simSdhcClockSource;
         \t}\n\n
   
         \t/**
         \t * Get SDHC input clock frequency
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getSdhcClock() {
         \t   
         \t   switch(sim().SOPT2&SIM_SOPT2_SDHCSRC_MASK) {
         \t   default:
         \t   case SIM_SOPT2_SDHCSRC(0): return SystemCoreClock;
         \t   case SIM_SOPT2_SDHCSRC(1): return getPeripheralClock();
         \t   case SIM_SOPT2_SDHCSRC(2): return Osc0Info::getOscerClock();
         \t   case SIM_SOPT2_SDHCSRC(3): return 0; // TODO SDHC0_CLKIN
         \t   }
         \t}\n\n
      ]]></template>
      
      <choiceOption name="sim_sopt2_clkoutsel" 
         description="CLKOUT select"
         toolTip="Selects the clock to output on the CLKOUT pin." >
         <choice value="0"  name="FlexBus CLKOUT" />
         <choice value="1"  name="Reserved" />
         <choice value="2"  name="Flash clock" isDefault="true" />
         <choice value="3"  name="LPO clock (1 kHz)" />
         <choice value="4"  name="MCGIRCLK" />
         <choice value="5"  name="RTC 32.768kHz clock" />
         <choice value="6"  name="OSCERCLK0" />
         <choice value="7"  name="IRC 48 MHz clock" />
      </choiceOption>
      
      <binaryOption name="sim_sopt2_traceclksel" 
         description="Debug trace clock select"
         toolTip="Selects the core/system clock or MCG output clock (MCGOUTCLK)
	          as the trace clock source" >
         <choice value="0"  name="MCGOUTCLK" isDefault="true" />
         <choice value="1"  name="Core/system clock" />
      </binaryOption>   
      
      <template><![CDATA[
         \t//! System Options Register 2
         \tstatic constexpr uint32_t sopt2 = 
         \t#ifdef SIM_SOPT2_TRACECLKSEL
         \t   SIM_SOPT2_TRACECLKSEL($(/SIM/sim_sopt2_traceclksel:-1)) |      // Debug trace clock select
         \t#endif
         \t#ifdef SIM_SOPT2_TIMESRC
         \t   SIM_SOPT2_TIMESRC($(/SIM/sim_sopt2_timesrc:-1)) |          // IEEE 1588 timestamp clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_RMIISRC
         \t   SIM_SOPT2_RMIISRC($(/SIM/sim_sopt2_rmiisrc:-1)) |          // Ethernet RMII clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_SDHCSRC
         \t      SIM_SOPT2_SDHCSRC($(/SIM/sim_sopt2_sdhcsrc:-1)) |       // SDHC clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_UART0SRC
         \t   SIM_SOPT2_UART0SRC($(/SIM/sim_sopt2_uart0src:-1)) |         // UART0 clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_LPUARTSRC
         \t      SIM_SOPT2_LPUARTSRC($(/SIM/sim_sopt2_lpuartsrc:-1)) |     // LPUART clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_LPUART0SRC
         \t      SIM_SOPT2_LPUART0SRC($(/SIM/sim_sopt2_lpuart0src:-1)) |     // LPUART clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_PTD7PAD
         \t      SIM_SOPT2_PTD7PAD($(/SIM/sim_sopt2_ptd7pad:-1)) |       // PTD7 pad drive strength
         \t#endif
         \t#ifdef SIM_SOPT2_TPMSRC
         \t      SIM_SOPT2_TPMSRC($(/SIM/sim_sopt2_tpmsrc:-1)) |        // TPM clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_USBSRC
         \t      SIM_SOPT2_USBSRC($(/SIM/sim_sopt2_usbsrc:-1)) |        // USB clock source select
         \t#endif
         \t#ifdef SIM_SOPT2_FBSL
         \t      SIM_SOPT2_FBSL($(/SIM/sim_sopt2_fbsl:-1)) |          // FlexBus security level
         \t#endif
         \t#ifdef SIM_SOPT2_PLLFLLSEL
         \t      SIM_SOPT2_PLLFLLSEL($(/SIM/sim_sopt2_pllfllsel[0]:-1))|      // PLL/FLL clock select
         \t#endif
         \t#ifdef SIM_SOPT2_RTCCLKOUTSEL
         \t      SIM_SOPT2_RTCCLKOUTSEL($(/SIM/sim_sopt2_rtcclkoutsel:-1)) |  // RTC clock out select
         \t#endif
         \t      SIM_SOPT2_CLKOUTSEL($(/SIM/sim_sopt2_clkoutsel));      // CLKOUT pin clock source select\n\n
      ]]></template>
   
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Clock divider for clock for some peripherals (TPM,LPUART)
         \t */
         \tenum SimPeripheralClockDivider {
         \t   SimPeripheralClockDivider_Mult2  = SIM_CLKDIV3_PLLFLLDIV(0)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Multiply by 2
         \t   SimPeripheralClockDivider_Mult1  = SIM_CLKDIV3_PLLFLLDIV(0)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Multiply by 1
         \t   SimPeripheralClockDivider_Div1_5 = SIM_CLKDIV3_PLLFLLDIV(2)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 1.5
         \t   SimPeripheralClockDivider_Div2   = SIM_CLKDIV3_PLLFLLDIV(1)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 2
         \t   SimPeripheralClockDivider_Div2_5 = SIM_CLKDIV3_PLLFLLDIV(4)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 2.5
         \t   SimPeripheralClockDivider_Div3   = SIM_CLKDIV3_PLLFLLDIV(2)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 3
         \t   SimPeripheralClockDivider_Div3_5 = SIM_CLKDIV3_PLLFLLDIV(6)|SIM_CLKDIV3_PLLFLLFRAC(1), //!< Divide by 3.5
         \t   SimPeripheralClockDivider_Div4   = SIM_CLKDIV3_PLLFLLDIV(3)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 4
         \t   SimPeripheralClockDivider_Div5   = SIM_CLKDIV3_PLLFLLDIV(4)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 5
         \t   SimPeripheralClockDivider_Div6   = SIM_CLKDIV3_PLLFLLDIV(5)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 6
         \t   SimPeripheralClockDivider_Div7   = SIM_CLKDIV3_PLLFLLDIV(6)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 7
         \t   SimPeripheralClockDivider_Div8   = SIM_CLKDIV3_PLLFLLDIV(7)|SIM_CLKDIV3_PLLFLLFRAC(0), //!< Divide by 8
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Set clock divider for some peripherals (TPM,LPUART)
         \t *
         \t * @param simPeripheralClockDivider Clock divider
         \t */
         \tstatic void setPeripheralClockDivider(SimPeripheralClockDivider simPeripheralClockDivider) {
         \t   // Must disable clock to TPMs, LPUARTs and FLEXIO before changing clock divider
         \t   uint32_t scgc2 = sim().SCGC2;
         \t   sim().SCGC2   = 0;
         \t   sim().CLKDIV3 = simPeripheralClockDivider;
         \t   sim().SCGC2   = scgc2;
         \t}\n\n
   
         \t/**
         \t * Get Peripheral clock frequency after clock divider (TPM,LPUART)
         \t *
         \t * @return Frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getDividedPeripheralClock() {
         \t   int  pllfllfrac  = (sim().CLKDIV3&SIM_CLKDIV3_PLLFLLFRAC_MASK)>>SIM_CLKDIV3_PLLFLLFRAC_SHIFT;
         \t   int  pllflldiv   = (sim().CLKDIV3&SIM_CLKDIV3_PLLFLLDIV_MASK)>>SIM_CLKDIV3_PLLFLLDIV_SHIFT;
         \t   return (getPeripheralClock()*(pllfllfrac+1))/(pllflldiv+1);
         \t}\n\n
   
         \t/**
         \t * Set TPM input clock source
         \t *
         \t * @param simTpmClockSource Clock source for TPM
         \t */
         \tstatic void setTpmClock(SimTpmClockSource simTpmClockSource) {
         \t   sim().SOPT2 = (sim().SOPT2&~SIM_SOPT2_TPMSRC_MASK) | simTpmClockSource;
         \t}\n\n
   
         \t/**
         \t * Get TPM input clock frequency
         \t *
         \t * @return TPM input clock frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getTpmClock() {
         \t   
         \t   switch(sim().SOPT2&SIM_SOPT2_TPMSRC_MASK) {
         \t   default:
         \t   case SIM_SOPT2_TPMSRC(0): return 0;
         \t   case SIM_SOPT2_TPMSRC(1): return getDividedPeripheralClock();
         \t   case SIM_SOPT2_TPMSRC(2): return Osc0Info::getOscerClock();
         \t   case SIM_SOPT2_TPMSRC(3): return McgInfo::getMcgIrClock();
         \t   }
         \t}\n\n
      ]]></template>

      <binaryOption name="sim_sopt2_rmiisrc" 
         description="RMII clock source select"
         toolTip="Selects the clock source for the Ethernet RMII interface">
         <choice value="0"  name="EXTAL clock" isDefault="true" />
         <choice value="1"  name="External bypass clock (ENET_1588_CLKIN)." />
      </binaryOption>

      <choiceOption name="sim_sopt2_timesrc" 
         description="IEEE 1588 timestamp clock source select"
         toolTip="Selects the clock source for the Ethernet RMII interface">
         <choice value="0"  name="Core/system clock" isDefault="true" />
         <choice value="1"  name="Peripheral Clock" />
         <choice value="3"  name="OSCERCLK Clock" />
         <choice value="4"  name="External bypass clock (ENET_1588_CLKIN)." />
      </choiceOption>
      
      <template><![CDATA[
         \t/**
         \t * Get IEEE 1588 Timestamp clock frequency
         \t *
         \t * @return Clock frequency as a uint32_t in Hz
         \t */
         \tstatic uint32_t getTimeClock() {
         \t   
         \t   switch(sim().SOPT2&SIM_SOPT2_TIMESRC_MASK) {
         \t   default:
         \t   case SIM_SOPT2_TIMESRC(0): return SystemCoreClock;
         \t   case SIM_SOPT2_TIMESRC(1): return getPeripheralClock();
         \t   case SIM_SOPT2_TIMESRC(2): return Osc0Info::getOscerClock();
         \t   case SIM_SOPT2_TIMESRC(3): return 0; // TODO ENET_1588_CLKIN
         \t   }
         \t}\n\n
      ]]></template>
   </category>
   
   <category name="SOPT4" description="FTM signals">
      <binaryOption name="sim_sopt4_ftm3trg1src" 
         description="FlexTimer 3 Hardware Trigger 1 Source Select"
         toolTip="Selects the source of FTM hardware trigger 1" >
         <choice value="0"  name="Reserved" />
         <choice value="1"  name="FTM2 channel match" isDefault="true" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm3trg0src" 
         description="FlexTimer 3 Hardware Trigger 0 Source Select"
         toolTip="Selects the source of FTM hardware trigger 0" >
         <choice value="0"  name="Reserved" />
         <choice value="1"  name="FTM1 channel match" isDefault="true" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0trg1src" 
         description="FlexTimer 0 Hardware Trigger 1 Source Select"
         toolTip="Selects the source of FTM hardware trigger 1" >
         <choice value="0"  name="PDB output trigger 1" isDefault="true" />
         <choice value="1"  name="FTM2 channel match" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0trg0src" 
         description="FlexTimer 0 Hardware Trigger 0 Source Select"
         toolTip="Selects the source of FTM hardware trigger 0" >
         <choice value="0"  name="CMP0 output" isDefault="true" />
         <choice value="1"  name="FTM1 channel match" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm3clksel" 
         description="FlexTimer 3 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the FTM module.">
         <choice value="0"  name="FTM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="FTM_CLKIN1 pin" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm2clksel" 
         description="FlexTimer 2 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the FTM module.">
         <choice value="0"  name="FTM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="FTM_CLKIN1 pin" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm1clksel" 
         description="FlexTimer 1 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the FTM module.">
         <choice value="0"  name="FTM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="FTM_CLKIN1 pin" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0clksel" 
         description="FlexTimer 0 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the FTM module.">
         <choice value="0"  name="FTM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="FTM_CLKIN1 pin" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm2ch1src" 
         description="FlexTimer 2 channel 1 input capture source select"
         toolTip="Selects the source for FTM channel 1 input capture\n
            NOTE: When the FTM is not in input capture mode, clear this field">
         <choice value="0" name="FTM2_CH1 signal"  isDefault="true"/>
         <choice value="2" name="FTM2_CH1 xor FTM2_CH0 xor FTM1_CH1" />
      </binaryOption>
   
      <choiceOption name="sim_sopt4_ftm2ch0src" 
         description="FlexTimer 2 channel 0 input capture source select"
         toolTip="Selects the source for FTM channel 0 input capture\n
            NOTE: When the FTM is not in input capture mode, clear this field">
         <choice value="0" name="FTM2_CH0 signal"  isDefault="true"/>
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt4_ftm1ch0src" 
         description="FlexTimer 1 channel 0 input capture source select"
         toolTip="Selects the source for FTM channel 0 input capture\n
            NOTE: When the FTM is not in input capture mode, clear this field">
         <choice value="0" name="FTM1_CH0 signal"  isDefault="true"/>
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="USB start of frame pulse" />
      </choiceOption>
      
      <binaryOption name="sim_sopt4_ftm3flt0" 
         description="FlexTimer 3 Fault 0 Select"
         toolTip="Selects the source of FTM fault 0" >
         <choice value="0"  name="FTM3_FLT0 pin" isDefault="true" />
         <choice value="1"  name="CMP0 output" />
      </binaryOption>
   
      <binaryOption name="sim_sopt4_ftm2flt0" 
         description="FlexTimer 2 Fault 0 Select"
         toolTip="Selects the source of FTM fault input  0" >
         <choice value="0"  name="FTM2_FLT0 pin" isDefault="true" />
         <choice value="1"  name="CMP0 output" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm1flt0" 
         description="FlexTimer 1 Fault 0 Select"
         toolTip="Selects the source of FTM fault input 0" >
         <choice value="0"  name="FTM1_FLT0 pin" isDefault="true" />
         <choice value="1"  name="CMP0 output" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0flt3" 
         description="FlexTimer 0 Fault 3 Select"
         toolTip="Selects the source of FTM fault input 3" >
         <choice value="0"  name="FTM0_FLT3 pin" isDefault="true" />
         <choice value="1"  name="CMP3 output" />
      </binaryOption>
   
      <binaryOption name="sim_sopt4_ftm0flt2" 
         description="FlexTimer 0 Fault 2 Select"
         toolTip="Selects the source of FTM fault input 2" >
         <choice value="0"  name="FTM0_FLT2 pin" isDefault="true" />
         <choice value="1"  name="CMP2 output" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0flt1" 
         description="FlexTimer 0 Fault 1 Select"
         toolTip="Selects the source of FTM fault input 1" >
         <choice value="0"  name="FTM0_FLT1 pin" isDefault="true" />
         <choice value="1"  name="CMP1 output" />
      </binaryOption>
      
      <binaryOption name="sim_sopt4_ftm0flt0" 
         description="FlexTimer 0 Fault 0 Select"
         toolTip="Selects the source of FTM fault input 0" >
         <choice value="0"  name="FTM0_FLT0 pin" isDefault="true" />
         <choice value="1"  name="CMP0 output" />
      </binaryOption>
      
      <template><![CDATA[
         \t//! System Options Register 4
         \tstatic constexpr uint32_t sopt4 = 
         \t#ifdef SIM_SOPT4_FTM3TRG1SRC
         \t   SIM_SOPT4_FTM3TRG1SRC($(sim_sopt4_ftm3trg1src:-1)) |   // FlexTimer 3 Hardware Trigger 1 Source Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM3TRG0SRC
         \t   SIM_SOPT4_FTM3TRG0SRC($(sim_sopt4_ftm3trg0src:-1)) |   // FlexTimer 3 Hardware Trigger 0 Source Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM0TRG1SRC
         \t   SIM_SOPT4_FTM0TRG1SRC($(sim_sopt4_ftm0trg1src:-1)) |   // FlexTimer 0 Hardware Trigger 1 Source Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM0TRG0SRC
         \t   SIM_SOPT4_FTM0TRG0SRC($(sim_sopt4_ftm0trg0src:-1)) |   // FlexTimer 0 Hardware Trigger 0 Source Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM3CLKSEL
         \t   SIM_SOPT4_FTM3CLKSEL($(sim_sopt4_ftm3clksel:-1))  |   // FlexTimer 3 External Clock Pin Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM2CLKSEL
         \t   SIM_SOPT4_FTM2CLKSEL($(sim_sopt4_ftm2clksel:-1))  |   // FlexTimer 2 External Clock Pin Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM1CLKSEL
         \t   SIM_SOPT4_FTM1CLKSEL($(sim_sopt4_ftm1clksel:-1))  |   // FlexTimer 1 External Clock Pin Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM0CLKSEL
         \t   SIM_SOPT4_FTM0CLKSEL($(sim_sopt4_ftm0clksel:-1))  |   // FlexTimer 0 External Clock Pin Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM2CH1SRC
         \t   SIM_SOPT4_FTM2CH1SRC($(sim_sopt4_ftm2ch1src:-1))  |   // FTM2 channel 1 input capture source select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM2CH0SRC
         \t   SIM_SOPT4_FTM2CH0SRC($(sim_sopt4_ftm2ch0src:-1))  |   // FTM2 channel 0 input capture source select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM1CH0SRC
         \t   SIM_SOPT4_FTM1CH0SRC($(sim_sopt4_ftm1ch0src:-1))  |   // FTM1 channel 0 input capture source select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM3FLT0
         \t   SIM_SOPT4_FTM3FLT0($(sim_sopt4_ftm3flt0:-1))    |   // FlexTimer 3 Fault 0 Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM2FLT0
         \t   SIM_SOPT4_FTM2FLT0($(sim_sopt4_ftm2flt0:-1))    |   // FlexTimer 2 Fault 0 Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM1FLT0
         \t   SIM_SOPT4_FTM1FLT0($(sim_sopt4_ftm1flt0:-1))    |   // FlexTimer 1 Fault 0 Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM0FLT3
         \t   SIM_SOPT4_FTM0FLT3($(sim_sopt4_ftm0flt3:-1))    |   // FlexTimer 0 Fault 3 Select
         \t#endif
         \t#ifdef SIM_SOPT4_FTM0FLT2
         \t   SIM_SOPT4_FTM0FLT2($(sim_sopt4_ftm0flt2:-1))    |   // FlexTimer 0 Fault 2 Select
         \t#endif
         \t   SIM_SOPT4_FTM0FLT1($(sim_sopt4_ftm0flt1))    |   // FlexTimer 0 Fault 1 Select
         \t   SIM_SOPT4_FTM0FLT0($(sim_sopt4_ftm0flt0));       // FlexTimer 0 Fault 0 Select\n\n
      ]]></template>
   </category>
   
   <category name="SOPT5" description="UART signals">
      <choiceOption name="sim_sopt5_uart0txsrc" 
         description="UART 0 transmit data source select"
         toolTip="Selects the source for the UART 0 transmit data.">
         <choice value="0" name="UART0_TX pin" isDefault="true" />
         <choice value="1" name="UART0_TX pin modulated with FTM1 channel 0 output" />
         <choice value="2" name="UART0_TX pin modulated with FTM2 channel 0 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt5_uart0rxsrc" 
         description="UART 0 receive data source select"
         toolTip="Selects the source for the UART 0 receive data.">
         <choice value="0" name="UART0_RX pin" isDefault="true" />
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt5_uart1txsrc" 
         description="UART 1 transmit data source select"
         toolTip="Selects the source for the UART 1 transmit data.">
         <choice value="0" name="UART1_TX pin" isDefault="true" />
         <choice value="1" name="UART1_TX pin modulated with FTM1 channel 0 output" />
         <choice value="1" name="UART1_TX pin modulated with FTM2 channel 0 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt5_uart1rxsrc" 
         description="UART 1 receive data source select"
         toolTip="Selects the source for the UART 1 receive data">
         <choice value="0" name="UART1_RX pin" isDefault="true" />
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt5_lpuart0txsrc" 
         description="LPUART 0 transmit data source select"
         toolTip="Selects the source for the LPUART 0 transmit data.">
         <choice value="0" name="LPUART0_TX pin" isDefault="true" />
         <choice value="1" name="LPUART0_TX pin modulated with FTM1 channel 0 output" />
         <choice value="2" name="LPUART0_TX pin modulated with FTM2 channel 0 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <choiceOption name="sim_sopt5_lpuart0rxsrc" 
         description="LPUART 0 receive data source select"
         toolTip="Selects the source for the LPUART 0 receive data.">
         <choice value="0" name="LPUART0_RX pin" isDefault="true" />
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
      
      <template><![CDATA[
         \t//! System Options Register 5
         \tstatic constexpr uint32_t sopt5 = 
         \t   SIM_SOPT5_UART0TXSRC($(sim_sopt5_uart0txsrc)) |      // UART 0 transmit data source select
         \t   SIM_SOPT5_UART0RXSRC($(sim_sopt5_uart0rxsrc)) |      // UART 0 receive data source select
         \t   SIM_SOPT5_UART1TXSRC($(sim_sopt5_uart1txsrc)) |      // UART 1 transmit data source select
         \t   SIM_SOPT5_UART1RXSRC($(sim_sopt5_uart1rxsrc)) |      // UART 1 receive data source select
         \t#ifdef SIM_SOPT5_LPUART0RXSRC
         \t   SIM_SOPT5_LPUART0RXSRC($(sim_sopt5_lpuart0rxsrc:-1)) |  // LPUART 0 receive data source select
         \t#endif
         \t#ifdef SIM_SOPT5_LPUART0TXSRC
         \t   SIM_SOPT5_LPUART0TXSRC($(sim_sopt5_lpuart0txsrc:-1)) |  // LPUART 0 transmit data source select
         \t#endif
         \t#ifdef SIM_SOPT5_LPUART1TXSRC
         \t   SIM_SOPT5_LPUART1TXSRC($(sim_sopt5_lpuart1txsrc:-1)) | // LPUART 1 transmit data source select
         \t#endif
         \t#ifdef SIM_SOPT5_LPUART1RXSRC
         \t   SIM_SOPT5_LPUART1RXSRC($(sim_sopt5_lpuart1rxsrc:-1)) | // LPUART 1 receive data source select
         \t#endif
         \t   0;\n\n
      ]]></template>
   </category>
   
   <category name="SOPT7" description="ADC signals">
      <binaryOption name="sim_sopt7_adc0alttrgen" 
         description="ADC0 alternate trigger enable"
         toolTip="Enable alternative conversion triggers for ADC0">
         <choice value="0" name="PDB trigger selected" isDefault="true" />
         <choice value="1" name="Alternate trigger selected" />
      </binaryOption>
      
      <binaryOption name="sim_sopt7_adc0pretrgsel" 
         description="ADC0 pretrigger select"
         toolTip="Selects the pre-trigger source when alternative triggers are enabled through ADC0ALTTRGEN">
         <choice value="0" name="Pre-trigger 0 (A)" isDefault="true" />
         <choice value="1" name="Pre-trigger 1 (B)" />
      </binaryOption>
      
      <choiceOption name="sim_sopt7_adc0trgsel" 
         description="ADC0 trigger select"
         toolTip="Selects the trigger source when alternative triggers are functional in stop and VLPS modes">
         <choice value="0"  name="PDB external trigger pin input (PDB0_EXTRG)" isDefault="true" />
         <choice value="1"  name="High speed comparator 0 output" />
         <choice value="2"  name="High speed comparator 1 output" />
         <choice value="3"  name="High speed comparator 2 output (if available)" />
         <choice value="4"  name="PIT trigger 0" />
         <choice value="5"  name="PIT trigger 1" />
         <choice value="6"  name="PIT trigger 2" />
         <choice value="7"  name="PIT trigger 3" />
         <choice value="8"  name="FTM0 trigger" />
         <choice value="9"  name="FTM1 trigger" />
         <choice value="10" name="FTM2 trigger (if available)" />
         <choice value="11" name="FTM3 trigger (if available)" />
         <choice value="12" name="RTC alarm" />
         <choice value="13" name="RTC seconds" />
         <choice value="14" name="Low-power timer trigger" />
         <choice value="15" name="TPM1 channel 0 (A pretrigger) and channel 1 (B pretrigger)" />
      </choiceOption>
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Selects the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
         \t */
         \tenum SimAdc0Trigger {
         \t   SimAdc0Trigger_PdbExTrig    = SIM_SOPT7_ADC0TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
         \t   SimAdc0Trigger_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   //!< Comparator 0
         \t   SimAdc0Trigger_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   //!< Comparator 1
         \t   SimAdc0Trigger_Cmp2         = SIM_SOPT7_ADC0TRGSEL(3),   //!< Comparator 2 (if present)
         \t   SimAdc0Trigger_PitCh0       = SIM_SOPT7_ADC0TRGSEL(4),   //!< PIT Channel 0
         \t   SimAdc0Trigger_PitCh1       = SIM_SOPT7_ADC0TRGSEL(5),   //!< PIT Channel 1
         \t   SimAdc0Trigger_PitCh2       = SIM_SOPT7_ADC0TRGSEL(6),   //!< PIT Channel 2
         \t   SimAdc0Trigger_PitCh3       = SIM_SOPT7_ADC0TRGSEL(7),   //!< PIT Channel 3
         \t   SimAdc0Trigger_Ftm0         = SIM_SOPT7_ADC0TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
         \t   SimAdc0Trigger_Ftm1         = SIM_SOPT7_ADC0TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
         \t   SimAdc0Trigger_Ftm2         = SIM_SOPT7_ADC0TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
         \t   SimAdc0Trigger_Ftm3         = SIM_SOPT7_ADC0TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
         \t   SimAdc0Trigger_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  //!< RTC Alarm
         \t   SimAdc0Trigger_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  //!< RTC Seconds
         \t   SimAdc0Trigger_Lptrm        = SIM_SOPT7_ADC0TRGSEL(14),  //!< LPTMR
         \t   SimAdc0Trigger_15           = SIM_SOPT7_ADC0TRGSEL(15),  //!< Reserved
         \t};\n\n
         
         \t/**
         \t * Selects the ADC0 trigger mode.\n
         \t * 
         \t *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
         \t *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
         \t *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc0Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
         \t */
         \tenum SimAdc0TriggerMode {
         \t   SimAdc0TriggerMode_Pdb               = SIM_SOPT7_ADC0ALTTRGEN(0),                              //!< PDB trigger
         \t   SimAdc0TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),   //!< Pre-trigger 0 = A (SC1[0])
         \t   SimAdc0TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),   //!< Pre-trigger 1 = B (SC1[1])
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Select the ADC0 Trigger source\n
         \t * 
         \t * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
         \t * otherwise Pre-trigger 0/1 is determined by this parameter.\n
         \t * For example, setAdc0Triggers(SimAdc0TriggerMode_Alt_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source\n
         \t * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
         \t *
         \t * @param[in] simAdc0TriggerMode Select ADC0 Trigger mode 
         \t * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
         \t */
         \tstatic void setAdc0Triggers(SimAdc0TriggerMode simAdc0TriggerMode, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_PdbExTrig) {
         \t   sim().SOPT7 = (sim().SOPT7&~(SIM_SOPT7_ADC0TRGSEL_MASK|SIM_SOPT7_ADC0ALTTRGEN_MASK))|simAdc0Trigger|simAdc0TriggerMode;
         \t};\n\n
      ]]></template>
      
      <binaryOption name="sim_sopt7_adc1alttrgen" 
         description="ADC1 alternate trigger enable"
         toolTip="Enable alternative conversion triggers for ADC1">
         <choice value="0" name="PDB trigger selected" isDefault="true" />
         <choice value="1" name="Alternate trigger selected" />
      </binaryOption>
   
      <binaryOption name="sim_sopt7_adc1pretrgsel" 
         description="ADC1 pretrigger select"
         toolTip="Selects the pre-trigger source when alternative triggers are enabled through ADC1ALTTRGEN">
         <choice value="0" name="Pre-trigger 0 (A)" isDefault="true" />
         <choice value="1" name="Pre-trigger 1 (B)" />
      </binaryOption>
   
      <choiceOption name="sim_sopt7_adc1trgsel" 
         description="ADC1 trigger select"
         toolTip="Selects the trigger source when alternative triggers are functional in stop and VLPS modes">
         <choice value="0"  name="PDB external trigger pin input (PDB0_EXTRG)" isDefault="true" />
         <choice value="1"  name="High speed comparator 0 output" />
         <choice value="2"  name="High speed comparator 1 output" />
         <choice value="3"  name="High speed comparator 2 output (if available)" />
         <choice value="4"  name="PIT trigger 0" />
         <choice value="5"  name="PIT trigger 1" />
         <choice value="6"  name="PIT trigger 2" />
         <choice value="7"  name="PIT trigger 3" />
         <choice value="8"  name="FTM0 trigger" />
         <choice value="9"  name="FTM1 trigger" />
         <choice value="10" name="FTM2 trigger (if available)" />
         <choice value="11" name="FTM3 trigger (if available)" />
         <choice value="12" name="RTC alarm" />
         <choice value="13" name="RTC seconds" />
         <choice value="14" name="Low-power timer trigger" />
         <choice value="15" name="TPM2 channel 0 (A pretrigger) and channel 1 (B pretrigger)" />
      </choiceOption>
      
      <template namespace="usbdm"><![CDATA[
         \t/**
         \t * Selects the ADC1 Trigger source in STOP and VLPS modes, or when ADC1 Alternative Trigger is active.
         \t */
         \tenum SimAdc1Trigger {
         \t   SimAdc1Trigger_PdbExTrig    = SIM_SOPT7_ADC1TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
         \t   SimAdc1Trigger_Cmp0         = SIM_SOPT7_ADC1TRGSEL(1),   //!< Comparator 0
         \t   SimAdc1Trigger_Cmp1         = SIM_SOPT7_ADC1TRGSEL(2),   //!< Comparator 1
         \t   SimAdc1Trigger_Cmp2         = SIM_SOPT7_ADC1TRGSEL(3),   //!< Comparator 2 (if present)
         \t   SimAdc1Trigger_PitCh0       = SIM_SOPT7_ADC1TRGSEL(4),   //!< PIT Channel 0
         \t   SimAdc1Trigger_PitCh1       = SIM_SOPT7_ADC1TRGSEL(5),   //!< PIT Channel 1
         \t   SimAdc1Trigger_PitCh2       = SIM_SOPT7_ADC1TRGSEL(6),   //!< PIT Channel 2
         \t   SimAdc1Trigger_PitCh3       = SIM_SOPT7_ADC1TRGSEL(7),   //!< PIT Channel 3
         \t   SimAdc1Trigger_Ftm0         = SIM_SOPT7_ADC1TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
         \t   SimAdc1Trigger_Ftm1         = SIM_SOPT7_ADC1TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
         \t   SimAdc1Trigger_Ftm2         = SIM_SOPT7_ADC1TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
         \t   SimAdc1Trigger_Ftm3         = SIM_SOPT7_ADC1TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
         \t   SimAdc1Trigger_RtcAlarm     = SIM_SOPT7_ADC1TRGSEL(12),  //!< RTC Alarm
         \t   SimAdc1Trigger_RtcSeconds   = SIM_SOPT7_ADC1TRGSEL(13),  //!< RTC Seconds
         \t   SimAdc1Trigger_Lptrm        = SIM_SOPT7_ADC1TRGSEL(14),  //!< LPTMR
         \t   SimAdc1Trigger_15           = SIM_SOPT7_ADC1TRGSEL(15),  //!< Reserved
         \t};\n\n
         
         \t/**
         \t * Selects the ADC1 trigger mode.\n
         \t * 
         \t *    _Pdb              - ADC is triggered by PDB which selects the pretrigger (SC1[0..n]/R[0..n]
         \t *    _Alt_PreTrigger_0 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 0 = A (SC1[0]/R[0])
         \t *    _Alt_PreTrigger_1 - ADC is triggered by SimAdc1Trigger selection and uses pretrigger 1 = B (SC1[1]/R[1])
         \t */
         \tenum SimAdc1TriggerMode {
         \t   SimAdc1TriggerMode_Pdb               = SIM_SOPT7_ADC1ALTTRGEN(0),                              //!< PDB trigger
         \t   SimAdc1TriggerMode_Alt_PreTrigger_0  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(0),   //!< Alt trigger source, pre-trigger 0 = A (SC1[0])
         \t   SimAdc1TriggerMode_Alt_PreTrigger_1  = SIM_SOPT7_ADC1ALTTRGEN(1)|SIM_SOPT7_ADC1PRETRGSEL(1),   //!< Alt trigger source, pre-trigger 1 = B (SC1[1])
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t/**
         \t * Select the ADC1 Trigger source\n
         \t * 
         \t * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
         \t * otherwise Pre-trigger 0/1 is determined by this parameter.\n
         \t * For example, setAdc1Triggers(SimAdc1TriggerMode_Alt_PreTrigger_1, SimAdc1Trigger_PitCh0) will set the trigger source\n
         \t * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
         \t *
         \t * @param[in] simAdc1TriggerMode Select ADC1 Trigger mode 
         \t * @param[in] simAdc1Trigger     Select the ADC1 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
         \t */
         \tstatic void setAdc1Triggers(SimAdc1TriggerMode simAdc1TriggerMode, SimAdc1Trigger simAdc1Trigger=SimAdc1Trigger_PdbExTrig) {
         \t   sim().SOPT7 = (sim().SOPT7&~(SIM_SOPT7_ADC1TRGSEL_MASK|SIM_SOPT7_ADC1ALTTRGEN_MASK))|simAdc1Trigger|simAdc1TriggerMode;
         \t};\n\n
      ]]></template>
      
      <template><![CDATA[
         \t//! System Options Register 7
         \tstatic constexpr uint32_t sopt7 = 
         \t#ifdef SIM_SOPT7_ADC1ALTTRGEN
         \t   SIM_SOPT7_ADC1ALTTRGEN($(sim_sopt7_adc1alttrgen:-1)) |    // ADC1 alternate trigger enable
         \t   SIM_SOPT7_ADC1PRETRGSEL($(sim_sopt7_adc1pretrgsel:-1)) |   // ADC1 pretrigger select
         \t   SIM_SOPT7_ADC1TRGSEL($(sim_sopt7_adc1trgsel:-1)) |      // ADC1 trigger select\n\n
         \t#endif
         \t   SIM_SOPT7_ADC0ALTTRGEN($(sim_sopt7_adc0alttrgen)) |    // ADC0 alternate trigger enable
         \t   SIM_SOPT7_ADC0PRETRGSEL($(sim_sopt7_adc0pretrgsel)) |   // ADC0 pretrigger select
         \t   SIM_SOPT7_ADC0TRGSEL($(sim_sopt7_adc0trgsel));       // ADC0 trigger select\n\n
      ]]></template>
   </category>
   
   <category name="SOPT8" description="FTM signals">
      <binaryOption name="sim_sopt8_ftm3och7src" 
         description="FTM3 channel 7 output source" >
         <choice value="0" name="FTM3_CH7 pin is FTM3 ch 7 output" />
         <choice value="1" name="FTM3_CH7 pin is FTM3 ch 7 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och6src" 
         description="FTM3 channel 6 output source" >
         <choice value="0" name="FTM3_CH6 pin is FTM3 ch 6 output" />
         <choice value="1" name="FTM3_CH6 pin is FTM3 ch 6 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och5src" 
         description="FTM3 channel 5 output source" >
         <choice value="0" name="FTM3_CH5 pin is FTM3 ch 5 output" />
         <choice value="1" name="FTM3_CH5 pin is FTM3 ch 5 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och4src" 
         description="FTM3 channel 4 output source" >
         <choice value="0" name="FTM3_CH4 pin is FTM3 ch 4 output" />
         <choice value="1" name="FTM3_CH4 pin is FTM3 ch 4 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och3src" 
         description="FTM3 channel 3 output source" >
         <choice value="0" name="FTM3_CH3 pin is FTM3 ch 3 output" />
         <choice value="1" name="FTM3_CH3 pin is FTM3 ch 3 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och2src" 
         description="FTM3 channel 2 output source" >
         <choice value="0" name="FTM3_CH2 pin is FTM3 ch 2 output" />
         <choice value="1" name="FTM3_CH2 pin is FTM3 ch 2 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och1src" 
         description="FTM3 channel 1 output source" >
         <choice value="0" name="FTM3_CH1 pin is FTM3 ch 1 output" />
         <choice value="1" name="FTM3_CH1 pin is FTM3 ch 1 output, modulated by FTM2 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm3och0src" 
         description="FTM3 channel 0 output source" >
         <choice value="3" name="FTM3_CH0 pin is FTM3 ch 0 output" />
         <choice value="1" name="FTM3_CH0 pin is FTM3 ch 0 output, modulated by FTM2 ch 1" />
      </binaryOption>
      
      <binaryOption name="sim_sopt8_ftm0och7src" 
         description="FTM0 channel 7 output source" >
         <choice value="0" name="FTM0_CH7 pin is FTM0 ch 7 output" />
         <choice value="1" name="FTM0_CH7 pin is FTM0 ch 7 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och6src" 
         description="FTM0 channel 6 output source" >
         <choice value="0" name="FTM0_CH6 pin is FTM0 ch 6 output" />
         <choice value="1" name="FTM0_CH6 pin is FTM0 ch 6 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och5src" 
         description="FTM0 channel 5 output source" >
         <choice value="0" name="FTM0_CH5 pin is FTM0 ch 5 output" />
         <choice value="1" name="FTM0_CH5 pin is FTM0 ch 5 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och4src" 
         description="FTM0 channel 4 output source" >
         <choice value="0" name="FTM0_CH4 pin is FTM0 ch 4 output" />
         <choice value="1" name="FTM0_CH4 pin is FTM0 ch 4 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och3src" 
         description="FTM0 channel 3 output source" >
         <choice value="0" name="FTM0_CH3 pin is FTM0 ch 3 output" />
         <choice value="1" name="FTM0_CH3 pin is FTM0 ch 3 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och2src" 
         description="FTM0 channel 2 output source" >
         <choice value="0" name="FTM0_CH2 pin is FTM0 ch 2 output" />
         <choice value="1" name="FTM0_CH2 pin is FTM0 ch 2 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och1src" 
         description="FTM0 channel 1 output source" >
         <choice value="0" name="FTM0_CH1 pin is FTM0 ch 1 output" />
         <choice value="1" name="FTM0_CH1 pin is FTM0 ch 1 output, modulated by FTM1 ch 1" />
      </binaryOption>

      <binaryOption name="sim_sopt8_ftm0och0src" 
         description="FTM0 channel 0 output source" >
         <choice value="0" name="FTM0_CH0 pin is FTM0 ch 0 output" />
         <choice value="1" name="FTM0_CH0 pin is FTM0 ch 0 output, modulated by FTM1 ch 1" />
      </binaryOption>
   
      <template><![CDATA[
         \t//! System Options Register 8
         \tstatic constexpr uint32_t sopt8 = 
         \t   SIM_SOPT8_FTM3OCH7SRC($(sim_sopt8_ftm3och7src)) |   // FTM3 channel 7 output source
         \t   SIM_SOPT8_FTM3OCH6SRC($(sim_sopt8_ftm3och6src)) |   // FTM3 channel 6 output source
         \t   SIM_SOPT8_FTM3OCH5SRC($(sim_sopt8_ftm3och5src)) |   // FTM3 channel 5 output source
         \t   SIM_SOPT8_FTM3OCH4SRC($(sim_sopt8_ftm3och4src)) |   // FTM3 channel 4 output source
         \t   SIM_SOPT8_FTM3OCH3SRC($(sim_sopt8_ftm3och3src)) |   // FTM3 channel 3 output source
         \t   SIM_SOPT8_FTM3OCH2SRC($(sim_sopt8_ftm3och2src)) |   // FTM3 channel 2 output source
         \t   SIM_SOPT8_FTM3OCH1SRC($(sim_sopt8_ftm3och1src)) |   // FTM3 channel 1 output source
         \t   SIM_SOPT8_FTM3OCH0SRC($(sim_sopt8_ftm3och0src)) |   // FTM3 channel 0 output source
         \t   SIM_SOPT8_FTM0OCH7SRC($(sim_sopt8_ftm0och7src)) |   // FTM0 channel 7 output source
         \t   SIM_SOPT8_FTM0OCH6SRC($(sim_sopt8_ftm0och6src)) |   // FTM0 channel 6 output source
         \t   SIM_SOPT8_FTM0OCH5SRC($(sim_sopt8_ftm0och5src)) |   // FTM0 channel 5 output source
         \t   SIM_SOPT8_FTM0OCH4SRC($(sim_sopt8_ftm0och4src)) |   // FTM0 channel 4 output source
         \t   SIM_SOPT8_FTM0OCH3SRC($(sim_sopt8_ftm0och3src)) |   // FTM0 channel 3 output source
         \t   SIM_SOPT8_FTM0OCH2SRC($(sim_sopt8_ftm0och2src)) |   // FTM0 channel 2 output source
         \t   SIM_SOPT8_FTM0OCH1SRC($(sim_sopt8_ftm0och1src)) |   // FTM0 channel 1 output source
         \t   SIM_SOPT8_FTM0OCH0SRC($(sim_sopt8_ftm0och0src));    // FTM0 channel 0 output source\n\n
      ]]></template>
   </category>
   
   <category name="SOPT9" description="TPM signals">
      <binaryOption name="sim_sopt9_tpm2clksel" 
         description="Low Power Timer 2 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the TPM module.">
         <choice value="0"  name="TPM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="TPM_CLKIN1 pin" />
      </binaryOption>
   
      <binaryOption name="sim_sopt9_tpm1clksel" 
         description="Low Power Timer 1 External Clock Pin Select"
         toolTip="Selects the external pin used to drive the clock to the TPM module.">
         <choice value="0"  name="TPM_CLKIN0 pin" isDefault="true" />
         <choice value="1"  name="TPM_CLKIN1 pin" />
      </binaryOption>
   
      <choiceOption name="sim_sopt9_tpm2ch0src" 
         description="Low Power Timer 2 channel 0 input capture source select"
         toolTip="Selects the source for TPM channel 0 input capture\n
            NOTE: When the TPM is not in input capture mode, clear this field">
         <choice value="0" name="TPM2_CH0 signal"  isDefault="true"/>
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="Reserved" />
      </choiceOption>
   
      <choiceOption name="sim_sopt9_tpm1ch0src" 
         description="Low Power Timer 1 channel 0 input capture source select"
         toolTip="Selects the source for TPM channel 0 input capture\n
            NOTE: When the TPM is not in input capture mode, clear this field">
         <choice value="0" name="TPM1_CH0 signal"  isDefault="true"/>
         <choice value="1" name="CMP0 output" />
         <choice value="2" name="CMP1 output" />
         <choice value="3" name="USB start of frame pulse" />
      </choiceOption>
   
      <template><![CDATA[
         \t//! System Options Register 9
         \tstatic constexpr uint32_t sopt9 = 
         \t   SIM_SOPT9_TPM2CLKSEL($(sim_sopt9_tpm2clksel))  |   // TPM2 External Clock Pin Select
         \t   SIM_SOPT9_TPM1CLKSEL($(sim_sopt9_tpm1clksel))  |   // TPM1 External Clock Pin Select
         \t   SIM_SOPT9_TPM2CH0SRC($(sim_sopt9_tpm2ch0src))  |   // TPM2 channel 0 input capture source select
         \t   SIM_SOPT9_TPM1CH0SRC($(sim_sopt9_tpm1ch0src));     // TPM1 channel 0 input capture source select\n\n
      ]]></template>
   </category>

   <choiceOption name="sim_clkdiv2_usb"
      description="USB clock divider" 
      toolTip="Sets the clock divider when the MCGFLLCLK, MCGPLLCLK, or IRC48M clock\n
      is the USB clock source.">
      <choice value="1" name="Multiply by 2 (div=0, frac=1)" />
      <choice value="0" name="Multiply by 1 (div=0, frac=0)" />
      <choice value="3" name="Multiply by 1 (div=1, frac=1)" />
      <choice value="5" name="Divide by 1.5 (div=2, frac=1)" />
      <choice value="2" name="Divide by 2 (div=1, frac=0)" />
      <choice value="7" name="Divide by 2 (div=3, frac=1)" />
      <choice value="9" name="Divide by 2.5 (div=4, frac=1)" />
      <choice value="4" name="Divide by 3 (div=2, frac=0)" />
      <choice value="11" name="Divide by 3 (div=5, frac=1)" />
      <choice value="13" name="Divide by 3.5 (div=6, frac=1)" />
      <choice value="6" name="Divide by 4 (div=3, frac=0)" />
      <choice value="15" name="Divide by 4 (div=7, frac=1)" />
      <choice value="8" name="Divide by 5 (div=4, frac=0)" />
      <choice value="10" name="Divide by 6 (div=5, frac=0)" />
      <choice value="12" name="Divide by 7 (div=6, frac=0)" />
      <choice value="14" name="Divide by 8 (div=7, frac=0)" />
   </choiceOption>
   
   <template><![CDATA[
      \t#ifdef SIM_CLKDIV2_USBDIV_MASK
      \t//! System Clock Divider Register 2
      \t//! USB clock divider divisor & fraction
      \tstatic constexpr uint32_t clkdiv2 = $(sim_clkdiv2_usb:-1);
      \t#endif\n\n
   ]]></template>
   
   <xi:include href="_simCommon.xml"/>

   <indexedCategory name="ClockConfig." dim="/SIM/numberOfClockSettings" 
        description="Clock configurations" 
        toolTip="Clock configurations for different run modes" >
      
      <aliasOption key="/MCG/ClockConfig."
        constant="true"/>
      
      <choiceOption name="sim_sopt2_pllfllsel."
         description="Peripheral Clock select"
         toolTip="Selects the clock for various peripherals (LPUART, TPM etc.)">
         <choice value="0"  name="MCGFLLCLK clock" isDefault="true" />
         <choice value="1"  name="MCGPLLCLK clock" />
         <choice value="2"  name="USB1 PFD clock" />
         <choice value="3"  name="IRC48 MHz clock" />
      </choiceOption>
   
      <intOption name="system_peripheral_clock."
         derived="true"
         constant="true"
         units="Hz"
         description="Peripheral Clock frequency"
         toolTip="Frequency of Peripheral Clock available to various peripherals"  />
	 
      <choiceOption name="sim_clkdiv3_pllfll."
         description="Peripheral Clock post-divider" 
         toolTip="Selects the post PLL/FLL clock divider for various peripherals (LPUART, TPM, FlexIO)">
         <choice value="1" name="Multiply by 2 (div=0, frac=1)" />
         <choice value="0" name="Multiply by 1 (div=0, frac=0)" />
         <choice value="3" name="Multiply by 1 (div=1, frac=1)"  isDefault="true" />
         <choice value="5" name="Divide by 1.5 (div=2, frac=1)" />
         <choice value="2" name="Divide by 2 (div=1, frac=0)" />
         <choice value="7" name="Divide by 2 (div=3, frac=1)" />
         <choice value="9" name="Divide by 2.5 (div=4, frac=1)" />
         <choice value="4" name="Divide by 3 (div=2, frac=0)" />
         <choice value="11" name="Divide by 3 (div=5, frac=1)" />
         <choice value="13" name="Divide by 3.5 (div=6, frac=1)" />
         <choice value="6" name="Divide by 4 (div=3, frac=0)" />
         <choice value="15" name="Divide by 4 (div=7, frac=1)" />
         <choice value="8" name="Divide by 5 (div=4, frac=0)" />
         <choice value="10" name="Divide by 6 (div=5, frac=0)" />
         <choice value="12" name="Divide by 7 (div=6, frac=0)" />
         <choice value="14" name="Divide by 8 (div=7, frac=0)" />
      </choiceOption>
      
      <intOption name="system_peripheral_postdivider_clock."
         derived="true"
         constant="true"
         units="Hz"
         description="Peripheral Post-divider Clock frequency/"
         toolTip="Frequency of Peripheral Clock available to various peripherals"  />
	 
      <intOption name="system_core_clock." 
         units="Hz"
         description="System Core Clock"
         toolTip="Clocks the ARM Cortex-M4 core and bus masters"
         value="120000000" />
      
      <intOption name="system_bus_clock." 
         units="Hz"
         description="System Bus Clock"
         toolTip="Clocks the bus slaves and peripherals\n
                  Must be &lt;= Core Clock frequency and an integer divisor"
         value="60000000" />
   
      <intOption name="system_flexbus_clock." 
         units="Hz"
         description="System Flexbus Clock"
         toolTip="Clocks the flexbus interface\n
                  Must be &lt;= Bus Clock frequency"
         value="60000000" />
      
      <intOption name="system_flash_clock." 
         units="Hz"
         description="System Flash Clock"
         toolTip="Clocks the flash memory\n
                  Must be an integer divisor of the Core Clock.\n
                  Must be &lt;= Bus Clock frequency."
         value="24000000" />
      
      <category name="CLKDIV1" description="System Clock Dividers">
         <intOption name="sim_clkdiv1_outdiv1." 
            derived="true"
            constant="true"
            description="Core &amp; System Clock Divider (OUTDIV1) - Divide by [1-16]"
            toolTip="Clocks the ARM Cortex-M4 core and bus masters [SIM_CLKDIV1_OUTDIV1]\n
                     Divides MCGOUT Clock to generate system_core_clock"
            value="1" offset="-1" min="1" max="16" />
         
         <intOption name="sim_clkdiv1_outdiv2." 
            derived="true"
            constant="true"
            description="Bus Clock Divider (OUTDIV2) - Divide by [1-16]"
            toolTip="Clocks the bus slaves and peripheral [SIM_CLKDIV1_OUTDIV2]\n
               Divides MCGOUT Clock to generate system_bus_clock\n
               MCGOUTCLK clock is source. Default /2"
            value="1" offset="-1" min="1" max="16" />
      
         <intOption name="sim_clkdiv1_outdiv3." 
            derived="true"
            constant="true"
            description="Flexbus Clock Divider (OUTDIV3) - Divide by [1-16]"
            toolTip="Clocks the flexbus interface [SIM_CLKDIV1_OUTDIV3]\n
                     Divides MCGOUT Clock to generate system_flexbus_clock\n
                     MCGOUTCLK clock is source. Default /2"
            value="1" offset="-1" min="1" max="16" />
         
         <intOption name="sim_clkdiv1_outdiv4." 
            derived="true"
            constant="true"
            description="Flash Clock Divider (OUTDIV4) - Divide by [1-16]"
            toolTip="Clocks the flash memory [SIM_CLKDIV1_OUTDIV4]\n
                     Divides MCGOUT Clock to generate system_flash_clock\n
                     MCGOUTCLK clock is source. Default /4"
            value="4" offset="-1" min="1" max="16" />
      </category>
   </indexedCategory>
   
   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.SimValidate" dim="/SIM/numberOfClockSettings">
      <param type="long" value="180MHz" />    <!-- Core         -->
      <param type="long" value="60MHz" />     <!-- Bus          -->
      <param type="long" value="28MHz" />     <!-- Flash        -->
      <param type="long" value="60MHz" />     <!-- FlexBus      -->
   </validate>
   
   <xi:include href="_simFiles-MK.xml"/>
   
   <template><![CDATA[
      \t/**
      \t * Initialise SIM registers
      \t */
      \tstatic void initRegs() {
      \t#ifdef SIM_SCGC4_USBOTG_MASK
      \t   // The USB interface must be disabled for clock changes to have effect
      \t   sim().SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
      \t#endif
      \t
      \t   sim().SOPT1 = sopt1;
      \t   // sim_sopt2_pllfllsel may also be altered by MCG clock code
      \t   sim().SOPT2 = sopt2;
      \t   sim().SOPT4 = sopt4;
      \t   sim().SOPT5 = sopt5;
      \t   sim().SOPT7 = sopt7;
      \t   sim().SOPT8 = sopt8;
      \t   sim().SOPT9 = sopt9;
      \t
      \t#ifdef SIM_CLKDIV2_USBDIV_MASK
      \t   sim().CLKDIV2 = clkdiv2;
      \t#endif
      \t}\n\n
   ]]></template>
</peripheralPage>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE fragment SYSTEM "_menu.dtd" >
<!-- smc_base.xml -->

<fragment xmlns:xi="http://www.w3.org/2001/XInclude" >

   <equation key="irq_parameters"            type="String"  value='""'  />
   <equation key="irq_dummy_parameters"      type="String"  value='""'  />
   <equation key="irq_call"                  type="String"  value='""'  />
   <equation key="generateDefault"           type="Boolean" value="false"         />
   <equation key="configureInStartupDefault" type="Boolean" value="false"         />
   <xi:include href="enablePeripheral.xml"  />
   <title />

   <!-- ************* PMPROT ****************** -->

   <binaryOption key="smc_pmprot_ahsrun" condition="smc_pmprot_ahsrun_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcAllowHighSpeedRun"
      baseType="uint8_t"
      description="Allow High Speed Run mode"
      toolTip="Allows the MCU to enter High Speed Run mode (HSRUN)" >
      <choice name="HSRUN is not allowed" enum="Disabled" value="0" />
      <choice name="HSRUN is allowed"     enum="Enabled"  value="1" isDefault="true" />
   </binaryOption>

   <binaryOption key="smc_pmprot_avlp" condition="smc_pmprot_avlp_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcAllowVeryLowPower"
      baseType="uint8_t"
      description="Allow Very Low Power modes"
      toolTip="Allows the MCU to enter any very low power modes: VLPR, VLPW, and VLPS" >
      <choice name="VLPR, VLPW and VLPS are not allowed" enum="Disabled" value="0" />
      <choice name="VLPR, VLPW and VLPS are allowed"     enum="Enabled"  value="1" isDefault="true" />
   </binaryOption>

   <binaryOption key="smc_pmprot_alls" condition="smc_pmprot_alls_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcAllowLowLeakageStop"
      baseType="uint8_t"
      description="Allow Low Leakage Stop mode"
      toolTip="Allows the MCU to enter any low leakage stop mode: LLS" >
      <choice name="LLS is not allowed" enum="Disabled" value="0" />
      <choice name="LLS is allowed"     enum="Enabled"  value="1" isDefault="true" />
   </binaryOption>

   <binaryOption key="smc_pmprot_avlls" condition="smc_pmprot_avlls_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcAllowVeryLowLeakageStop"
      baseType="uint8_t"
      description="Allow Very Low Leakage Stop mode"
      toolTip="Allows the MCU to enter any low leakage stop mode: VLLSx" >
      <choice name="VLLSx is not allowed" enum="Disabled" value="0" />
      <choice name="VLLSx is allowed"     enum="Enabled"  value="1" isDefault="true" />
   </binaryOption>

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_pmprot_ahsrun,smc_pmprot_avlp,smc_pmprot_alls,smc_pmprot_avlls" > <![CDATA[
      \t/**
      \t * Enable all power modes.
      \t * A power mode must be enabled before it can be entered.
      \t *
      \t * @note This is a write-once-after-reset operation
      \t */
      \tstatic ErrorCode enableAllPowerModes() {
      \t
      \t   smc->PMPROT = 0xFF;
      \t   return E_NO_ERROR;
      \t}

      \t/**
      \t * Enable the given power modes
      \t * A mode must be enabled before it can be entered.
      \t
      \t * @note This is a write-once operation after reset
      \t *
      %paramDescription
      \t */
      \tstatic void enablePowerModes(%params) {
      \t
      \t   %register = %paramExpression;
      \t}\n\n
   ]]></variableTemplate>

   <!-- ************* PMCTRL ****************** -->

   <for keys="n" dim="=/SIM/numberOfClockSettings" >
      <choiceOption key="smc_pmctrl_runm[%(n)]" condition="smc_pmctrl_runm_present"
         hidden="true"
         typeName="SmcRunMode"
         baseType="uint8_t"
         description="Run mode"
         toolTip="Determines the clock speed restrictions that apply">
         <choice value="0"  name="Normal RUN"         enum="Normal"        isDefault="true" />
         <choice value="2"  name="Very Low Power RUN" enum="VeryLowPower"  condition="smc_pmprot_avlp" />
         <choice value="3"  name="High Speed RUN"     enum="HighSpeed"     condition="smc_pmprot_ahsrun" />
      </choiceOption>
   </for>

   <binaryOption key="smc_pmctrl_lpwui" condition="smc_pmctrl_lpwui_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcExitLowPowerOnInt"
      baseType="uint8_t"
      description="Exit low power on interrupt"
      toolTip="Causes the SMC to exit to normal RUN mode when any active interrupt\n
               occurs while in a VLP mode (VLPR, VLPW or VLPS)" >
      <choice name="Stay in VLPR on int" enum="Disabled" value="0" isDefault="true" />
      <choice name="Exit VLPR on int"    enum="Enabled"  value="1" />
   </binaryOption>

   <binaryOption key="smc_pmctrl_stopa" condition="smc_pmctrl_stopa_present"
      hidden="true"
      typeName="SmcStopOutcome"
      description="Stop Aborted"
      toolTip="This read-only status bit indicates an interrupt occured during the previous stop mode entry \n
               sequence, preventing the system from entering that mode. \n
               This field is cleared by reset or by hardware at the beginning of any stop mode\n
               entry sequence and is set if the sequence was aborted." >
      <choice value="0" name="Entry Successful" enum="Successful"/>
      <choice value="1" name="Entry Aborted"    enum="Aborted"/>
   </binaryOption>

   <choiceOption key="smc_pmctrl_stopm" condition="smc_pmctrl_stopm_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcStopMode"
      baseType="uint8_t"
      toolTip="Controls entry into the selected stop mode when Sleep-Now or Sleep-On-Exit \n
               mode is entered with SLEEPDEEP=1\n
               This field is cleared by hardware on any successful write to the PMPROT register"
      description="Stop Mode Control" >
      <choice value="0" enum="NormalStop"          name="Normal Stop (STOP)" />
      <choice value="2" enum="VeryLowPowerStop"    name="Very-Low-Power Stop (VLPS)" />
      <choice value="3" enum="LowLeakageStop"      name="Low-Leakage Stop (LLSx)" />
      <choice value="4" enum="VeryLowLeakageStop"  name="Very-Low-Leakage Stop (VLLSx)" />
   </choiceOption>

   <clockCodeTemplate variable="smc_pmctrl_lpwui"  codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t *
      \t * @return E_NO_ERROR                 Success
      \t * @return E_ILLEGAL_POWER_TRANSITION If not in RUN mode
      \t */
      \tstatic ErrorCode setExitVeryLowPowerOnInterrupt(%paramType %paramName) {
      \t   if (getStatus() != SmcStatus_RUN) {
      \t      // Can only change in RUN mode
      \t      return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
      \t   }
      \t
      \t   %fieldAssignment;
      \t
      \t   // Make sure write completes
      \t   (void)smc->PMCTRL;
      \t   return E_NO_ERROR;
      \t}\n\n
   ]]></clockCodeTemplate>

   <!-- ************* STOPCTRL ****************** -->

   <choiceOption key="smc_stopctrl_pstopo" condition="smc_stopctrl_pstopo_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcPartialStopMode"
      baseType="uint8_t"
      description="Partial Stop Mode"
      toolTip="Controls whether a Partial Stop mode is entered when STOPM=STOP">
      <choice value="0" enum="Normal"    name="STOP - Normal Stop mode" />
      <choice value="1" enum="Partial1"  name="PSTOP1 - Partial Stop with both system and bus clocks disabled" />
      <choice value="2" enum="Partial2"  name="PSTOP2 - Partial Stop with system clock disabled and bus clock enabled" />
   </choiceOption>

   <binaryOption key="smc_stopctrl_porpo" condition="smc_stopctrl_porpo_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcPowerOnResetInVlls0"
      baseType="uint8_t"
      description="Power-On_Reset Detection in VLLS0 mode"
      toolTip="Controls whether the Power-On-Reset detect circuit is enabled in VLLS0 mode (Brown-out detection)" >
      <choice value="0" enum="Enabled"  name="POR detect circuit is enabled in VLLS0"  isDefault="true" />
      <choice value="1" enum="Disabled" name="POR detect circuit is disabled in VLLS0"  />
   </binaryOption>

   <choiceOption key="smc_stopctrl_llsm" condition="smc_stopctrl_llsm_present &amp;&amp; !smc_stopctrl_vllsm_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcLowLeakageStopMode"
      baseType="uint8_t"
      description="Low Leakage Mode Control"
      toolTip="Controls which LLS sub-mode to enter if STOPM = LLSx">
      <choice value="2" enum="LLS2" name="Enter LLS2 in LLSx mode" />
      <choice value="3" enum="LLS3" name="Enter LLS3 in LLSx mode" isDefault="true" />
   </choiceOption>

   <choiceOption key="smc_stopctrl_vllsm" condition="!smc_stopctrl_llsm_present &amp;&amp; smc_stopctrl_vllsm_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcLowLeakageStopMode"
      baseType="uint8_t"
      description="Low Leakage Mode Control"
      toolTip="Controls which VLLS sub-mode to enter if STOPM = VLLSx">
      <choice value="0" enum="VLLS0" name="Enter VLLS0 in VLLSx mode" />
      <choice value="1" enum="VLLS1" name="Enter VLLS1 in VLLSx mode" />
      <choice value="2" enum="VLLS2" name="Enter VLLS2 in VLLSx mode" />
      <choice value="3" enum="VLLS3" name="Enter VLLS3 in VLLSx mode" isDefault="true" />
   </choiceOption>

   <choiceOption key="smc_stopctrl_vllsm_llsm" condition="smc_stopctrl_llsm_present &amp;&amp; smc_stopctrl_vllsm_present"
      enabledBy="enablePeripheralSupport"
      valueFormat="SMC_STOPCTRL_VLLSM(%s)"
      typeName="SmcLowLeakageStopMode"
      baseType="uint8_t"
      description="Low Leakage Mode Control"
      toolTip="Controls which VLLS/LLS sub-mode to enter if STOPM = LLSx/VLLSx\n
               Note that options apply to both modes _VLLS2 == _LLS2">
      <choice value="0" enum="VLLS0" name="Enter VLLS0 in VLLSx mode" />
      <choice value="1" enum="VLLS1" name="Enter VLLS1 in VLLSx mode" />
      <choice value="2" enum="VLLS2" name="Enter VLLS2/LLS2 in VLLSx/LLSx mode" />
      <choice value="3" enum="VLLS3" name="Enter VLLS3/LLS3 in VLLSx/LLSx mode" isDefault="true" />
      <choice value="2" enum="LLS2" name="Enter VLLS2/LLS2 in VLLSx/LLSx mode" />
      <choice value="3" enum="LLS3" name="Enter VLLS2/LLS3 in VLLSx/LLSx mode" />
   </choiceOption>

   <binaryOption key="smc_stopctrl_ram2po" condition="smc_stopctrl_ram2po_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcLowLeakageRam2"
      baseType="uint8_t"
      description="RAM2 Power Option"
      toolTip="Controls powering of RAM partition 2 in LLS2/VLLS2 mode" >
      <choice value="0" enum="Disabled" name="RAM2 not powered in VLLS2"     isDefault="true" />
      <choice value="1" enum="Enabled"  name="RAM2 powered in VLLS2" />
   </binaryOption>

   <binaryOption key="smc_stopctrl_lpopo" condition="smc_stopctrl_lpopo_present"
      enabledBy="enablePeripheralSupport"
      typeName="SmcLpoInLowLeakage"
      baseType="uint8_t"
      description="Stop mode LPO Option"
      toolTip="Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes" >
      <choice value="0" enum="Disabled" name="LPO clock is enabled in LLS/VLLSx"  isDefault="true" />
      <choice value="1" enum="Enabled"  name="LPO clock is disabled in LLS/VLLSx" />
   </binaryOption>

   <clockCodeTemplate variable="smc_stopctrl_pstopo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setPartialStopMode(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_porpo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setPowerOnResetInVLLS0(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_vllsm" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setLowLeakageStopMode(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_llsm" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setLowLeakageStopMode(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_ram2po" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setRam2PoweredInLLS2_VLLS2(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_lpopo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
   ><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setLpoPoweredInLLS_VLLS(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <clockCodeTemplate variable="smc_stopctrl_vllsm_llsm"><![CDATA[
      \t/**
      \t * Set %description
      \t *
      \t * @param %paramName %tooltip
      \t */
      \tstatic void setLowLeakageStopMode(%paramType %paramName) {
      \t   %fieldAssignment;
      \t}\n\n
   ]]></clockCodeTemplate>

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_stopctrl_pstopo,smc_stopctrl_llsm,smc_stopctrl_vllsm,smc_stopctrl_vllsm_llsm,smc_stopctrl_porpo,smc_stopctrl_ram2po,smc_stopctrl_lpopo">
      <![CDATA[
      \t/**
      \t * Allows the detailed operation in STOP mode to be controlled.
      \t *
      %paramDescription
      \t */
      \tstatic void setStopOptions(%params) {

      \t   %register = %paramExpression;
      \t}\n\n
   ]]></variableTemplate>

   <!-- ************** PMSTAT ************** -->

   <choiceOption key="smc_pmstat_pmstat" condition="smc_pmstat_pmstat_present"
      hidden="true"
      typeName="SmcStatus"
      baseType="uint8_t"
      description="Power Mode Status"
      toolTip="Shows the execution state of the processor" >
      <choice value="1&lt;&lt;7" enum="HSRUN" name="Processor is in High Speed Run mode"  condition="smc_pmprot_ahsrun" />
      <choice value="1&lt;&lt;0" enum="RUN"   name="Processor is in Normal Run mode"            />
      <choice value="1&lt;&lt;2" enum="VLPR"  name="Processor is in Very Low Power Run mode"    />
      <choice value="1&lt;&lt;3" enum="VLPW"  name="Processor is in Very Low Power Wait mode"   />
      <choice value="1&lt;&lt;1" enum="STOP"  name="Processor is in Stop mode"                  />
      <choice value="1&lt;&lt;4" enum="VLPS"  name="Processor is in Very Low Power Stop mode"   />
      <choice value="1&lt;&lt;5" enum="LLS"   name="Processor is in Low Leakage Stop mode"      />
      <choice value="1&lt;&lt;6" enum="VLLS"  name="Processor is in Very Low Leakage Stop mode" />
   </choiceOption>

<!-- Setters and getters -->

   <for keys="field           : get   : set   : clear : genCode                 : name"
        values="
         smc_pmprot_ahsrun    : true  : true  : false : enableGettersAndSetters : AllowHSRUN;
         smc_pmprot_avlp      : true  : true  : false : enableGettersAndSetters : AlllowLP;
         smc_pmprot_alls      : true  : true  : false : enableGettersAndSetters : AllowLLS;
         smc_pmprot_avlls     : true  : true  : false : enableGettersAndSetters : AllowVLLS;

         smc_pmctrl_runm      : false : true  : false : enableGettersAndSetters : RunMode;
         smc_pmctrl_stopa     : true  : false : false : enableGettersAndSetters : StopOutcome;
         smc_pmctrl_stopm     : true  : true  : false : true                    : StopMode;

         smc_stopctrl_pstopo  : true  : true  : false : enableGettersAndSetters : PartialStopOption;
         smc_stopctrl_porpo   : true  : true  : false : enableGettersAndSetters : PowerOptionPOR;
         smc_stopctrl_llsm    : true  : true  : false : enableGettersAndSetters : ModeControlLLS;
         smc_stopctrl_vllsm   : true  : true  : false : enableGettersAndSetters : ModeControlVLLS;

         smc_pmstat_pmstat    : true  : false : false : true                    : Status" >
      <variableTemplate variables="%(field)" condition="%(set)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         %paramDescription
         \t */
         \tstatic void set%(name)(%params) {
         \t   %fieldAssignment;
         \t   // Make sure write has completed
         \t   (void)(%register);
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(get)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Get %description
         \t *
         \t * @return %tooltip
         \t */
         \tstatic %paramType get%(name)() {
         \t   return %paramType(%register&%mask);
         \t}
         \t\n
      ]]></variableTemplate>
      <variableTemplate variables="%(field)" condition="%(clear)" codeGenCondition="%(genCode)"
      ><![CDATA[
         \t/**
         \t * Set %description
         \t *
         \tstatic void clear%(name)() {
         \t   %register = %register|%mask;
         \t}
         \t\n
      ]]></variableTemplate>
   </for>

    <!-- ************** General ************** -->

   <if condition="smc_pmprot_ahsrun" >
      <template key="enterRunMode" where="all"
         codeGenCondition="/MCG/enablePeripheralSupport&amp;&amp;/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
         \t/**
         \t * Enter Run Mode.
         \t *
         \t * This may be used to change between supported RUN modes (RUN, VLPR, HSRUN).\n
         \t * Only the following transitions are allowed: VLPR <-> RUN <-> HSRUN.
         \t *
         \t * @param[in] clockConfig Clock configuration (Includes run mode to enter)
         \t *
         \t * @return E_NO_ERROR                 No error
         \t * @return E_CLOCK_INIT_FAILED        Clock transition failure
         \t * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to smcRunMode from current run mode
         \t */
         \tstatic ErrorCode enterRunMode(ClockConfig clockConfig) {
         \t
         \t   SmcRunMode smcRunMode = Mcg::clockInfo[clockConfig].runMode;
         \t
         \t   ErrorCode rc = E_NO_ERROR;
         \t
         \t   /*
         \t    * Transition    Change clock configuration
         \t    * HSRUN->RUN    Before
         \t    * VLPR->RUN     After
         \t    * RUN->HSRUN    After
         \t    * RUN->VLPR     Before
         \t    */
         \t   auto smcStatus = getStatus();
         \t   bool changeBefore = (smcStatus == SmcStatus_HSRUN);
         \t
         \t   switch(smcRunMode) {
         \t
         \t      case SmcRunMode_Normal:
         \t         if (changeBefore) {
         \t            // Change clock mode
         \t            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t            if (rc != E_NO_ERROR) {
         \t               break;
         \t            }
         \t         }
         \t         // Change power mode
         \t         SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
         \t
         \t         // Wait for power status to change
         \t         while (getStatus() != SmcStatus_RUN) {
         \t            __asm__("nop");
         \t         }
         \t         if (!changeBefore) {
         \t            // Change clock mode
         \t            rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t         }
         \t         break;
         \t
         \t      case SmcRunMode_HighSpeed:
         \t         if (smcStatus != SmcStatus_RUN) {
         \t            // Can only transition from RUN mode
         \t            return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
         \t         }
         \t         // Change power mode
         \t         SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
         \t
         \t         // Wait for power status to change
         \t         while (getStatus() != SmcStatus_HSRUN) {
         \t            __asm__("nop");
         \t         }
         \t         rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t         break;
         \t
         \t      case SmcRunMode_VeryLowPower:
         \t         if (smcStatus != SmcStatus_RUN) {
         \t            // Can only transition from RUN mode
         \t            return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
         \t         }
         \t         // Change clock mode
         \t         rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t         if (rc != E_NO_ERROR) {
         \t            break;
         \t         }
         \t         // Change power mode
         \t         SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
         \t
         \t         // Wait for power status to change
         \t         while (getStatus() != SmcStatus_VLPR) {
         \t            __asm__("nop");
         \t         }
         \t         break;
         \t
         \t      default:
         \t         return setErrorCode(E_ILLEGAL_PARAM);
         \t   }
         \t   return rc;
         \t}\n\n
      ]]></template>
   <else />
      <template key="enterRunMode" where="all"
         codeGenCondition="/MCG/enablePeripheralSupport&amp;&amp;/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
         \t/**
         \t * Enter Run Mode.
         \t *
         \t * This may be used to change between supported RUN modes (RUN, VLPR, HSRUN).\n
         \t * Only the following transitions are allowed: VLPR <-> RUN <-> HSRUN.
         \t *
         \t * @param[in] clockConfig Clock configuration (Includes run mode to enter)
         \t *
         \t * @return E_NO_ERROR                 No error
         \t * @return E_CLOCK_INIT_FAILED        Clock transition failure
         \t * @return E_ILLEGAL_POWER_TRANSITION Cannot transition to smcRunMode from current run mode
         \t */
         \tstatic ErrorCode enterRunMode(ClockConfig clockConfig) {
         \t
         \t   SmcRunMode smcRunMode = Mcg::clockInfo[clockConfig].runMode;
         \t
         \t   ErrorCode rc = E_NO_ERROR;
         \t
         \t   /*
         \t    * Transition    Change clock configuration
         \t    * VLPR->RUN     After
         \t    * RUN->VLPR     Before
         \t    */
         \t   switch(smcRunMode) {
         \t
         \t      case SmcRunMode_Normal:
         \t         // Change power mode
         \t         SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
         \t
         \t         // Wait for power status to change
         \t         while (getStatus() != SmcStatus_RUN) {
         \t            __asm__("nop");
         \t         }
         \t         // Change clock mode
         \t         rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t         break;
         \t
         \t      case SmcRunMode_VeryLowPower:
         \t         // Change clock mode
         \t         rc = Mcg::clockTransition(Mcg::clockInfo[clockConfig]);
         \t         if (rc != E_NO_ERROR) {
         \t            break;
         \t         }
         \t         // Change power mode
         \t         SMC->PMCTRL = (SMC->PMCTRL&~SMC_PMCTRL_RUNM_MASK)|smcRunMode;
         \t
         \t         // Wait for power status to change
         \t         while (getStatus() != SmcStatus_VLPR) {
         \t            __asm__("nop");
         \t         }
         \t         break;
         \t      default:
         \t         return setErrorCode(E_ILLEGAL_PARAM);
         \t   }
         \t   return rc;
         \t}\n\n
      ]]></template>
   </if>

   <template key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t/**
      \t * Change power mode.
      \t *
      \t * @note Note this method does not affect advanced STOP options such as PORPO and RAM2PO
      \t *       These should be set beforehand.
      \t *
      \t * @param smcPowerMode  Power mode to change to (apart from SmcPowerMode_RUN/VLPR/HSRUN)
      \t *
      \t * @return E_NOERROR                   Success
      \t * @return E_ILLEGAL_PARAM             Cannot enter RUN or VLPR using this method (use enterRunMode())
      \t * @return E_ILLEGAL_POWER_TRANSITION  It is not possible to transition directly to the given power mode
      \t * @return E_INTERRUPTED               Processor failed to change mode due to interrupt
      \t */
      \tstatic ErrorCode enterPowerMode(SmcPowerMode smcPowerMode) {
      \t
      \t   switch(smcPowerMode) {
      \t
      \t      // Transition refers to Figure 15-5. Power mode state diagram in MK22F Manual (K22P121M120SF7RM)
      \t
      \t      case SmcPowerMode_RUN   : // (VLPR,HSRUN)->RUN Transition 3,12
      \t      case SmcPowerMode_VLPR  : // RUN->VLPR         Transition 3\n
   ]]></template>
   <variableTemplate variables="smc_pmprot_ahsrun" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t      case SmcPowerMode_HSRUN : // RUN->HSRUN        Transition 12\n
   ]]></variableTemplate>
   <template key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t         // Clock changes needed etc. Use enterRunMode()
      \t         return E_ILLEGAL_PARAM;
      \t
      \t      case SmcPowerMode_VLPW  : // VLPR->VLPW        Transition 4
      \t         // Check if in correct run mode
      \t         if (SmcRunMode_VeryLowPower != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
      \t            return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
      \t         }
      \t         [[fallthrough]];
      \t      case SmcPowerMode_WAIT  : // (RUN,VLPR)->VLPW  Transition 1,4
      \t         enterWaitMode();
      \t         return E_NO_ERROR;
      \t         break;
      \t
      \t      case SmcPowerMode_NormalSTOP   : // RUN->STOP Transition 2a\n
   ]]></template>
   <variableTemplate variables="smc_stopctrl_pstopo" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t      case SmcPowerMode_PartialSTOP1 : // RUN->STOP Transition 2b
      \t      case SmcPowerMode_PartialSTOP2 : // RUN->STOP Transition 2c\n
   ]]></variableTemplate>
   <template key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t         // Check if in correct run mode
      \t         if (SmcRunMode_Normal != (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
      \t            return E_ILLEGAL_POWER_TRANSITION;
      \t         }
      \t         [[fallthrough]];
      \t      case SmcPowerMode_VLPS  :        // (RUN,VLPR)->VLPS  Transition 7,6 \n
   ]]></template>
   <template condition="smc_stopctrl_llsm_present" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t      case SmcPowerMode_LLS2  :        // (RUN,VLPR)->LLS2   Transition 10a,11a
      \t      case SmcPowerMode_LLS3  :        // (RUN,VLPR)->LLS3   Transition 10b,11b \n
   ]]></template>
   <template condition="smc_stopctrl_vllsm_present" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t      case SmcPowerMode_VLLS0 :        // (RUN,VLPR)->VLLS0 Transition 8a,9a
      \t      case SmcPowerMode_VLLS1 :        // (RUN,VLPR)->VLLS1 Transition 8b,9b
      \t      case SmcPowerMode_VLLS2 :        // (RUN,VLPR)->VLLS2/LLS2 Transition 8c,9c
      \t      case SmcPowerMode_VLLS3 :        // (RUN,VLPR)->VLLS3/LLS3 Transition 8d,9d \n
   ]]></template>
   <variableTemplate variables="smc_pmprot_ahsrun" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t         // Check if in allowable run modes
      \t         if (SmcRunMode_HighSpeed == (SMC->PMCTRL&SMC_PMCTRL_RUNM_MASK)) {
      \t            return E_ILLEGAL_POWER_TRANSITION;
      \t         }\n
   ]]></variableTemplate>
   <variableTemplate variables="smc_stopctrl_pstopo, smc_stopctrl_llsm, smc_stopctrl_vllsm, smc_stopctrl_vllsm_llsm" key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t         // Set partial_stop and (v)lls options
      \t         %register = (%register&~%mask)|(smcPowerMode>>8);
      \t
      \t         return enterStopMode((SmcStopMode)(smcPowerMode&SMC_PMCTRL_STOPM_MASK));\n
   ]]></variableTemplate>
   <template key="enterPowerMode" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
      \t   }
      \t   return setErrorCode(E_ILLEGAL_POWER_TRANSITION);
      \t}\n\n
   ]]></template>

   <template where="usbdm" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \tconsteval uint32_t make16(uint8_t pmctrl, uint8_t stopctrl=0, uint8_t bias=0) {
   \t   return pmctrl+(stopctrl<<8)+(bias<<16);
   \t}

   \tenum SmcPowerMode {
   \t   /*                           value                                                                                    Entry             Trans  Core       Requirements                                           */ //
   \t   SmcPowerMode_RUN           = make16(SmcRunMode_Normal),                                                            /* (VLPR,HSRUN)->RUN 3,12   Run        SMC_PMCTRL_RUNM(0)                                     */ ///<  Run mode
   \t   SmcPowerMode_VLPR          = make16(SmcRunMode_VeryLowPower),                                                      /* RUN->VLPR         3      Run        SMC_PMCTRL_RUNM(2)                                     */ ///<  Very low power run mode     \n
   ]]></template>
   <variableTemplate where="usbdm" variables="smc_pmprot_ahsrun" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t   SmcPowerMode_HSRUN         = make16(SmcRunMode_HighSpeed),                                                         /* RUN->HSRUN        12     Run        SMC_PMCTRL_RUNM(3)                                     */ ///<  High-speed run mode         \n
   ]]></variableTemplate>
   <template where="usbdm" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t
   \t   SmcPowerMode_WAIT          = make16(SmcRunMode_Normal,0,1),                                                        /* RUN->WAIT         1      Sleep      wfi+SMC_PMCTRL_RUNM(0)                                 */ ///<  Wait mode
   \t   SmcPowerMode_VLPW          = make16(SmcRunMode_VeryLowPower,0,1),                                                  /* VLPR->VLPW        4      Sleep      wfi+SMC_PMCTRL_RUNM(2)                                 */ ///<  Very low power wait mode
   \t
   \t   SmcPowerMode_NormalSTOP    = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,0,2),                                 /* RUN->STOP         2a     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode                   \n
   ]]></template>
   <template where="usbdm" condition="smc_stopctrl_pstopo" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t   SmcPowerMode_PartialSTOP1  = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,SmcPartialStopMode_Partial1),         /* RUN->STOP         2b     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode
   \t   SmcPowerMode_PartialSTOP2  = make16(SmcRunMode_Normal|SmcStopMode_NormalStop,SmcPartialStopMode_Partial2),         /* RUN->STOP         2c     Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0) RUN<->STOP           */ ///<  Stop mode                   \n
   ]]></template>
   <template where="usbdm" condition="smc_pmprot_avlp_present" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t
   \t   SmcPowerMode_VLPS          = make16(SmcRunMode_Normal|SmcStopMode_VeryLowPowerStop),                               /* (RUN,VLPR)->VLPS  7,6    Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(2)                      */ ///<  Very low power stop mode
   \t   /*                               or if SmcRunMode_VeryLowPower,                                                       VLPR->VLPS        6      Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(0/2)                    */ ///<  Very low power stop mode    \n
   ]]></template>
   <template where="usbdm" condition="smc_stopctrl_llsm_present" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t
   \t   SmcPowerMode_LLS2          = make16(SmcRunMode_Normal|SmcStopMode_LowLeakageStop,SmcLowLeakageStopMode_LLS2),      /* (RUN,VLPR)->LLS   10,11a Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(3)+SMC_STOPCTRL_LLSM(2) */ ///<  Low leakage stop mode 2
   \t   SmcPowerMode_LLS3          = make16(SmcRunMode_Normal|SmcStopMode_LowLeakageStop,SmcLowLeakageStopMode_LLS3),      /* (RUN,VLPR)->LLS   10,11b Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(3)+SMC_STOPCTRL_LLSM(3) */ ///<  Low leakage stop mode 3     \n
   ]]></template>
   <template where="usbdm" condition="smc_stopctrl_vllsm_present" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t
   \t   SmcPowerMode_VLLS0         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS0), /* (RUN,VLPR)->VLLS0 8,9a   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(0) */ ///<  Very low leakage stop mode 0
   \t   SmcPowerMode_VLLS1         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS1), /* (RUN,VLPR)->VLLS1 8,9b   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(1) */ ///<  Very low leakage stop mode 1
   \t   SmcPowerMode_VLLS2         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS2), /* (RUN,VLPR)->VLLS2 8,9c   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(2) */ ///<  Very low leakage stop mode 2
   \t   SmcPowerMode_VLLS3         = make16(SmcRunMode_Normal|SmcStopMode_VeryLowLeakageStop,SmcLowLeakageStopMode_VLLS3), /* (RUN,VLPR)->VLLS3 8,9d   Deep Sleep wfi+sleepDeep+SMC_PMCTRL_STOPM(4)+SMC_STOPCTRL_LLSM(3) */ ///<  Very low leakage stop mode 3 \n
   ]]></template>
   <template where="usbdm" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" ><![CDATA[
   \t};\n\n
   ]]></template>

   <!--   ========== Interrupt handling =============================== -->

   <!--   ========== SMC Init class =============================== -->

   <template codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo">
   <![CDATA[
      \t/**
      \t * Class used to do initialisation of the $(_Baseclass)
      \t *
      \t * This class has a templated constructor that accepts various values.
      \t * Parameters available may vary with device - see $(_Class)::DefaultInitValue for relevant example.
      \t * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
      \t *
      \t * @note This constructor may be used to create a const instance in Flash
      \t *
      \t * Example:
      \t * @code
      \t * // Parameters may be in any order
      \t * // Omitted values are taken to be zero unless a default value is given
      \t * // Options available vary with target - See SmcInfo::DefaultInitValue for specific example
      \t * static const Smc::Init smcInit{
      \t *    // Allow all power modes
      \t *    SmcAllowVeryLowPower_Enabled, SmcAllowLowLeakageStop_Enabled, SmcAllowVeryLowLeakageStop_Enabled,
      \t *    // Partial Stop mode to use
      \t *    SmcPartialStopMode_Partial2,
      \t *    // (Very) Low leakage stop mode to use
      \t *    SmcLowLeakageStopMode_LLS3,
      \t *    // Allow brown-out detection in VLLS0
      \t *    SmcPowerOnResetInVlls0_Enabled,
      \t *    // Power RAM2 in in LLS2/VLLS2 mode
      \t *    SmcLowLeakageRam2_Enabled,
      \t *    // Stop mode to enter on Deep-sleep
      \t *    SmcStopMode_NormalStop
      \t *    // Optional value to build upon - must be last in parameter list
      \t *    // The value below is generated from Configure.usbdmProject
      \t *    Smc::DefaultInitValue,
      \t * };
      \t *
      \t * // This version initialises all registers including write-once
      \t * // Use for initial setup
      \t * smcInit.initialise();
      \t *
      \t * // This version initialises all registers apart from write-once
      \t * // It may be used to change settings later
      \t * smcInit.setOptions();
      \t *
      \t * The value can also be used with enterStopMode()
      \t * Smc::enterStopMode(smcInit);
      \t * @endcode
      \t *
      \t * Example2: Inline example
      \t * @code
      \t * Smc::Init{
      \t *    // Stop mode to enter on Deep-sleep
      \t *    SmcStopMode_NormalStop,
      \t *    // The value below is generated from Configure.usbdmProject
      \t *    Smc::DefaultInitValue}.setOptions();
      \t * @endcode
      \t */
      \tclass Init {
      \t
      \tpublic:
      \t   /**
      \t    * Copy Constructor
      \t    */
      \t   constexpr Init(const Init &other) = default;
      \t
      \t   /**
      \t    * Default Constructor
      \t    */
      \t   constexpr Init() = default;
      \t
      \tpublic:
      \t   /**
      \t    * Configure STOP mode options as specified in the constructor.
      \t    * This does not include write-once registers.
      \t    */
      \t   inline void setOptions() const {
      \t      smc->STOPCTRL  = stopctrl;
      \t      smc->PMCTRL    = (smc->PMCTRL & ~(SMC_PMCTRL_STOPM_MASK))|pmctrl;
      \t   }
      \t
      \t   /**
      \t    * Configure all STOP mode options as specified in the constructor.
      \t    * This includes write-once registers
      \t    */
      \t   inline void initialise() const {
      \t      smc->PMPROT    = pmprot;
      \t      setOptions();
      \t   }
      \t
      \t   /**
      \t    * Read the current STOP mode options from hardware registers
      \t    */
      \t   void readConfig() {
      \t      pmprot   = smc->PMPROT;
      \t      stopctrl = smc->STOPCTRL;
      \t      pmctrl   = smc->PMCTRL & SMC_PMCTRL_STOPM_MASK;
      \t   }
      \t\n
   ]]>
   </template>

   <!--   Member variables -->

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_pmprot_ahsrun,smc_pmprot_avlp,smc_pmprot_alls,smc_pmprot_avlls"
   ><![CDATA[
      \t   /// Power Mode Protection Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_pmctrl_runm,smc_pmctrl_stopm"
   ><![CDATA[
      \t   /// Power Mode Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_stopctrl_pstopo,smc_stopctrl_porpo,smc_stopctrl_llsm,smc_stopctrl_vllsm"
   ><![CDATA[
      \t   /// Stop Control Register
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
      variables="smc_vllsctrl_pstopo,smc_vllsctrl_porpo,smc_vllsctrl_llsm,smc_vllsctrl_vllsm"
   ><![CDATA[
      \t   /// VLLS Control Register (old name)
      \t   uint8_t %registerName = 0;\n\n
   ]]></variableTemplate>

   <!--   Constructors -->

   <for keys="r"
      values="
            smc_pmprot_ahsrun;
            smc_pmprot_avlp;
            smc_pmprot_alls;
            smc_pmprot_avlls;
            smc_pmctrl_stopm;
            smc_pmctrl_lpwui;
            smc_stopctrl_pstopo;
            smc_stopctrl_porpo;
            smc_stopctrl_ram2po;
            smc_stopctrl_lpopo;
            smc_stopctrl_llsm;
            smc_stopctrl_vllsm;
            smc_stopctrl_vllsm_llsm
            " >
      <variableTemplate codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo"
         variables="%(r)"
         linePadding="xxx" >
      <![CDATA[
         \t   /**
         \t    * Constructor for %description
         \t    *
         \t    * @tparam   Types
         \t    * @param    rest
         \t    *
         %paramDescription
         \t    */
         \t   template <typename... Types>
         \t   constexpr Init(%params, Types... rest) : Init(rest...) {
         \t
         \t      %registerName = (%registerName&~%mask) | %paramExpression;
         \t   }
         \t\n
      ]]>
      </variableTemplate>
   </for>

<!--   Default Initialisation value -->

   <variableTemplate key="/$(_BASENAME)/DefaultInitValue" where="all" codeGenCondition="enablePeripheralSupport"
      separator=","
      terminator=","
      variables="
            smc_pmprot_ahsrun,
            smc_pmprot_avlp,
            smc_pmprot_alls,
            smc_pmprot_avlls,
            smc_pmctrl_lpwui,
            smc_pmctrl_stopm,
            smc_stopctrl_pstopo,
            smc_stopctrl_porpo,
            smc_stopctrl_llsm,
            smc_stopctrl_vllsm,
            smc_vllsctrl_pstopo,
            smc_vllsctrl_porpo,
            smc_stopctrl_ram2po,
            smc_stopctrl_lpopo,
            smc_vllsctrl_llsm,
            smc_vllsctrl_vllsm
         "
   ><![CDATA[
      \t/**
      \t * Default initialisation value for $(_Class)
      \t * This value is created from Configure.usbdmProject settings
      \t */
      \tstatic constexpr Init DefaultInitValue = {%initExpression
      \t};
      \t\n
   ]]></variableTemplate>

<!--   Configure methods -->

   <template key="/$(_BASENAME)/InitMethod" discardRepeats="true" codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo" >
   <![CDATA[
      \t/**
      \t * Configure with default settings.
      \t * Configuration determined from Configure.usbdmProject
      \t */
      \tstatic inline void defaultConfigure() {
      \t
      \t   // Update settings
      \t   DefaultInitValue.initialise();
      \t}
      \t\n
   ]]></template>
   <template  codeGenCondition="/$(_STRUCTNAME)/generateSharedInfo">
   <![CDATA[
      \t}; // class $(_Structname)/Init
      \t\n
   ]]>
   </template>

   <!-- ************* Common ****************** -->

   <template key="/$(_BASENAME)/declarations" codeGenCondition="enablePeripheralSupport" >
   <![CDATA[
      \t/**
      \t * Class representing $(_NAME)
      \t */
      \tclass $(_Class) : public $(_Baseclass)Base {};
      \t\n
   ]]>
   </template>

   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator" >
   </validate>

   <projectActionList id="smc_files" >
      <copy source="Project_Headers/smc.h"                  target="Project_Headers/smc.h"                  overwrite="true" derived="true" />
      <copy source="Project_Headers/KinetisPowerModes.png"  target="Project_Headers/KinetisPowerModes.png"  overwrite="true" derived="true" macroReplace="false" />
      <copy source="Project_Headers/PowerModes.png"         target="Project_Headers/PowerModes.png"         overwrite="true" derived="true" macroReplace="false" />
      <copy source="Snippets/vlpr-run-hsrun-example.cpp"    target="Snippets/vlpr-run-hsrun-example.cpp"    overwrite="true" derived="true" />
   </projectActionList>

   <!-- ************* Startup ****************** -->

   <template key="/SYSTEM/Includes" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
      <![CDATA[#include "$(_basename).h"\n
   ]]></template>

   <template key="/SYSTEM/Startup" condition="configurePeripheralInStartUp" codeGenCondition="configurePeripheralInStartUp" >
   <![CDATA[
      \t/*  Initialise $(_Class) */
      \tUSBDM::$(_Class)::defaultConfigure();\n
   ]]></template>


</fragment>

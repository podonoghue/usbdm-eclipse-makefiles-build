<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE peripheralPage SYSTEM "_menu.dtd" >
<!-- gpio_def.xml -->

<peripheralPage xmlns:xi="http://www.w3.org/2001/XInclude" name="_instance" description="General Purpose Input/Output">

   <irqOption name="irqHandlingMethod"  
      description="Peripheral interrupt handler"
      toolTip="This selection allow the interrupt handler for this peripheral to be installed using several different methods"
      pattern=".*PORT%i.*" 
      classHandler="%c%i::irqHandler" />
      
   <choiceOption key="irqLevel"
      description="Default IRQ level for this peripheral"
      toolTip="Sets the default priority level used to configure the NVIC">
      <choice name="VeryHigh"      value="NvicPriority_VeryHigh" />
      <choice name="High"          value="NvicPriority_High" />
      <choice name="MidHigh"       value="NvicPriority_MidHigh" />
      <choice name="Normal"        value="NvicPriority_Normal" isDefault="true"/>
      <choice name="Midlow"        value="NvicPriority_Midlow" />
      <choice name="Low"           value="NvicPriority_Low" />
      <choice name="VeryLow"       value="NvicPriority_VeryLow" />
   </choiceOption>

   <template namespace="usbdm"><![CDATA[
      /* gpio_def.xml */
      
      #if defined(PCC_PCC_PORT$(_instance)_CGC_MASK)
      \t/** Port information for PORT$(_instance) */
      \tconstexpr PortInfo  __attribute__((unused)) Port$(_instance)Info {PORT$(_instance)_BasePtr, static_cast<uint32_t>(PCC_BasePtr+offsetof(PCC_Type, PCC_PORT$(_instance))), PORT$(_instance)_IRQn, GPIO$(_instance)_BasePtr, $(?irqHandlingMethod:$(irqLevel):NvicPriority_NotInstalled)};
      #elif defined(SIM_SCGC5_PORT$(_instance)_MASK)
      #ifndef PORT$(_instance)_IRQS
      \t/** Port information for PORT$(_instance) */
      \tconstexpr PortInfo  __attribute__((unused)) Port$(_instance)Info {PORT$(_instance)_BasePtr, SIM_SCGC5_PORT$(_instance)_MASK, IRQn_None, GPIO$(_instance)_BasePtr, $(?irqHandlingMethod:$(irqLevel):NvicPriority_NotInstalled)};
      #else
      \tconstexpr IRQn_Type PORT$(_instance)_IRQS_AR[] = PORT$(_instance)_IRQS;
      \t/** Port information for PORT$(_instance) */
      \tconstexpr PortInfo  __attribute__((unused)) Port$(_instance)Info {PORT$(_instance)_BasePtr, SIM_SCGC5_PORT$(_instance)_MASK, PORT$(_instance)_IRQS_AR[0], GPIO$(_instance)_BasePtr, $(?irqHandlingMethod:$(irqLevel):NvicPriority_NotInstalled)};
      #endif
      #endif\n\n
   ]]></template>
      
   <validate
      class="net.sourceforge.usbdm.deviceEditor.validators.PeripheralValidator">
   </validate>

   <projectActionList id = "gpio_files" >
      <copy source="Snippets/digital-rotary-encoder-example.cpp" target="Snippets/digital-rotary-encoder-example.cpp" overwrite="true" derived="true" />
      <copy source="Snippets/digital-interrupt-example.cpp"      target="Snippets/digital-interrupt-example.cpp"      overwrite="true" derived="true" />
      <copy source="Snippets/digital-example1.cpp"               target="Snippets/digital-example1.cpp"               overwrite="true" derived="true" />
      <copy source="Snippets/digital-example2.cpp"               target="Snippets/digital-example2.cpp"               overwrite="true" derived="true" />
      <copy source="Snippets/sht10.h"                            target="Snippets/sht10.h"                            overwrite="true" derived="true" />
      <copy source="Snippets/sht10-example.cpp"                  target="Snippets/sht10-example.cpp"                  overwrite="true" derived="true" />
   </projectActionList>

   <!--
   <choiceOption key="port_pcr_irqc" 
         description="Interrupt Configuration"
         toolTip="The pin interrupt configuration is valid in all digital pin muxing modes" >
      <choice value="0" name="Interrupt/DMA request disabled" />
      <choice value="1" name="DMA request on rising edge" />
      <choice value="2" name="DMA request on falling edge" />
      <choice value="3" name="DMA request on either edge" />
      <choice value="8" name="Interrupt when logic zero" />
      <choice value="9" name="Interrupt on rising edge" />
      <choice value="10" name="Interrupt on falling edge" />
      <choice value="11" name="Interrupt on either edge" />
      <choice value="12" name="Interrupt when logic one" />
   </choiceOption>

   <binaryOption name="port_pcr_lk" 
      description="Lock Register"
      toolTip="Locks Pin Control Register bits [15:0]">
      <choice value="0" name="Not locked" />
      <choice value="1" name="Locked" />
   </binaryOption>

   <binaryOption name="port_pcr_dse" 
      description="Drive Strength Enable"
      toolTip="Drive strength configuration when in digital pin muxing modes\n
         with the pin configured as an output">
      <choice value="0" name="Low drive strength" />
      <choice value="1" name="High drive strength" />
   </binaryOption>

   <binaryOption name="port_pcr_ode" 
      description="Open Drain Enable"
      toolTip="Open drain configuration when in digital pin muxing modes\n
         with the pin configured as an output">
      <choice value="0" name="Push-pull" />
      <choice value="1" name="Open drain" />
   </binaryOption>

   <binaryOption name="port_pcr_pfe" 
      description="Passive Filter Enable"
      toolTip="Filter configuration when in digital pin muxing modes\n
         with the pin configured as an input\n
         A low pass filter of 10 MHz-30 MHz is enabled on the digital input path">
      <choice value="0" name="Disabled" />
      <choice value="1" name="Enabled" />
   </binaryOption>

   <binaryOption name="port_pcr_sre" 
      description="Slew Rate Enable"
      toolTip="Slew rate configuration when in digital pin muxing modes\n
         with the pin configured as an output">
      <choice value="0" name="Fast slew" />
      <choice value="1" name="Slow slew" />
   </binaryOption>

   <choiceOption key="port_pcr_pull_mode" 
      description="Pull Up/Down Enable"
      toolTip="Pull configuration when in digital pin muxing modes\n
         with the pin configured as an input">
      <choice value="0" name="Not enabled" />
      <choice value="1" name="Not enabled" />
      <choice value="2" name="Pull-down enabled" />
      <choice value="3" name="Pull-up enabled" />
   </choiceOption>

   <template><![CDATA[
      \t//! Interrupt Configuration
      \tstatic constexpr uint32_t port_pcr = 
      \t   PORT_PCR_IRQC($(port_pcr_irqc)) |  // Interrupt Configuration
      \t   PORT_PCR_LK($(port_pcr_lk)) |    // Lock Register
      \t   PORT_PCR_DSE($(port_pcr_dse)) |   // Drive Strength Enable
      \t   PORT_PCR_ODE($(port_pcr_ode)) |   // Open Drain Enable
      \t   PORT_PCR_PFE($(port_pcr_pfe)) |   // Passive Filter Enable
      \t   PORT_PCR_SRE($(port_pcr_sre)) |   // Slew Rate Enable
      \t   PORT_PCR_PE($(port_pcr_pull_mode)>>1) | // Pull Enable
      \t   PORT_PCR_PS($(port_pcr_pull_mode));     // Pull direction\n\n
   ]]></template>
   -->
   
   <template key="/GPIO/declarations" namespace="all"  ><![CDATA[
   \t/**
   \t * @brief Convenience template for $(_class). See @ref Gpio_T
   \t *
   \t * <b>Usage</b>
   \t * @code
   \t * using namespace USBDM;
   \t *
   \t * // Instantiate for bit 3 of $(_class)
   \t * using $(_class)3 = $(_class)<3, ActiveHigh>;
   \t *
   \t * // Set as digital output
   \t * $(_class)3::setOutput();
   \t *
   \t * // Set pin high
   \t * $(_class)3::set();
   \t *
   \t * // Set pin low
   \t * $(_class)3::clear();
   \t *
   \t * // Toggle pin
   \t * $(_class)3::toggle();
   \t *
   \t * // Set pin to boolean value
   \t * $(_class)3::write(true);
   \t *
   \t * // Set pin to boolean value
   \t * $(_class)3::write(false);
   \t *
   \t * // Set as digital input
   \t * $(_class)3::setInput();
   \t *
   \t * // Read pin as boolean value
   \t * bool x = $(_class)3::read();
   \t * @endcode
   \t *
   \t * @tparam bitNum        Bit number in the port
   \t * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
   \t */
   \ttemplate<unsigned bitNum, Polarity polarity=ActiveHigh> class $(_class) :
   \t      public Gpio_T<Port$(_instance)Info.clockInfo, Port$(_instance)Info.portAddress, Port$(_instance)Info.irqNum, Port$(_instance)Info.gpioAddress, GPIO_DEFAULT_PCR, Port$(_instance)Info.irqLevel, bitNum, polarity> {};
   \ttypedef PcrBase_T<Port$(_instance)Info.portAddress, Port$(_instance)Info.irqNum, Port$(_instance)Info.irqLevel> Port$(_instance);

   \t/**
   \t * @brief Convenience template for $(_class) fields. See @ref GpioField_T
   \t *
   \t * <b>Usage</b>
   \t * @code
   \t * using namespace USBDM;
   \t *
   \t * // Instantiate for bit 6 down to 3 of $(_class)
   \t * using $(_class)6_3 = $(_class)Field<6,3>;
   \t *
   \t * // Set as digital output
   \t * $(_class)6_3::setOutput();
   \t *
   \t * // Write value to field
   \t * $(_class)6_3::write(0x53);
   \t *
   \t * // Clear all of field
   \t * $(_class)6_3::bitClear();
   \t *
   \t * // Clear lower two bits of field
   \t * $(_class)6_3::bitClear(0x3);
   \t *
   \t * // Set lower two bits of field
   \t * $(_class)6_3::bitSet(0x3);
   \t *
   \t * // Set as digital input
   \t * $(_class)6_3::setInput();
   \t *
   \t * // Read pin as int value
   \t * int x = $(_class)6_3::read();
   \t * @endcode
   \t *
   \t * @tparam left          Bit number of leftmost bit in port (inclusive)
   \t * @tparam right         Bit number of rightmost bit in port (inclusive)
   \t * @tparam polarity      Polarity of all pins. Either ActiveHigh, ActiveLow or a bitmask (0=>bit active-high, 1=>bit active-low)
   \t */
   \ttemplate<unsigned left, unsigned right, uint32_t polarity=ActiveHigh>
   \tclass $(_class)Field : public GpioField_T<Port$(_instance)Info.portAddress, Port$(_instance)Info.clockInfo, Port$(_instance)Info.irqNum, Port$(_instance)Info.gpioAddress, GPIO_DEFAULT_PCR, Port$(_instance)Info.irqLevel, left, right, polarity> {};\n\n
   ]]></template>
      
   
   <signals/>
   
</peripheralPage>

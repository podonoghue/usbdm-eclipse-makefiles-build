/******************************************************************************
 * @file tft_ILI9163.cpp (180.ARM_Peripherals/Snippets)
 *
 *  Requires declarations for the following in Configure.usbdmProject
 *
 *  TftCs       TFT CSX as SPI Peripheral select e.g. PCS0 (D7)
 *  TftDc       TFT D/CX as SPI Peripheral select e.g. PCS2 (A3)
 *  TftResetPin TFT Reset pin as GPIO e.g. GpioB.1 (A4)
 *
 *  Fixed SPI specific connections
 *  SDA         SOUT (D11)
 *  ---         SIN  (D12)
 *  SCL         SCK  (D13)
 *
 *  Power
 *  GND
 *  VCC
 ******************************************************************************/
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "tft_ILI9163.h"
#include "hardware.h"

using namespace USBDM;

///**
// * Converts a uint16_t into little-endian std::array<uint8_t, 2>
// *
// * @param value  Value to convert
// *
// * @return std::array containing the two bytes
// */
//static constexpr std::array<uint8_t, 2>get2Bytes(uint16_t value) {
//   return {uint8_t(value), uint8_t(value>>8)};
//}
//

///**
// * Converts two uint16_t into big-endian std::array<uint8_t, 4>
// *
// * @param value1  1st value to convert
// * @param value2  2nd value to convert
// *
// * @return std::array containing the four bytes
// */
//static constexpr std::array<uint8_t, 3>getColourAsBytes(Colour colour) {
//   return {(uint8_t)(colour>>(11-3)&0b1111'1000), (uint8_t)(colour>>(5-2)&0b1111'1100), (uint8_t)(colour<<(8-5)&0b1111'1000), };
//}

/**
 * Converts two uint16_t into big-endian std::array<uint8_t, 4>
 *
 * @param value1  1st value to convert
 * @param value2  2nd value to convert
 *
 * @return std::array containing the four bytes
 */
static constexpr std::array<uint8_t, 4>get4Bytes(uint16_t value1, uint16_t value2) {
   return {uint8_t(value1>>8), uint8_t(value1), uint8_t(value2>>8), uint8_t(value2)};
}

/**
 * Force hardware reset of module
 */
void TFT_ILI9163::hardwareReset() {

   TftResetPin::high();
   waitMS(5);
   TftResetPin::low();
   waitMS(20);
   TftResetPin::high();
   waitMS(150);
}

/**
 * Send a command to display
 *
 * @param Command  Command value
 */
void TFT_ILI9163::sendCommand(Command Command) {

   spi.startTransaction(commandConfiguration);
   spi.txRxFinal(Command);
   spi.endTransaction();
}

/**
 * Send a command followed by a data byte to display
 *
 * @param Command Command byte
 * @param data       Data byte
 */
void TFT_ILI9163::sendCommand(Command Command, const uint8_t data) {

   sendCommand(Command);
   sendData(data);
}

/**
 * Send a command followed by an array of data to display
 *
 * @param Command Command byte
 * @param size       Size of data
 * @param data       Data array
 */
void TFT_ILI9163::sendCommand(Command Command, unsigned size, const uint8_t *data) {

   sendCommand(Command);
   sendData(size, data);
}

/**
 * Send a command followed by an array of data to display
 *
 * @tparam N   Size of array (inferred)
 *
 * @param Command Command byte
 * @param data       Data array
 */
template<size_t N>
void TFT_ILI9163::sendCommand(Command Command, const uint8_t (&data)[N]) {

   sendCommand(Command);
   sendData(N, data);
}

/**
 * Send a command followed by an std::array of data to display
 *
 * @tparam N   Size of array (inferred)
 *
 * @param Command Command byte
 * @param data       Data array
 */
template<size_t N>
void TFT_ILI9163::sendCommand(Command Command, const std::array<uint8_t, N>&data) {

   sendCommand(Command);
   sendData(N, data.data());
}

/**
 * Send a data value to display
 *
 * @param data Data value to send
 */
void TFT_ILI9163::sendData(uint8_t data) {

   spi.startTransaction(dataConfiguration);
   spi.txRxFinal(data);
   spi.endTransaction();
}

/**
 * Send an array of data to display
 *
 * @param length  Length of data array to send (in bytes)
 * @param data    Data array
 */
void TFT_ILI9163::sendData(unsigned length, const uint8_t *data) {

   spi.startTransaction(dataConfiguration);
   spi.tx(length, data, true);
   spi.endTransaction();
}

/**
 * Send an array of data to display
 *
 * @tparam N   Size of data array (inferred)
 *
 * @param data Data array
 */
template<size_t N>
void TFT_ILI9163::sendData(const uint8_t (&data)[N]) {

   sendData(N, data);
}

static constexpr uint8_t SENTINEL  = 0xFF;
static constexpr uint8_t OP_MASK   = 0xC0;
static constexpr uint8_t DELAY     = 0xC0;
static constexpr uint8_t HW_RESET  = 0x80;
//static constexpr uint8_t BUSY_WAIT = 0x40;

void TFT_ILI9163::sendSequence(const uint8_t sequence[]) {

   while(*sequence != SENTINEL) {

      unsigned length   = *sequence++;
      uint8_t operation = (length&OP_MASK);
      length &= ~OP_MASK;

      if (operation==HW_RESET) {
         // Cannot be combined with command
         hardwareReset();
         continue;
      }
      // Do command sequence
      Command command = (Command)*sequence++;
      sendCommand(command, length, sequence);
      sequence += length;

      if (operation==DELAY) {
         // Delay after command: 1 parameter
         waitMS(*sequence++);
      }
      //      if (operation==BUSY_WAIT) {
      //         // Busy-wait after command: no parameters
      //         waitWhileBusy();
      //      }
   }
}

/**
 * Send a pixel colour as 2 bytes
 *
 * @param colour Colour to send
 */
void TFT_ILI9163::sendColour(Colour colour) {

   const uint8_t data[] = {
         //         (uint8_t)(colour>>(11-3)&0b1111'1000),
         //         (uint8_t)(colour>>(5-2)&0b1111'1100),
         //         (uint8_t)(colour<<(8-5)&0b1111'1000),
         (uint8_t) (colour>>8),
         (uint8_t) colour,
   };
   sendData(data);
}

/**
 * Initialise the Display
 */
void TFT_ILI9163::initialise() {

   static const uint8_t initSequence[] = {

         HW_RESET,

         DELAY|0, Command_SoftReset,
         120,                          // 120ms delay

         DELAY|0, Command_ExitSleep,
         120,                          // 120ms delay

         // Set colour mode, 1 arg, no delay
         DELAY|1, Command_SetPixelFormat,
         Format_RBG565,
         10,                           // 10ms delay ?

         // Set Gamma curve, 1 arg.
         1, Command_SetGammaCurve,
         0x04,                        // Gamma Curve 3

         1, Command_GammaSetting_Green,
         0x01, // Gamma adjustment enabled

         // +ve Gamma
         15, Command_PositiveGammaControl,
         0x3F, 0x25, 0x1C, 0x1E, 0x20,
         0x12, 0x2A, 0x90, 0x24, 0x11,
         0x00, 0x00, 0x00, 0x00, 0x00,

         // -ve Gamma
         15, Command_NegativeGammaControl,
         0x20, 0x20, 0x20, 0x20, 0x05,
         0x00, 0x15, 0xA7, 0x3D, 0x18,
         0x25, 0x2A, 0x2B, 0x2B, 0x3A,

         // Frame rate control - normal mode, 2 args: Rate = 200kHz/(LINE+VPC)(DIVC+4) = 64.4 Hz
         DELAY|2,  Command_SetFrameRateNormalMode,
         17,                           // DIVC = Division ratio for internal clocks when Normal mode.
         20,                           // VPC  = Vsync porch for internal clocks when Normal mode
         10,                           // 10 ms delay ?

         // Display inversion ctrl, 1 arg, no delay
         1,  Command_SetDisplayInversionControl,
         0x07,                         // Frame Inversion, Frame Inversion, Frame Inversion

         // Power control 1, 2 args, no delay
         DELAY|2, Command_PowerControl1,
         10,                           // VRH = 4.30
         2,                            // VC  = 2.65
         10,                           // 10 ms delay

         // Power control 2, 1 args, no delay
         1, Command_PowerControl2,     //      AVDD    VCL      VGH     VGL
         0x02,                         // BT = 2xVCI1, -1xVCI1, 5xVCI1, -3xVCI1

         // Vcom control 1, 2 arg, no delay
         DELAY|2, Command_VcomControl1,
         80,                           // VMH = 80 = 4.5
         91,                           // VML = 91 = 4.775
         10,                           // 10 ms delay

         // Vcom offset control, 1 arg, no delay
         DELAY|1, Command_VcomOffsetControl,
         64,                           // VMF = 64 = VMH/VML (no offset)
         10,                           // 10 ms delay

         // Set memory access control
         1, Command_SetMemoryAccessControl,
         ORIENTATION,                  // MY?+MX?+MV?+RGB

         // Main screen turn on, no delay
         DELAY|0, Command_DisplayOn,
         255,                          // 255 ms delay

         SENTINEL,
   };

   sendSequence(initSequence);
}

/**
 * Set window in display RAM
 * Note: X dimensions are rounded down to byte boundaries
 *
 * @param Xstart  X start
 * @param Ystart  Y start
 * @param Xend    X end
 * @param Yend    Y end
 */
void TFT_ILI9163::setWindow(uint16_t Xstart, uint16_t Ystart, uint16_t Xend, uint16_t Yend) {

   static constexpr struct {
      unsigned sx;   ///< Start X
      unsigned ex;   ///< End X
      unsigned sy;   ///< Start Y
      unsigned ey;   ///< End Y
   } offsets[] {
         // sx ex sy ey
         {  2, 2, 1, 1 },  // Normal
         {  1, 1, 2, 2 },  // Mirrored across X=Y axis
         {  2, 2, 1, 1 },  // Mirrored across Y Axis
         {  1, 1, 2, 2 },  // Rotated 270 degrees
         {  2, 2, 3, 3 },  // Mirrored across X Axis
         {  3, 3, 2, 2 },  // Rotated 90 degrees
         {  2, 2, 3, 3 },  // Rotated 180 degrees
         {  3, 3, 2, 2 },  // Mirrored across X=-Y axis
   };
   static constexpr unsigned sx = offsets[ORIENTATION>>5].sx;
   static constexpr unsigned ex = offsets[ORIENTATION>>5].ex;
   static constexpr unsigned sy = offsets[ORIENTATION>>5].sy;
   static constexpr unsigned ey = offsets[ORIENTATION>>5].ey;

   sendCommand(Command_SetColumnAddress, get4Bytes(Xstart+sx, Xend+ex));
   sendCommand(Command_SetRowAddress,    get4Bytes(Ystart+sy, Yend+ey));
}

/**
 * Clear display screen
 */
void TFT_ILI9163::clear() {

   constexpr unsigned MAX_BLOCK = 16;

   static Colour filler[MAX_BLOCK];

   std::fill_n(filler, MAX_BLOCK, Colour(((backgroundColour>>8)&0xFF)|(backgroundColour<<8)));

   setWindow(0, 0, WIDTH+2, HEIGHT+2);
   sendCommand(Command_MemoryWriteStart);

   unsigned remaining = (WIDTH+3)*(HEIGHT+3)*sizeof(Colour);
   while (remaining>0) {
      unsigned size = remaining;
      if (size > sizeof(filler)) {
         size = sizeof(filler);
      }
      sendData(size, (uint8_t*)filler);
      remaining -= size;
   }

   x = 0;
   y = 0;
}

/**
 * Enter sleep mode
 */
void TFT_ILI9163::sleep() {

   sendCommand(Command_EnterSleep);  // Enter sleep
   inHibernation = true;
   waitMS(5);
}

/**
 * Enter sleep mode
 */
void TFT_ILI9163::awaken() {

   sendCommand(Command_ExitSleep);  // Exit sleep
   inHibernation = false;
   waitMS(120);
}

void TFT_ILI9163::drawPixel(unsigned x, unsigned y, Colour colour) {

   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Off screen
      return;
   }
   setWindow(x, y, x+1, y+1);
   sendCommand(Command_MemoryWriteStart);
   sendColour(colour);
}

/**
 * Simple line drawing for physical y0=y1
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param x1   End X
 */
void TFT_ILI9163::drawHorizontalLine(unsigned x0, unsigned y0, unsigned x1) {

   if(x1 > WIDTH-1) {
      // Clip to width
      x1 = WIDTH-1;
   }
   setWindow(x0, y0, x1, y0);

   sendCommand(Command_MemoryWriteStart);
   while (x0++<=x1) {
      sendColour(colour);
   }
}


/**
 * Simple line drawing for physical x0=x1
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param y1   End Y
 */
void TFT_ILI9163::drawVerticalLine(unsigned x0, unsigned y0, unsigned y1) {

   if(y1 > HEIGHT-1) {
      // Clip to height
      y1 = HEIGHT-1;
   }
   setWindow(x0, y0, x0, y1);

   sendCommand(Command_MemoryWriteStart);
   while (y0++<=y1) {
      sendColour(colour);
   }
}

/**
 * Simple line drawing using Bresenham's algorithm
 * Ref : https://en.wikipedia.org/wiki/Bresenham's_line_algorithm
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param x1   End X
 * @param y1   End Y
 */
void TFT_ILI9163::drawLine(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   if (y0==y1) {
      drawHorizontalLine(x0, y0, x1);
   }
   else if (x0==x1) {
      drawVerticalLine(x0, y0, y1);
   }
   else {
      int dx = std::abs((int)x1 - (int)x0);
      int sx = (x0 < x1) ? 1 : -1;
      int dy = -abs((int)y1 - (int)y0);
      int sy = (y0 < y1) ? 1 : -1;
      int error = dx + dy;

      while (true) {
         drawPixel(x0, y0, colour);
         int e2 = 2 * error;
         if (e2 >= dy) {
            if (x0 == x1) {
               break;
            }
            error = error + dy;
            x0 = x0 + sx;
         }
         if (e2 <= dx) {
            if (y0 == y1) {
               break;
            }
            error = error + dx;
            y0 = y0 + sy;
         }
      }
   }
}

/**
 * Draw a filled rectangle
 *
 * @param x0  Top-left X
 * @param y0  Top-left Y
 * @param x1  Bottom-right X
 * @param y1  Bottom-right Y
 */
void TFT_ILI9163::drawRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   for (unsigned y=y0; y<=y1; y++) {
      drawHorizontalLine(x0, y, x1);
   }
}

/**
 * Draw an open rectangle
 *
 * @param x0  Top-left X
 * @param y0  Top-left Y
 * @param x1  Bottom-right X
 * @param y1  Bottom-right Y
 */
void TFT_ILI9163::drawOpenRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   drawHorizontalLine(x0, y0, x1);
   drawHorizontalLine(x0, y1, x1);
   drawVerticalLine(x0, y0+1, y1-1);
   drawVerticalLine(x1, y0+1, y1-1);
}

/**
 * Draw filled circle
 *
 * @param X       Circle centre X
 * @param Y       Circle centre Y
 * @param Radius  Circle radius
 */
void TFT_ILI9163::drawCircle(unsigned X, unsigned Y, unsigned Radius) {

   int16_t f = 1 - Radius;
   int16_t ddF_x = 1;
   int16_t ddF_y = -2 * Radius;
   int16_t x = 0;
   int16_t y = Radius;

   // Solid Circle - Draw the fill line
   drawLine(X - Radius, Y, X + Radius, Y);

   while (x < y)
   {
      if (f >= 0)
      {
         y--;
         ddF_y += 2;
         f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      // Solid Circle - Draw the fill line
      drawLine(X - x, Y + y, X + x, Y + y);
      drawLine(X - x, Y - y, X + x, Y - y);
      drawLine(X - y, Y + x, X + y, Y + x);
      drawLine(X - y, Y - x, X + y, Y - x);
   }
}

/**
 * Draw open circle
 *
 * @param X       Circle centre X
 * @param Y       Circle centre Y
 * @param Radius  Circle radius
 */
void TFT_ILI9163::drawOpenCircle(unsigned X, unsigned Y, unsigned Radius) {

   int16_t f = 1 - Radius;
   int16_t ddF_x = 1;
   int16_t ddF_y = -2 * Radius;
   int16_t x = 0;
   int16_t y = Radius;

   // Hollow Circle - Draw 8 points of symmetry
   drawPixel(X, Y + Radius, colour);
   drawPixel(X, Y - Radius, colour);
   drawPixel(X + Radius, Y, colour);
   drawPixel(X - Radius, Y, colour);

   while (x < y)
   {
      if (f >= 0)
      {
         y--;
         ddF_y += 2;
         f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      // Hollow Circle - Draw 8 points of symmetry
      drawPixel(X + x, Y + y, colour);
      drawPixel(X - x, Y + y, colour);
      drawPixel(X + x, Y - y, colour);
      drawPixel(X - x, Y - y, colour);
      drawPixel(X + y, Y + x, colour);
      drawPixel(X - y, Y + x, colour);
      drawPixel(X + y, Y - x, colour);
      drawPixel(X - y, Y - x, colour);
   }
}

/**
 * Draw an image to display
 *
 * @param img  Image with 16-bit colours
 * @param x    Top-left X
 * @param y    Top-left Y
 * @param w    Width
 * @param h    Height
 */
void TFT_ILI9163::drawImage(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

   // rudimentary clipping (drawChar w/big text requires this)
   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Clipped
      return;
   }
   if((x + w - 1) >= (int)WIDTH)  {
      // Clip on edge
      w = WIDTH  - x;
   }
   if((y + h - 1) >= (int)HEIGHT) {
      // Clip on edge
      h = HEIGHT - y;
   }

   setWindow(x, y, x+w-1, y+h-1);
   sendCommand(Command_MemoryWriteStart);

   uint8_t linebuff[w*3+1];
   unsigned count = 0;

   for (unsigned row=0; row<h; row++) {

      // Process each row to buffer and send
      unsigned pixelCount = 0;

      for (unsigned col=0; col<w; col++) {

         // 2 bytes of image -> 3 byte colour on display
         uint8_t b1 = img[count++];
         uint8_t b2 = img[count++];
         uint16_t colour = b1 << 8 | b2;
         linebuff[pixelCount++] = (colour & 0xF800) >> (11-3);
         linebuff[pixelCount++] = (colour & 0x07E0) >> (5-2);
         linebuff[pixelCount++] = (colour & 0x001F) << (8-3);
      }
      sendData(3*w, linebuff);
   }
}

/**
 * Draw an image to display
 *
 * @param img  Bitmap image 8-pixels/byte
 * @param x    Top-left X
 * @param y    Top-left Y
 * @param w    Width
 * @param h    Height
 */
void TFT_ILI9163::drawBitmap(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

   // rudimentary clipping (drawChar w/big text requires this)
   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Clipped
      return;
   }
   if((x + w - 1) >= (int)WIDTH)  {
      // Clip on edge
      w = WIDTH  - x;
   }
   if((y + h - 1) >= (int)HEIGHT) {
      // Clip on edge
      h = HEIGHT - y;
   }

   setWindow(x, y, x+w-1, y+h-1);
   sendCommand(Command_MemoryWriteStart);

   uint8_t  linebuff[w*2+1];
   unsigned count   = 0;

   for (unsigned row=0; row<h; row++) {

      // Process each row to buffer and send
      unsigned pixcount = 0;
      uint8_t  bitMask  = 0;
      uint8_t  byte;

      for (unsigned col=0; col<w; col++) {
         if (bitMask==0) {
            bitMask = 0b1000'0000;
            byte    = img[count++];
         }
         // 1 bit of image -> 2 byte colour on display
         Colour c = (byte&bitMask)?colour:backgroundColour;
         linebuff[pixcount++] = uint8_t(c >> 8);
         linebuff[pixcount++] = uint8_t(c);
         bitMask >>= 1;
      }
      sendData(2*w, linebuff);
   }
}

/**
 * Write a custom character to the LCD in graphics mode at the current x,y location
 *
 * @param[in] image  Image describing the character
 * @param[in] width  Width of the image
 * @param[in] height Height of character
 *
 * @return Reference to self
 */
TFT_ILI9163 &TFT_ILI9163::putCustomChar(const uint8_t *image, unsigned width, unsigned height) {

   drawBitmap(image, x, y, width, height);
   x += width;
   fontHeight = max(fontHeight, height);

   return *this;
}

/**
 * Writes whitespace to the frame buffer at the current x,y location
 *
 * @param[in] width Width of white space in pixels
 *
 * @return Reference to self
 */
TFT_ILI9163 &TFT_ILI9163::putSpace(int width) {

   static const uint8_t space[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
   while (width>0) {
      int t = 8;
      if (t>width) {
         t = width;
      }
      putCustomChar(space, t, 8);
      width -= t;
   }
   return *this;
}

/**
 * Write a character to the frame buffer at the current x,y location
 *
 * @param[in]  ch - character to write
 */
void TFT_ILI9163::_writeChar(char ch) {

   unsigned width  = font->width;
   unsigned height = font->height;

   if (ch == '\\n') {
      putSpace(width-x);
      x  = 0;
      y += fontHeight;
      fontHeight = 0;
   }
   else {
      if ((x+width)>WIDTH) {
         // Don't display partial characters
         return;
      }
      drawBitmap((*font)[ch], x, y, width, height);
      x += width;
      fontHeight = max(fontHeight, height);
   }
   return;
}


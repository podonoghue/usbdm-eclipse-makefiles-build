/******************************************************************************
 * @file tft_ST7735.h (180.ARM_Peripherals/Snippets)
 *
 *  Requires declarations for the following in Configure.usbdmProject
 *
 *  TftCs       TFT CS as SPI Peripheral select e.g. PCS0 (D7)
 *  TftDc       TFT DC as SPI Peripheral select e.g. PCS2 (A3)
 *  TftResetPin TFT Reset pin as GPIO e.g. GpioB.1 (A4)
 *
 *  Fixed SPI specific connections
 *  SDA         SOUT (D11)
 *  ---         SIN  (D12)
 *  SCL         SCK  (D13)
 *
 *  Power
 *  GND
 *  VCC
 *
 *  Adjust the following as needed in this file:
 *    orientation
 ******************************************************************************/
#ifndef INCLUDE_USBDM_ST7735_H
#define INCLUDE_USBDM_ST7735_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include <memory.h>

#include "hardware.h"
#include "spi.h"
#include "formatted_io.h"
#include "fonts.h"

namespace USBDM {

static constexpr unsigned colourRGB565(uint8_t R, uint8_t G, uint8_t B) {
   return ((R&0b11111)<<11)|((G&0b111111)<<5)|((B&0b11111)<<0);
}

enum Colour : uint16_t {
   BLACK       = colourRGB565(  0,   0,   0),
   NAVY        = colourRGB565(  0,   0, 128),
   DARKGREEN   = colourRGB565(  0, 128,   0),
   DARKCYAN    = colourRGB565(  0, 128, 128),
   MAROON      = colourRGB565(128,   0,   0),
   PURPLE      = colourRGB565(128,   0, 128),
   OLIVE       = colourRGB565(128, 128,   0),
   LIGHTGREY   = colourRGB565(192, 192, 192),
   DARKGREY    = colourRGB565(128, 128, 128),
   BLUE        = colourRGB565(  0,   0, 255),
   GREEN       = colourRGB565(  0, 255,   0),
   CYAN        = colourRGB565(  0, 255, 255),
   RED         = colourRGB565(255,   0,   0),
   MAGENTA     = colourRGB565(255,   0, 255),
   YELLOW      = colourRGB565(255, 255,   0),
   WHITE       = colourRGB565(255, 255, 255),
   ORANGE      = colourRGB565(255, 165,   0),
   GREENYELLOW = colourRGB565(173, 255,  47),
   PINK        = colourRGB565(255, 0,    255),
};

//  Possible values of Display Orientation
enum Orientation : uint8_t {
//                                              +----- MV (row)
//                                              |+---- MX (col)
//                                              ||+--- MY (row-col exchange)
//                                              |||
//                                              vvv
   Orientation_Normal                       = 0b000'0'1000, // RGB + Normal
   Orientation_Mirrored_XequalsY            = 0b001'0'1000, // RGB + Mirrored across X=Y axis
   Orientation_Mirrored_YAxis               = 0b010'0'1000, // RGB + Mirrored across Y Axis
   Orientation_Rotated_270                  = 0b011'0'1000, // RGB + Rotated 270 degrees
   Orientation_Mirrored_XAxis               = 0b100'0'1000, // RGB + Mirrored across X Axis
   Orientation_Rotated_90                   = 0b101'0'1000, // RGB + Rotated 90 degrees
   Orientation_Rotated_180                  = 0b110'0'1000, // RGB + Rotated 180 degrees
   Orientation_Mirrored_XequalsMinusY       = 0b111'0'1000, // RGB + Mirrored across X=-Y axis
};

template<Orientation orientation=Orientation_Normal>
class TFT_ST7735 : public FormattedIO {

   using SELF = TFT_ST7735;

protected:

   // Modify this
   static constexpr Orientation ORIENTATION = orientation;

public:

   static constexpr unsigned WIDTH  = 128;
   static constexpr unsigned HEIGHT = 128;

protected:

   /// TFT commands
   enum Command {
      Command_NOP                            = 0x00,
      Command_SoftReset                      = 0x01,
      Command_ReadDisplayIdentity            = 0x04,
      Command_ReadDisplayStatus              = 0x09,
      Command_GetDisplayPowerMode            = 0x0A,
      Command_GetMemoryAccessControl         = 0x0B,
      Command_GetPixelFormat                 = 0x0C,
      Command_GetImageMode                   = 0x0D,
      Command_GetSignalMode                  = 0x0E,
      Command_GetSelfDiagnostic              = 0x0F,
      Command_EnterSleep                     = 0x10,
      Command_ExitSleep                      = 0x11,
      Command_PartialDisplayModeOn           = 0x12,
      Command_NormalDisplayModeOn            = 0x13,
      Command_DisplayInversionOff            = 0x20,
      Command_DisplayInversionOn             = 0x21,
      Command_AllPixelsOff                   = 0x22,
      Command_AllPixelsOn                    = 0x23,
      Command_DisplayOff                     = 0x28,
      Command_DisplayOn                      = 0x29,
      Command_SetColumnAddress               = 0x2A,
      Command_SetRowAddress                  = 0x2B, // == CommandSetgeAddressSet
      Command_MemoryWriteStart               = 0x2C,
      Command_MemoryReadStart                = 0x2E,
      Command_SetPartialArea                 = 0x30,
      Command_SetScrollArea                  = 0x33,
      Command_SetMemoryAccessControl         = 0x36,
      Command_SetScrollStartAddress          = 0x37,
      Command_IdleModeOff                    = 0x38,
      Command_IdleModeOn                     = 0x39,
      Command_SetPixelFormat                 = 0x3A,
      Command_MemoryWriteContinue            = 0x3C,
      Command_MemoryReadContinue             = 0x3E,
      Command_InterfaceModeControl           = 0xB0,
      Command_SetFrameRateNormalMode         = 0xB1,
      Command_SetFrameRateIdleMode           = 0xB2,
      Command_SetFrameRatePartialMode        = 0xB3,
      Command_SetDisplayInversionControl     = 0xB4,
      Command_BlankingPorchControl           = 0xB5,
      Command_DisplayFunctionSet5            = 0xB6,
      Command_SetEntryMode                   = 0xB7,
      Command_PowerControl1                  = 0xC0,
      Command_PowerControl2                  = 0xC1,
      Command_PowerControl3                  = 0xC2,
      Command_PowerControl4                  = 0xC3,
      Command_PowerControl5                  = 0xC4,
      Command_VcomControl1                   = 0xC5,
      Command_VcomOffsetControl              = 0xC7,
      Command_PositiveGammaControl           = 0xE0,
      Command_NegativeGammaControl           = 0xE1,
      Command_SetImageFunction               = 0xE9,
      Command_AdjustControl3                 = 0xF7,
      Command_AdjustControl6                 = 0xFC,
   };

   // Possible values of pixel data format
   enum McuPixelFormat {
      McuPixelFormat_RBG444                = 0b011,    // Pixel format RGB444 = 12 bpp
      McuPixelFormat_RBG565                = 0b101,    // Pixel format RGB565 = 16 bpp
      McuPixelFormat_RBG666                = 0b110,    // Pixel format RGB666 = 18 bpp
   };

   /* TFT SPI Signals (used for CD and CS during transfers) */
   static constexpr SpiPeripheralSelect SpiPeripheralSelect_TftCs = USBDM::SpiPeripheralSelect_TftCs; // CS Active-low
   static constexpr SpiPeripheralSelect SpiPeripheralSelect_TftDc = USBDM::SpiPeripheralSelect_TftDc; // Data=high, Command=Low

   /* TFT GPIOs */
   using TftResetPin = USBDM::TftResetPin;    // Low=active
//   using TftBusyPin  = USBDM::TftBusyPin;     // High=busy

   // Communication settings
   static constexpr Spi0::SerialInit serialInitValue {
      25_MHz ,               // (speed[0])                 Speed of interface
      SpiMode_0 ,            // (spi_ctar_mode[0])         Mode - Mode 0: CPOL=0, CPHA=0
      SpiFrameSize_8_bits ,  // (spi_ctar_fmsz[0])         SPI Frame sizes - 8 bits/transfer
      SpiBitOrder_MsbFirst,  // (spi_ctar_lsbfe[0])        Transmission order - MSB sent first
   };

   /** SPI interface used to communicate with LCD */
   USBDM::Spi &spi;

   // SPI Configuration to send data bytes
   const Spi::SpiCalculatedConfiguration dataConfiguration;

   // SPI Configuration to send command bytes
   const Spi::SpiCalculatedConfiguration commandConfiguration;

   bool inHibernation = true;

   // X position
   unsigned x = 0;

   // Y position
   unsigned y = 0;

   // Graphic mode font height (for newline)
   unsigned fontHeight = 0;

   // Current font
   const USBDM::Font *font;

   // Current foreground colour
   Colour colour = Colour::WHITE;

   // Current background colour
   Colour backgroundColour = Colour::BLACK;

public:

   /**
    * Set colour for painting
    *
    * @param colour  Colour to use
    *
    * @return Reference to self
    */
   SELF &setColour(Colour colour) {

      this->colour = colour;
      return *this;
   }

   /**
    * Get colour currently set for painting
    *
    * @return Colour currently being used
    */
   Colour &getColour() {

      return this->colour;
   }

   /**
    * Set colour for painting background
    *
    * @param colour  Colour to use
    *
    * @return Reference to self
    */
   SELF &setBackgroundColour(Colour colour) {

      this->backgroundColour = colour;
      return *this;
   }

   /**
    * Get colour currently set for painting background
    *
    * @return Colour currently being used
    */
   Colour &getBackgroundColour() {

      return this->backgroundColour;
   }

   /**
    * Set font to use for subsequent operations
    *
    * @param [in] font
    *
    * @return Reference to self
    */
   SELF &setFont(const USBDM::Font &font) {

      this->font = &font;
      return *this;
   }

   /**
    * Get current font
    *
    * @return The current font
    */
   const Font *getFont() {

      return font;
   }

   /**
    * Move current location
    *
    * @param x
    * @param y
    *
    * @return Reference to self
    */
   SELF &moveXY(unsigned x, unsigned y) {

      this->x = x;
      this->y = y;

      return *this;
   }

   /**
    * Move relative to current location
    *
    * @param x X offset
    * @param y Y offset
    *
    * @return Reference to self
    */
   SELF &moveXYRelative(unsigned x, unsigned y) {

      this->x += x;
      this->y += y;

      return *this;
   }

   /**
    * Get current X coordinate
    *
    * @return X co-ordinate
    */
   unsigned getX() {

      return x;
   }

   /**
    * Get current Y coordinate
    *
    * @return Y co-ordinate
    */
   unsigned getY() {

      return y;
   }

   /**
    *  Flush output data
    */
   virtual SELF &flushOutput() override {
      return *this;
   }

   /**
    * Create TFT interface
    *
    * @param [in] spi  SPI to use
    * @param [in] font Initial font to use
    */
   TFT_ST7735(Spi &spi, const Font *font=&font8x8) :
      spi(spi),
      dataConfiguration(spi.calculateConfiguration(serialInitValue, SpiPeripheralSelect_TftCs, SpiPeripheralSelectMode_Transaction)),
      commandConfiguration(spi.calculateConfiguration(serialInitValue, SpiPeripheralSelect_TftCs|SpiPeripheralSelect_TftDc, SpiPeripheralSelectMode_Transaction)),
      font(font) {

      // Set CS and CD polarities
      spi.setPcsPolarityActiveLow(SpiPeripheralSelect_TftDc|SpiPeripheralSelect_TftCs);

      // GPIOs
      static constexpr PcrInit pcrValue {
         PinPull_Up,
         PinAction_None,
         PinDriveStrength_Low,
         PinDriveMode_PushPull,
         PinFilter_None,
      };
      TftResetPin::setOutput(pcrValue);
//      TftBusyPin::setInput(pcrValue);
      TftResetPin::high();

      initialise();
   }

   /**
    * Delete TFT interface
    */
   virtual ~TFT_ST7735() {

      sleep();

      TftResetPin::low();
   }

protected:

   /**
    * Converts two uint16_t into big-endian std::array<uint8_t, 4>
    *
    * @param value1  1st value to convert
    * @param value2  2nd value to convert
    *
    * @return std::array containing the four bytes
    */
   static constexpr std::array<uint8_t, 4>get4Bytes(uint16_t value1, uint16_t value2) {
      return {uint8_t(value1>>8), uint8_t(value1), uint8_t(value2>>8), uint8_t(value2)};
   }

   /**
    * Force hardware reset of module
    */
   void hardwareReset() {

      TftResetPin::high();
      waitMS(5);
      TftResetPin::low();
      waitMS(20);
      TftResetPin::high();
      waitMS(150);
   }

   /**
    * Send a command to display
    *
    * @param Command  Command value
    */
   void sendCommand(Command Command) {

      spi.startTransaction(commandConfiguration);
      spi.txRxFinal(Command);
      spi.endTransaction();
   }

   /**
    * Send a command followed by a data byte to display
    *
    * @param Command Command byte
    * @param data       Data byte
    */
   void sendCommand(Command Command, const uint8_t data) {

      sendCommand(Command);
      sendData(data);
   }

   /**
    * Send a command followed by an array of data to display
    *
    * @param Command Command byte
    * @param size       Size of data
    * @param data       Data array
    */
   void sendCommand(Command Command, unsigned size, const uint8_t *data) {

      sendCommand(Command);
      sendData(size, data);
   }

   /**
    * Send a command followed by an array of data to display
    *
    * @tparam N   Size of array (inferred)
    *
    * @param Command Command byte
    * @param data       Data array
    */
   template<size_t N>
   void sendCommand(Command Command, const uint8_t (&data)[N]) {

      sendCommand(Command);
      sendData(N, data);
   }

   /**
    * Send a command followed by an std::array of data to display
    *
    * @tparam N   Size of array (inferred)
    *
    * @param Command Command byte
    * @param data       Data array
    */
   template<size_t N>
   void sendCommand(Command Command, const std::array<uint8_t, N>&data) {

      sendCommand(Command);
      sendData(N, data.data());
   }

   /**
    * Send a data value to display
    *
    * @param data Data value to send
    */
   void sendData(uint8_t data) {

      spi.startTransaction(dataConfiguration);
      spi.txRxFinal(data);
      spi.endTransaction();
   }

   /**
    * Send an array of data to display
    *
    * @param length  Length of data array to send (in bytes)
    * @param data    Data array
    */
   void sendData(unsigned length, const uint8_t *data) {

      spi.startTransaction(dataConfiguration);
      spi.tx(length, data, true);
      spi.endTransaction();
   }

   /**
    * Send an array of data to display
    *
    * @tparam N   Size of data array (inferred)
    *
    * @param data Data array
    */
   template<size_t N>
   void sendData(const uint8_t (&data)[N]) {

      sendData(N, data);
   }

   static constexpr uint8_t SENTINEL  = 0xFF;
   static constexpr uint8_t OP_MASK   = 0xC0;
   static constexpr uint8_t DELAY     = 0xC0;
   static constexpr uint8_t HW_RESET  = 0x80;
//   static constexpr uint8_t BUSY_WAIT = 0x40;

   void sendSequence(const uint8_t sequence[]) {

      while(*sequence != SENTINEL) {

         unsigned length   = *sequence++;
         uint8_t operation = (length&OP_MASK);
         length &= ~OP_MASK;

         if (operation==HW_RESET) {
            // Cannot be combined with command
            hardwareReset();
            continue;
         }
         // Do command sequence
         Command command = (Command)*sequence++;
         sendCommand(command, length, sequence);
         sequence += length;

         if (operation==DELAY) {
            // Delay after command: 1 parameter
            waitMS(*sequence++);
         }
//         if (operation==BUSY_WAIT) {
//            // Busy-wait after command: no parameters
//            waitWhileBusy();
//         }
      }
   }

   /**
    * Send a pixel colour as 2 bytes
    *
    * @param colour Colour to send
    */
   void sendColour(Colour colour) {

      const uint8_t data[] = {
            //         (uint8_t)(colour>>(11-3)&0b1111'1000),
            //         (uint8_t)(colour>>(5-2)&0b1111'1100),
            //         (uint8_t)(colour<<(8-5)&0b1111'1000),
            (uint8_t) (colour>>8),
            (uint8_t) colour,
      };
      sendData(data);
   }

   /**
    * Initialise the Display
    */
   void initialise() {

   //   enum DisplaySize {
   //      DisplaySize_132x162, // GM=00
   //      DisplaySize_132x132, // GM=01
   //      DisplaySize_128x160, // GM=11
   //   };
   //   static constexpr DisplaySize DISPLAY_SIZE = DisplaySize_132x162;
   //
   //   // Divider
   //   static constexpr uint8_t FrameRateControl_RTNA[] {
   //      5, 58, 58,
   //   };
   //
   //   // Front porch
   //   static constexpr uint8_t FrameRateControl_FPA[] {
   //      8, 59, 59,
   //   };
   //
   //   // Back porch
   //   static constexpr uint8_t FrameRateControl_BPA[] {
   //      5, 60, 60,
   //   };

      static constexpr uint8_t initSequence[] = {
            // Based on https://github.com/adafruit/Adafruit-ST7735-Library/blob/master/Adafruit_ST7735.cpp
            HW_RESET,

            DELAY|0, Command_SoftReset,
            120,                          // 120ms delay

            DELAY|0, Command_ExitSleep,
            120,                          // 120ms delay

            // Set colour mode, 1 arg, no delay
            DELAY|1, Command_SetPixelFormat,
            McuPixelFormat_RBG565,
            10,                           // 10ms delay ?

            /* Gamma Adjustments (pos. polarity), 16 args, 16 args, no delay */
            16, Command_PositiveGammaControl,
            0x09, 0x16, 0x09, 0x20,       //     Provides more accurate colours
            0x21, 0x1B, 0x13, 0x19,
            0x17, 0x15, 0x1E, 0x2B,
            0x04, 0x05, 0x02, 0x0E,

            /* Gamma Adjustments (neg. polarity), 16 args, no delay */
            DELAY|16, Command_NegativeGammaControl,
            0x0B, 0x14, 0x08, 0x1E,       //     Provides more accurate colours
            0x22, 0x1D, 0x18, 0x1E,
            0x1B, 0x1A, 0x24, 0x2B,
            0x06, 0x06, 0x02, 0x0F,
            10,                           //     10 ms delay

            /* Frame rate control - normal mode, 3 args:Rate = fosc/(1x2+40) * (LINE+2C+2D) */
            DELAY|3,  Command_SetFrameRateNormalMode,
            0, //FrameRateControl_RTNA[DISPLAY_SIZE],   //  0?   fastest refresh
            6, //FrameRateControl_FPA[DISPLAY_SIZE],    //  6? lines front porch
            3, //FrameRateControl_BPA[DISPLAY_SIZE],    //  3? lines back porch
            10,                           //     10 ms delay ?

            1, Command_SetMemoryAccessControl,
            ORIENTATION,                  //     Depends on orientation

            2, Command_DisplayFunctionSet5,
            0x15,                         //  1  clk cycle non-overlap, 2 cycle gate rise, 3 cycle osc equalise
            0x02,                         //     Fix on VTL

            /* Display inversion ctrl, 1 arg, no delay */
            1,  Command_SetDisplayInversionControl,
            0x00,                         // Line inversion

            /* Power control, 3 args, no delay */
            DELAY|2, Command_PowerControl1,
            0x02,                         //     GVDD = 4.7V
            0x70,                         //     1.0uA
            10,                           //     10 ms delay

            /* Power control, 1 args, no delay */
            1, Command_PowerControl2,
            0x05,                         //     VGH = 14.7V, VGL = -7.35V

            /* Power control, 2 args, no delay */
            DELAY|2, Command_PowerControl3,
            0x01,                         //     Opamp current small
            0x02,                         //     Boost frequency
            10,                           //     10 ms delay

            /* Power control, 1 arg, no delay */
            DELAY|2, Command_VcomControl1,
            0x3C,                         //     VCOMH = 4V
            0x38,                         //     VCOML = -1.1V
            10,                           //     10 ms delay

            /* Power control, 2 args, no delay */
            2, Command_AdjustControl6,
            0x11,
            0x15,

            /* Normal display on, no args, no delay */
            DELAY|0, Command_NormalDisplayModeOn,
            10,                           //     10 ms delay

            // Main screen turn on, no delay
            DELAY|0, Command_DisplayOn,
            255,                          // 255 ms delay

            DELAY|0, Command_AllPixelsOff,
            255,

            DELAY|0, Command_AllPixelsOn,
            255,

            SENTINEL,
      };

      sendSequence(initSequence);
   }

   /**
    * Set window in display RAM
    * Note: X dimensions are rounded down to byte boundaries
    *
    * @param Xstart  X start
    * @param Ystart  Y start
    * @param Xend    X end
    * @param Yend    Y end
    */
   void setWindow(uint16_t Xstart, uint16_t Ystart, uint16_t Xend, uint16_t Yend) {

   //   static constexpr struct {
   //      unsigned sx;   ///< Start X
   //      unsigned ex;   ///< End X
   //      unsigned sy;   ///< Start Y
   //      unsigned ey;   ///< End Y
   //   } offsets[] {
   //         // sx ex sy ey
   //         {  2, 2, 1, 1 },  // Normal
   //         {  1, 1, 2, 2 },  // Mirrored across X=Y axis
   //         {  2, 2, 1, 1 },  // Mirrored across Y Axis
   //         {  1, 1, 2, 2 },  // Rotated 270 degrees
   //         {  2, 2, 3, 3 },  // Mirrored across X Axis
   //         {  3, 3, 2, 2 },  // Rotated 90 degrees
   //         {  2, 2, 3, 3 },  // Rotated 180 degrees
   //         {  3, 3, 2, 2 },  // Mirrored across X=-Y axis
   //   };
      static constexpr unsigned sx = 0; // offsets[ORIENTATION>>5].sx;
      static constexpr unsigned ex = 0; // offsets[ORIENTATION>>5].ex;
      static constexpr unsigned sy = 0; // offsets[ORIENTATION>>5].sy;
      static constexpr unsigned ey = 0; // offsets[ORIENTATION>>5].ey;

      sendCommand(Command_SetColumnAddress, get4Bytes(Xstart+sx, Xend+ex));
      sendCommand(Command_SetRowAddress,    get4Bytes(Ystart+sy, Yend+ey));
   }

public:
   /**
    * Clear display screen
    */
   void clear(unsigned x=0, unsigned y=0, unsigned w=WIDTH, unsigned h=HEIGHT) {

      constexpr unsigned MAX_BLOCK = 16;

      Colour filler[MAX_BLOCK];

      std::fill_n(filler, MAX_BLOCK, Colour(((backgroundColour>>8)&0xFF)|(backgroundColour<<8)));

      setWindow(x,y,w,h);
      sendCommand(Command_MemoryWriteStart);

      unsigned remaining = (w+3)*(h+3)*sizeof(Colour);
      while (remaining>0) {
         unsigned size = remaining;
         if (size > sizeof(filler)) {
            size = sizeof(filler);
         }
         sendData(size, (uint8_t*)filler);
         remaining -= size;
      }
      x = 0;
      y = 0;
   }

   /**
    * Enter sleep mode
    */
   void sleep() {

      sendCommand(Command_EnterSleep);  // Enter sleep
      inHibernation = true;
      waitMS(5);
   }

   /**
    * Enter sleep mode
    */
   void awaken() {

      sendCommand(Command_ExitSleep);  // Exit sleep
      inHibernation = false;
      waitMS(120);
   }

   void drawPixel(unsigned x, unsigned y, Colour colour) {

      if((x >= WIDTH) || (y >= HEIGHT)) {
         // Off screen
         return;
      }
      setWindow(x, y, x+1, y+1);
      sendCommand(Command_MemoryWriteStart);
      sendColour(colour);
   }

   /**
    * Simple line drawing for physical y0=y1
    *
    * @param x0   Start X
    * @param y0   Start Y
    * @param x1   End X
    */
   void drawHorizontalLine(unsigned x0, unsigned y0, unsigned x1) {

      if(x1 > WIDTH-1) {
         // Clip to width
         x1 = WIDTH-1;
      }
      setWindow(x0, y0, x1, y0);

      sendCommand(Command_MemoryWriteStart);
      while (x0++<=x1) {
         sendColour(colour);
      }
   }


   /**
    * Simple line drawing for physical x0=x1
    *
    * @param x0   Start X
    * @param y0   Start Y
    * @param y1   End Y
    */
   void drawVerticalLine(unsigned x0, unsigned y0, unsigned y1) {

      if(y1 > HEIGHT-1) {
         // Clip to height
         y1 = HEIGHT-1;
      }
      setWindow(x0, y0, x0, y1);

      sendCommand(Command_MemoryWriteStart);
      while (y0++<=y1) {
         sendColour(colour);
      }
   }

   /**
    * Simple line drawing using Bresenham's algorithm
    * Ref : https://en.wikipedia.org/wiki/Bresenham's_line_algorithm
    *
    * @param x0   Start X
    * @param y0   Start Y
    * @param x1   End X
    * @param y1   End Y
    */
   void drawLine(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

      if (y0==y1) {
         drawHorizontalLine(x0, y0, x1);
      }
      else if (x0==x1) {
         drawVerticalLine(x0, y0, y1);
      }
      else {
         int dx = std::abs((int)x1 - (int)x0);
         int sx = (x0 < x1) ? 1 : -1;
         int dy = -abs((int)y1 - (int)y0);
         int sy = (y0 < y1) ? 1 : -1;
         int error = dx + dy;

         while (true) {
            drawPixel(x0, y0, colour);
            int e2 = 2 * error;
            if (e2 >= dy) {
               if (x0 == x1) {
                  break;
               }
               error = error + dy;
               x0 = x0 + sx;
            }
            if (e2 <= dx) {
               if (y0 == y1) {
                  break;
               }
               error = error + dx;
               y0 = y0 + sy;
            }
         }
      }
   }

   /**
    * Draw a filled rectangle
    *
    * @param x0  Top-left X
    * @param y0  Top-left Y
    * @param x1  Bottom-right X
    * @param y1  Bottom-right Y
    */
   void drawRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

      for (unsigned y=y0; y<=y1; y++) {
         drawHorizontalLine(x0, y, x1);
      }
   }

   /**
    * Draw an open rectangle
    *
    * @param x0  Top-left X
    * @param y0  Top-left Y
    * @param x1  Bottom-right X
    * @param y1  Bottom-right Y
    */
   void drawOpenRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

      drawHorizontalLine(x0, y0, x1);
      drawHorizontalLine(x0, y1, x1);
      drawVerticalLine(x0, y0+1, y1-1);
      drawVerticalLine(x1, y0+1, y1-1);
   }

   /**
    * Draw filled circle
    *
    * @param X       Circle centre X
    * @param Y       Circle centre Y
    * @param Radius  Circle radius
    */
   void drawCircle(unsigned X, unsigned Y, unsigned Radius) {

      int16_t f = 1 - Radius;
      int16_t ddF_x = 1;
      int16_t ddF_y = -2 * Radius;
      int16_t x = 0;
      int16_t y = Radius;

      // Solid Circle - Draw the fill line
      drawLine(X - Radius, Y, X + Radius, Y);

      while (x < y)
      {
         if (f >= 0)
         {
            y--;
            ddF_y += 2;
            f += ddF_y;
         }
         x++;
         ddF_x += 2;
         f += ddF_x;

         // Solid Circle - Draw the fill line
         drawLine(X - x, Y + y, X + x, Y + y);
         drawLine(X - x, Y - y, X + x, Y - y);
         drawLine(X - y, Y + x, X + y, Y + x);
         drawLine(X - y, Y - x, X + y, Y - x);
      }
   }

   /**
    * Draw open circle
    *
    * @param X       Circle centre X
    * @param Y       Circle centre Y
    * @param Radius  Circle radius
    */
   void drawOpenCircle(unsigned X, unsigned Y, unsigned Radius) {

      int16_t f = 1 - Radius;
      int16_t ddF_x = 1;
      int16_t ddF_y = -2 * Radius;
      int16_t x = 0;
      int16_t y = Radius;

      // Hollow Circle - Draw 8 points of symmetry
      drawPixel(X, Y + Radius, colour);
      drawPixel(X, Y - Radius, colour);
      drawPixel(X + Radius, Y, colour);
      drawPixel(X - Radius, Y, colour);

      while (x < y)
      {
         if (f >= 0)
         {
            y--;
            ddF_y += 2;
            f += ddF_y;
         }
         x++;
         ddF_x += 2;
         f += ddF_x;

         // Hollow Circle - Draw 8 points of symmetry
         drawPixel(X + x, Y + y, colour);
         drawPixel(X - x, Y + y, colour);
         drawPixel(X + x, Y - y, colour);
         drawPixel(X - x, Y - y, colour);
         drawPixel(X + y, Y + x, colour);
         drawPixel(X - y, Y + x, colour);
         drawPixel(X + y, Y - x, colour);
         drawPixel(X - y, Y - x, colour);
      }
   }

   /**
    * Draw an image to display
    *
    * @param img  Image with 16-bit colours
    * @param x    Top-left X
    * @param y    Top-left Y
    * @param w    Width
    * @param h    Height
    */
   void drawImage(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

      // rudimentary clipping (drawChar w/big text requires this)
      if((x >= WIDTH) || (y >= HEIGHT)) {
         // Clipped
         return;
      }
      if((x + w - 1) >= (int)WIDTH)  {
         // Clip on edge
         w = WIDTH  - x;
      }
      if((y + h - 1) >= (int)HEIGHT) {
         // Clip on edge
         h = HEIGHT - y;
      }

      setWindow(x, y, x+w-1, y+h-1);
      sendCommand(Command_MemoryWriteStart);

      uint8_t linebuff[w*3+1];
      unsigned count = 0;

      for (unsigned row=0; row<h; row++) {

         // Process each row to buffer and send
         unsigned pixelCount = 0;

         for (unsigned col=0; col<w; col++) {

            // 2 bytes of image -> 3 byte colour on display
            uint8_t b1 = img[count++];
            uint8_t b2 = img[count++];
            uint16_t colour = b1 << 8 | b2;
            linebuff[pixelCount++] = (colour & 0xF800) >> (11-3);
            linebuff[pixelCount++] = (colour & 0x07E0) >> (5-2);
            linebuff[pixelCount++] = (colour & 0x001F) << (8-3);
         }
         sendData(3*w, linebuff);
      }
   }

   /**
    * Draw an image to display
    *
    * @param img  Bitmap image 8-pixels/byte
    * @param x    Top-left X
    * @param y    Top-left Y
    * @param w    Width
    * @param h    Height
    */
   void drawBitmap(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

      // rudimentary clipping (drawChar w/big text requires this)
      if((x >= WIDTH) || (y >= HEIGHT)) {
         // Clipped
         return;
      }
      if((x + w - 1) >= (int)WIDTH)  {
         // Clip on edge
         w = WIDTH  - x;
      }
      if((y + h - 1) >= (int)HEIGHT) {
         // Clip on edge
         h = HEIGHT - y;
      }

      setWindow(x, y, x+w-1, y+h-1);
      sendCommand(Command_MemoryWriteStart);

      uint8_t  linebuff[w*2+1];
      unsigned count   = 0;

      for (unsigned row=0; row<h; row++) {

         // Process each row to buffer and send
         unsigned pixcount = 0;
         uint8_t  bitMask  = 0;
         uint8_t  byte;

         for (unsigned col=0; col<w; col++) {
            if (bitMask==0) {
               bitMask = 0b1000'0000;
               byte    = img[count++];
            }
            // 1 bit of image -> 2 byte colour on display
            Colour c = (byte&bitMask)?colour:backgroundColour;
            linebuff[pixcount++] = uint8_t(c >> 8);
            linebuff[pixcount++] = uint8_t(c);
            bitMask >>= 1;
         }
         sendData(2*w, linebuff);
      }
   }

   /**
    * Write a custom character to the LCD in graphics mode at the current x,y location
    *
    * @param[in] image  Image describing the character
    * @param[in] width  Width of the image
    * @param[in] height Height of character
    *
    * @return Reference to self
    */
   TFT_ST7735 &putCustomChar(const uint8_t *image, unsigned width, unsigned height) {

      drawBitmap(image, x, y, width, height);
      x += width;
      fontHeight = max(fontHeight, height);

      return *this;
   }

   /**
    * Writes whitespace to the frame buffer at the current x,y location
    *
    * @param[in] width Width of white space in pixels
    *
    * @return Reference to self
    */
   TFT_ST7735 &putSpace(int width) {

      while (width>0) {
         int t = font->width;
         if (t>width) {
            t = width;
         }
         putCustomChar((*font)[' '], t, font->height);
         width -= t;
         if (x>WIDTH) {
            break;
         }
      }
      return *this;
   }

   /**
    * Write a character to the frame buffer at the current x,y location
    *
    * @param[in]  ch - character to write
    */
   void _writeChar(char ch) {

      unsigned width  = font->width;
      unsigned height = font->height;

      if (ch == '\\n') {
         putSpace(width-x);
         x  = 0;
         y += fontHeight;
         fontHeight = 0;
      }
      else {
         if ((x+width)>WIDTH) {
            // Don't display partial characters
            return;
         }
         drawBitmap((*font)[ch], x, y, width, height);
         x += width;
         fontHeight = max(fontHeight, height);
      }
      return;
   }

};

} // end namespace USBDM

#endif // INCLUDE_USBDM_ST7735_H

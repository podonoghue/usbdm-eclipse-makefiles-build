/**
 * @file EPD_1in54_GDEM0154I61.h
 *
 *  Requires declarations for the following in Configure.usbdmProject
 *
 *  EpdCs       [BLUE]    EPD CS as SPI Peripheral select e.g. PCS0 (D7)
 *  EpdDc       [WHITE]   EPD DC as SPI Peripheral select e.g. PCS2 (A3)
 *  EpdResetPin [ORANGE]  EPD Reset pin as GPIO e.g. GpioB.1 (A4)
 *  EpdBusyPin  [VIOLET]  EPD Busy pin as GPIO e.g. GpioB.0 (A5)
 *
 *  Fixed SPI specific connections
 *  SDA         [YELLOW]  SOUT (D11)
 *  ---         ---       SIN  (D12)
 *  SCL         [GREEN]   SCK  (D13)
 *
 *  Power
 *  GND         [BLACK]
 *  VCC         [RED]
 *
 *  Based on example code from https://www.good-display.com/product/535.html
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to  whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS OR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *
 ******************************************************************************/
#ifndef INCLUDE_USBDM_EPD_1IN54_GDEM0154I61
#define INCLUDE_USBDM_EPD_1IN54_GDEM0154I61
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include <memory.h>

#include "hardware.h"
#include "spi.h"
#include "FrameBuffer.h"

namespace USBDM {

/// Refresh modes
enum Refresh : uint8_t {
   Refresh_full,
   Refresh_partial,
};

template <unsigned WIDTH=200, unsigned HEIGHT=200, ScaleMode scale=ScaleMode_1, RotateMode rotate=RotateMode_0, MirrorMode mirror=MirrorMode_None>
class EPD_1in54_GDEM0154I61 : public FrameBuffer<WIDTH, HEIGHT, PixelPacking_8x1xRow, scale, rotate, mirror> {

protected:
   using FB = FrameBuffer<WIDTH, HEIGHT, PixelPacking_8x1xRow, scale, rotate, mirror>;
   using FB::getFrameSize;

   /// EPD commands
   enum EpdCommand {
      EpdCommand_DriverOutput         = 0x01,
      EpdCommand_GateVoltage          = 0x03,
      EpdCommand_SourceDrivingVoltage = 0x04,
      //      EpdCommand_BoosterStartControl  = 0x0C,
      EpdCommand_DeepSleep            = 0x10,
      EpdCommand_DataEntryMode        = 0x11,
      EpdCommand_SoftwareReset        = 0x12,
      //      EpdCommand_HVReadyDetect        = 0x14,
      //      EpdCommand_VCIDetect            = 0x15,
      EpdCommand_TempSensorSelect     = 0x18,
      EpdCommand_TempSensorWrite      = 0x1A,
      //      EpdCommand_ReadTemperature      = 0x1B,
      //      EpdCommand_WriteExtTempChip     = 0x1C,
      EpdCommand_MasterActivation     = 0x20,
      EpdCommand_UpdateControl1       = 0x21,
      EpdCommand_UpdateControl2       = 0x22,
      EpdCommand_WriteRamBlackWhite   = 0x24,
      EpdCommand_WriteRamRedWhite     = 0x26,
      EpdCommand_ReadRam              = 0x27,
      //      EpdCommand_VCOMSense            = 0x28,
      //      EpdCommand_VcomSenseDuration    = 0x29,
      //      EpdCommand_ProgramVcomOtp       = 0x2A,
      //      EpdCommand_WriteVcomControl     = 0x2B,
      EpdCommand_WriteVcomRegister    = 0x2C,
      //      EpdCommand_ReadOtpDisplayOption = 0x2D,
      //      EpdCommand_ReadUserId           = 0x2E,
      //      EpdCommand_ReadStatusBit        = 0x2F,
      //      EpdCommand_ProgramWsOtp         = 0x30,
      //      EpdCommand_LoadWsOtp            = 0x31,
      EpdCommand_WriteLutRegister     = 0x32,
      //      EpdCommand_CrcStatusRead        = 0x35,
      //      EpdCommand_ProgramOtpSelection  = 0x36,
      EpdCommand_WriteDisplayOption   = 0x37,
      //      EpdCommand_WriteUserId          = 0x38,
      //      EpdCommand_OtpProgramMode       = 0x39,
      EpdCommand_BorderWaveForm       = 0x3C,
      EpdCommand_EndOption            = 0x3F,
      EpdCommand_ReadRamOption        = 0x41,
      EpdCommand_SetWindowX           = 0x44,
      EpdCommand_SetWindowY           = 0x45,
      EpdCommand_AutoWriteRedRam      = 0x46,
      EpdCommand_AutoWriteBlackRam    = 0x47,
      EpdCommand_SetRamXAddr          = 0x4E,
      EpdCommand_SetRamYAddr          = 0x4F,
      //      EpdCommand_Nop                  = 0x7F,
   };

   /// EPD sleep modes
   enum DeepSleepMode {
      DeepSleepMode_Normal = 0x00,
      DeepSleepMode_Mode1  = 0x01,
      DeepSleepMode_Mode2  = 0x03,
   };

   /* EPD SPI Signals (used for CD and CS during transfers) */
   static constexpr SpiPeripheralSelect SpiPeripheralSelect_EpdCs = USBDM::SpiPeripheralSelect_EpdCs; // CS Active-low
   static constexpr SpiPeripheralSelect SpiPeripheralSelect_EpdDc = USBDM::SpiPeripheralSelect_EpdDc; // Data=high, Command=Low

   /* EPD GPIOs */
   using EpdResetPin = USBDM::EpdResetPin;    // Low=active
   using EpdBusyPin  = USBDM::EpdBusyPin;     // High=busy

   // Communication settings
   static constexpr Spi0::SerialInit serialInitValue {
      20_MHz ,               // (speed[0])                 Speed of interface
      SpiMode_0 ,            // (spi_ctar_mode[0])         Mode - Mode 0: CPOL=0, CPHA=0
      SpiFrameSize_8_bits ,  // (spi_ctar_fmsz[0])         SPI Frame sizes - 8 bits/transfer
      SpiBitOrder_MsbFirst,  // (spi_ctar_lsbfe[0])        Transmission order - MSB sent first
   };

   // SPI interface used to communicate with LCD
   USBDM::Spi &spi;

   // SPI Configuration to send data bytes
   const Spi::SpiCalculatedConfiguration dataConfiguration;

   // SPI Configuration to send command bytes
   const Spi::SpiCalculatedConfiguration commandConfiguration;

   inline static bool inHibernation = true;

   // Refresh mode
   inline static Refresh refresh = Refresh_full;

   // Frame buffer
   inline static uint8_t fb[HEIGHT*(WIDTH+7)/8];

   /**
    * Converts a uint16_t into little-endian std::array<uint8_t, 2>
    *
    * @param value  Value to convert
    *
    * @return std::array containing the two bytes
    */
   static constexpr std::array<uint8_t, 2>get2Bytes(uint16_t value) {
      return {uint8_t(value), uint8_t(value>>8)};
   }

   /**
    * Converts two uint16_t into little-endian std::array<uint8_t, 4>
    *
    * @param value1  1st value to convert
    * @param value2  2nd value to convert
    *
    * @return std::array containing the four bytes
    */
   static constexpr std::array<uint8_t, 4>get4Bytes(uint16_t value1, uint16_t value2) {
      return {uint8_t(value1), uint8_t(value1>>8), uint8_t(value2), uint8_t(value2>>8)};
   }

   /**
    * Wait while module is busy (polls module)
    */
   void waitWhileBusy() {

      while(EpdBusyPin::isActive()) {
         __asm__("NOP");
         //         console.WRITELN("EPD busy...\r\n");
      }
      //   console.WRITELN("EPD busy release\r\n");
   }

   /**
    * Force hardware reset of module
    */
   void hardwareReset() {

      EpdResetPin::high();
      waitMS(10);
      EpdResetPin::low();
      waitMS(10);
      EpdResetPin::high();
      waitMS(20);
      waitWhileBusy();
   }

   /**
    * Send a command to EPD
    *
    * @param epdCommand  Command value
    */
   void sendCommand(EpdCommand epdCommand) {

      spi.startTransaction(commandConfiguration);
      spi.txRxFinal(epdCommand);
      spi.endTransaction();
   }

   /**
    * Send a command followed by a data byte to EPD
    *
    * @param epdCommand Command byte
    * @param data       Data byte
    */
   void sendCommand(EpdCommand epdCommand, const uint8_t data) {

      sendCommand(epdCommand);
      sendData(data);
   }

   /**
    * Send a command followed by an array of data to EPD
    *
    * @param epdCommand Command byte
    * @param size       Size of data
    * @param data       Data array
    */
   void sendCommand(EpdCommand epdCommand, unsigned size, const uint8_t *data) {

      sendCommand(epdCommand);
      sendData(size, data);
   }

   /**
    * Send a command followed by an array of data to EPD
    *
    * @tparam N   Size of array (inferred)
    *
    * @param epdCommand Command byte
    * @param data       Data array
    */
   template<size_t N>
   void sendCommand(EpdCommand epdCommand, const uint8_t (&data)[N]) {

      sendCommand(epdCommand);
      sendData(N, data);
   }

   /**
    * Send a command followed by an std::array of data to EPD
    *
    * @tparam N   Size of array (inferred)
    *
    * @param epdCommand Command byte
    * @param data       Data array
    */
   template<size_t N>
   void sendCommand(EpdCommand epdCommand, const std::array<uint8_t, N>&data) {

      sendCommand(epdCommand);
      sendData(N, data.data());
   }

   /**
    * Send a data value to EPD
    *
    * @param data Data value to send
    */
   void sendData(uint8_t data) {

      spi.startTransaction(dataConfiguration);
      spi.txRxFinal(data);
      spi.endTransaction();
   }

   /**
    * Send an array of data to EPD
    *
    * @param length  Length of data array to send (in bytes)
    * @param data    Data array
    */
   void sendData(unsigned length, const uint8_t *data) {

      spi.startTransaction(dataConfiguration);
      spi.tx(length, data, true);
      spi.endTransaction();
   }

   /**
    * Send an array of data to EPD
    *
    * @tparam N   Size of data array (inferred)
    *
    * @param data Data array
    */
   template<size_t N>
   void sendData(const uint8_t (&data)[N]) {

      sendData(N, data);
   }

#ifdef WAVESHARE
   /**
    * Send LUT to EPD
    *
    * @param lut  LUT to send
    */
   void setLut(const uint8_t *lut) {

      sendCommand(EpdCommand_WriteLutRegister, 152, lut);
      waitWhileBusy();

      // EOPT, VGH, VSH1, VSH2, VSL, VCOM
      sendCommand(EpdCommand_EndOption, lut[153]);
      sendCommand(EpdCommand_GateVoltage, lut[154]);
      sendCommand(EpdCommand_SourceDrivingVoltage, 3, lut+155);
      sendCommand(EpdCommand_WriteVcomRegister,lut[158]);
   }
#endif

   static constexpr uint8_t SENTINEL  = 0xFF;
   static constexpr uint8_t OP_MASK   = 0xC0;
   static constexpr uint8_t DELAY     = 0xC0;
   static constexpr uint8_t HW_RESET  = 0x80;
   static constexpr uint8_t BUSY_WAIT = 0x40;

   void sendSequence(const uint8_t sequence[]) {

      while(*sequence != SENTINEL) {

         unsigned length   = *sequence++;
         uint8_t operation = (length&OP_MASK);
         length &= ~OP_MASK;

         if (operation==HW_RESET) {
            // Cannot be combined with command
            hardwareReset();
            continue;
         }
         // Do command sequence
         EpdCommand command = (EpdCommand)*sequence++;
         sendCommand(command, length, sequence);
         sequence += length;

         if (operation==DELAY) {
            // Delay after command: 1 parameter
            waitMS(*sequence++);
         }
         if (operation==BUSY_WAIT) {
            // Busy-wait after command: no parameters
            waitWhileBusy();
         }
      }
   }

   /**
    * Initialise the EPD register
    */
   void initialise() {

      static const uint8_t sequence[] = {
            HW_RESET,

            0|BUSY_WAIT, EpdCommand_SoftwareReset,

            // Driver output control:
            3, EpdCommand_DriverOutput,
            (uint8_t)(WIDTH-1),        // Number of gates
            (uint8_t)((WIDTH-1)>>8),   //    A[7-0],A[8] = (WIDTH-1), (WIDTH-1)/256
            0b001,   // Gate scanning sequence and direction (interlaced) B[2-0]
            //          B[2]=0 G0,G1,G2,G3,..., =1 G1,G0,G3,G2,...
            //          B[1]=0 G0,G1,G2...295   =1 G0,G2,G4,G294,G1,G3,...G295
            //          B[0]=0 [Scan G0->G295], =1 Scan G295->G0

            // Data entry mode address counter action after write to RAM
            1, EpdCommand_DataEntryMode,
            0b0'01,  // Address update direction
            //             A[2] 0=X direction, 1=Y direction
            //          Address increment/decrement
            //             A[1,0] 00=Y-:X-, [01=Y-:X+], 10=Y+:X-, 11=Y+:X+

            // Border Waveform 0x05 => VBD=VCOM, GS Tran=LUT,VCOM@RED
            1, EpdCommand_BorderWaveForm,
            0b00'00'01'01, //          VBD sel   Fixed   GS Transition        GS Transition for VBD
            //                         A[7,6],   A[5,4], A[2],                A[1,0]
            //                0b00=>  [A[1,0]]   VSS     Follow LUT VCOM@RED  LUT0
            //                0b01=>   A[5,4]    VSH1   [Follow LUT]         [LUT1]
            //                0b10=>   VCOM      VSL                          LUT2
            //                0b11=>   HiZ       VSH2                         LUT3

            // Select internal temperature sensor
            1, EpdCommand_TempSensorSelect,
            0x80,  // 0x80 = Internal, 0x48 = External

            // Set window X dimensions
            2, EpdCommand_SetWindowX,
            (uint8_t)(0>>3),                           // Start address (byte) = 0
            (uint8_t)((HEIGHT-1)>>3),                  // End address (byte) = HEIGHT-1

            // Set window Y dimensions
            4, EpdCommand_SetWindowY,
            uint8_t(WIDTH-1), uint8_t((WIDTH-1)>>8),   // Start address (pixel) = WIDTH-1
            uint8_t(0), uint8_t(0>>8),                 // End address (pixel) = 0

            // Set RAM X write address
            1, EpdCommand_SetRamXAddr,
            (uint8_t)(0>>3),                           // Write X address (byte) = 0

            // Set RAM Y write address
            2, EpdCommand_SetRamYAddr,
            uint8_t(HEIGHT-1), uint8_t((HEIGHT-1)>>8), // Write Y address = HEIGHT-1

#if 0
            // Display update control,  0xB1
            // Load TS and then Load LUT from OTP
            1, EpdCommand_UpdateControl2,
            0b1011'0001,  // A[7-0] bitmask evaluated 7->0
            //               x   7 Enable Clock
            //                   6 Enable Analogue
            //               x   5 Load Temperature
            //               x   4 Load LUT for display mode 1
            //                  32 Display:
            //               x     00=Disable
            //                     01=Enable mode 1
            //                     10=
            //                     11=Enable mode 2
            //                   1 Disable Analogue
            //               x   0 Disable Clock

            0|BUSY_WAIT, EpdCommand_MasterActivation,

            10, EpdCommand_WriteDisplayOption,
            0x00,  /* A[7] spare */
            0x00,  /* B[7:0] Display Mode for WS[7:0]   (0=Mode 1, */
            0x00,  /* C[7:0] Display Mode for WS[15:8]   1=Mode 2) */
            0x00,  /* D[7:0] Display Mode for WS[23:16]            */
            0x00,  /* E[7:0] Display Mode for WS[31:24]            */
            0x40,  /* F[3:0] Display Mode for WS[35:32]
                               F[6] = PingPong for Mode 2, 0=disable, 1=enable */
            0x00,  /* G + Module ID/Waveform version  */
            0x00,  /* H |                             */
            0x00,  /* I |                             */
            0x00,  /* J +                             */
#endif

            SENTINEL,
      };

      sendSequence(sequence);

      inHibernation = false;
   }

   /**
    * Initialise the EPD register
    */
//   void initialiseFull() {
//
//      // Border Waveform 0x05 => VBD=VCOM, GS Tran=LUT,VCOM@RED
//      //          VBD sel   Fixed   GS Transition        GS Transition for VBD
//      //          A[7,6],   A[5,4], A[2],                A[1,0]
//      // 0b00=>   A[1,0]    VSS     Follow LUT VCOM@RED  LUT0
//      // 0b01=>   A[5,4]    VSH1    Follow LUT           LUT1
//      // 0b10=>  [VCOM]     VSL                          LUT2
//      // 0b11=>   HiZ       VSH2                         LUT3
//      sendCommand(EpdCommand_BorderWaveForm, 0b00'00'01'01);
//
//#ifdef WAVESHARE
//      setLut(WF_Full_1IN54);
//#endif
//   }

   /**
    * Initialise the EPD register (Partial display)
    */
//   void initialisePartial() {
//
//      hardwareReset();
//      waitWhileBusy();
//
//      sendCommand(EpdCommand_SoftwareReset);
//      waitWhileBusy();
//
//      inHibernation = false;
//
//      // Driver output control:
//      // Number of gates
//      //    A[7-0],A[8] = (WIDTH-1), (WIDTH-1)/256
//      // Gate scanning sequence and direction (interlaced) B[2-0]
//      //    B[2]=0 G0,G1,G2,G3,..., =1 G1,G0,G3,G2,...
//      //    B[1]=0 G0,G1,G2...295   =1 G0,G2,G4,G294,G1,G3,...G295
//      //    B[0]=0 [Scan G0->G295], =1 Scan G295->G0
//      const uint8_t data1[] = {(uint8_t)(HEIGHT-1), (uint8_t)((HEIGHT-1)>>8), 0b001}; // ,..,..,0?
//      sendCommand(EpdCommand_DriverOutput, data1);
//
//      // Data entry mode address counter action after write to RAM
//      // Address update direction
//      //    A[2] 0=X direction, 1=Y direction
//      // Address increment/decrement
//      //    A[1,0] 00=Y-:X-, [01=Y-:X+], 10=Y+:X-, 11=Y+:X+
//      //   sendCommand(EpdCommand_DataEntryMode, 0b0'01);
//      sendCommand(EpdCommand_DataEntryMode, 0b0'01);
//
//      // Set window to whole screen
//      setWindow(0, HEIGHT-1, WIDTH-1, 0);
//
//      // Border Waveform 0x05 => VBD=VCOM, GS Tran=LUT,VCOM@RED
//      //          VBD sel   Fixed   GS Transition        GS Transition for VBD
//      //          A[7,6],   A[5,4], A[2],                A[1,0]
//      // 0b00=>   A[1,0]    VSS     Follow LUT VCOM@RED  LUT0
//      // 0b01=>   A[5,4]    VSH1    Follow LUT           LUT1
//      // 0b10=>  [VCOM]     VSL                          LUT2
//      // 0b11=>   HiZ       VSH2                         LUT3
//      sendCommand(EpdCommand_BorderWaveForm, 0b10'00'00'00);
//
//      // Select internal temperature sensor
//      // 0x80 = Internal
//      // 0x48 = External
//      sendCommand(EpdCommand_TempSensorSelect, 0x80);
//
//      setCursor(0, HEIGHT-1);
//
//      /* Display update control,  0xB1
//       * Load TS and then Load LUT from OTP
//       *
//       * A[7-0] bitmask evaluated 7->0
//       * x   7 Enable Clock
//       *     6 Enable Analogue
//       * x   5 Load Temperature
//       * x   4 Load LUT for display mode 1
//       *    32 Display:
//       * x     00=Disable
//       *       01=Enable mode 1
//       *       10=
//       *       11=Enable mode 2
//       *     1 Disable Analogue
//       * x   0 Disable Clock
//       */
//      //   sendCommand(EpdCommand_UpdateControl2, 0b1011'0001);
//      //   sendCommand(EpdCommand_MasterActivation);
//      //   waitWhileBusy();
//
//      //   uint8_t data2[] = {
//      //         0x00,  /* A[7] spare */
//      //         0x00,  /* B[7:0] Display Mode for WS[7:0]   (0=Mode 1, */
//      //         0x00,  /* C[7:0] Display Mode for WS[15:8]   1=Mode 2) */
//      //         0x00,  /* D[7:0] Display Mode for WS[23:16]            */
//      //         0x00,  /* E[7:0] Display Mode for WS[31:24]            */
//      //         0x40,  /* F[3:0] Display Mode for WS[35:32]
//      //                   F[6] = PingPong for Mode 2, 0=disable, 1=enable */
//      //         0x00,  /* G + Module ID/Waveform version  */
//      //         0x00,  /* H |                             */
//      //         0x00,  /* I |                             */
//      //         0x00,  /* J +                             */
//      //   };
//      //   sendCommand(EpdCommand_WriteDisplayOption, data2);
//
//
//      // Border Waveform 0x05 => VBD=VCOM
//      //          VBD sel   Fixed   GS Transition        GS Transition for VBD
//      //          A[7,6],   A[5,4], A[2],                A[1,0]
//      // 0b00=>   A[1,0]    VSS     Follow LUT Vcom@RED  LUT0
//      // 0b01=>   A[5,4]    VSH1    Follow LUT           LUT1
//      // 0b10=>  [VCOM]     VSL                          LUT2
//      // 0b11=>   HiZ       VSH2                         LUT3
//      sendCommand(EpdCommand_BorderWaveForm, 0b10'00'00'00);
//
//#ifdef WAVESHARE
//      setLut(WF_PARTIAL_1IN54);
//#endif
//
//      /* Display update control,  0xC0
//       * Load TS and then Load LUT from OTP
//       *
//       * A[7-0] bitmask evaluated 7->0
//       * x   7 Enable Clock
//       * x   6 Enable Analogue
//       *     5 Load Temperature
//       *     4 Load LUT for display mode 1
//       *    32 Display:
//       * x     00=Disable
//       *       01=Enable mode 1
//       *       10=
//       *       11=Enable mode 2
//       *     1 Disable Analogue
//       *     0 Disable Clock
//       */
//      //   sendCommand(EpdCommand_UpdateControl2, 0xC0);
//      //   sendCommand(EpdCommand_MasterActivation);
//      //   waitWhileBusy();
//   }


   /**
    * Sends an image from buffers in RAM to EPD and displays
    *
    * @param Images
    */
   void display(const uint8_t *image) {

      setCursor(0, HEIGHT-1);
      sendCommand(EpdCommand_WriteRamBlackWhite, getFrameSize(), image);
      updateFull();
   }

   /**
    * The image of the previous frame must be uploaded, otherwise
    * the first few seconds will display an exception.
    *
    * @param image Base image
    */
   void displayPartialBaseImage(const uint8_t *image) {

      setCursor(0, HEIGHT-1);
      sendCommand(EpdCommand_WriteRamBlackWhite, getFrameSize(), image);
      setCursor(0, HEIGHT-1);
      sendCommand(EpdCommand_WriteRamRedWhite,   getFrameSize(), image);
      updateFull();
   }

   /**
    * Sends the image buffer in RAM to EPD and displays
    *
    * @param image Image to display
    */
   void displayPart(const uint8_t *image) {

      setCursor(0, HEIGHT-1);
      sendCommand(EpdCommand_WriteRamBlackWhite, getFrameSize(), image);
      updatePartial();
   }
   /**
    * Turn On Display full
    */
   void updateFull() {

      /* Display update control,  0xF7
       * Load TS and then Load LUT from OTP
       *
       * A[7-0] bitmask evaluated 7->0
       * x   7 Enable Clock
       * x   6 Enable Analogue
       * x   5 Load Temperature
       * x   4 Load LUT for display mode 1
       *    32 Display:
       *       00=Disable
       * x     01=Enable mode 1
       *       10=
       *       11=Enable mode 2
       * x   1 Disable Analogue
       * x   0 Disable Clock
       */
      sendCommand(EpdCommand_UpdateControl2, 0xF7);
      sendCommand(EpdCommand_MasterActivation);
      waitWhileBusy();
   }

   /**
    * Turn On Display partial
    */
   void updatePartial() {

      /* Display update control,  0xFF
       * Load TS and then Load LUT from OTP
       *
       * A[7-0] bitmask evaluated 7->0
       * x   7 Enable Clock
       * x   6 Enable Analogue
       * x   5 Load Temperature
       * x   4 Load LUT for display mode 1
       *    32 Display:
       *       00=Disable
       *       01=Enable mode 1
       *       10=
       * x     11=Enable mode 2 partial update
       * x   1 Disable Analogue
       * x   0 Disable Clock
       */
      sendCommand(EpdCommand_UpdateControl2, 0xFF);
      sendCommand(EpdCommand_MasterActivation);
      waitWhileBusy();
   }

   /**
    * Set window in EPD display RAM
    * Note: X dimensions are rounded down to byte boundaries
    *
    * @param Xstart  X start
    * @param Ystart  Y start
    * @param Xend    X end
    * @param Yend    Y end
    */
   void setWindow(uint16_t Xstart, uint16_t Ystart, uint16_t Xend, uint16_t Yend) {

      sendCommand(EpdCommand_SetWindowX);
      sendData((uint8_t)(Xstart>>3));
      sendData((uint8_t)(Xend>>3));

      sendCommand(EpdCommand_SetWindowY, get4Bytes(Ystart, Yend));
   }

   /**
    * Set EPD cursor
    * Note: X dimension is rounded to byte boundary
    *
    * @param Xstart  X
    * @param Ystart  Y
    */
   void setCursor(uint16_t Xstart, uint16_t Ystart) {

      sendCommand(EpdCommand_SetRamXAddr, (uint8_t)(Xstart>>3));
      sendCommand(EpdCommand_SetRamYAddr, get2Bytes(Ystart));
   }

public:

   /**
    * Enter sleep mode
    */
   void deepSleep() {

      sendCommand(EpdCommand_DeepSleep, 0x01);  // Enter deep sleep
      inHibernation = true;
      waitMS(100);
   }

   /**
    * Clear EPD screen
    */
   void clearDisplay() {

      constexpr unsigned MAX_BLOCK = 10;
      //   static const uint8_t dummyLow[MAX_BLOCK]  = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
      static const uint8_t dummyHigh[MAX_BLOCK] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

      unsigned size, remaining;

      initialise();

      setCursor(0, HEIGHT-1);
      sendCommand(EpdCommand_WriteRamBlackWhite);
      remaining = getFrameSize();
      while (remaining>0) {
         size = remaining;
         if (size > MAX_BLOCK) {
            size = MAX_BLOCK;
         }
         sendData(size, dummyHigh);
         remaining -= size;
      }
      //   setCursor(0, height-1);
      //   sendCommand(EpdCommand_WriteRamRedWhite);
      //   remaining = getFrameSize();
      //   while (remaining>0) {
      //      size = remaining;
      //      if (size > MAX_BLOCK) {
      //         size = MAX_BLOCK;
      //      }
      //      sendData(size, dummyLow);
      //      remaining -= size;
      //   }
      updateFull();
   }

   /**
    * Display page from frame buffer using full refresh and selects the refresh mode for nextPage()
    * This fully initialises the EPD.
    * The EPD is put in deep sleep when done.
    *
    * @param refresh  Refresh mode.
    *                 Note that Refresh_partial should only be used 5 times in sequence
    *                 before a Refresh_full.
    */
   void firstPage(Refresh refresh) {

      this->refresh = refresh;

      initialise();

      switch (refresh) {

         case Refresh_full:
            display(fb);
            deepSleep();
            break;

         case Refresh_partial:
            displayPartialBaseImage(fb);
            deepSleep();
            break;
      }
   }

   /**
    * Display next page from frame buffer.
    * The EPD is woken from sleep if needed.
    * The EPD is put in deep sleep when done.
    *
    * This will use full refresh (with flashing screen!) or partial refresh
    * as set up by firstPage().
    */
   void nextPage() {

      //   initialiseCommon();

      // Make sure awake
      if (inHibernation) {
         hardwareReset();
      }
      switch (refresh) {

         case Refresh_full:
            display(fb);
            deepSleep();
            break;

         case Refresh_partial:
            displayPart(fb);
            deepSleep();
            break;
      }
   }

   /**
    *  Flush output data
    */
   virtual EPD_1in54_GDEM0154I61 &flushOutput() override {

      firstPage(Refresh_full);
      return *this;
   }

   /**
    * Create EPD interface
    *
    * @param [in] spi  SPI to use
    * @param [in] font Initial font to use
    */
   EPD_1in54_GDEM0154I61(Spi &spi, const Font *font=&USBDM::font8x8) :
      FB(font, fb),
      spi(spi),
      dataConfiguration(spi.calculateConfiguration(serialInitValue, SpiPeripheralSelect_EpdCs, SpiPeripheralSelectMode_Transfer)),
      commandConfiguration(spi.calculateConfiguration(serialInitValue, SpiPeripheralSelect_EpdCs|SpiPeripheralSelect_EpdDc, SpiPeripheralSelectMode_Transfer)) {

      // Set CS and CD polarities
      spi.setPcsPolarityActiveLow(SpiPeripheralSelect_EpdDc|SpiPeripheralSelect_EpdCs);

      // GPIOs
      static constexpr PcrInit pcrValue {
         PinPull_Up,
         PinAction_None,
         PinDriveStrength_Low,
         PinDriveMode_PushPull,
         PinFilter_None,
      };
      EpdResetPin::setOutput(pcrValue);
      EpdBusyPin::setInput(pcrValue);
      EpdResetPin::high();
   }

   /**
    * Delete EPD interface
    */
   ~EPD_1in54_GDEM0154I61() {

      deepSleep();

      EpdResetPin::low();
   }
};

} // end namespace USBDM

#endif // INCLUDE_USBDM_EPD_1IN54_GDEM0154I61

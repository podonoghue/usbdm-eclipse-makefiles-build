/**
 * @file    fonts.h  (180.ARM_Peripherals/Snippets)
 * @brief   Fonts for LCD
 */
#ifndef INCLUDE_USBDM_FONTS_H
#define INCLUDE_USBDM_FONTS_H

 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "array"

namespace USBDM {

/**
 * Represents a font
 */
class Font {

public:
   const uint8_t * (*fptr)(uint8_t ch);   // Pointer to indexing function
   const uint8_t width;                   // Width of the character in pixels
   const uint8_t height;                  // Height of the character in pixels

   constexpr Font(unsigned width, unsigned height, const uint8_t * (*fptr)(uint8_t ch)) :
      fptr(fptr), width(width), height(height) {
   }

   /**
    * Get pixel data for a character
    *
    * @param ch   Character
    *
    * @return  Pixel data for ch.
    *
    * @note Returned value is a C array of size ((WIDTH+7)/8)*HEIGHT
    */
   const uint8_t *operator[] (uint8_t ch) const {
      return fptr(ch);
   }
};

template<unsigned width, unsigned height>
using FontCharacter = std::array<uint8_t, ((width+7)/8)*height>;

/**
 * Used to create a Font that is a subset of another font.
 * Only useful if a few characters are needed from a large font.
 *
 * Usage :
 * @code
 *    constexpr FontArraySubset<
 *       FontVeryLarge,                                  // Font to extract character data from
 *       ' ','0','1','2','3','4','5','6','7','8','9',',' // Characters to be available
 *       > mainFont;
 * @endcode
 *
 * @tparam FontData Font type to extract character data from
 * @tparam elements Characters to be available (a list of characters)
 */
template<typename FontData, uint8_t... elements>
class FontArraySubset : public Font {

public:
   static constexpr unsigned WIDTH      = FontData::WIDTH;
   static constexpr unsigned HEIGHT     = FontData::HEIGHT;

   constexpr FontArraySubset() : Font(WIDTH, HEIGHT, getByte) {
   }

   /**
    * Get index of ch for character pixel array
    *
    * @param ch
    *
    * @return Index or 0 if character is not supported.
    *         It is convenient to have space mapped to location 0 in the pixel array.
    */
   static uint8_t getIndex(uint8_t ch) {
      static constexpr uint8_t lookupIndex[sizeof...(elements)] = {elements...};

      for (uint8_t index=0; index<sizeof...(elements); index++) {
         if (lookupIndex[index] == ch) {
            return index;
         }
      }
      return 0;
   }

   /**
    * Get pixel data for this character
    *
    * @param ch   Character
    *
    * @return  Pixel data for ch.  This is a C array of size ((width+7)/8)*height.
    */
   static const uint8_t *getByte(uint8_t ch) {
      static constexpr typename FontData::FontCharacterType font[sizeof...(elements)] = {
            {FontData::data[elements-' ']}..., // !
      };

      return font[getIndex(ch)].data();
   }
};

#include "../Fonts/font6x8.inc"
#include "../Fonts/font7x12.inc"
#include "../Fonts/font8x8.inc"
#include "../Fonts/font8x16.inc"
#include "../Fonts/font11x16.inc"
#include "../Fonts/font14x20.inc"
#include "../Fonts/font16x32.inc"
#include "../Fonts/font16x24.inc"

}; // end namespace USBDM

#endif /* INCLUDE_USBDM_FONTS_H */

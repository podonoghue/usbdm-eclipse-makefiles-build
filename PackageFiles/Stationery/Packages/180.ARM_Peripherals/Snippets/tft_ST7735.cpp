/******************************************************************************
 * @file tft_ST7735.cpp (180.ARM_Peripherals/Snippets)
 *
 *  Requires declarations for the following in Configure.usbdmProject
 *
 *  TftCs       TFT CSX as SPI Peripheral select e.g. PCS0 (D7)
 *  TftDc       TFT D/CX as SPI Peripheral select e.g. PCS2 (A3)
 *  TftResetPin TFT Reset pin as GPIO e.g. GpioB.1 (A4)
 *
 *  Fixed SPI specific connections
 *  SDA         SOUT (D11)
 *  ---         SIN  (D12)
 *  SCL         SCK  (D13)
 *
 *  Power
 *  GND
 *  VCC
 ******************************************************************************/
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "tft_ST7735.h"
#include "hardware.h"

using namespace USBDM;

///**
// * Converts a uint16_t into little-endian std::array<uint8_t, 2>
// *
// * @param value  Value to convert
// *
// * @return std::array containing the two bytes
// */
//static constexpr std::array<uint8_t, 2>get2Bytes(uint16_t value) {
//   return {uint8_t(value), uint8_t(value>>8)};
//}
//

///**
// * Converts two uint16_t into big-endian std::array<uint8_t, 4>
// *
// * @param value1  1st value to convert
// * @param value2  2nd value to convert
// *
// * @return std::array containing the four bytes
// */
//static constexpr std::array<uint8_t, 3>getColourAsBytes(Colour colour) {
//   return {(uint8_t)(colour>>(11-3)&0b1111'1000), (uint8_t)(colour>>(5-2)&0b1111'1100), (uint8_t)(colour<<(8-5)&0b1111'1000), };
//}

/**
 * Converts two uint16_t into big-endian std::array<uint8_t, 4>
 *
 * @param value1  1st value to convert
 * @param value2  2nd value to convert
 *
 * @return std::array containing the four bytes
 */
static constexpr std::array<uint8_t, 4>get4Bytes(uint16_t value1, uint16_t value2) {
   return {uint8_t(value1>>8), uint8_t(value1), uint8_t(value2>>8), uint8_t(value2)};
}

/**
 * Force hardware reset of module
 */
void TFT_ST7735::hardwareReset() {

   TftResetPin::high();
   waitMS(5);
   TftResetPin::low();
   waitMS(20);
   TftResetPin::high();
   waitMS(150);
}

/**
 * Send a command to display
 *
 * @param Command  Command value
 */
void TFT_ST7735::sendCommand(Command Command) {

   spi.startTransaction(commandConfiguration);
   spi.txRxFinal(Command);
   spi.endTransaction();
}

/**
 * Send a command followed by a data byte to display
 *
 * @param Command Command byte
 * @param data       Data byte
 */
void TFT_ST7735::sendCommand(Command Command, const uint8_t data) {

   sendCommand(Command);
   sendData(data);
}

/**
 * Send a command followed by an array of data to display
 *
 * @param Command Command byte
 * @param size       Size of data
 * @param data       Data array
 */
void TFT_ST7735::sendCommand(Command Command, unsigned size, const uint8_t *data) {

   sendCommand(Command);
   sendData(size, data);
}

/**
 * Send a command followed by an array of data to display
 *
 * @tparam N   Size of array (inferred)
 *
 * @param Command Command byte
 * @param data       Data array
 */
template<size_t N>
void TFT_ST7735::sendCommand(Command Command, const uint8_t (&data)[N]) {

   sendCommand(Command);
   sendData(N, data);
}

/**
 * Send a command followed by an std::array of data to display
 *
 * @tparam N   Size of array (inferred)
 *
 * @param Command Command byte
 * @param data       Data array
 */
template<size_t N>
void TFT_ST7735::sendCommand(Command Command, const std::array<uint8_t, N>&data) {

   sendCommand(Command);
   sendData(N, data.data());
}

/**
 * Send a data value to display
 *
 * @param data Data value to send
 */
void TFT_ST7735::sendData(uint8_t data) {

   spi.startTransaction(dataConfiguration);
   spi.txRxFinal(data);
   spi.endTransaction();
}

/**
 * Send an array of data to display
 *
 * @param length  Length of data array to send (in bytes)
 * @param data    Data array
 */
void TFT_ST7735::sendData(unsigned length, const uint8_t *data) {

   spi.startTransaction(dataConfiguration);
   spi.tx(length, data, true);
   spi.endTransaction();
}

/**
 * Send an array of data to display
 *
 * @tparam N   Size of data array (inferred)
 *
 * @param data Data array
 */
template<size_t N>
void TFT_ST7735::sendData(const uint8_t (&data)[N]) {

   sendData(N, data);
}

static constexpr uint8_t SENTINEL  = 0xFF;
static constexpr uint8_t OP_MASK   = 0xC0;
static constexpr uint8_t DELAY     = 0xC0;
static constexpr uint8_t HW_RESET  = 0x80;
//static constexpr uint8_t BUSY_WAIT = 0x40;

void TFT_ST7735::sendSequence(const uint8_t sequence[]) {

   while(*sequence != SENTINEL) {

      unsigned length   = *sequence++;
      uint8_t operation = (length&OP_MASK);
      length &= ~OP_MASK;

      if (operation==HW_RESET) {
         // Cannot be combined with command
         hardwareReset();
         continue;
      }
      // Do command sequence
      Command command = (Command)*sequence++;
      sendCommand(command, length, sequence);
      sequence += length;

      if (operation==DELAY) {
         // Delay after command: 1 parameter
         waitMS(*sequence++);
      }
      //      if (operation==BUSY_WAIT) {
      //         // Busy-wait after command: no parameters
      //         waitWhileBusy();
      //      }
   }
}

/**
 * Send a pixel colour as 2 bytes
 *
 * @param colour Colour to send
 */
void TFT_ST7735::sendColour(Colour colour) {

   const uint8_t data[] = {
         //         (uint8_t)(colour>>(11-3)&0b1111'1000),
         //         (uint8_t)(colour>>(5-2)&0b1111'1100),
         //         (uint8_t)(colour<<(8-5)&0b1111'1000),
         (uint8_t) (colour>>8),
         (uint8_t) colour,
   };
   sendData(data);
}

/**
 * Initialise the Display
 */
void TFT_ST7735::initialise() {

   static const uint8_t initSequence[] = {

         HW_RESET,

         DELAY|0, Command_SoftReset,
         120,                          // 120ms delay

         DELAY|0, Command_ExitSleep,
         120,                          // 120ms delay

         // Set colour mode, 1 arg, no delay
         DELAY|1, Command_SetPixelFormat,
         Format_RBG565,
         10,                           // 10ms delay ?

         /* Frame rate control - normal mode, 3 args:Rate = fosc/(1x2+40) * (LINE+2C+2D) */
         DELAY|3,  Command_SetFrameRateNormalMode,
         0x00,                         //     fastest refresh
         0x06,                         //     6 lines front porch
         0x03,                         //     3 lines back porch
         10,                           //     10 ms delay ?

         1, Command_SetMemoryAccessControl,
         0x08,                         //     Row/col addr, bottom-top refresh

         2, Command_DisplayFunctionSet5,
         0x15,                         //  1  clk cycle non-overlap, 2 cycle gate rise, 3 cycle osc equalise
         0x02,                         //     Fix on VTL

         /* Display inversion ctrl, 1 arg, no delay */
         1,  Command_SetDisplayInversionControl,
         0x00,                         // Line inversion

         /* Power control, 3 args, no delay */
         DELAY|2, Command_PowerControl1,
         0x02,                         //     GVDD = 4.7V
         0x70,                         //     1.0uA
         10,                           //     10 ms delay

         /* Power control, 1 args, no delay */
         1, Command_PowerControl2,
         0x05,                         //     VGH = 14.7V, VGL = -7.35V

         /* Power control, 2 args, no delay */
         DELAY|2, Command_PowerControl3,
         0x01,                         //     Opamp current small
         0x02,                         //     Boost frequency
         10,                           //     10 ms delay

         /* Power control, 1 arg, no delay */
         DELAY|2, Command_VcomControl1,
         0x3C,                         //     VCOMH = 4V
         0x38,                         //     VCOML = -1.1V
         10,                           //     10 ms delay

         /* Power control, 2 args, no delay */
         2, Command_AdjustControl6,
         0x11, 0x15,

         /* Gamma Adjustments (pos. polarity), 16 args, 16 args, no delay */
         16, Command_PositiveGammaControl,
         0x09, 0x16, 0x09, 0x20,       //     Provides more accurate colours
         0x21, 0x1B, 0x13, 0x19,
         0x17, 0x15, 0x1E, 0x2B,
         0x04, 0x05, 0x02, 0x0E,

         /* Gamma Adjustments (neg. polarity), 16 args, no delay */
         DELAY|16, Command_NegativeGammaControl,
         0x0B, 0x14, 0x08, 0x1E,       //     Provides more accurate colours
         0x22, 0x1D, 0x18, 0x1E,
         0x1B, 0x1A, 0x24, 0x2B,
         0x06, 0x06, 0x02, 0x0F,
         10,                           //     10 ms delay

         /* Normal display on, no args, no delay */
         DELAY|0, Command_NormalDisplayModeOn,
         10,                           //     10 ms delay

         // Main screen turn on, no delay
         DELAY|0, Command_DisplayOn,
         255,                          // 255 ms delay

         DELAY|0, Command_AllPixelsOff,
         255,

         DELAY|0, Command_AllPixelsOn,
         255,

         SENTINEL,
   };

   sendSequence(initSequence);
}

/**
 * Set window in display RAM
 * Note: X dimensions are rounded down to byte boundaries
 *
 * @param Xstart  X start
 * @param Ystart  Y start
 * @param Xend    X end
 * @param Yend    Y end
 */
void TFT_ST7735::setWindow(uint16_t Xstart, uint16_t Ystart, uint16_t Xend, uint16_t Yend) {

   static constexpr struct {
      unsigned sx;   ///< Start X
      unsigned ex;   ///< End X
      unsigned sy;   ///< Start Y
      unsigned ey;   ///< End Y
   } offsets[] {
         // sx ex sy ey
         {  2, 2, 1, 1 },  // Normal
         {  1, 1, 2, 2 },  // Mirrored across X=Y axis
         {  2, 2, 1, 1 },  // Mirrored across Y Axis
         {  1, 1, 2, 2 },  // Rotated 270 degrees
         {  2, 2, 3, 3 },  // Mirrored across X Axis
         {  3, 3, 2, 2 },  // Rotated 90 degrees
         {  2, 2, 3, 3 },  // Rotated 180 degrees
         {  3, 3, 2, 2 },  // Mirrored across X=-Y axis
   };
   static constexpr unsigned sx = offsets[ORIENTATION>>5].sx;
   static constexpr unsigned ex = offsets[ORIENTATION>>5].ex;
   static constexpr unsigned sy = offsets[ORIENTATION>>5].sy;
   static constexpr unsigned ey = offsets[ORIENTATION>>5].ey;

   sendCommand(Command_SetColumnAddress, get4Bytes(Xstart+sx, Xend+ex));
   sendCommand(Command_SetRowAddress,    get4Bytes(Ystart+sy, Yend+ey));
}

/**
 * Clear display screen
 */
void TFT_ST7735::clear() {

   constexpr unsigned MAX_BLOCK = 16;

   static Colour filler[MAX_BLOCK];

   std::fill_n(filler, MAX_BLOCK, Colour(((backgroundColour>>8)&0xFF)|(backgroundColour<<8)));

   setWindow(0, 0, WIDTH+2, HEIGHT+2);
   sendCommand(Command_MemoryWriteStart);

   unsigned remaining = (WIDTH+3)*(HEIGHT+3)*sizeof(Colour);
   while (remaining>0) {
      unsigned size = remaining;
      if (size > sizeof(filler)) {
         size = sizeof(filler);
      }
      sendData(size, (uint8_t*)filler);
      remaining -= size;
   }

   x = 0;
   y = 0;
}

/**
 * Enter sleep mode
 */
void TFT_ST7735::sleep() {

   sendCommand(Command_EnterSleep);  // Enter sleep
   inHibernation = true;
   waitMS(5);
}

/**
 * Enter sleep mode
 */
void TFT_ST7735::awaken() {

   sendCommand(Command_ExitSleep);  // Exit sleep
   inHibernation = false;
   waitMS(120);
}

void TFT_ST7735::drawPixel(unsigned x, unsigned y, Colour colour) {

   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Off screen
      return;
   }
   setWindow(x, y, x+1, y+1);
   sendCommand(Command_MemoryWriteStart);
   sendColour(colour);
}

/**
 * Simple line drawing for physical y0=y1
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param x1   End X
 */
void TFT_ST7735::drawHorizontalLine(unsigned x0, unsigned y0, unsigned x1) {

   if(x1 > WIDTH-1) {
      // Clip to width
      x1 = WIDTH-1;
   }
   setWindow(x0, y0, x1, y0);

   sendCommand(Command_MemoryWriteStart);
   while (x0++<=x1) {
      sendColour(colour);
   }
}


/**
 * Simple line drawing for physical x0=x1
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param y1   End Y
 */
void TFT_ST7735::drawVerticalLine(unsigned x0, unsigned y0, unsigned y1) {

   if(y1 > HEIGHT-1) {
      // Clip to height
      y1 = HEIGHT-1;
   }
   setWindow(x0, y0, x0, y1);

   sendCommand(Command_MemoryWriteStart);
   while (y0++<=y1) {
      sendColour(colour);
   }
}

/**
 * Simple line drawing using Bresenham's algorithm
 * Ref : https://en.wikipedia.org/wiki/Bresenham's_line_algorithm
 *
 * @param x0   Start X
 * @param y0   Start Y
 * @param x1   End X
 * @param y1   End Y
 */
void TFT_ST7735::drawLine(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   if (y0==y1) {
      drawHorizontalLine(x0, y0, x1);
   }
   else if (x0==x1) {
      drawVerticalLine(x0, y0, y1);
   }
   else {
      int dx = std::abs((int)x1 - (int)x0);
      int sx = (x0 < x1) ? 1 : -1;
      int dy = -abs((int)y1 - (int)y0);
      int sy = (y0 < y1) ? 1 : -1;
      int error = dx + dy;

      while (true) {
         drawPixel(x0, y0, colour);
         int e2 = 2 * error;
         if (e2 >= dy) {
            if (x0 == x1) {
               break;
            }
            error = error + dy;
            x0 = x0 + sx;
         }
         if (e2 <= dx) {
            if (y0 == y1) {
               break;
            }
            error = error + dx;
            y0 = y0 + sy;
         }
      }
   }
}

/**
 * Draw a filled rectangle
 *
 * @param x0  Top-left X
 * @param y0  Top-left Y
 * @param x1  Bottom-right X
 * @param y1  Bottom-right Y
 */
void TFT_ST7735::drawRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   for (unsigned y=y0; y<=y1; y++) {
      drawHorizontalLine(x0, y, x1);
   }
}

/**
 * Draw an open rectangle
 *
 * @param x0  Top-left X
 * @param y0  Top-left Y
 * @param x1  Bottom-right X
 * @param y1  Bottom-right Y
 */
void TFT_ST7735::drawOpenRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {

   drawHorizontalLine(x0, y0, x1);
   drawHorizontalLine(x0, y1, x1);
   drawVerticalLine(x0, y0+1, y1-1);
   drawVerticalLine(x1, y0+1, y1-1);
}

/**
 * Draw filled circle
 *
 * @param X       Circle centre X
 * @param Y       Circle centre Y
 * @param Radius  Circle radius
 */
void TFT_ST7735::drawCircle(unsigned X, unsigned Y, unsigned Radius) {

   int16_t f = 1 - Radius;
   int16_t ddF_x = 1;
   int16_t ddF_y = -2 * Radius;
   int16_t x = 0;
   int16_t y = Radius;

   // Solid Circle - Draw the fill line
   drawLine(X - Radius, Y, X + Radius, Y);

   while (x < y)
   {
      if (f >= 0)
      {
         y--;
         ddF_y += 2;
         f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      // Solid Circle - Draw the fill line
      drawLine(X - x, Y + y, X + x, Y + y);
      drawLine(X - x, Y - y, X + x, Y - y);
      drawLine(X - y, Y + x, X + y, Y + x);
      drawLine(X - y, Y - x, X + y, Y - x);
   }
}

/**
 * Draw open circle
 *
 * @param X       Circle centre X
 * @param Y       Circle centre Y
 * @param Radius  Circle radius
 */
void TFT_ST7735::drawOpenCircle(unsigned X, unsigned Y, unsigned Radius) {

   int16_t f = 1 - Radius;
   int16_t ddF_x = 1;
   int16_t ddF_y = -2 * Radius;
   int16_t x = 0;
   int16_t y = Radius;

   // Hollow Circle - Draw 8 points of symmetry
   drawPixel(X, Y + Radius, colour);
   drawPixel(X, Y - Radius, colour);
   drawPixel(X + Radius, Y, colour);
   drawPixel(X - Radius, Y, colour);

   while (x < y)
   {
      if (f >= 0)
      {
         y--;
         ddF_y += 2;
         f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      // Hollow Circle - Draw 8 points of symmetry
      drawPixel(X + x, Y + y, colour);
      drawPixel(X - x, Y + y, colour);
      drawPixel(X + x, Y - y, colour);
      drawPixel(X - x, Y - y, colour);
      drawPixel(X + y, Y + x, colour);
      drawPixel(X - y, Y + x, colour);
      drawPixel(X + y, Y - x, colour);
      drawPixel(X - y, Y - x, colour);
   }
}

/**
 * Draw an image to display
 *
 * @param img  Image with 16-bit colours
 * @param x    Top-left X
 * @param y    Top-left Y
 * @param w    Width
 * @param h    Height
 */
void TFT_ST7735::drawImage(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

   // rudimentary clipping (drawChar w/big text requires this)
   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Clipped
      return;
   }
   if((x + w - 1) >= (int)WIDTH)  {
      // Clip on edge
      w = WIDTH  - x;
   }
   if((y + h - 1) >= (int)HEIGHT) {
      // Clip on edge
      h = HEIGHT - y;
   }

   setWindow(x, y, x+w-1, y+h-1);
   sendCommand(Command_MemoryWriteStart);

   uint8_t linebuff[w*3+1];
   unsigned count = 0;

   for (unsigned row=0; row<h; row++) {

      // Process each row to buffer and send
      unsigned pixelCount = 0;

      for (unsigned col=0; col<w; col++) {

         // 2 bytes of image -> 3 byte colour on display
         uint8_t b1 = img[count++];
         uint8_t b2 = img[count++];
         uint16_t colour = b1 << 8 | b2;
         linebuff[pixelCount++] = (colour & 0xF800) >> (11-3);
         linebuff[pixelCount++] = (colour & 0x07E0) >> (5-2);
         linebuff[pixelCount++] = (colour & 0x001F) << (8-3);
      }
      sendData(3*w, linebuff);
   }
}

/**
 * Draw an image to display
 *
 * @param img  Bitmap image 8-pixels/byte
 * @param x    Top-left X
 * @param y    Top-left Y
 * @param w    Width
 * @param h    Height
 */
void TFT_ST7735::drawBitmap(const uint8_t* img, uint16_t x, uint16_t y, uint16_t w, uint16_t h) {

   // rudimentary clipping (drawChar w/big text requires this)
   if((x >= WIDTH) || (y >= HEIGHT)) {
      // Clipped
      return;
   }
   if((x + w - 1) >= (int)WIDTH)  {
      // Clip on edge
      w = WIDTH  - x;
   }
   if((y + h - 1) >= (int)HEIGHT) {
      // Clip on edge
      h = HEIGHT - y;
   }

   setWindow(x, y, x+w-1, y+h-1);
   sendCommand(Command_MemoryWriteStart);

   uint8_t  linebuff[w*2+1];
   unsigned count   = 0;

   for (unsigned row=0; row<h; row++) {

      // Process each row to buffer and send
      unsigned pixcount = 0;
      uint8_t  bitMask  = 0;
      uint8_t  byte;

      for (unsigned col=0; col<w; col++) {
         if (bitMask==0) {
            bitMask = 0b1000'0000;
            byte    = img[count++];
         }
         // 1 bit of image -> 2 byte colour on display
         Colour c = (byte&bitMask)?colour:backgroundColour;
         linebuff[pixcount++] = uint8_t(c >> 8);
         linebuff[pixcount++] = uint8_t(c);
         bitMask >>= 1;
      }
      sendData(2*w, linebuff);
   }
}

/**
 * Write a custom character to the LCD in graphics mode at the current x,y location
 *
 * @param[in] image  Image describing the character
 * @param[in] width  Width of the image
 * @param[in] height Height of character
 *
 * @return Reference to self
 */
TFT_ST7735 &TFT_ST7735::putCustomChar(const uint8_t *image, unsigned width, unsigned height) {

   drawBitmap(image, x, y, width, height);
   x += width;
   fontHeight = max(fontHeight, height);

   return *this;
}

/**
 * Writes whitespace to the frame buffer at the current x,y location
 *
 * @param[in] width Width of white space in pixels
 *
 * @return Reference to self
 */
TFT_ST7735 &TFT_ST7735::putSpace(int width) {

   static const uint8_t space[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
   while (width>0) {
      int t = 8;
      if (t>width) {
         t = width;
      }
      putCustomChar(space, t, 8);
      width -= t;
   }
   return *this;
}

/**
 * Write a character to the frame buffer at the current x,y location
 *
 * @param[in]  ch - character to write
 */
void TFT_ST7735::_writeChar(char ch) {

   unsigned width  = font->width;
   unsigned height = font->height;

   if (ch == '\\n') {
      putSpace(width-x);
      x  = 0;
      y += fontHeight;
      fontHeight = 0;
   }
   else {
      if ((x+width)>WIDTH) {
         // Don't display partial characters
         return;
      }
      drawBitmap((*font)[ch], x, y, width, height);
      x += width;
      fontHeight = max(fontHeight, height);
   }
   return;
}


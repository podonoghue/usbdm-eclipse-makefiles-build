/******************************************************************************
 * @file oled_SSD1306.h (180.ARM_Peripherals/Snippets)
 *
 *  Requires declarations for the following in Configure.usbdmProject
 *
 *  Fixed I2C specific connections
 *  SCL         SCL  (PTB.0/A5)
 *  SDA         SDA  (PTB.1/A4)
 *
 *  Power
 *  GND
 *  VCC
 ******************************************************************************/
#ifndef INCLUDE_USBDM_SSD1306
#define INCLUDE_USBDM_SSD1306
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include <memory.h>

#include "hardware.h"
#include "i2c.h"
#include "FrameBuffer.h"

namespace USBDM {

enum class OledDisplayType {
   OledDisplayType_ssd1306,
   OledDisplayType_sh1106,
};

enum OledVccControl : uint8_t {
   OledVccControl_Internal = 0,
   OledVccControl_External = 1,
};

/**
 *
 * @tparam scale        How to scale the display
 * @tparam rotate       How to rotate display
 * @tparam mirrorMode   How to mirror the display
 * @tparam WIDTH        Physical width of display   - Don't change
 * @tparam HEIGHT       Physical height of display  - Don't change
 */
template <ScaleMode scale=ScaleMode_1, RotateMode rotate=RotateMode_0, MirrorMode mirrorMode=MirrorMode_None, unsigned WIDTH=128, unsigned HEIGHT=64>
class Oled_SSD1306 : public FrameBuffer<WIDTH, HEIGHT, PixelPacking_1x8xRow, scale, rotate, mirrorMode> {

   using FB = FrameBuffer<WIDTH, HEIGHT, PixelPacking_1x8xRow, scale, rotate, mirrorMode>;
   using FB::getFrameSize;

protected:

   enum Command : uint8_t {

      // Control byte
      Control_SINGLE_COMMAND                        = 0b10000000, ///< Co=1, D/C=0: Command data followed by control byte
      Control_MULTIPLE_COMMANDS                     = 0b00000000, ///< Co=0, D/C=0: Command data until I2C stop
      Control_MULTIPLE_GDRAM                        = 0b01000000, ///< Co=0, D/C=1: Graphic data until I2C stop

      // Actual commands
      Command_MEMORYMODE                            = 0x20, ///< See datasheet
      Command_COLUMNADDR                            = 0x21, ///< See datasheet
      Command_PAGEADDR                              = 0x22, ///< See datasheet
      Command_SETCONTRAST                           = 0x81, ///< See datasheet
      Command_CHARGEPUMP                            = 0x8D, ///< See datasheet
      Command_SEGREMAP                              = 0xA0, ///< See datasheet
      Command_DISPLAYALLON_RESUME                   = 0xA4, ///< See datasheet
      Command_DISPLAYALLON                          = 0xA5, ///< Not currently used
      Command_NORMALDISPLAY                         = 0xA6, ///< See datasheet
      Command_INVERTDISPLAY                         = 0xA7, ///< See datasheet
      Command_SETMULTIPLEX                          = 0xA8, ///< See datasheet
      Command_DISPLAYOFF                            = 0xAE, ///< See datasheet
      Command_DISPLAYON                             = 0xAF, ///< See datasheet
      Command_COMSCANINC                            = 0xC0, ///< Not currently used
      Command_COMSCANDEC                            = 0xC0, ///< b3=COM0..COMn/COMn..COM0
      Command_SETDISPLAYOFFSET                      = 0xD3, ///< See datasheet
      Command_SETDISPLAYCLOCKDIV                    = 0xD5, ///< See datasheet
      Command_SETPRECHARGE                          = 0xD9, ///< See datasheet
      Command_SETCOMPINS                            = 0xDA, ///< b5=COM left/right map, b4=seq/alt COM pin config.
      Command_SETVCOMDETECT                         = 0xDB, ///< See datasheet

      Command_SETLOWCOLUMN                          = 0x00, ///< Not currently used
      Command_SETHIGHCOLUMN                         = 0x10, ///< Not currently used
      Command_SETSTARTLINE                          = 0x40, ///< See datasheet

      Command_RIGHT_HORIZONTAL_SCROLL               = 0x26, ///< Init rt scroll
      Command_LEFT_HORIZONTAL_SCROLL                = 0x27, ///< Init left scroll
      Command_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL  = 0x29, ///< Init diag scroll
      Command_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL   = 0x2A, ///< Init diag scroll
      Command_DEACTIVATE_SCROLL                     = 0x2E, ///< Stop scroll
      Command_ACTIVATE_SCROLL                       = 0x2F, ///< Start scroll
      Command_SET_VERTICAL_SCROLL_AREA              = 0xA3, ///< Set scroll range

      // SHT1106 only
      Command_SET_PAGE_ADDRESS                       = 0xB0, ///< Set page address, b3-0 = page #
   };

   // Change as needed for actual display
   static constexpr OledDisplayType DISPLAY_TYPE = OledDisplayType::OledDisplayType_sh1106;
   static constexpr OledVccControl  VCC_CONTROL  = OledVccControl_Internal;

   // Frame buffer
   inline static uint8_t fb[HEIGHT*(WIDTH+7)/8];

   // Address (LSB = R/W bit = 0)
   static constexpr unsigned   I2C_ADDRESS   = 0b01111000;
   static constexpr unsigned   I2C_SPEED     = 400_kHz;

   // Size of image array in memory
   static constexpr size_t IMAGE_DATA_SIZE = WIDTH * ((HEIGHT + 7) / 8);

   // Number of pages in OLED internal image buffer
   // Set to zero if auto-increment of image pointer across pages is supported
   static constexpr size_t IMAGE_PAGE_COUNT =
         (DISPLAY_TYPE==OledDisplayType::OledDisplayType_sh1106)?(HEIGHT/8):
               (DISPLAY_TYPE==OledDisplayType::OledDisplayType_ssd1306)?0:
                     0;

   /** I2C peripheral to use */
   I2c &i2c;

   template <uint8_t padsModeSet, uint8_t contrast>
   const uint8_t (&getInitSequence_ssd1306())[33] {

      static constexpr uint8_t data[33] = {
            Control_MULTIPLE_COMMANDS,            // Co = 0, D/C = 0
            Command_DISPLAYOFF,                   // 0xAE
            Command_SETDISPLAYCLOCKDIV,           // 0xD5
            0x80,                                 // = Reset value (105Hz)
            Command_SETMULTIPLEX,                 // 0xA8
            (HEIGHT - 1),
            Command_SETDISPLAYOFFSET,             // 0xD3
            0x0,                                  // = Reset value, no offset
            Command_SETSTARTLINE | 0x0,           // 0x40 - line #0
            Command_CHARGEPUMP,                   // 0x8D
            ((VCC_CONTROL == OledVccControl_External) ? 0x10 : 0x14),
            Command_MEMORYMODE,                   // 0x20
            0x00,                                 // Horizontal addressing mode
            Command_SEGREMAP | 0x1,               // 0xA0 | 0x01 map col127->SEG0
            Command_COMSCANDEC | 0x8,             // 0xC0 | 0x8  scan COM[N-1] -> COM0

            Command_COLUMNADDR,                   // 0x21
            0,                                    // first column
            (WIDTH-1),                            // last column
            Command_PAGEADDR,                     // 0x22
            0,                                    // first page
            (((HEIGHT+7)/8)-1),                   // last page

            Command_SETCOMPINS,                   // 0xDA
            0x02|padsModeSet,                     // b4=Sequential/Alt COM pin config, b5=-,left/right remap
            Command_SETCONTRAST,                  // 0x81
            contrast,                             // Contrast level reset = 0x7F

            Command_SETPRECHARGE,                 // 0xD9
            ((VCC_CONTROL == OledVccControl_External) ? 0x22 : 0xF1),
            Command_SETVCOMDETECT,                // 0xDB
            0x40,
            Command_DISPLAYALLON_RESUME,          // 0xA4
            Command_NORMALDISPLAY,                // 0xA6
            Command_DEACTIVATE_SCROLL,            // 0x2E
            Command_DISPLAYON,                    // Main screen turn on
      };
      return data;
   }

   template <uint8_t padsModeSet, uint8_t contrast>
   const uint8_t (&getInitSequence_sh1106())[27] {

      static constexpr uint8_t data[27] = {
            Control_MULTIPLE_COMMANDS,            // Co = 0, D/C = 0
            Command_DISPLAYOFF,                   // 0xAE
            Command_SETDISPLAYCLOCKDIV,           // 0xD5
            0x80,                                 // = Reset value (105Hz)
            Command_SETMULTIPLEX,                 // 0xA8
            (HEIGHT - 1),
            Command_SETDISPLAYOFFSET,             // 0xD3
            0x0,                                  // = Reset value, no offset
            Command_SETSTARTLINE | 0x0,           // 0x40 - line #0
            Command_CHARGEPUMP,                   // 0x8D
            ((VCC_CONTROL == OledVccControl_External) ? 0x10 : 0x14),
            Command_MEMORYMODE,                   // 0x20
            0x00,                                 // Horizontal addressing mode
            Command_SEGREMAP | 0x1,               // 0xA0 | 0x01 map col127->SEG0
            Command_COMSCANDEC | 0x8,             // 0xC0 | 0x8  scan COM[N-1] -> COM0

            Command_SETCOMPINS,                   // 0xDA
            0x02|padsModeSet,                     // b4=Sequential/Alt COM pin config, b5=-,left/right remap
            Command_SETCONTRAST,                  // 0x81
            contrast,                             // Contrast level reset = 0x7F

            Command_SETPRECHARGE,                 // 0xD9
            ((VCC_CONTROL == OledVccControl_External) ? 0x22 : 0xF1),
            Command_SETVCOMDETECT,                // 0xDB
            0x40,
            Command_DISPLAYALLON_RESUME,          // 0xA4
            Command_NORMALDISPLAY,                // 0xA6
            Command_DEACTIVATE_SCROLL,            // 0x2E
            Command_DISPLAYON,                    // Main screen turn on
      };
      return data;
   }

   template<typename T> T max(T a, T b) {
      return (a>b)?a:b;
   }

public:

   using FB::clear;

   /**
    * Initialise OLED peripheral
    *
    * @note   This function must be called before any drawing or updates!
    * @note   Based loosely on Adafruit library initialisation sequence
    */
   void initialise() {

      clear(WHITE);
      if (DISPLAY_TYPE == OledDisplayType::OledDisplayType_ssd1306) {
         if constexpr ((WIDTH == 128) && (HEIGHT == 32)) {

            i2c.transmit(I2C_ADDRESS, getInitSequence_ssd1306<0x02,0x10>());

         } else if constexpr ((WIDTH == 128) && (HEIGHT == 64)) {

            i2c.transmit(I2C_ADDRESS, getInitSequence_ssd1306<0x12,0x9F>());

         } else if constexpr ((WIDTH == 96) && (HEIGHT == 16)) {

            i2c.transmit(I2C_ADDRESS, getInitSequence_ssd1306<0x02,0xAF>());

         } else {
            __asm__("   bkpt");
         }
      }
      else if (DISPLAY_TYPE == OledDisplayType::OledDisplayType_sh1106) {
         if constexpr ((WIDTH == 128) && (HEIGHT == 64)) {

            i2c.transmit(I2C_ADDRESS, getInitSequence_sh1106<0x12,0x9F>());

         } else {
            __asm__("   bkpt");
         }
      }
      return;
   }

   /**
    * Turn display on or off
    */
   void enable(bool enable) {
      static const uint8_t onCommand[] = {
            Control_MULTIPLE_COMMANDS,            // Co = 0, D/C = 0
            Command_DISPLAYON,                    // 0xAF
      };
      static const uint8_t offCommand[] = {
            Control_MULTIPLE_COMMANDS,            // Co = 0, D/C = 0
            Command_DISPLAYOFF,                   // 0xAE
      };
      i2c.transmit(I2C_ADDRESS, enable?onCommand:offCommand);
   }

   /**
    * Control display contrast/brightness
    *
    *  Has no appreciable effect on display tested
    *
    * @param level
    */
   void setContrast(uint8_t level) {
      uint8_t contrastCommand[] = {
            Control_MULTIPLE_COMMANDS,            // Co = 0, D/C = 0
            Command_SETCONTRAST,                  // 0x81
            level,
      };
      i2c.transmit(I2C_ADDRESS, contrastCommand);
   }

   /**
    * Refresh OLED from frame buffer
    */
   void refreshImage() {
      if constexpr (IMAGE_PAGE_COUNT==0) {
         // Transmit as a single image
         static const uint8_t preamble[] = {
               Control_MULTIPLE_GDRAM,
         };
         i2c.transmitIncomplete(I2C_ADDRESS, preamble);
         i2c.transmit(I2C_ADDRESS, getFrameSize(), fb);
      }
      else {
         // Have to transmit a line at a time
         uint8_t *dataPtr = fb;

         for (uint8_t page=0; page<HEIGHT/8; page++) {
            // Each page
            uint8_t preamble[] = {
                  Control_SINGLE_COMMAND,                   // Co=1, D/C=0: Command byte followed by control byte
                  (uint8_t)(Command_SET_PAGE_ADDRESS|page), // Select page
                  Control_SINGLE_COMMAND,                   // Co=1, D/C=0: Command byte followed by control byte
                  Command_SETHIGHCOLUMN|0,
                  Control_SINGLE_COMMAND,                   // Co=1, D/C=0: Command byte followed by control byte
                  Command_SETLOWCOLUMN|2,
                  Control_MULTIPLE_GDRAM,                   // Co=0, D/C=1: Graphic data until I2C stop
            };
            // Select page, reset column, and set up for Graphic data
            i2c.transmitIncomplete(I2C_ADDRESS, preamble);
            // Graphic data
            i2c.transmit(I2C_ADDRESS, WIDTH, dataPtr);
            dataPtr += WIDTH;
         }
      }
   }

   /**
    *  Flush output data
    */
   virtual Oled_SSD1306 &flushOutput() override {
      refreshImage();
      return *this;
   }

   /**
    * Create OLED interface
    *
    * @param [in] i2c  I2C to use
    * @param [in] font Initial font to use
    */
   Oled_SSD1306(I2c &i2c, const Font *font=&font8x8) :
      FB(font, fb),
      i2c(i2c) {
      initialise();
   }

   ~Oled_SSD1306() = default;

};
} // namespace USBDM

#endif /* INCLUDE_USBDM_SSD1306 */

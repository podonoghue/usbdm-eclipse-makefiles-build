/****************************************************************************************************//**
 * @file     lcd.h
 *
 * @brief    Abstraction layer for Lcd interface
 *
 * @version  V2.0
 * @date     2025
 *
 *******************************************************************************************************/
#ifndef INCLUDE_USBDM_LCD_H_
#define INCLUDE_USBDM_LCD_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

#include "hardware.h"
#include "spi.h"
#include "fonts.h"
#include "formatted_io.h"

namespace USBDM {

//-------- <<< Use Configuration Wizard in Context Menu >>> -----------------

// Lcd Options ==============================
//
//   <o> Lcd PWM back-light support
//   <i> Enables the use of PWM to adjust the Lcd back-light
//   <i> This ties up one of the FTMs so is rather expensive to provide.
//     <0=> Back-light on/off only
//     <1=> Back-light adjustable
//     <0=> Default
/**
 * Controls if PWM feature is available for back-light
 */
#define LCD_BACKLIGHT_PWM_FEATURE 0

//------------- <<< end of configuration section >>> -----------------------

/**
 * Indicates the code should be for a ELEC FREAKS version of the Lcd
 */
#define ELEC_FREAKS

/**
 * @addtogroup LCD_Group Elecfreaks Liquid Crystal Display
 * @brief C++ Class allowing access Lcd
 * @{
 */

//********************************************************************
//
//   Lcd Dimension Definitions
//
//********************************************************************
constexpr int ROW_LENGTH       = 132;
constexpr int COL_HEIGHT       = 132;
constexpr int ENDPAGE          = 132;
constexpr int ENDCOL           = 130;

// Usable area
constexpr int LCD_X_MIN        = 1;
constexpr int LCD_X_MAX        = 130;
constexpr int LCD_Y_MIN        = 1;
constexpr int LCD_Y_MAX        = 130;

/**
 * Calculates colour as 16-bit value in 4:4:4 format
 *
 * @param r Red
 * @param g Green
 * @param b Blue
 */
constexpr uint16_t colour444(uint8_t r, uint8_t g, uint8_t b) {
   return ((r&0xF)<<8)|((g&0xF)<<4)|(b&0xF);
}
using Colour = uint16_t;

//*******************************************************
//   12-Bit Colour Definitions
//*******************************************************
constexpr Colour BLACK            = 0x000;
constexpr Colour NAVY             = 0x008;
constexpr Colour BLUE             = 0x00F;
constexpr Colour TEAL             = 0x088;
constexpr Colour EMERALD          = 0x0C5;
constexpr Colour GREEN            = 0x0F0;
constexpr Colour CYAN             = 0x0FF;
constexpr Colour SLATE            = 0x244;
constexpr Colour INDIGO           = 0x408;
constexpr Colour TURQUOISE        = 0x4ED;
constexpr Colour OLIVE            = 0x682;
constexpr Colour MAROON           = 0x800;
constexpr Colour PURPLE           = 0x808;
constexpr Colour GRAY             = 0x888;
constexpr Colour SKYBLUE          = 0x8CE;
constexpr Colour BROWN            = 0xB22;
constexpr Colour CRIMSON          = 0xD13;
constexpr Colour ORCHID           = 0xD7D;
constexpr Colour RED              = 0xF00;
constexpr Colour MAGENTA          = 0xF0F;
//constexpr Colour ORANGE           = 0xF40;
constexpr Colour PINK             = 0xF6A;
constexpr Colour CORAL            = 0xF75;
constexpr Colour SALMON           = 0xF87;
constexpr Colour ORANGE           = 0xFA0;
constexpr Colour GOLD             = 0xFD0;
constexpr Colour YELLOW           = 0xFF0;
constexpr Colour WHITE            = 0xFFF;

/**
 * Font settings object.
 *
 * Encapsulates the font and colours for text
 */
class FontSettings {

public:
   /// Font to use
   const Font   *font;

   /// Foreground colour
   Colour foregroundColour;

   /// Background colour
   Colour backgroundColour;

   /**
    * Constructor
    *
    * @param font             Font to use
    * @param foregroundColour Foreground colour
    * @param backgroundColour Background colour
    */
   constexpr FontSettings(
         const Font &font,
         Colour foregroundColour,
         Colour backgroundColour) : font(&font), foregroundColour(foregroundColour), backgroundColour(backgroundColour) {}

   /**
    * Set font
    *
    * @param font Font to use
    *
    * @return Reference to self
    */
   FontSettings &setFont(const Font &font) {
      this->font = &font;
      return *this;
   }

   /**
    * Set foreground colour
    *
    * @param colour Colour to use
    *
    * @return Reference to self
    */
   FontSettings &setForegroundColour(Colour colour) {
      this->foregroundColour = colour;
      return *this;
   }

   /**
    * Set background colour
    *
    * @param colour Colour to use
    *
    * @return Reference to self
    */
   FontSettings &setBackgroundColour(Colour colour) {
      this->backgroundColour = colour;
      return *this;
   }
};

//*******************************************************
//       Circle Definitions
//*******************************************************
constexpr unsigned SECTOR_0_45      = 0x01;
constexpr unsigned SECTOR_45_90     = 0x02;
constexpr unsigned SECTOR_90_135    = 0x04;
constexpr unsigned SECTOR_135_180   = 0x08;
constexpr unsigned SECTOR_180_225   = 0x10;
constexpr unsigned SECTOR_225_270   = 0x20;
constexpr unsigned SECTOR_270_315   = 0x40;
constexpr unsigned SECTOR_315_360   = 0x80;

constexpr unsigned QUAD_NORTH_EAST  = (SECTOR_0_45|SECTOR_45_90);
constexpr unsigned QUAD_NORTH_WEST  = (SECTOR_90_135|SECTOR_135_180);
constexpr unsigned QUAD_SOUTH_WEST  = (SECTOR_180_225|SECTOR_225_270);
constexpr unsigned QUAD_SOUTH_EAST  = (SECTOR_270_315|SECTOR_315_360);

constexpr unsigned FULLCIRCLE       = (QUAD_NORTH_EAST|QUAD_NORTH_WEST|QUAD_SOUTH_EAST|QUAD_SOUTH_WEST);
constexpr unsigned OPENSOUTH        = (QUAD_NORTH_EAST|QUAD_NORTH_WEST);
constexpr unsigned OPENNORTH        = (QUAD_SOUTH_EAST|QUAD_SOUTH_WEST);
constexpr unsigned OPENEAST         = (QUAD_NORTH_WEST|QUAD_SOUTH_WEST);
constexpr unsigned OPENWEST         = (QUAD_NORTH_EAST|QUAD_SOUTH_EAST);
constexpr unsigned OPENNORTHEAST    = (QUAD_NORTH_WEST|QUAD_SOUTH_EAST|QUAD_SOUTH_WEST);
constexpr unsigned OPENNORTHWEST    = (QUAD_NORTH_EAST|QUAD_SOUTH_EAST|QUAD_SOUTH_WEST);
constexpr unsigned OPENSOUTHEAST    = (QUAD_NORTH_EAST|QUAD_NORTH_WEST|QUAD_SOUTH_WEST);
constexpr unsigned OPENSOUTHWEST    = (QUAD_NORTH_EAST|QUAD_NORTH_WEST|QUAD_SOUTH_EAST);

constexpr unsigned DEFAULT_LCD_CONTRAST = 65;

/**
 * @brief Class representing an LCD
 *
 * <b>Example</b>
 * @code
 * // Instantiate interface
 * Lcd *lcd = new Lcd(new SPI_0());
 *
 * lcd.clear(RED);
 * lcd.drawCircle(65, 65, 20, WHITE);
 * lcd.drawCircle(65, 65, 30, WHITE);
 * lcd.drawCircle(65, 65, 40, WHITE);
 * lcd.putStr("Some Circles", 30, 10, Fonts::fontSmall, WHITE, RED);
 *
 *  @endcode
 */
class LcdBase : public FormattedIO {

   // Communication settings
   static constexpr Spi0::SerialInit serialInitValue {
      10_MHz ,               // (speed[0])                 Speed of interface
      SpiMode_0 ,            // (spi_ctar_mode[0])         Mode - Mode 0: CPOL=0, CPHA=0
      SpiFrameSize_9_bits ,  // (spi_ctar_fmsz[0])         SPI Frame sizes - 8 bits/transfer
      SpiBitOrder_MsbFirst,  // (spi_ctar_lsbfe[0])        Transmission order - MSB sent first
   };

   /* EPD SPI Signals (used for CD and CS during transfers) */
//   static constexpr SpiPeripheralSelect SpiPeripheralSelect_EpdCs = USBDM::SpiPeripheralSelect_Pcs1; // CS Active-low

protected:
   /** SPI interface used to communicate with LCD */
   USBDM::Spi &spi;

   // SPI Configuration to send data bytes
   const Spi::SpiCalculatedConfiguration spiConfig;

   int     fX = 0;
   int     fY = 0;
   FontSettings fSettings;

#ifdef __CMSIS_RTOS
   /** Mutex to protect access to LCD */
   CMSIS::Mutex mutex;

   void lock() {
      mutex.lock();
   }
   void unlock() {
      mutex.unlock();
   }
#else
   void lock() {
   }
   void unlock() {
   }
#endif

   static constexpr uint16_t  DATA_FLAG = 0x100;

   /**
    * Reset LCD
    */
   virtual void reset() = 0;

   /**
    * Send a single command byte to the display
    *
    * @param command Command byte to send
    */
   virtual void txCommand(uint8_t command) = 0;

   /**
    * Send a single data byte to the display
    *
    * @param data Data byte to send
    */
   virtual void txData(uint8_t data) = 0;

   /**
    * Send two pixels of a single colour to the display
    *
    * @param colour Colour to send
    */
   virtual void txTwoPixels(Colour colour) = 0;

   /**
    * Send a single colour block to the display
    *
    * @param colour Colour to send
    * @param size   Size of colour block
    */
   virtual void txColourBlock(Colour colour, unsigned size) = 0;

   /**
    *  Initialises the LCD
    */
   void init();

   /**
    * Sets the Row and Column addresses
    *
    * @param x Row address (0 .. 131)
    * @param y Column address (0 .. 131)
    */
   void setXY(unsigned x, unsigned y);

public:
   /**
    *  Constructor
    *
    *  @param spi   SPI interface to use to communicate with LCD
    */
   LcdBase(Spi &spi) :
      spi(spi),
      spiConfig(spi.calculateConfiguration(serialInitValue, SpiPeripheralSelect_None, SpiPeripheralSelectMode_Transfer)),
      fSettings(USBDM::font6x8, WHITE, BLACK) {

      // Set SPI CS polarity
//      spi.setPcsPolarityActiveLow(SpiPeripheralSelect_EpdCs);
   }

   virtual ~LcdBase() {
   }
#ifdef ELEC_FREAKS
   /**
    * Set back-light level
    *
    * @param  level  Level back-light level as percentage
    *
    * @note     Requires @ref LCD_BACKLIGHT_PWM_FEATURE to be fully implemented.\n
    *           Otherwise it falls back to basic on/off
    *
    * Note : Only available for elecfreaks version of shield
    */
   virtual void backlightSetLevel(unsigned level) = 0;
   /**
    * Turn LCD back-light on
    */
   void backlightOn(void) { backlightSetLevel(100); }
   /**
    * Turn LCD back-light off
    */
   void backLightOff(void) { backlightSetLevel(0); }
#endif

   /**
    * Set LCD contrast - range varies with device
    *
    *  @param setting - Contrast level (0..127) ?
    */
   virtual void setContrast(uint8_t setting);

   /**
    * This function will clear the screen to the given colour.
    *
    * @param colour - 12-bit colour value RRRRGGGGBBBB
    *
    * @author James P Lynch July 7, 2007
    */
   void clear(Colour colour);

   /** This function will clear the screen to the default background colour.
    */
   void clear() { clear(fSettings.backgroundColour); }

   /**
    * Draws a single pixel in the specified colour at the specified x and y addresses
    *
    * @param  x     - row address (0 .. 131)
    * @param  y     - column address (0 .. 131)
    * @param  colour - 12-bit colour value RRRRGGGGBBBB
    *
    * @note See lcd.h for some sample colour settings
    *
    * @author James P Lynch July 7, 2007
    */
   void drawPixel(unsigned x, unsigned y, Colour colour);

   /** Draws a single pixel in the current foreground colour.
    *
    * @param  x      Row address (0 .. 131)
    * @param  y      Column address (0 .. 131)
    *
    * @note See lcd.h for some sample colour settings
    */
   void drawPixel(unsigned x, unsigned y) {
      drawPixel(x, y, fSettings.foregroundColour);
   }

   /**
    * Draws a line in the specified colour from (x0,y0) to (x1,y1)
    *
    * @param x0       Top-left-X
    * @param y0       Top-left-Y
    * @param x1       Bottom-right-X
    * @param y1       Bottom-right-Y
    * @param colour   Colour
    *
    * @author James P Lynch July 7, 2007
    *
    * @note Good write-up on this algorithm in Wikipedia (search for Bresenham's line algorithm)
    * @note See lcd.h for some sample colour settings
    *
    * @author Authors: Dr. Leonard McMillan, Associate Professor UNC \n
    *                  Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
    *
    * @note Taken verbatim from Professor McMillan's presentation: \n
    *       http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
    */
   void drawLine(unsigned x0, unsigned y0, unsigned x1, unsigned y1, Colour colour);

   /** Draws a line in the foreground colour from (x0,y0) to (x1,y1)
    *
    * @param  x0      Row address (0 .. 131)
    * @param  y0      Column address (0 .. 131)
    * @param  x1      Row address (0 .. 131)
    * @param  y1      Column address (0 .. 131)
    */
   void drawLine(unsigned x0, unsigned y0, unsigned x1, unsigned y1) {
      drawLine(x0, y0, x1, y1, fSettings.foregroundColour);
   }

   /**
    *  Draws a rectangle in the specified colour from (x1,y1) to (x2,y2)\n
    *  Rectangle can be filled with a colour if desired
    *
    * @param  x0     Row address (0 .. 131)
    * @param  y0     Column address (0 .. 131)
    * @param  x1     Row address (0 .. 131)
    * @param  y1     Column address (0 .. 131)
    * @param  fill    Indicates if the rectangle will be filled
    * @param  colour 12-bit colour value RRRRGGGGBBBB
    *
    * note See lcd.h for some sample colour settings
    *
    * author James P Lynch July 7, 2007
    *
    * note
    *    The best way to fill a rectangle is to take advantage of the "wrap-around" feature
    *    built into the Philips PCF8833 controller. By defining a drawing box, the memory can
    *    be simply filled by successive memory writes until all pixels have been illuminated.
    *
    *    1. Given the coordinates of two opposing corners (x0, y0) (x1, y1)
    *       calculate the minimums and maximums of the coordinates
    *
    *       xmin = (x0 <= x1) ? x0 : x1;
    *       xmax = (x0 > x1) ? x0 : x1;
    *       ymin = (y0 <= y1) ? y0 : y1;
    *       ymax = (y0 > y1) ? y0 : y1;
    *
    *    2. Now set up the drawing box to be the desired rectangle
    *
    *       LCDCommand(PASET); // set the row boundaries
    *       LCDData(xmin);
    *       LCDData(xmax);
    *       LCDCommand(CASET); // set the column boundaries
    *       LCDData(ymin);
    *       LCDData(ymax);
    *
    *    3. Calculate the number of pixels to be written divided by 2
    *
    *       NumPixels = ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1)
    *
    *       You may notice that I added one pixel to the formula.
    *       This covers the case where the number of pixels is odd and we
    *       would lose one pixel due to rounding error. In the case of
    *       odd pixels, the number of pixels is exact.
    *       in the case of even pixels, we have one more pixel than
    *       needed, but it cannot be displayed because it is outside
    *       the drawing box.
    *
    *       We divide by 2 because two pixels are represented by three bytes.
    *       So we work through the rectangle two pixels at a time.
    *
    *    4. Now a simple memory write loop will fill the rectangle
    *
    *       for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1); i++) {
    *          LCDData((colour >> 4) & 0xFF);
    *          LCDData(((colour & 0xF) << 4) | ((colour >> 8) & 0xF));
    *          LCDData(colour & 0xFF);
    *       }
    *
    *       In the case of an unfilled rectangle, drawing four lines with the Bresenham line
    *       drawing algorithm is reasonably efficient.
    */
   void drawRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1, bool fill, Colour colour);

   /** Draws a rectangle in the foreground colour from (x1,y1) to (x2,y2)\n
    *  Rectangle can be filled with a colour if desired
    *
    * @param  x0      Row address (0 .. 131)
    * @param  y0      Column address (0 .. 131)
    * @param  x1      Row address (0 .. 131)
    * @param  y1      Column address (0 .. 131)
    * @param  fill    Indicates if the rectangle will be filled
    */
   void drawRect(unsigned x0, unsigned y0, unsigned x1, unsigned y1, bool fill) {
      drawRect(x0, y0, x1, y1, fill, fSettings.foregroundColour);
   }

   /**
    * Draws a line circle in the specified colour at center (x0,y0) with radius
    *
    * @param centreX      Row address (0 .. 131)
    * @param centreY      Column address (0 .. 131)
    * @param radius       Radius in pixels
    * @param colour       12-bit colour value RRRRGGGGBBBB
    * @param circleType   Controls which segments of the circle are drawn
    *
    * @author Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
    *
    * @note Taken verbatim Wikipedia article on Bresenham's line algorithm \n
    *        http://www.wikipedia.org
    */
   void drawCircle(unsigned centreX, unsigned centreY, unsigned radius, Colour colour, unsigned circleType=FULLCIRCLE);

   /**
    * Draws a filled circle
    *
    * @param centreX      Circle centre-X in pixels
    * @param centreY      Circle centre-Y in pixels
    * @param radius       Radius in pixels
    * @param colour       12-bit colour value RRRRGGGGBBBB
    */
   void drawFilledCircle(unsigned centreX, unsigned centreY, unsigned radius, Colour colour);

   /**
    * Writes the entire LCD screen from a bmp file
    *
    * @param bmp - bitmap to display
    *
    * @author Olimex, James P Lynch July 7, 2007
    *
    * @note Use Olimex BmpToArray.exe utility to create bitmap
    */
   void drawBitmap(uint8_t bmp[131*131]);

   /**
    * Draws an ASCII character at the specified (x,y) address, font and foreground colour and current background
    *
    * @param c                 Character to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    * @param font              Font to use (Lcd::fontSmall, Lcd::fontMedium, Lcd::fontLarge)
    * @param foregroundColour  12-bit foreground colour value RRRRGGGGBBBB
    * @param backgroundColour  12-bit background colour value RRRRGGGGBBBB
    *
    * @verbatim
    * Notes: Here's an example to display "E" at address (20,20)
    *
    *           LCDPutChar('E', 20, 20, MEDIUM, WHITE, BLACK);
    *
    *                (27,20)       (27,27)
    *                   |             |
    *                   |             |
    *                 ^ V             V
    *                 : _ # # # # # # #   0x7F
    *                 : _ _ # # _ _ _ #   0x31
    *                 : _ _ # # _ # _ _   0x34
    *                 x _ _ # # # # _ _   0x3C
    *                 : _ _ # # _ # _ _   0x34
    *                 : _ _ # # _ _ _ #   0x31
    *                 : _ # # # # # # #   0x7F
    *                 : _ _ _ _ _ _ _ _   0x00
    *
    *                   ------y------->
    *                   ^             ^
    *                   |             |
    *                   |             |
    *                (20,20)       (20,27)
    *
    *
    *    The most efficient way to display a character is to make use of the "wrap-around" feature
    *    of the Philips PCF8833 LCD controller chip.
    *
    *    Assume that we position the character at (20, 20) that's a (row, col) specification.
    *    With the row and column address set commands, you can specify an 8x8 box for the SMALL and MEDIUM
    *    characters or a 16x8 box for the LARGE characters.
    *
    *            spi_txCommand(PASET);   // set the row drawing limits
    *            spi_txData(20);         //
    *            spi_txData(27);         // limit rows to (20, 27)
    *
    *            spi_txCommand(CASET);   // set the column drawing limits
    *            spi_txData(20);         //
    *            spi_txData(27);         // limit columns to (20,27)
    *
    *    When the algorithm completes col 27, the column address wraps back to 20
    *    At the same time, the row address increases by one (this is done by the controller)
    *
    *    We walk through each row, two pixels at a time. The purpose is to create three
    *    data bytes representing these two pixels in the following format (as specified by Philips
    *    for RGB 4 : 4 : 4 format (see page 62 of PCF8833 controller manual).
    *
    *            Data for pixel 0: RRRRGGGGBBBB
    *            Data for Pixel 1: RRRRGGGGBBBB
    *
    *            spi_txCommand(RAMWR);                 // start a memory write (96 data bytes to follow)
    *
    *            spi_txData(RRRRGGGG);                 // first pixel, red and green data
    *            spi_txData(BBBBRRRR);                 // first pixel, blue data; second pixel, red data
    *            spi_txData(GGGGBBBB);                 // second pixel, green and blue data
    *            :
    *            and so on until all pixels displayed!
    *            :
    *            spi_txCommand(NOP);                   // this will terminate the RAMWR command
    *
    *  @endverbatim
    *
    *  @author James P Lynch July 7, 2007
    */
   void putChar(char c, unsigned x, unsigned y, const Font &font, Colour foregroundColour, Colour backgroundColour);

   /**
    * Draws an ASCII character at the specified (x,y) address, font and foreground colour and current background
    *
    * @param c                 Character to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    * @param font              Font to use (Lcd::fontSmall, Lcd::fontMedium, Lcd::fontLarge)
    * @param foregroundColour  12-bit foreground colour value RRRRGGGGBBBB
    */
   void putChar(char c, unsigned x, unsigned y, const Font &font, Colour foregroundColour) {
      putChar(c, x, y, font, foregroundColour, fSettings.backgroundColour);
   }

   /** Draws an ASCII character at the specified (x,y) address, font and current colours
    *
    * @param c        Character to be displayed
    * @param x        Row address (0 .. 131)
    * @param y        Column address (0 .. 131)
    * @param font     Font pitch (Lcd::fontSmall, Lcd::fontMedium, Lcd::fontLarge)
    */
   void putChar(char c, unsigned x, unsigned y, const Font &font) {
      putChar(c, x, y, font, fSettings.foregroundColour, fSettings.backgroundColour);
   }

   /** Draws an ASCII character at the specified (x,y) address and colours using the currently set font and colours
    *
    * @param c        Character to be displayed
    * @param x        Row address (0 .. 131)
    * @param y        Column address (0 .. 131)
    */
   void putChar(char c, unsigned x, unsigned y) {
      putChar(c, x, y, *fSettings.font, fSettings.foregroundColour, fSettings.backgroundColour);
   }

   /**
    * Draws a nul-terminated character string at the specified (x,y) address and colour
    *
    * @param str                Character string to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    * @param font              Font to use (Lcd::fontSmall, Lcd::fontMedium, Lcd::fontLarge)
    * @param foregroundColour  12-bit foreground colour value RRRRGGGGBBBB
    * @param backgroundColour  12-bit background colour value RRRRGGGGBBBB
    *
    * @code{.c}
    *       // Here's an example to display "Hello World!" at address (20,20)
    *
    *       lcd_putStr("Hello World!", 20, 20, WHITE, BLACK);
    * @endcode
    *
    * @author James P Lynch, August 30, 2007 \n
    *         Edited by Peter Davenport on August 23, 2010
    *
    * @note For more information on how this code does it's thing look at this \n
    *       "http://www.sparkfun.com/tutorial/Nokia%206100%20LCD%20Display%20Driver.pdf"
    */
   void putStr(const char *str, unsigned x, unsigned y, const Font &font, Colour foregroundColour, Colour backgroundColour);

   /** Draws a nul-terminated character string at the specified (x,y) address and colours using the current font
    *
    * @param str               Character string to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    * @param foregroundColour  12-bit foreground colour value RRRRGGGGBBBB
    * @param backgroundColour  12-bit background colour value RRRRGGGGBBBB
    */
   void putStr(const char *str, unsigned x, unsigned y, Colour foregroundColour, Colour backgroundColour) {
      putStr(str, x, y, *fSettings.font, foregroundColour, backgroundColour);
   }

   /** Draws a nul-terminated character string at the specified (x,y) address and colours using the current font
    *
    * @param str               Character string to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    * @param foregroundColour  12-bit foreground colour value RRRRGGGGBBBB
    */
   void putStr(const char *str, unsigned x, unsigned y, Colour foregroundColour) {
      putStr(str, x, y, *fSettings.font, foregroundColour, fSettings.backgroundColour);
   }

   /** Draws a nul-terminated character string at the specified (x,y) address and colours using the current font
    *
    * @param str               Character string to be displayed
    * @param x                 Row address (0 .. 131)
    * @param y                 Column address (0 .. 131)
    */
   void putStr(const char *str, unsigned x, unsigned y) {
      putStr(str, x, y, *fSettings.font, fSettings.foregroundColour, fSettings.backgroundColour);
   }

   int  _readChar() override { return -1;}
   bool _isCharAvailable() override { return false; }
   LcdBase &flushInput() override { return *this; }
   LcdBase &flushOutput() override { return *this; }

public:
   /**
    * Set text font
    *
    * @param font Font to use
    *
    * @return reference to self
    */
   LcdBase &setFont(const Font &font) {
      fSettings.font = &font;
      return *this;
   }

   /**
    * Set text foreground colour
    *
    * @param colour  Colour to use
    *
    * @return reference to self
    */
   LcdBase &setForeground(Colour colour) {
      fSettings.foregroundColour = colour;
      return *this;
   }

   /**
    * Set text background colour
    *
    * @param colour  Colour to use
    *
    * @return reference to self
    */
   LcdBase &setBackground(Colour colour) {
      fSettings.backgroundColour = colour;
      return *this;
   }

   /**
    * Move text cursor
    *
    * @param x X position of lower left
    * @param y Y position of lower left
    *
    * @return reference to self
    */
   LcdBase &moveXY(unsigned x, unsigned y) {
      fX = x;
      fY = y;
      return *this;
   }

   /**
    * Get current X location
    *
    * @return X location in pixels
    */
   int getX() {
      return fX;
   }

   /**
    * Get current Y location
    *
    * @return Y location in pixels
    */
   int getY() {
      return fY;
   }

   /**
    * Get current X,Y location
    *
    * @param [out] x X location in pixels
    * @param [out] y Y location in pixels
    *
    * @return Reference to self
    */
   LcdBase &getXY(int &x, int &y) {
      x = this->fX;
      y = this->fY;
      return *this;
   }

   /**
    * Get current text settings
    *
    * @return Text settings
    */
   FontSettings getTextSettings() {
      return fSettings;
   }

   /**
    * Set current text settings
    *
    * @param settings Settings to use
    */
   void setTextSettings(FontSettings settings) {
      fSettings = settings;
   }

   /**
    * Does newline - move to start of next line
    */
   void _newline() {
      if (fY > (LCD_Y_MIN+fSettings.font->height)) {
         fY -= fSettings.font->height;
         fX = LCD_X_MIN;
      }
   }

   /**
    * Writes a character (blocking)
    *
    * @param[in]  ch - character to send
    */
   void _writeChar(char ch) override {
      // Keep on screen
      if (ch == '\n') {
         // Convert to => \n\r
         _newline();
      }
      else if (ch == '\r') {
         fX = LCD_X_MIN;
      }
      else {
         if (fX >= LCD_X_MAX) {
            _newline();
         }
         putChar(ch, fX, fY, *fSettings.font, fSettings.foregroundColour, fSettings.backgroundColour);
         fX += fSettings.font->width;
      }
   }
};

/**
 * Template for LCD
 *
 * @tparam SpiCS_n   Display CS     (D9 on Arduino)
 * @tparam Reset_n   Display reset  (D8 on Arduino)
 * @tparam BackLight Display back-light control (may be PWM) (D10 on Arduino)
 */
template<typename SpiCS_n, typename Reset_n, typename BackLight>
class Lcd_T : public LcdBase {

public:
   /**
    *  Constructor
    *
    *  Initialises the LCD
    *
    *  @param spi The SPI interface to use to communicate with LCD
    */
   Lcd_T(Spi &spi) : LcdBase(spi) {
      // Chip select pin
      SpiCS_n::setOutput();
      SpiCS_n::high();         // Set idle high

      // LCD Reset pin
      Reset_n::setOutput();
      Reset_n::high();

      init();
   }

   /**
    * Reset LCD
    */
   virtual void reset() override  {
      // Reset display
      //      SpiCS_n::low();
      Reset_n::low();
      waitMS(2);
      Reset_n::high();
      SpiCS_n::high();
      waitMS(20);
   }

   /**
    * Send a single command byte to the display
    *
    * @param command Command byte to send
    */
   virtual void txCommand(uint8_t command) override {
      spi.startTransaction(spiConfig);
      SpiCS_n::low();
      spi.txRx(command);
      SpiCS_n::high();
      spi.endTransaction();
   }

   /**
    * Send a single data byte to the display
    *
    * @param data Data byte to send
    */
   virtual void txData(uint8_t data) override {
      spi.startTransaction(spiConfig);
      SpiCS_n::low();
      spi.txRx(DATA_FLAG|data);
      SpiCS_n::high();
      spi.endTransaction();
   }

   /**
    * Send two pixels of a single colour to the display
    *
    * @param colour Colour to send
    */
   virtual void txTwoPixels(Colour colour) override {
      // Construct RRRRGGGG|BBBBRRRR|GGGGBBBB in 3 bytes = 2 pixels
      uint16_t data1 = DATA_FLAG|(colour >> 4);
      uint16_t data2 = DATA_FLAG|(((colour & 0xF) << 4) | ((colour >> 8) & 0xF));
      uint16_t data3 = DATA_FLAG|(colour & 0xFF);

      spi.startTransaction(spiConfig);
      SpiCS_n::low();
      spi.txRx(data1);
      spi.txRx(data2);
      spi.txRx(data3);
      SpiCS_n::high();
      spi.endTransaction();
   }

   /**
    * Send a single colour multiple times to the display (multiple of 2 pixels)
    *
    * @param colour Colour to send
    * @param size   Size of colour block (even)
    */
   virtual void txColourBlock(Colour colour, unsigned size) override {
      // Construct RRRRGGGG|BBBBRRRR|GGGGBBBB in 3 bytes = 2 pixels
      uint16_t data1 = DATA_FLAG|(colour >> 4);
      uint16_t data2 = DATA_FLAG|(((colour & 0xF) << 4) | ((colour >> 8) & 0xF));
      uint16_t data3 = DATA_FLAG|(colour & 0xFF);

      spi.startTransaction(spiConfig);
      SpiCS_n::low();
      size = (size+1)/2;
      while(size-->0) {
         spi.txRx(data1);
         spi.txRx(data2);
         spi.txRx(data3);
      }
      SpiCS_n::high();
      spi.endTransaction();
   }

#ifdef ELEC_FREAKS
   /**
    * Set back-light level
    *
    * @param level 0-100 back-light level as percentage
    */
   virtual void backlightSetLevel(unsigned level) {
#if LCD_BACKLIGHT_PWM_FEATURE
      BackLight::setMode(1000, tmr_leftAlign);
      if (level>100) {
         level = 100;
      }
      if (level<0) {
         level = 0;
      }
      BackLight::setDutyCycle(level);
#else
      BackLight::setOutput();
      BackLight::write(level>0);
#endif
   }
#endif

};

/**
 * @brief Class representing an LCD\n
 * Convenience type for typical Arduino shield LCD
 *
 * <b>Example</b>
 * @code
 * // Instantiate interface
 * Lcd *lcd = new Lcd(new SPI_0());
 *
 * lcd.clear(RED);
 * lcd.drawCircle(65, 65, 20, WHITE);
 * lcd.drawCircle(65, 65, 30, WHITE);
 * lcd.drawCircle(65, 65, 40, WHITE);
 * lcd.putStr("Some Circles", 30, 10, Fonts::fontSmall, WHITE, RED);
 *
 *  @endcode
 */
#if LCD_BACKLIGHT_PWM_FEATURE
// PWM control for back-light brightness
using Lcd = Lcd_T<USBDM::Lcd_CS, USBDM::Lcd_Reset, USBDM::Ftm0<1>>;
#else
// On/Off control of back-light
using Lcd = Lcd_T<USBDM::Lcd_CS, USBDM::Lcd_Reset, USBDM::Lcd_BackLight>;
#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_LCD_H_ */

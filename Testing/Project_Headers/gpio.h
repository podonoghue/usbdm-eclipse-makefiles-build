/**
 * @file     gpio.h (180.ARM_Peripherals/Project_Headers/gpio-MK.h)
 * @brief    General Purpose Input/Output
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */

#ifndef HEADER_GPIO_H
#define HEADER_GPIO_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include "derivative.h"
#ifdef RELEASE_BUILD
#include "bitband.h"
#endif

/*
 * Default port information
 */
#ifndef FIXED_PORT_CLOCK_REG
#define FIXED_PORT_CLOCK_REG SCGC5
#endif

namespace USBDM {

/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief General Purpose Input/Output
 * @{
 */

/**
 * @brief Template representing a pin with Digital I/O capability
 *
 * <b>Example</b>
 * @code
 * // Instantiate
 * using Pta3 = USBDM::GpioBase_T<SIM_SCGC5_PORTA_MASK, PORTA_BasePtr, PORTA_IRQn, GPIOA_BasePtr, 3, ActiveHigh>;
 *
 * // Set as digital output
 * Pta3::setOutput();
 *
 * // Set pin high
 * Pta3::set();
 *
 * // Set pin low
 * Pta3::clear();
 *
 * // Toggle pin
 * Pta3::toggle();
 *
 * // Set pin to boolean value
 * Pta3::write(true);
 *
 * // Set pin to boolean value
 * Pta3::write(false);
 *
 * // Set as digital input
 * Pta3::setInput();
 *
 * // Read pin as boolean value
 * bool x = Pta3::read();
 *
 * @endcode
 *
 *
 * @tparam clockInfo             Clock mask for PORT (PCR register) associated with GPIO
 * @tparam portAddress           Address of PORT (PCR register array) associated with GPIO
 * @tparam irqNum                IRQ number for pin interrupt
 * @tparam gpioAddress           GPIO hardware address
 * @tparam defPcrValue           Default value for PCR (including MUX value)
 * @tparam defaultNvicPriority   Default interrupt priority.\n
 *                               NvicPriority_NotInstalled indicates PORT not configured for interrupts.
 * @tparam bitNum                Bit number within PORT/GPIO
 * @tparam polarity              Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<uint32_t clockInfo, uint32_t portAddress, IRQn_Type irqNum, uint32_t gpioAddress, uint32_t defPcrValue, NvicPriority defaultNvicPriority, int bitNum, Polarity polarity>
class GpioBase_T : public Pcr_T<clockInfo, portAddress, irqNum, defPcrValue, defaultNvicPriority, bitNum> {
   static_assert((static_cast<unsigned>(bitNum)<=31), "Illegal bit number in Gpio");

private:
   /**
    * This class is not intended to be instantiated
    */
   GpioBase_T() = delete;
   GpioBase_T(const GpioBase_T&) = delete;
   GpioBase_T(GpioBase_T&&) = delete;

public:
   /** PCR associated with this GPIO pin */
   using Pcr = Pcr_T<clockInfo, portAddress, irqNum, defPcrValue, defaultNvicPriority, bitNum>;

   /** Get base address of GPIO hardware as pointer to struct */
   static volatile GPIO_Type &gpio() { return *reinterpret_cast<volatile GPIO_Type *>(gpioAddress); }

   /** Get base address of GPIO hardware as uint32_t */
   static constexpr uint32_t gpioBase() { return gpioAddress; }
   /** Get base address of GPIO.PDOR register as uint32_t */
   static constexpr uint32_t gpioPDOR() { return gpioBase() + offsetof(GPIO_Type, PDOR); }
   /** Get base address of GPIO.PSOR register as uint32_t */
   static constexpr uint32_t gpioPSOR() { return gpioBase() + offsetof(GPIO_Type, PSOR); }
   /** Get base address of GPIO.PCOR register as uint32_t */
   static constexpr uint32_t gpioPCOR() { return gpioBase() + offsetof(GPIO_Type, PCOR); }
   /** Get base address of GPIO.PTOR register as uint32_t */
   static constexpr uint32_t gpioPTOR() { return gpioBase() + offsetof(GPIO_Type, PTOR); }
   /** Get base address of GPIO.PDIR register as uint32_t */
   static constexpr uint32_t gpioPDIR() { return gpioBase() + offsetof(GPIO_Type, PDIR); }
   /** Get base address of GPIO.PDDR register as uint32_t */
   static constexpr uint32_t gpioPDDR() { return gpioBase() + offsetof(GPIO_Type, PDDR); }

#ifdef PORT_DFCR_CS_MASK
   /** Get base address of PORT hardware as pointer to struct */
   static volatile PORT_DFER_Type &port() { return *reinterpret_cast<volatile PORT_DFER_Type *>(gpioAddress); }
   /** Get base address of PORT register as uint32_t */
   static constexpr uint32_t portBase() { return gpioAddress; }
   /** Get base address of PORT.PCR register as uint32_t */
   static constexpr uint32_t portPCR(int index) { return portBase() + offsetof(PORT_DFER_Type, PCR[index]); }
   /** Get base address of PORT.GPCLR registers as uint32_t */
   static constexpr uint32_t portGPCLR() { return portBase() + offsetof(PORT_DFER_Type, GPCLR); }
   /** Get base address of PORT.GPCHR registers as uint32_t */
   static constexpr uint32_t portGPCHR() { return portBase() + offsetof(PORT_DFER_Type, GPCHR); }
   /** Get base address of PORT.ISFR registers as uint32_t */
   static constexpr uint32_t portISFR() { return portBase() + offsetof(PORT_DFER_Type, ISFR); }
#else
   /** Get base address of PORT hardware as pointer to struct */
   static volatile PORT_Type &port() { return *reinterpret_cast<volatile PORT_Type *>(gpioAddress); }
   /** Get base address of PORT register as uint32_t */
   static constexpr uint32_t portBase() { return gpioAddress; }
   /** Get base address of PORT.PCR register as uint32_t */
   static constexpr uint32_t portPCR(int index) { return portBase() + offsetof(PORT_Type, PCR[index]); }
   /** Get base address of PORT.GPCLR registers as uint32_t */
   static constexpr uint32_t portGPCLR() { return portBase() + offsetof(PORT_Type, GPCLR); }
   /** Get base address of PORT.GPCHR registers as uint32_t */
   static constexpr uint32_t portGPCHR() { return portBase() + offsetof(PORT_Type, GPCHR); }
   /** Get base address of PORT.ISFR registers as uint32_t */
   static constexpr uint32_t portISFR() { return portBase() + offsetof(PORT_Type, ISFR); }
#endif

   /** Polarity of pin */
   static constexpr Polarity POLARITY = polarity;

   /**
    * Set pin as digital I/O.
    * Pin is initially set as an input.
    * Use SetIn() and SetOut() to change direction.
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pcrValue PCR value to use in configuring pin (excluding MUX value). See pcrValue()
    */
   static void setInOut(PcrValue pcrValue) {
      // Make input initially
      setIn();
      // Set inactive pin state (if later made output)
      setInactive();
      Pcr::setPCR(pcrValue);
   }
   /**
    * Set pin as digital I/O.
    * Pin is initially set as an input.
    * Use SetIn() and SetOut() to change direction.
    * If open-drain then input function may meaningfully be used while set as output
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setInOut(
         PinPull           pinPull           = PinPull_None,
         PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinAction         pinAction         = PinAction_None,
         PinFilter         pinFilter         = PinFilter_None,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
   ) {
      // Make input initially
      setIn();
      // Set inactive pin state (if later made output)
      setInactive();
      // Configure PCR
      Pcr::setPCR(pinPull|pinDriveStrength|pinDriveMode|pinAction|pinFilter|pinSlewRate);
      }
   /**
    * Set pin as digital output
    *
    * @note Does not affect other pin settings
    */
   static void setOut() {
      // Make pin an output
#ifdef RELEASE_BUILD
      bitbandSet(gpio().PDDR, bitNum);
#else
      gpio().PDDR |= Pcr::BITMASK;
#endif
   }
   /**
    * Enable pin as digital output with initial inactive level.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding MUX value). See pcrValue()
    */
   static void setOutput(PcrValue pcrValue) {
      // Set initial level before enabling pin drive
      setInactive();
      // Make pin an output
      setOut();
      // Configure pin
      Pcr::setPCR(pcrValue);
   }
   /**
    * @brief
    * Enable pin as digital output with initial inactive level.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Resets the pin value to the inactive state
    * @note Use setOut() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Slow)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
   ) {
      // Set initial level before enabling pin drive
      setInactive();
      // Make pin an output
      setOut();
      // Configure pin
      Pcr::setPCR(pinDriveStrength|pinDriveMode|pinSlewRate);
      }
   /**
    * Set pin as digital input
    *
    * @note Does not affect other pin settings
    */
   static void setIn() {
      // Make pin an input
#ifdef RELEASE_BUILD
      bitbandClear(gpio().PDDR, bitNum);
#else
      gpio().PDDR &= ~Pcr::BITMASK;
#endif
   }
   /**
    * @brief
    * Enable pin as digital input.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Resets the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding MUX value)
    */
   static void setInput(PcrValue pcrValue) {
      // Make pin an input
      setIn();
      Pcr::setPCR(pcrValue);
   }
   /**
    * @brief
    * Enable pin as digital input.\n
    * Configures all Pin Control Register (PCR) values
    *
    * @note Reset the Pin Control Register value (PCR value).
    * @note Use setIn() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull           = PinPull_None,
         PinAction         pinAction         = PinAction_None,
         PinFilter         pinFilter         = PinFilter_None
   ) {
      // Make pin an input
      setIn();
      Pcr::setPCR(pinPull|pinAction|pinFilter);
      }
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void high() {
      gpio().PSOR = Pcr::BITMASK;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void low() {
      gpio().PCOR = Pcr::BITMASK;
   }
   /**
    * Set pin. Pin will be high if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void set() {
      gpio().PSOR = Pcr::BITMASK;
   }
   /**
    * Clear pin. Pin will be low if configured as an output.
    *
    * @note Polarity _is_ _not_ significant
    * @note Don't use this method unless dealing with very low-level I/O
    */
   static void clear() {
      gpio().PCOR = Pcr::BITMASK;
   }
   /**
    * Toggle pin (if output)
    */
   static void toggle() {
      gpio().PTOR = Pcr::BITMASK;
   }
   /**
    * Set pin to active level (if configured as output)
    *
    * @note Polarity _is_ significant
    */
   static void setActive() {
      if constexpr (polarity) {
         set();
      }
      else {
         clear();
      }
   }
   /**
    * Set pin to inactive level (if configured as output)
    *
    * @note Polarity _is_ significant
    */
   static void setInactive() {
      if constexpr (polarity) {
         clear();
      }
      else {
         set();
      }
   }
   /**
    * Set pin to active level (if configured as output).
    * Convenience method for setActive()
    *
    * @note Polarity _is_ significant
    */
   static void __attribute__((always_inline)) on() {
      setActive();
   }
   /**
    * Set pin to inactive level (if configured as output).
    * Convenience method for setInactive()
    *
    * @note Polarity _is_ significant
    */
   static void __attribute__((always_inline)) off() {
      setInactive();
   }
   /**
    * Write boolean value to pin (if configured as output)
    *
    * @param[in] value true/false value
    *
    * @note Polarity _is_ significant
    */
   static void write(bool value) {
#ifdef RELEASE_BUILD
      if constexpr (polarity) {
         bitbandWrite(gpio().PDOR, bitNum, value);
      }
      else {
         bitbandWrite(gpio().PDOR, bitNum, !value);
      }
#else
      if (value) {
         setActive();
      }
      else {
         setInactive();
      }
#endif
   }
   /**
    * Checks if pin is high
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   static bool isHigh() {
      return (gpio().PDIR & Pcr::BITMASK) != 0;
   }
   /**
    * Checks if pin is low
    *
    * @return true/false reflecting value on pin
    *
    * @note This reads the PDIR
    * @note Polarity _is_ _not_ significant
    */
   static bool isLow() {
      return (gpio().PDIR & Pcr::BITMASK) == 0;
   }
   /**
    * Read pin value
    *
    * @return true/false reflecting pin value.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool read() {
      if constexpr (polarity) {
         return isHigh();
      }
      else {
         return isLow();
      }
   }
   /**
    * Read pin value and return true if active level.
    * Equivalent to read()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isActive() {
      return read();
   }
   /**
    * Read pin value and return true if inactive level
    * Equivalent to !read()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isInactive() {
      return !read();
   }
   /**
    * Read pin value and return true if active level.\n
    * Convenience method equivalent to isActive()
    *
    * @return true/false reflecting if pin is active.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isPressed() {
      return isActive();
   }
   /**
    * Read pin value and return true if inactive level.\n
    * Convenience method equivalent to isInactive()
    *
    * @return true/false reflecting if pin is inactive.
    *
    * @note This reads the PDIR
    * @note Polarity _is_ significant
    */
   static bool __attribute__((always_inline)) isReleased() {
      return isInactive();
   }
   /**
    * Read value being driven to pin (if configured as output)
    *
    * @return true/false reflecting value in output register.
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   static bool readState() {
      uint32_t t = gpio().PDOR & Pcr::BITMASK;
      if constexpr (polarity) {
         return t;
      }
      else {
         return !t;
      }
   }
};

/**
 * Create GPIO from Peripheral Info class info table
 *
 * @tparam Info          Peripheral information class
 * @tparam index         Index of signal within the info table
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<class Info, const uint32_t index, Polarity polarity>
using  GpioTable_T = GpioBase_T<Info::info[index].clockInfo, Info::info[index].portAddress, Info::info[index].irqNum, Info::info[index].gpioAddress, GPIO_DEFAULT_PCR, Info::info[index].irqLevel, Info::info[index].gpioBit, polarity>;
/**
 * @brief Template representing a field within a port
 *
 * <b>Example</b>
 * @code
 * // Instantiate object representing Port A 6 down to 3
 * using Pta6_3 = Field_T<GpioAInfo, 6, 3>;
 *
 * // Set as digital output
 * Pta6_3::setOutput();
 *
 * // Write value to field
 * Pta6_3::write(0x53);
 *
 * // Clear all of field
 * Pta6_3::bitClear();
 *
 * // Clear lower two bits of field
 * Pta6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * Pta6_3::bitSet(0x3);
 *
 * // Set as digital input
 * Pta6_3::setInput();
 *
 * // Read pin as int value
 * int x = Pta6_3::read();
 * @endcode
 *
 * @tparam Info           Class describing the associated GPIO and PORT
 * @tparam left           Bit number of leftmost bit in GPIO (inclusive)
 * @tparam right          Bit number of rightmost bit in GPIO (inclusive)
 * @tparam polarity       Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<const PortInfo &Info, const unsigned left, const unsigned right, Polarity polarity=ActiveHigh>
class Field_T : public PcrBase_T<Info.portAddress, Info.irqNum, Info.irqLevel>{

   static_assert(((left<=31)&&(left>=right)), "Illegal bit number for left or right in GpioField");

public:
   /** Get base address of GPIO hardware as pointer to struct */
   static volatile GPIO_Type &gpio() { return *reinterpret_cast<volatile GPIO_Type *>(Info.gpioAddress); }

   /** Get base address of GPIO hardware as uint32_t */
   static constexpr uint32_t gpioBase() { return Info.gpioAddress; }
   /** Get base address of GPIO.PDOR register as uint32_t */
   static constexpr uint32_t gpioPDOR() { return gpioBase() + offsetof(GPIO_Type, PDOR); }
   /** Get base address of GPIO.PSOR register as uint32_t */
   static constexpr uint32_t gpioPSOR() { return gpioBase() + offsetof(GPIO_Type, PSOR); }
   /** Get base address of GPIO.PCOR register as uint32_t */
   static constexpr uint32_t gpioPCOR() { return gpioBase() + offsetof(GPIO_Type, PCOR); }
   /** Get base address of GPIO.PTOR register as uint32_t */
   static constexpr uint32_t gpioPTOR() { return gpioBase() + offsetof(GPIO_Type, PTOR); }
   /** Get base address of GPIO.PDIR register as uint32_t */
   static constexpr uint32_t gpioPDIR() { return gpioBase() + offsetof(GPIO_Type, PDIR); }
   /** Get base address of GPIO.PDDR register as uint32_t */
   static constexpr uint32_t gpioPDDR() { return gpioBase() + offsetof(GPIO_Type, PDDR); }

#ifdef PORT_DFCR_CS_MASK
   /** Get base address of PORT hardware as pointer to struct */
   static volatile PORT_DFER_Type &port() { return *reinterpret_cast<volatile PORT_DFER_Type *>(Info.portAddress); }
   /** Get base address of PORT register as uint32_t */
   static constexpr uint32_t portBase() { return Info.portAddress; }
   /** Get base address of PORT.PCR register as uint32_t */
   static constexpr uint32_t portPCR(int index) { return portBase() + offsetof(PORT_DFER_Type, PCR[index]); }
   /** Get base address of PORT.GPCLR registers as uint32_t */
   static constexpr uint32_t portGPCLR() { return portBase() + offsetof(PORT_DFER_Type, GPCLR); }
   /** Get base address of PORT.GPCHR registers as uint32_t */
   static constexpr uint32_t portGPCHR() { return portBase() + offsetof(PORT_DFER_Type, GPCHR); }
   /** Get base address of PORT.ISFR registers as uint32_t */
   static constexpr uint32_t portISFR() { return portBase() + offsetof(PORT_DFER_Type, ISFR); }
#else
   /** Get base address of PORT hardware as pointer to struct */
   static volatile PORT_Type &port() { return *reinterpret_cast<volatile PORT_Type *>(Info.portAddress); }
   /** Get base address of PORT register as uint32_t */
   static constexpr uint32_t portBase() { return Info.portAddress; }
   /** Get base address of PORT.PCR register as uint32_t */
   static constexpr uint32_t portPCR(int index) { return portBase() + offsetof(PORT_Type, PCR[index]); }
   /** Get base address of PORT.GPCLR registers as uint32_t */
   static constexpr uint32_t portGPCLR() { return portBase() + offsetof(PORT_Type, GPCLR); }
   /** Get base address of PORT.GPCHR registers as uint32_t */
   static constexpr uint32_t portGPCHR() { return portBase() + offsetof(PORT_Type, GPCHR); }
   /** Get base address of PORT.ISFR registers as uint32_t */
   static constexpr uint32_t portISFR() { return portBase() + offsetof(PORT_Type, ISFR); }
#endif

public:
   /** Port associated with this GPIO Field */
   using Port = PcrBase_T<Info.portAddress, Info.irqNum, Info.irqLevel>;

   /** Bit number of left bit in port */
   static constexpr unsigned LEFT = left;

   /** Bit number of right bit in port */
   static constexpr unsigned RIGHT = right;

   /** Mask for the bits being manipulated within underlying port hardware */
   static constexpr uint32_t BITMASK = static_cast<uint32_t>((1ULL<<(left-right+1))-1)<<right;

   /** Polarity of field */
   static constexpr Polarity POLARITY = polarity;

   /**
    * Calculate Port bit-mask from field bit number
    *
    * @param bitNum  Bit number within field (left-right,0]
    *
    * @return Mask for given bit within underlying port hardware
    */
   static constexpr uint32_t mask(uint32_t bitNum) {
      return 1<<(bitNum+right);
   }

   /**
    *  Disable Pins
    *  This sets the pins to MUX(0) which is specified for minimum leakage in low-power modes.
    *
    *  @note The clock is left enabled as shared with other pins.
    *  @note Mux(0) is also the Analogue MUX setting
    */
   static void disablePins() {
      // Enable clock to port
      enablePortClocks(Info.clockInfo);

      // Default to input
      gpio().PDDR &= ~BITMASK;

      // Default to output inactive
      write(0);

      /*
       * Set all PCRs.
       * Can't use GPCLR/GPCHR as doesn't affect IRQ function
       */
      for (unsigned bitNum=right; bitNum<=left; bitNum++) {
         port().PCR[bitNum] = PinMux_Disabled;
      }
   }

   /**
    * Set field as digital I/O.
    * Pins are initially set as an input.
    * Use setIn(), setOut() and setDirection() to change pin directions.
    *
    * @note Resets the Pin Control Register values (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pcrValue PCR value to use in configuring pin (excluding MUX value). See pcrValue()
    */
   static void setInOut(PcrValue pcrValue=GPIO_DEFAULT_PCR) {
      // Enable clock to port
      enablePortClocks(Info.clockInfo);

      // Default to input
      gpio().PDDR &= ~BITMASK;

      // Default to output inactive
      write(0);

      // Make sure MUX value is correct
      pcrValue += PinMux_Gpio;

//      if ((((uint32_t)pcrValue) & 0xFFFF0000U) == 0) {
//         if constexpr (BITMASK & 0xFF) {
//            port().GPCLR = PORT_GPCLR_GPWD(pcrValue)|PORT_GPCLR_GPWE(BITMASK);
//         }
//         if constexpr (BITMASK & 0x00FF) {
//            port().GPCHR = PORT_GPCHR_GPWD(pcrValue)|PORT_GPCHR_GPWE(BITMASK>>16);
//         }
//      }
//      else {
         /*
          * Set all PCRs.
          * Can't use GPCLR/GPCHR as doesn't affect IRQ function (PinAction)
          */
         for (unsigned bitNum=right; bitNum<=left; bitNum++) {
            port().PCR[bitNum] = pcrValue;
         }
//      }
   }

   /**
    * Set field as digital I/O.
    * Pins are initially set as an input.
    * Use setIn(), setOut() and setDirection() to change pin directions.
    *
    * @note Resets the Pin Control Register values (PCR value).
    * @note Resets the pin output value to the inactive state
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down (defaults to PinPull_None)
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setInOut(
         PinPull           pinPull,
         PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinAction         pinAction         = PinAction_None,
         PinFilter         pinFilter         = PinFilter_None,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
   ) {
      setInOut(pinPull|pinDriveStrength|pinDriveMode|pinAction|pinFilter|pinSlewRate);
   }
   /**
    * Set all pins as digital outputs.
    *
    * @note Does not affect other pin settings
    */
   static void setOut() {
      gpio().PDDR |= BITMASK;
   }
   /**
    * Sets all pin as digital outputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding mux fn)
    */
   static void setOutput(PcrValue pcrValue=GPIO_DEFAULT_PCR) {
      setInOut(pcrValue);
      gpio().PDDR |= BITMASK;
   }
   /**
    * Sets all pin as digital outputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setOut() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    */
   static void setOutput(
         PinDriveStrength  pinDriveStrength,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast
   ) {
      setOutput(pinDriveStrength|pinDriveMode|pinSlewRate);
   }
   /**
    * Set all pins as digital inputs.
    *
    * @note Does not affect other pin settings
    */
   static void setIn() {
      gpio().PDDR &= ~BITMASK;
   }
   /**
    * Set all pins as digital inputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pcrValue PCR value to use in configuring port (excluding mux and irq functions)
    */
   static void setInput(PcrValue pcrValue=GPIO_DEFAULT_PCR) {
      setInOut(pcrValue);
   }
   /**
    * Set all pins as digital inputs.
    * Configures all Pin Control Register (PCR) values
    *
    * @note This will also reset the Pin Control Register value (PCR value).
    * @note Use setIn() or setDirection() for a lightweight change of direction without affecting other pin settings.
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down (defaults to PinPull_None)
    * @param[in] pinAction        One of PinAction_None, etc (defaults to PinAction_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    */
   static void setInput(
         PinPull           pinPull,
         PinAction         pinAction         = PinAction_None,
         PinFilter         pinFilter         = PinFilter_None
   ) {
      setInOut(pinPull|pinAction|pinFilter);
   }
   /**
    * Set individual pin directions
    *
    * @param[in] mask Mask for pin directions (1=>out, 0=>in)
    *
    * @note Does not affect other pin settings
    */
   static void setDirection(uint32_t mask) {
      gpio().PDDR = (gpio().PDDR&~BITMASK)|((mask<<right)&BITMASK);
   }
   /**
    * Set bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => set bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitSet(const uint32_t mask) {
      gpio().PSOR = (mask<<right)&BITMASK;
   }
   /**
    * Clear bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => clear bit, 0 => unchanged)
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitClear(const uint32_t mask) {
      gpio().PCOR = (mask<<right)&BITMASK;
   }
   /**
    * Toggle bits in field
    *
    * @param[in] mask Mask to apply to the field (1 => toggle bit, 0 => unchanged)
    */
   static void bitToggle(const uint32_t mask) {
      gpio().PTOR = (mask<<right)&BITMASK;
   }
   /**
    * Read field as unmodified bit field
    *
    * @return value from field
    *
    * @note Polarity _is_ _not_ significant
    */
   static uint32_t bitRead() {
      return (gpio().PDIR & BITMASK)>>right;
   }
   /**
    * Read field
    *
    * @return value from field
    *
    * @note Polarity _is_ significant
    */
   static uint32_t read() {
      if constexpr (polarity) {
         return (gpio().PDIR & BITMASK)>>right;
      }
      else {
         return (~gpio().PDIR & BITMASK)>>right;
      }
   }
   /**
    * Read value being driven to field pins (if configured as output)
    *
    * @return value from field output
    *
    * @note This reads the PDOR
    * @note Polarity _is_ significant
    */
   static bool readState() {
      if constexpr (polarity) {
         return (gpio().PDOR & BITMASK)>>right;
      }
      else {
         return (~gpio().PDOR & BITMASK)>>right;
      }
   }
   /**
    * Write field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ significant
    */
   static void write(uint32_t value) {
      if constexpr (!polarity) {
         value = ~value;
      }
      {
         USBDM::CriticalSection cs;
         gpio().PDOR = ((gpio().PDOR) & ~BITMASK) | ((value<<right)&BITMASK);
      }
   }

   /**
    * Write bit field
    *
    * @param[in] value to insert as field
    *
    * @note Polarity _is_ _not_ significant
    */
   static void bitWrite(uint32_t value) {
      USBDM::CriticalSection cs;
      gpio().PDOR = ((gpio().PDOR) & ~BITMASK) | ((value<<right)&BITMASK);
   }

   /**
    * Set callback for Pin interrupts
    *
    * @param[in] callback The function to call on Pin interrupt. \n
    *                     nullptr to indicate none
    *
    * @return E_NO_ERROR            No error
    * @return E_HANDLER_ALREADY_SET Handler already set
    *
    * @note There is a single callback function for all pins on the related port.
    *       It is necessary to identify the originating pin in the callback
    * @note This is a convenience function for Pcr::setPinCallback(callback)
    */
   static ErrorCode setPinCallback(PinCallbackFunction callback) {
      static_assert(Port::HANDLER_INSTALLED, "Gpio containing GpioField not configured for interrupts - Modify Configure.usbdm");
      return Port::setPinCallback(callback);
   }

   /**
    * @brief Convenience template for Gpios associated with a bit of this field. See @ref Gpio_T
    *
    * <b>Usage</b>
    * @code
    * using namespace USBDM;
    *
    * // Instantiate a 4-bit field in GPIO C
    * using Field = GpioCField<5, 2, ActiveHigh>;
    *
    * // Instantiate a GPIO within the field ( <=> GpioC<4, ActiveLow>)
    * using Bit = Field::Bit<2, ActiveLow>;
    *
    * @endcode
    *
    * @tparam bitNum        Bit number within the <em>field<em>
    * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
    */
   template<unsigned bitNum, Polarity bitPolarity=polarity> class Bit :
   public GpioBase_T<Info.clockInfo, Info.portAddress, Info.irqNum, Info.gpioAddress, GPIO_DEFAULT_PCR, Info.irqLevel, bitNum+RIGHT, bitPolarity> {
      static_assert(bitNum<=(left-right), "Bit does not exist in field");
   public:
      // Allow access to owning field
      using Owner = Field_T;
   };
};

#ifdef USBDM_GPIOA_IS_DEFINED
/**
 * @brief Convenience template for GpioA. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 3 of GpioA
 * GpioA<3, ActiveHigh> GpioA3;
 *
 * // Set as digital output
 * GpioA3::setOutput();
 *
 * // Set pin high
 * GpioA3::set();
 *
 * // Set pin low
 * GpioA3::clear();
 *
 * // Toggle pin
 * GpioA3::toggle();
 *
 * // Set pin to boolean value
 * GpioA3::write(true);
 *
 * // Set pin to boolean value
 * GpioA3::write(false);
 *
 * // Set as digital input
 * GpioA3::setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioA3::read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<unsigned bitNum, Polarity polarity=ActiveHigh> class GpioA :
      public GpioBase_T<PortAInfo.clockInfo, PortAInfo.portAddress, PortAInfo.irqNum, PortAInfo.gpioAddress, GPIO_DEFAULT_PCR, PortAInfo.irqLevel, bitNum, polarity> {};
using PortA = PcrBase_T<PortAInfo.portAddress, PortAInfo.irqNum, PortAInfo.irqLevel>;

/**
 * @brief Convenience template for GpioA fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 6 down to 3 of GpioA
 * using GpioA6_3 = GpioAField<6,3>;
 *
 * // Set as digital output
 * GpioA6_3::setOutput();
 *
 * // Write value to field
 * GpioA6_3::write(0x53);
 *
 * // Clear all of field
 * GpioA6_3::bitClear();
 *
 * // Clear lower two bits of field
 * GpioA6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioA6_3::bitSet(0x3);
 *
 * // Set as digital input
 * GpioA6_3::setInput();
 *
 * // Read pin as int value
 * int x = GpioA6_3::read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 * @tparam polarity      Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<unsigned left, unsigned right, Polarity polarity=ActiveHigh>
using GpioAField = Field_T<PortAInfo, left, right, polarity>;
#endif

#ifdef USBDM_GPIOB_IS_DEFINED
/**
 * @brief Convenience template for GpioB. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 3 of GpioB
 * using GpioB3 = GpioB<3, ActiveHigh>;
 *
 * // Set as digital output
 * GpioB3::setOutput();
 *
 * // Set pin high
 * GpioB3::set();
 *
 * // Set pin low
 * GpioB3::clear();
 *
 * // Toggle pin
 * GpioB3::toggle();
 *
 * // Set pin to boolean value
 * GpioB3::write(true);
 *
 * // Set pin to boolean value
 * GpioB3::write(false);
 *
 * // Set as digital input
 * GpioB3::setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioB3::read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<unsigned bitNum, Polarity polarity=ActiveHigh> class GpioB :
      public GpioBase_T<PortBInfo.clockInfo, PortBInfo.portAddress, PortBInfo.irqNum, PortBInfo.gpioAddress, GPIO_DEFAULT_PCR, PortBInfo.irqLevel, bitNum, polarity> {};
using PortB = PcrBase_T<PortBInfo.portAddress, PortBInfo.irqNum, PortBInfo.irqLevel>;

/**
 * @brief Convenience template for GpioB fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 6 down to 3 of GpioB
 * using GpioB6_3 = GpioBField<6,3>;
 *
 * // Set as digital output
 * GpioB6_3::setOutput();
 *
 * // Write value to field
 * GpioB6_3::write(0x53);
 *
 * // Clear all of field
 * GpioB6_3::bitClear();
 *
 * // Clear lower two bits of field
 * GpioB6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioB6_3::bitSet(0x3);
 *
 * // Set as digital input
 * GpioB6_3::setInput();
 *
 * // Read pin as int value
 * int x = GpioB6_3::read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 * @tparam polarity      Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<unsigned left, unsigned right, Polarity polarity=ActiveHigh>
using GpioBField = Field_T<PortBInfo, left, right, polarity>;
#endif

#ifdef USBDM_GPIOC_IS_DEFINED
/**
 * @brief Convenience template for GpioC. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 3 of GpioC
 * using GpioC3 = GpioC<3, ActiveHigh>;
 *
 * // Set as digital output
 * GpioC3::setOutput();
 *
 * // Set pin high
 * GpioC3::set();
 *
 * // Set pin low
 * GpioC3::clear();
 *
 * // Toggle pin
 * GpioC3::toggle();
 *
 * // Set pin to boolean value
 * GpioC3::write(true);
 *
 * // Set pin to boolean value
 * GpioC3::write(false);
 *
 * // Set as digital input
 * GpioC3::setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioC3::read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<unsigned bitNum, Polarity polarity=ActiveHigh> class GpioC :
      public GpioBase_T<PortCInfo.clockInfo, PortCInfo.portAddress, PortCInfo.irqNum, PortCInfo.gpioAddress, GPIO_DEFAULT_PCR, PortCInfo.irqLevel, bitNum, polarity> {};
using PortC = PcrBase_T<PortCInfo.portAddress, PortCInfo.irqNum, PortCInfo.irqLevel>;

/**
 * @brief Convenience template for GpioC fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 6 down to 3 of GpioC
 * using GpioC6_3 = GpioCField<6,3>;
 *
 * // Set as digital output
 * GpioC6_3::setOutput();
 *
 * // Write value to field
 * GpioC6_3::write(0x53);
 *
 * // Clear all of field
 * GpioC6_3::bitClear();
 *
 * // Clear lower two bits of field
 * GpioC6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioC6_3::bitSet(0x3);
 *
 * // Set as digital input
 * GpioC6_3::setInput();
 *
 * // Read pin as int value
 * int x = GpioC6_3::read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 * @tparam polarity      Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<unsigned left, unsigned right, Polarity polarity=ActiveHigh>
using GpioCField = Field_T<PortCInfo, left, right, polarity>;
#endif

#ifdef USBDM_GPIOD_IS_DEFINED
/**
 * @brief Convenience template for GpioD. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 3 of GpioD
 * using GpioD3 = GpioD<3, ActiveHigh>;
 *
 * // Set as digital output
 * GpioD3::setOutput();
 *
 * // Set pin high
 * GpioD3::set();
 *
 * // Set pin low
 * GpioD3::clear();
 *
 * // Toggle pin
 * GpioD3::toggle();
 *
 * // Set pin to boolean value
 * GpioD3::write(true);
 *
 * // Set pin to boolean value
 * GpioD3::write(false);
 *
 * // Set as digital input
 * GpioD3::setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioD3::read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<unsigned bitNum, Polarity polarity=ActiveHigh> class GpioD :
      public GpioBase_T<PortDInfo.clockInfo, PortDInfo.portAddress, PortDInfo.irqNum, PortDInfo.gpioAddress, GPIO_DEFAULT_PCR, PortDInfo.irqLevel, bitNum, polarity> {};
using PortD = PcrBase_T<PortDInfo.portAddress, PortDInfo.irqNum, PortDInfo.irqLevel>;

/**
 * @brief Convenience template for GpioD fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 6 down to 3 of GpioD
 * using GpioD6_3 = GpioDField<6,3>;
 *
 * // Set as digital output
 * GpioD6_3::setOutput();
 *
 * // Write value to field
 * GpioD6_3::write(0x53);
 *
 * // Clear all of field
 * GpioD6_3::bitClear();
 *
 * // Clear lower two bits of field
 * GpioD6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioD6_3::bitSet(0x3);
 *
 * // Set as digital input
 * GpioD6_3::setInput();
 *
 * // Read pin as int value
 * int x = GpioD6_3::read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 * @tparam polarity      Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<unsigned left, unsigned right, Polarity polarity=ActiveHigh>
using GpioDField = Field_T<PortDInfo, left, right, polarity>;
#endif

#ifdef USBDM_GPIOE_IS_DEFINED
/**
 * @brief Convenience template for GpioE. See @ref Gpio_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 3 of GpioE
 * using GpioE3 = GpioE<3, ActiveHigh>;
 *
 * // Set as digital output
 * GpioE3::setOutput();
 *
 * // Set pin high
 * GpioE3::set();
 *
 * // Set pin low
 * GpioE3::clear();
 *
 * // Toggle pin
 * GpioE3::toggle();
 *
 * // Set pin to boolean value
 * GpioE3::write(true);
 *
 * // Set pin to boolean value
 * GpioE3::write(false);
 *
 * // Set as digital input
 * GpioE3::setInput();
 *
 * // Read pin as boolean value
 * bool x = GpioE3::read();
 * @endcode
 *
 * @tparam bitNum        Bit number in the port
 * @tparam polarity      Polarity of pin. Either ActiveHigh or ActiveLow
 */
template<unsigned bitNum, Polarity polarity=ActiveHigh> class GpioE :
      public GpioBase_T<PortEInfo.clockInfo, PortEInfo.portAddress, PortEInfo.irqNum, PortEInfo.gpioAddress, GPIO_DEFAULT_PCR, PortEInfo.irqLevel, bitNum, polarity> {};
using PortE = PcrBase_T<PortEInfo.portAddress, PortEInfo.irqNum, PortEInfo.irqLevel>;

/**
 * @brief Convenience template for GpioE fields. See @ref Field_T
 *
 * <b>Usage</b>
 * @code
 * using namespace USBDM;
 *
 * // Instantiate for bit 6 down to 3 of GpioE
 * using GpioE6_3 = GpioEField<6,3>;
 *
 * // Set as digital output
 * GpioE6_3::setOutput();
 *
 * // Write value to field
 * GpioE6_3::write(0x53);
 *
 * // Clear all of field
 * GpioE6_3::bitClear();
 *
 * // Clear lower two bits of field
 * GpioE6_3::bitClear(0x3);
 *
 * // Set lower two bits of field
 * GpioE6_3::bitSet(0x3);
 *
 * // Set as digital input
 * GpioE6_3::setInput();
 *
 * // Read pin as int value
 * int x = GpioE6_3::read();
 * @endcode
 *
 * @tparam left          Bit number of leftmost bit in port (inclusive)
 * @tparam right         Bit number of rightmost bit in port (inclusive)
 * @tparam polarity      Polarity of all pins. Either ActiveHigh or ActiveLow
 */
template<unsigned left, unsigned right, Polarity polarity=ActiveHigh>
using GpioEField = Field_T<PortEInfo, left, right, polarity>;
#endif

/**
 * End GPIO_Group
 * @}
 */
} // End namespace USBDM

#endif /* HEADER_GPIO_H */

